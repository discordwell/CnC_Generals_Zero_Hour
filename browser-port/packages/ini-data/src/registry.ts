/**
 * INI Data Registry — loads parsed INI JSON and builds indexed lookups.
 *
 * Resolves inheritance chains, validates references, and provides
 * typed access to game objects, weapons, upgrades, sciences, and factions.
 */

import type { IniBlock, IniValue } from '@generals/core';

// ---------------------------------------------------------------------------
// Definition types
// ---------------------------------------------------------------------------

export interface ObjectDef {
  name: string;
  parent?: string;
  side?: string;
  kindOf?: string[];
  fields: Record<string, IniValue>;
  blocks: IniBlock[];
  resolved: boolean;
  hasUnresolvedParent?: boolean;
}

export interface WeaponDef {
  name: string;
  parent?: string;
  fields: Record<string, IniValue>;
  blocks: IniBlock[];
}

export interface ArmorDef {
  name: string;
  fields: Record<string, IniValue>;
}

export interface UpgradeDef {
  name: string;
  fields: Record<string, IniValue>;
  blocks?: IniBlock[];
  kindOf?: string[];
}

export interface SpecialPowerDef {
  name: string;
  parent?: string;
  fields: Record<string, IniValue>;
  blocks: IniBlock[];
}

export interface ObjectCreationListDef {
  name: string;
  parent?: string;
  fields: Record<string, IniValue>;
  blocks: IniBlock[];
}

export interface ScienceDef {
  name: string;
  fields: Record<string, IniValue>;
}

export interface FactionDef {
  name: string;
  side?: string;
  fields: Record<string, IniValue>;
}

export interface LocomotorDef {
  name: string;
  fields: Record<string, IniValue>;
  surfaces: string[];
  surfaceMask: number;
  downhillOnly: boolean;
  speed?: number;
}

export interface CommandButtonDef {
  name: string;
  fields: Record<string, IniValue>;
  blocks: IniBlock[];
  commandTypeName?: string;
  options: string[];
  unitSpecificSoundName?: string;
}

export interface CommandSetButtonSlot {
  slot: number;
  commandButtonName: string;
}

export interface CommandSetDef {
  name: string;
  fields: Record<string, IniValue>;
  buttons: string[];
  slottedButtons?: CommandSetButtonSlot[];
}

export type AudioEventSoundType = 'music' | 'streaming' | 'sound';

export interface AudioEventDef {
  name: string;
  fields: Record<string, IniValue>;
  blocks: IniBlock[];
  soundType: AudioEventSoundType;
  priorityName?: string;
  typeNames: string[];
  controlNames: string[];
  volume?: number;
  minVolume?: number;
  limit?: number;
  minRange?: number;
  maxRange?: number;
  filename?: string;
}

export interface MiscAudioDef {
  entries: Record<string, string>;
  guiClickSoundName?: string;
  noCanDoSoundName?: string;
}

export interface RegistryStats {
  objects: number;
  weapons: number;
  armors: number;
  upgrades: number;
  sciences: number;
  factions: number;
  audioEvents: number;
  commandButtons: number;
  commandSets: number;
  unresolvedInheritance: number;
  totalBlocks: number;
}

export interface RegistryError {
  type: 'unresolved_parent' | 'duplicate' | 'unsupported_block';
  blockType: string;
  name: string;
  detail: string;
  file?: string;
}

export interface AiConfig {
  attackUsesLineOfSight?: boolean;
  skirmishBaseDefenseExtraDistance?: number;
}

/**
 * Source parity: WeaponBonusSet::parseWeaponBonusSet — a single entry from
 * `WeaponBonus = CONDITION FIELD PERCENT%` in GameData.ini.
 */
export interface WeaponBonusEntry {
  condition: string;
  field: string;
  multiplier: number;
}

/**
 * Source parity: TheGlobalData — selected fields from the global GameData INI block.
 */
export interface GameDataConfig {
  weaponBonusEntries: WeaponBonusEntry[];
}

export interface AudioSettingsConfig {
  sampleCount2D?: number;
  sampleCount3D?: number;
  streamCount?: number;
  minSampleVolume?: number;
  globalMinRange?: number;
  globalMaxRange?: number;
  relative2DVolume?: number;
  defaultSoundVolume?: number;
  default3DSoundVolume?: number;
  defaultSpeechVolume?: number;
  defaultMusicVolume?: number;
}

export interface IniDataBundle {
  objects: ObjectDef[];
  weapons: WeaponDef[];
  armors: ArmorDef[];
  upgrades: UpgradeDef[];
  sciences: ScienceDef[];
  factions: FactionDef[];
  specialPowers?: SpecialPowerDef[];
  objectCreationLists?: ObjectCreationListDef[];
  locomotors?: LocomotorDef[];
  audioEvents?: AudioEventDef[];
  miscAudio?: MiscAudioDef;
  commandButtons?: CommandButtonDef[];
  commandSets?: CommandSetDef[];
  ai?: AiConfig;
  audioSettings?: AudioSettingsConfig;
  gameData?: GameDataConfig;
  stats: RegistryStats;
  errors: RegistryError[];
  unsupportedBlockTypes: string[];
}

// ---------------------------------------------------------------------------
// Registry
// ---------------------------------------------------------------------------

export class IniDataRegistry {
  readonly objects = new Map<string, ObjectDef>();
  readonly weapons = new Map<string, WeaponDef>();
  readonly armors = new Map<string, ArmorDef>();
  readonly upgrades = new Map<string, UpgradeDef>();
  readonly sciences = new Map<string, ScienceDef>();
  readonly factions = new Map<string, FactionDef>();
  readonly specialPowers = new Map<string, SpecialPowerDef>();
  readonly objectCreationLists = new Map<string, ObjectCreationListDef>();
  readonly locomotors = new Map<string, LocomotorDef>();
  readonly audioEvents = new Map<string, AudioEventDef>();
  readonly commandButtons = new Map<string, CommandButtonDef>();
  readonly commandSets = new Map<string, CommandSetDef>();
  readonly errors: RegistryError[] = [];
  private ai: AiConfig | undefined;
  private audioSettings: AudioSettingsConfig | undefined;
  private gameData: GameDataConfig | undefined;
  private miscAudio: MiscAudioDef | undefined;

  private unsupportedBlockTypes = new Set<string>();

  /** Load parsed INI blocks (from CLI JSON output or parseIni result). */
  loadBlocks(blocks: IniBlock[], sourcePath?: string): void {
    for (const block of blocks) {
      this.indexBlock(block, sourcePath);
    }
  }

  /** Resolve all inheritance chains. Call after all blocks are loaded. */
  resolveInheritance(): void {
    // Resolve objects
    for (const [name, obj] of this.objects) {
      if (obj.parent && !obj.resolved) {
        this.resolveObjectChain(name, new Set());
      }
    }
  }

  /** Load prebuilt registry state from an INI data bundle. */
  loadBundle(bundle: IniDataBundle): void {
    this.objects.clear();
    this.weapons.clear();
    this.armors.clear();
    this.upgrades.clear();
    this.sciences.clear();
    this.factions.clear();
    this.specialPowers.clear();
    this.objectCreationLists.clear();
    this.locomotors.clear();
    this.audioEvents.clear();
    this.commandButtons.clear();
    this.commandSets.clear();
    this.errors.length = 0;
    this.unsupportedBlockTypes.clear();
    this.miscAudio = undefined;
    this.audioSettings = undefined;
    this.gameData = undefined;

    for (const object of bundle.objects) {
      this.objects.set(object.name, {
        ...object,
        fields: { ...object.fields },
        blocks: [...object.blocks],
        kindOf: object.kindOf ? [...object.kindOf] : undefined,
      });
    }

    for (const weapon of bundle.weapons) {
      this.weapons.set(weapon.name, {
        ...weapon,
        fields: { ...weapon.fields },
        blocks: [...weapon.blocks],
      });
    }

    for (const armor of bundle.armors) {
      this.armors.set(armor.name, { ...armor, fields: { ...armor.fields } });
    }

    for (const upgrade of bundle.upgrades) {
      this.upgrades.set(upgrade.name, {
        ...upgrade,
        fields: { ...upgrade.fields },
        blocks: [...(upgrade.blocks ?? [])],
        kindOf: upgrade.kindOf ? [...upgrade.kindOf] : undefined,
      });
    }

    for (const science of bundle.sciences) {
      this.sciences.set(science.name, { ...science, fields: { ...science.fields } });
    }

    for (const faction of bundle.factions) {
      this.factions.set(faction.name, { ...faction, fields: { ...faction.fields } });
    }
    for (const specialPower of bundle.specialPowers ?? []) {
      this.specialPowers.set(specialPower.name, {
        ...specialPower,
        fields: { ...specialPower.fields },
        blocks: [...specialPower.blocks],
      });
    }
    for (const objectCreationList of bundle.objectCreationLists ?? []) {
      this.objectCreationLists.set(objectCreationList.name, {
        ...objectCreationList,
        fields: { ...objectCreationList.fields },
        blocks: [...objectCreationList.blocks],
      });
    }
    for (const locomotor of bundle.locomotors ?? []) {
      this.locomotors.set(locomotor.name, {
        ...locomotor,
        fields: { ...locomotor.fields },
        surfaces: [...locomotor.surfaces],
      });
    }
    for (const audioEvent of bundle.audioEvents ?? []) {
      this.audioEvents.set(audioEvent.name, {
        ...audioEvent,
        fields: { ...audioEvent.fields },
        blocks: [...audioEvent.blocks],
        typeNames: [...audioEvent.typeNames],
        controlNames: [...audioEvent.controlNames],
      });
    }
    for (const commandButton of bundle.commandButtons ?? []) {
      this.commandButtons.set(commandButton.name, {
        ...commandButton,
        fields: { ...commandButton.fields },
        blocks: [...(commandButton.blocks ?? [])],
        commandTypeName: commandButton.commandTypeName ?? extractTokenString(commandButton.fields['Command']),
        options: [...(commandButton.options ?? extractOptions(commandButton.fields['Options']))],
        unitSpecificSoundName: commandButton.unitSpecificSoundName,
      });
    }
    for (const commandSet of bundle.commandSets ?? []) {
      const normalizedButtons = commandSet.buttons ?? [];
      const slottedButtons = normalizeCommandSetButtonSlots(
        commandSet.slottedButtons ??
          normalizedButtons.map((commandButtonName, index) => ({
            slot: index + 1,
            commandButtonName,
          })),
      );
      this.commandSets.set(commandSet.name, {
        ...commandSet,
        fields: { ...commandSet.fields },
        buttons: slottedButtons.map((entry) => entry.commandButtonName),
        slottedButtons,
      });
    }
    this.miscAudio = bundle.miscAudio
      ? {
          entries: { ...bundle.miscAudio.entries },
          guiClickSoundName: bundle.miscAudio.guiClickSoundName,
          noCanDoSoundName: bundle.miscAudio.noCanDoSoundName,
        }
      : undefined;

    this.errors.push(...bundle.errors);
    this.ai = bundle.ai ? { ...bundle.ai } : undefined;
    this.audioSettings = bundle.audioSettings ? { ...bundle.audioSettings } : undefined;
    this.gameData = bundle.gameData
      ? { weaponBonusEntries: [...bundle.gameData.weaponBonusEntries] }
      : undefined;
    for (const unsupported of bundle.unsupportedBlockTypes) {
      this.unsupportedBlockTypes.add(unsupported);
    }
  }

  /** Get all objects matching a KindOf flag. */
  getObjectsByKind(kind: string): ObjectDef[] {
    const results: ObjectDef[] = [];
    for (const obj of this.objects.values()) {
      if (obj.kindOf?.includes(kind)) {
        results.push(obj);
      }
    }
    return results;
  }

  /** Get all objects for a given side (America, China, GLA). */
  getObjectsBySide(side: string): ObjectDef[] {
    const results: ObjectDef[] = [];
    for (const obj of this.objects.values()) {
      if (obj.side === side) {
        results.push(obj);
      }
    }
    return results;
  }

  getObject(name: string): ObjectDef | undefined {
    return this.objects.get(name);
  }

  getWeapon(name: string): WeaponDef | undefined {
    return this.weapons.get(name);
  }

  getArmor(name: string): ArmorDef | undefined {
    return this.armors.get(name);
  }

  getUpgrade(name: string): UpgradeDef | undefined {
    return this.upgrades.get(name);
  }

  getScience(name: string): ScienceDef | undefined {
    return this.sciences.get(name);
  }

  getFaction(name: string): FactionDef | undefined {
    return this.factions.get(name);
  }

  getSpecialPower(name: string): SpecialPowerDef | undefined {
    return this.specialPowers.get(name);
  }

  getObjectCreationList(name: string): ObjectCreationListDef | undefined {
    return this.objectCreationLists.get(name);
  }

  getAiConfig(): AiConfig | undefined {
    return this.ai ? { ...this.ai } : undefined;
  }

  getGameData(): GameDataConfig | undefined {
    return this.gameData
      ? { weaponBonusEntries: [...this.gameData.weaponBonusEntries] }
      : undefined;
  }

  getAudioSettings(): AudioSettingsConfig | undefined {
    return this.audioSettings ? { ...this.audioSettings } : undefined;
  }

  getLocomotor(name: string): LocomotorDef | undefined {
    return this.locomotors.get(name);
  }

  getAudioEvent(name: string): AudioEventDef | undefined {
    return this.audioEvents.get(name);
  }

  getCommandButton(name: string): CommandButtonDef | undefined {
    return this.commandButtons.get(name);
  }

  getCommandSet(name: string): CommandSetDef | undefined {
    return this.commandSets.get(name);
  }

  getMiscAudio(): MiscAudioDef | undefined {
    if (!this.miscAudio) {
      return undefined;
    }
    return {
      entries: { ...this.miscAudio.entries },
      guiClickSoundName: this.miscAudio.guiClickSoundName,
      noCanDoSoundName: this.miscAudio.noCanDoSoundName,
    };
  }

  /** Get summary statistics. */
  getStats(): RegistryStats {
    return {
      objects: this.objects.size,
      weapons: this.weapons.size,
      armors: this.armors.size,
      upgrades: this.upgrades.size,
      sciences: this.sciences.size,
      factions: this.factions.size,
      audioEvents: this.audioEvents.size,
      commandButtons: this.commandButtons.size,
      commandSets: this.commandSets.size,
      // SpecialPower and ObjectCreationList definitions are intentionally excluded here
      // until we decide whether to expose their totals in the public stats contract.
      unresolvedInheritance: this.getUnresolvedInheritanceCount(),
      totalBlocks: this.objects.size + this.weapons.size + this.armors.size +
        this.upgrades.size + this.sciences.size + this.factions.size + this.locomotors.size +
        this.audioEvents.size +
        this.commandButtons.size + this.commandSets.size,
    };
  }

  /** Get unsupported block types encountered during loading. */
  getUnsupportedBlockTypes(): string[] {
    return [...this.unsupportedBlockTypes].sort();
  }

  /** Export a deterministic compatibility-friendly bundle. */
  toBundle(): IniDataBundle {
    const stats = this.getStats();

    return {
      objects: [...this.objects.values()].sort((a, b) => a.name.localeCompare(b.name)),
      weapons: [...this.weapons.values()].sort((a, b) => a.name.localeCompare(b.name)),
      armors: [...this.armors.values()].sort((a, b) => a.name.localeCompare(b.name)),
      upgrades: [...this.upgrades.values()].sort((a, b) => a.name.localeCompare(b.name)),
      sciences: [...this.sciences.values()].sort((a, b) => a.name.localeCompare(b.name)),
      factions: [...this.factions.values()].sort((a, b) => a.name.localeCompare(b.name)),
      specialPowers: [...this.specialPowers.values()].sort((a, b) => a.name.localeCompare(b.name)),
      objectCreationLists: [...this.objectCreationLists.values()]
        .sort((a, b) => a.name.localeCompare(b.name)),
      locomotors: [...this.locomotors.values()].sort((a, b) => a.name.localeCompare(b.name)),
      audioEvents: [...this.audioEvents.values()].sort((a, b) => a.name.localeCompare(b.name)),
      miscAudio: this.miscAudio
        ? {
            entries: { ...this.miscAudio.entries },
            guiClickSoundName: this.miscAudio.guiClickSoundName,
            noCanDoSoundName: this.miscAudio.noCanDoSoundName,
          }
        : undefined,
      commandButtons: [...this.commandButtons.values()].sort((a, b) => a.name.localeCompare(b.name)),
      commandSets: [...this.commandSets.values()].sort((a, b) => a.name.localeCompare(b.name)),
      ai: this.ai ? { ...this.ai } : undefined,
      audioSettings: this.audioSettings ? { ...this.audioSettings } : undefined,
      gameData: this.gameData
        ? { weaponBonusEntries: [...this.gameData.weaponBonusEntries] }
        : undefined,
      stats,
      errors: [...this.errors],
      unsupportedBlockTypes: this.getUnsupportedBlockTypes(),
    };
  }

  // -------------------------------------------------------------------------
  // Private
  // -------------------------------------------------------------------------

  private indexBlock(block: IniBlock, sourcePath?: string): void {
    const addDefinition = <T extends { name: string }>(
      collection: Map<string, T>,
      blockType: string,
      definition: T,
    ): void => {
      if (collection.has(definition.name)) {
        this.errors.push({
          type: 'duplicate',
          blockType,
          name: definition.name,
          detail: `Duplicate definition for ${blockType} "${definition.name}" in ${sourcePath ?? 'unknown source'}`,
          file: sourcePath,
        });
      }
      collection.set(definition.name, definition);
    };

    switch (block.type) {
      case 'Object':
      case 'ChildObject':
        addDefinition(this.objects, block.type, {
          name: block.name,
          parent: block.parent,
          side: extractString(block.fields['Side']),
          kindOf: extractStringArray(block.fields['KindOf']),
          fields: block.fields,
          blocks: block.blocks,
          resolved: !block.parent,
        });
        break;

      case 'Weapon':
        addDefinition(this.weapons, block.type, {
          name: block.name,
          parent: block.parent,
          fields: block.fields,
          blocks: block.blocks,
        });
        break;

      case 'Armor':
        addDefinition(this.armors, block.type, {
          name: block.name,
          fields: block.fields,
        });
        break;

      case 'Upgrade':
        addDefinition(this.upgrades, block.type, {
          name: block.name,
          fields: block.fields,
          blocks: block.blocks,
          kindOf: extractStringArray(block.fields['KindOf']),
        });
        break;

      case 'Science':
        addDefinition(this.sciences, block.type, {
          name: block.name,
          fields: block.fields,
        });
        break;

      case 'PlayerTemplate':
      case 'Faction':
        addDefinition(this.factions, block.type, {
          name: block.name,
          side: extractString(block.fields['Side']),
          fields: block.fields,
        });
        break;

      case 'Locomotor':
        addDefinition(this.locomotors, block.type, {
          name: block.name,
          fields: block.fields,
          surfaces: extractLocomotorSurfaces(block.fields['Surfaces']),
          surfaceMask: locomotorSurfaceMaskFromNames(extractLocomotorSurfaces(block.fields['Surfaces'])),
          downhillOnly: extractBoolean(block.fields['DownhillOnly']) ?? false,
          speed: extractNumber(block.fields['Speed']) ?? 0,
        });
        break;

      case 'CommandButton':
        addDefinition(this.commandButtons, block.type, {
          name: block.name,
          fields: block.fields,
          blocks: block.blocks,
          commandTypeName: extractTokenString(block.fields['Command']),
          options: extractOptions(block.fields['Options']),
          unitSpecificSoundName: extractAudioEventName(block.fields['UnitSpecificSound']),
        });
        break;

      case 'CommandSet': {
        const slottedButtons = extractCommandSetButtonSlots(block.fields);
        addDefinition(this.commandSets, block.type, {
          name: block.name,
          fields: block.fields,
          buttons: slottedButtons.map((entry) => entry.commandButtonName),
          slottedButtons,
        });
        break;
      }

      case 'SpecialPower':
        addDefinition(this.specialPowers, block.type, {
          name: block.name,
          parent: block.parent,
          fields: block.fields,
          blocks: block.blocks,
        });
        break;

      case 'ObjectCreationList':
        addDefinition(this.objectCreationLists, block.type, {
          name: block.name,
          parent: block.parent,
          fields: block.fields,
          blocks: block.blocks,
        });
        break;

      case 'AudioEvent':
      case 'MusicTrack':
      case 'DialogEvent':
        addDefinition(this.audioEvents, block.type, {
          name: block.name,
          fields: block.fields,
          blocks: block.blocks,
          soundType: audioEventSoundTypeFromBlockType(block.type),
          priorityName: extractTokenString(block.fields['Priority'])?.toUpperCase(),
          typeNames: extractOptions(block.fields['Type']),
          controlNames: extractOptions(block.fields['Control']),
          volume: extractPercentToReal(block.fields['Volume']),
          minVolume: extractPercentToReal(block.fields['MinVolume']),
          limit: extractInteger(block.fields['Limit']),
          minRange: extractNumber(block.fields['MinRange']),
          maxRange: extractNumber(block.fields['MaxRange']),
          filename: extractTokenString(block.fields['Filename']) ?? extractTokenString(block.fields['Sounds']),
        });
        break;

      case 'MiscAudio': {
        const entries = {
          ...(this.miscAudio?.entries ?? {}),
          ...extractAudioEventEntries(block.fields),
        };
        this.miscAudio = {
          entries,
          guiClickSoundName: entries['GUIClickSound'],
          noCanDoSoundName: entries['NoCanDoSound'],
        };
        break;
      }

      case 'GameData':
        this.indexGameDataBlock(block);
        break;

      // Known but not indexed block types — skip silently
      case 'DamageFX':
      case 'FXList':
      case 'Multisound':
      case 'EvaEvent':
      case 'MappedImage':
      case 'ParticleSystem':
      case 'Animation':
      case 'Terrain':
      case 'Road':
      case 'Bridge':
      case 'Weather':
      case 'WaterSet':
      case 'SkyboxTextureSet':
      case 'Video':
      case 'Campaign':
      case 'Mission':
      case 'CrateData':
      case 'ExperienceLevel':
      case 'ModifierList':
      case 'MultiplayerSettings':
      case 'DrawGroupInfo':
      case 'WindowTransition':
      case 'HeaderTemplate':
      case 'WebpageURL':
      case 'InGameUI':
      case 'ControlBarScheme':
      case 'ControlBarResizer':
      case 'ShellMenuScheme':
      case 'LocomotorSet':
      case 'ClientBehavior':
      case 'ClientUpdate':
      case 'WeaponSet':
      case 'Draw':
      case 'Body':
      case 'ArmorSet':
      case 'AI':
        this.ai = {
          ...this.ai,
          attackUsesLineOfSight: extractBoolean(block.fields['AttackUsesLineOfSight']) ??
            this.ai?.attackUsesLineOfSight,
          skirmishBaseDefenseExtraDistance:
            extractNumber(block.fields['SkirmishBaseDefenseExtraDistance']) ??
            this.ai?.skirmishBaseDefenseExtraDistance,
        };
        break;

      case 'AudioSettings':
        this.audioSettings = {
          ...this.audioSettings,
          sampleCount2D: extractInteger(block.fields['SampleCount2D']) ?? this.audioSettings?.sampleCount2D,
          sampleCount3D: extractInteger(block.fields['SampleCount3D']) ?? this.audioSettings?.sampleCount3D,
          streamCount: extractInteger(block.fields['StreamCount']) ?? this.audioSettings?.streamCount,
          minSampleVolume:
            extractPercentToReal(block.fields['MinSampleVolume']) ?? this.audioSettings?.minSampleVolume,
          globalMinRange: extractInteger(block.fields['GlobalMinRange']) ?? this.audioSettings?.globalMinRange,
          globalMaxRange: extractInteger(block.fields['GlobalMaxRange']) ?? this.audioSettings?.globalMaxRange,
          relative2DVolume:
            extractSignedPercentToReal(block.fields['Relative2DVolume']) ?? this.audioSettings?.relative2DVolume,
          defaultSoundVolume:
            extractPercentToReal(block.fields['DefaultSoundVolume']) ?? this.audioSettings?.defaultSoundVolume,
          default3DSoundVolume:
            extractPercentToReal(block.fields['Default3DSoundVolume']) ?? this.audioSettings?.default3DSoundVolume,
          defaultSpeechVolume:
            extractPercentToReal(block.fields['DefaultSpeechVolume']) ?? this.audioSettings?.defaultSpeechVolume,
          defaultMusicVolume:
            extractPercentToReal(block.fields['DefaultMusicVolume']) ?? this.audioSettings?.defaultMusicVolume,
        };
        break;

      default:
        this.unsupportedBlockTypes.add(block.type);
        this.errors.push({
          type: 'unsupported_block',
          blockType: block.type,
          name: block.name,
          detail: `Unsupported block type: ${block.type}`,
          file: sourcePath,
        });
        break;
    }
  }

  /**
   * Source parity: GlobalData::parseGameDataDefinition — extract WeaponBonus entries
   * from the GameData INI block. Format: `WeaponBonus = CONDITION FIELD PERCENT%`.
   */
  private indexGameDataBlock(block: IniBlock): void {
    const weaponBonusValue = block.fields['WeaponBonus'];
    if (!weaponBonusValue) {
      return;
    }

    const entries: WeaponBonusEntry[] = this.gameData?.weaponBonusEntries
      ? [...this.gameData.weaponBonusEntries]
      : [];

    const lines = Array.isArray(weaponBonusValue) ? weaponBonusValue : [weaponBonusValue];
    for (const line of lines) {
      const tokens = String(line).trim().split(/\s+/);
      if (tokens.length < 3) continue;
      const condition = tokens[0]!.toUpperCase();
      const field = tokens[1]!.toUpperCase();
      const rawPercent = tokens[2]!;
      // Source parity: INI::scanPercentToReal — "125%" → 1.25 (no clamping).
      const percentStr = rawPercent.endsWith('%') ? rawPercent.slice(0, -1) : rawPercent;
      const multiplier = Number(percentStr) / 100;
      if (Number.isFinite(multiplier)) {
        entries.push({ condition, field, multiplier });
      }
    }

    this.gameData = { weaponBonusEntries: entries };
  }

  private resolveObjectChain(name: string, visited: Set<string>): ObjectDef | undefined {
    const obj = this.objects.get(name);
    if (!obj) return undefined;
    if (obj.resolved) return obj;

    if (visited.has(name)) {
      obj.hasUnresolvedParent = true;
      obj.resolved = true;
      this.errors.push({
        type: 'unresolved_parent',
        blockType: 'Object',
        name,
        detail: 'Circular inheritance detected',
      });
      return obj;
    }

    visited.add(name);

    if (!obj.parent) {
      obj.resolved = true;
      return obj;
    }

    const parent = this.resolveObjectChain(obj.parent, visited);
    if (!parent) {
      obj.hasUnresolvedParent = true;
      obj.resolved = true;
      this.errors.push({
        type: 'unresolved_parent',
        blockType: 'Object',
        name,
        detail: `Parent "${obj.parent}" not found`,
      });
      return obj;
    }

    // Merge: parent fields are defaults, child fields override
    obj.fields = { ...parent.fields, ...obj.fields };
    obj.blocks = [...parent.blocks, ...obj.blocks];

    // Inherit side and kindOf if not set
    if (!obj.side && parent.side) obj.side = parent.side;
    if (!obj.kindOf && parent.kindOf) obj.kindOf = parent.kindOf;

    obj.resolved = true;
    obj.hasUnresolvedParent = false;
    return obj;
  }

  private getUnresolvedInheritanceCount(): number {
    let count = 0;
    for (const obj of this.objects.values()) {
      if (obj.hasUnresolvedParent) count++;
    }
    return count;
  }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const MAX_COMMAND_SET_SLOTS = 12;

function extractString(value: IniValue | undefined): string | undefined {
  if (typeof value === 'string') return value;
  return undefined;
}

function extractTokenString(value: IniValue | undefined): string | undefined {
  if (typeof value === 'undefined') {
    return undefined;
  }
  const tokens = flattenIniStrings(value)
    .flatMap((entry) => entry.split(/[\s,;|]+/))
    .map((entry) => entry.trim())
    .filter(Boolean);
  if (tokens.length === 0) {
    return undefined;
  }
  return tokens[0];
}

function extractAudioEventName(value: IniValue | undefined): string | undefined {
  const token = extractTokenString(value);
  if (!token) {
    return undefined;
  }
  if (token.toLowerCase() === 'nosound') {
    return undefined;
  }
  return token;
}

function extractOptions(value: IniValue | undefined): string[] {
  if (typeof value === 'undefined') {
    return [];
  }

  return flattenIniStrings(value)
    .flatMap((entry) => entry.split(/[\s,;|]+/))
    .map((entry) => entry.trim().toUpperCase())
    .filter(Boolean);
}

function extractAudioEventEntries(fields: Record<string, IniValue>): Record<string, string> {
  const entries: Record<string, string> = {};
  for (const [fieldName, value] of Object.entries(fields)) {
    const eventName = extractAudioEventName(value);
    if (!eventName) {
      continue;
    }
    entries[fieldName] = eventName;
  }
  return entries;
}

function normalizeCommandSetButtonSlots(slottedButtons: readonly CommandSetButtonSlot[]): CommandSetButtonSlot[] {
  return slottedButtons
    .filter((entry) =>
      Number.isInteger(entry.slot) &&
      entry.slot >= 1 &&
      entry.slot <= MAX_COMMAND_SET_SLOTS &&
      typeof entry.commandButtonName === 'string' &&
      entry.commandButtonName.trim().length > 0,
    )
    .map((entry) => ({
      slot: entry.slot,
      commandButtonName: entry.commandButtonName.trim(),
    }))
    .sort((a, b) => a.slot - b.slot);
}

function extractCommandSetButtonSlots(fields: Record<string, IniValue>): CommandSetButtonSlot[] {
  const entries = Object.entries(fields)
    .map(([key, value]) => {
      const slot = Number(key);
      if (!Number.isInteger(slot) || slot <= 0 || slot > MAX_COMMAND_SET_SLOTS) {
        return null;
      }
      const commandButtonName = extractTokenString(value);
      if (!commandButtonName) {
        return null;
      }
      return { slot, commandButtonName };
    })
    .filter((entry): entry is { slot: number; commandButtonName: string } => entry !== null)
    .sort((a, b) => a.slot - b.slot);

  return entries;
}

function extractStringArray(value: IniValue | undefined): string[] | undefined {
  if (Array.isArray(value) && value.every((v) => typeof v === 'string')) {
    return value as string[];
  }
  return undefined;
}

function extractBoolean(value: IniValue | undefined): boolean | undefined {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value !== 0;
  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    if (normalized === 'true' || normalized === 'yes' || normalized === '1') return true;
    if (normalized === 'false' || normalized === 'no' || normalized === '0') return false;
  }
  return undefined;
}

function extractNumber(value: IniValue | undefined): number | undefined {
  const values = readNumericValues(value);
  if (values.length === 0) {
    return undefined;
  }
  const candidate = values[0];
  return Number.isFinite(candidate) ? candidate : undefined;
}

function extractInteger(value: IniValue | undefined): number | undefined {
  const numberValue = extractNumber(value);
  if (numberValue === undefined) {
    return undefined;
  }
  return Math.trunc(numberValue);
}

function extractPercentToReal(value: IniValue | undefined): number | undefined {
  if (typeof value === 'undefined') {
    return undefined;
  }

  if (typeof value === 'string') {
    const token = value.trim();
    if (!token) {
      return undefined;
    }
    if (token.endsWith('%')) {
      const rawPercent = Number(token.slice(0, -1).trim());
      if (!Number.isFinite(rawPercent)) {
        return undefined;
      }
      return Math.min(1, Math.max(0, rawPercent / 100));
    }
  }

  let numeric: number | undefined;
  if (Array.isArray(value)) {
    for (const entry of value) {
      const parsed = extractPercentToReal(entry as IniValue);
      if (parsed !== undefined) {
        return parsed;
      }
    }
    return undefined;
  } else if (typeof value === 'number') {
    numeric = value;
  } else if (typeof value === 'boolean') {
    numeric = value ? 1 : 0;
  } else if (typeof value === 'string') {
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) {
      return undefined;
    }
    numeric = parsed;
  }

  if (numeric === undefined || !Number.isFinite(numeric)) {
    return undefined;
  }

  const normalized = numeric > 1 ? numeric / 100 : numeric;
  return Math.min(1, Math.max(0, normalized));
}

function extractSignedPercentToReal(value: IniValue | undefined): number | undefined {
  if (typeof value === 'undefined') {
    return undefined;
  }

  if (Array.isArray(value)) {
    for (const entry of value) {
      const parsed = extractSignedPercentToReal(entry as IniValue);
      if (parsed !== undefined) {
        return parsed;
      }
    }
    return undefined;
  }

  let numeric: number | undefined;
  if (typeof value === 'string') {
    const token = value.trim();
    if (!token) {
      return undefined;
    }
    if (token.endsWith('%')) {
      const rawPercent = Number(token.slice(0, -1).trim());
      if (!Number.isFinite(rawPercent)) {
        return undefined;
      }
      numeric = rawPercent / 100;
    } else {
      const parsed = Number(token);
      if (!Number.isFinite(parsed)) {
        return undefined;
      }
      numeric = parsed > 1 || parsed < -1 ? parsed / 100 : parsed;
    }
  } else if (typeof value === 'number') {
    numeric = value > 1 || value < -1 ? value / 100 : value;
  } else if (typeof value === 'boolean') {
    numeric = value ? 1 : 0;
  }

  if (numeric === undefined || !Number.isFinite(numeric)) {
    return undefined;
  }

  return Math.min(1, Math.max(-1, numeric));
}

function readNumericValues(value: IniValue | undefined): number[] {
  if (typeof value === 'number') {
    return [value];
  }
  if (typeof value === 'boolean') {
    return [value ? 1 : 0];
  }
  if (typeof value === 'string') {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) {
      return [parsed];
    }
    return value.split(/[\s,;|]+/)
      .map((part) => part.trim())
      .filter(Boolean)
      .map((part) => Number(part))
      .filter((entry) => Number.isFinite(entry));
  }
  if (Array.isArray(value)) {
    return value
      .flatMap((entry) => readNumericValues(entry as IniValue))
      .filter((entry) => Number.isFinite(entry));
  }
  return [];
}

function extractLocomotorSurfaces(value: IniValue | undefined): string[] {
  if (!value) {
    return [];
  }
  const tokens = flattenIniStrings(value)
    .flatMap((token) => token.split(/[\s,;|]+/))
    .map((token) => token.trim().toUpperCase())
    .filter(Boolean);
  return Array.from(new Set(tokens));
}

function flattenIniStrings(value: IniValue): string[] {
  if (typeof value === 'string') return [value];
  if (typeof value === 'number' || typeof value === 'boolean') return [String(value)];
  if (Array.isArray(value)) {
    return value.flatMap((entry) => flattenIniStrings(entry as IniValue));
  }
  return [];
}

function locomotorSurfaceMaskFromNames(names: string[]): number {
  let mask = 0;
  for (const name of names) {
    switch (name) {
      case 'GROUND':
        mask |= 1 << 0;
        break;
      case 'WATER':
        mask |= 1 << 1;
        break;
      case 'CLIFF':
        mask |= 1 << 2;
        break;
      case 'AIR':
        mask |= 1 << 3;
        break;
      case 'RUBBLE':
        mask |= 1 << 4;
        break;
      default:
        break;
    }
  }
  return mask;
}

function audioEventSoundTypeFromBlockType(blockType: string): AudioEventSoundType {
  switch (blockType) {
    case 'MusicTrack':
      return 'music';
    case 'DialogEvent':
      return 'streaming';
    case 'AudioEvent':
    default:
      return 'sound';
  }
}
