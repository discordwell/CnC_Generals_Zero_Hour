/**
 * AssetManager — central runtime asset loading subsystem.
 *
 * Implements the Subsystem interface from @generals/core. Orchestrates:
 *  - Manifest loading and indexed lookups
 *  - IndexedDB caching with hash-based invalidation
 *  - In-flight request deduplication
 *  - SHA-256 integrity verification
 *  - Streaming progress reporting
 */

import type { Subsystem } from '@generals/core';
import type { AssetHandle, AssetManagerConfig, ProgressCallback } from './types.js';
import { DEFAULT_CONFIG } from './types.js';
import { AssetFetchError, AssetIntegrityError } from './errors.js';
import { sha256Hex } from './hash.js';
import { RuntimeManifest, loadManifest } from './manifest-loader.js';
import { CacheStore } from './cache.js';

export class AssetManager implements Subsystem {
  readonly name = 'AssetManager';

  private config: AssetManagerConfig;
  private manifest: RuntimeManifest | null = null;
  private cache: CacheStore | null = null;

  /** In-flight deduplication: path → pending Promise<ArrayBuffer>. */
  private readonly inflight = new Map<string, Promise<ArrayBuffer>>();

  constructor(config: Partial<AssetManagerConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  // ===========================================================================
  // Subsystem lifecycle
  // ===========================================================================

  async init(): Promise<void> {
    // Load manifest (returns null on 404 — graceful fallback)
    this.manifest = await loadManifest(this.resolveUrl(this.config.manifestUrl));

    // Open IndexedDB cache
    if (this.config.cacheEnabled) {
      this.cache = new CacheStore(this.config.dbName, this.config.maxCacheSize);
      try {
        await this.cache.open();
      } catch {
        // IndexedDB may be unavailable (incognito, etc.) — continue without cache
        console.warn('AssetManager: IndexedDB unavailable, caching disabled.');
        this.cache = null;
      }
    }
  }

  update(_dt: number): void {
    // Assets are loaded on-demand, nothing to do per frame.
  }

  dispose(): void {
    this.cache?.close();
    this.cache = null;
    this.manifest = null;
    this.inflight.clear();
  }

  reset(): void {
    this.inflight.clear();
  }

  // ===========================================================================
  // Public API
  // ===========================================================================

  /** Whether the manifest was successfully loaded. */
  get hasManifest(): boolean {
    return this.manifest !== null;
  }

  /** Get the loaded RuntimeManifest (may be null). */
  getManifest(): RuntimeManifest | null {
    return this.manifest;
  }

  /**
   * Load a JSON asset by output path.
   * Returns parsed JSON of type T.
   */
  async loadJSON<T = unknown>(path: string, onProgress?: ProgressCallback): Promise<AssetHandle<T>> {
    const raw = await this.loadRaw(path, onProgress);
    const text = new TextDecoder().decode(raw.data);
    const data = JSON.parse(text) as T;
    return { path: raw.path, data, hash: raw.hash, cached: raw.cached };
  }

  /**
   * Load a raw ArrayBuffer asset by output path.
   */
  async loadArrayBuffer(path: string, onProgress?: ProgressCallback): Promise<AssetHandle<ArrayBuffer>> {
    return this.loadRaw(path, onProgress);
  }

  /**
   * Load multiple assets in parallel with aggregate progress.
   */
  async loadBatch(
    paths: string[],
    onProgress?: ProgressCallback,
  ): Promise<AssetHandle<ArrayBuffer>[]> {
    let completedBytes = 0;
    const totalEstimate = paths.length; // Each counts as 1 unit for progress

    const handles = await Promise.all(
      paths.map(async (path) => {
        const handle = await this.loadRaw(path);
        completedBytes++;
        onProgress?.(completedBytes, totalEstimate);
        return handle;
      }),
    );

    return handles;
  }

  // ===========================================================================
  // Core loading logic
  // ===========================================================================

  private async loadRaw(path: string, onProgress?: ProgressCallback): Promise<AssetHandle<ArrayBuffer>> {
    const manifestEntry = this.manifest?.getByOutputPath(path);
    const expectedHash = manifestEntry?.outputHash ?? null;

    // 1. Check IndexedDB cache
    if (this.cache) {
      const cached = await this.cache.get(path, expectedHash ?? undefined);
      if (cached) {
        onProgress?.(cached.size, cached.size);
        return { path, data: cached.data, hash: cached.hash, cached: true };
      }
    }

    // 2. Fetch with in-flight deduplication
    const data = await this.fetchDeduped(path, onProgress);

    // 3. Integrity check
    let actualHash: string | null = null;
    if (this.config.integrityChecks && expectedHash) {
      actualHash = await sha256Hex(data);
      if (actualHash !== expectedHash) {
        throw new AssetIntegrityError(path, expectedHash, actualHash);
      }
    }

    // 4. Cache write (fire-and-forget)
    if (this.cache && actualHash) {
      this.cache.put(path, data, actualHash).catch(() => {});
    } else if (this.cache && !actualHash) {
      // Hash wasn't computed for integrity — compute it for cache keying
      sha256Hex(data).then((hash) => {
        this.cache?.put(path, data, hash).catch(() => {});
      }).catch(() => {});
    }

    return { path, data, hash: actualHash, cached: false };
  }

  private fetchDeduped(path: string, onProgress?: ProgressCallback): Promise<ArrayBuffer> {
    const existing = this.inflight.get(path);
    if (existing) return existing;

    const promise = this.fetchAsset(path, onProgress).finally(() => {
      this.inflight.delete(path);
    });

    this.inflight.set(path, promise);
    return promise;
  }

  private async fetchAsset(path: string, onProgress?: ProgressCallback): Promise<ArrayBuffer> {
    const url = this.resolveUrl(path);
    let response: Response;

    try {
      response = await fetch(url);
    } catch {
      throw new AssetFetchError(path, 0);
    }

    if (!response.ok) {
      throw new AssetFetchError(path, response.status);
    }

    // Streaming progress if callback provided and content-length available
    if (onProgress && response.body) {
      const contentLength = Number(response.headers.get('content-length') ?? 0);
      if (contentLength > 0) {
        return this.readWithProgress(response.body, contentLength, onProgress);
      }
    }

    return response.arrayBuffer();
  }

  private async readWithProgress(
    body: ReadableStream<Uint8Array>,
    total: number,
    onProgress: ProgressCallback,
  ): Promise<ArrayBuffer> {
    const reader = body.getReader();
    const chunks: Uint8Array[] = [];
    let received = 0;

    for (;;) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      received += value.byteLength;
      onProgress(received, total);
    }

    // Concatenate chunks
    const result = new Uint8Array(received);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.byteLength;
    }

    return result.buffer as ArrayBuffer;
  }

  private resolveUrl(path: string): string {
    const base = this.config.baseUrl;
    if (!base) return path;
    return base.endsWith('/') ? `${base}${path}` : `${base}/${path}`;
  }
}
