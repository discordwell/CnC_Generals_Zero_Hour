import * as THREE from 'three';
import { describe, expect, it } from 'vitest';

import type { IniBlock } from '@generals/core';
import type { InputState } from '@generals/input';
import {
  type ArmorDef,
  type CommandButtonDef,
  type CommandSetDef,
  type FactionDef,
  IniDataRegistry,
  type IniDataBundle,
  type LocomotorDef,
  type ObjectDef,
  type ScienceDef,
  type SpecialPowerDef,
  type UpgradeDef,
  type WeaponDef,
} from '@generals/ini-data';
import { HeightmapGrid, type MapDataJSON, type MapObjectJSON, uint8ArrayToBase64 } from '@generals/terrain';

import { GameLogicSubsystem } from './index.js';
import { CELL_CLEAR, CELL_FOGGED, CELL_SHROUDED } from './fog-of-war.js';

function makeBlock(
  type: string,
  name: string,
  fields: Record<string, unknown>,
  blocks: IniBlock[] = [],
): IniBlock {
  return {
    type,
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
    blocks,
  };
}

function makeObjectDef(
  name: string,
  side: string,
  kindOf: string[],
  blocks: IniBlock[],
  fields: Record<string, unknown> = {},
): ObjectDef {
  return {
    name,
    side,
    kindOf,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
    blocks,
    resolved: true,
  };
}

function makeWeaponDef(name: string, fields: Record<string, unknown>): WeaponDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
    blocks: [],
  };
}

function makeArmorDef(name: string, fields: Record<string, unknown>): ArmorDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
  };
}

function makeLocomotorDef(name: string, speed: number): LocomotorDef {
  return {
    name,
    fields: { Speed: speed },
    surfaces: ['GROUND'],
    surfaceMask: 1,
    downhillOnly: false,
    speed,
  };
}

function makeUpgradeDef(name: string, fields: Record<string, unknown>): UpgradeDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
  };
}

function makeCommandButtonDef(name: string, fields: Record<string, unknown>): CommandButtonDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
  };
}

function makeCommandSetDef(name: string, fields: Record<string, unknown>): CommandSetDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
  };
}

function makeScienceDef(name: string, fields: Record<string, unknown>): ScienceDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
  };
}

function makeSpecialPowerDef(name: string, fields: Record<string, unknown>): SpecialPowerDef {
  return {
    name,
    fields: fields as Record<string, string | number | boolean | string[] | number[]>,
    blocks: [],
  };
}

function makeBundle(params: {
  objects: ObjectDef[];
  weapons?: WeaponDef[];
  armors?: ArmorDef[];
  upgrades?: UpgradeDef[];
  commandButtons?: CommandButtonDef[];
  commandSets?: CommandSetDef[];
  sciences?: ScienceDef[];
  specialPowers?: SpecialPowerDef[];
  locomotors?: LocomotorDef[];
  factions?: FactionDef[];
}): IniDataBundle {
  const weapons = params.weapons ?? [];
  const armors = params.armors ?? [];
  const upgrades = params.upgrades ?? [];
  const commandButtons = params.commandButtons ?? [];
  const commandSets = params.commandSets ?? [];
  const sciences = params.sciences ?? [];
  const specialPowers = params.specialPowers ?? [];
  const locomotors = params.locomotors ?? [];
  const factions = params.factions ?? [];
  return {
    objects: params.objects,
    weapons,
    armors,
    upgrades,
    commandButtons,
    commandSets,
    sciences,
    specialPowers,
    factions,
    locomotors,
    ai: {
      attackUsesLineOfSight: true,
    },
    stats: {
      objects: params.objects.length,
      weapons: weapons.length,
      armors: armors.length,
      upgrades: upgrades.length,
      sciences: sciences.length,
      factions: 0,
      unresolvedInheritance: 0,
      totalBlocks:
        params.objects.length
        + weapons.length
        + armors.length
        + upgrades.length
        + specialPowers.length
        + commandButtons.length
        + commandSets.length
        + sciences.length
        + locomotors.length,
    },
    errors: [],
    unsupportedBlockTypes: [],
  };
}

function makeRegistry(bundle: IniDataBundle): IniDataRegistry {
  const registry = new IniDataRegistry();
  registry.loadBundle(bundle);
  return registry;
}

function makeHeightmap(width = 8, height = 8): HeightmapGrid {
  const data = new Uint8Array(width * height).fill(0);
  return HeightmapGrid.fromJSON({
    width,
    height,
    borderSize: 0,
    data: uint8ArrayToBase64(data),
  });
}

function makeMap(objects: MapObjectJSON[], width = 8, height = 8): MapDataJSON {
  const data = new Uint8Array(width * height).fill(0);
  return {
    heightmap: {
      width,
      height,
      borderSize: 0,
      data: uint8ArrayToBase64(data),
    },
    objects,
    triggers: [],
    textureClasses: [],
    blendTileCount: 0,
  };
}

function makeMapObject(
  templateName: string,
  x: number,
  y: number,
  properties: Record<string, string> = {},
): MapObjectJSON {
  return {
    templateName,
    angle: 0,
    flags: 0,
    position: { x, y, z: 0 },
    properties,
  };
}

function makeInputState(overrides: Partial<InputState> = {}): InputState {
  return {
    keysDown: new Set<string>(),
    keysPressed: new Set<string>(),
    mouseX: 0,
    mouseY: 0,
    viewportWidth: 800,
    viewportHeight: 600,
    wheelDelta: 0,
    middleMouseDown: false,
    leftMouseDown: false,
    rightMouseDown: false,
    leftMouseClick: false,
    rightMouseClick: false,
    middleDragDx: 0,
    middleDragDy: 0,
    pointerInCanvas: true,
    ...overrides,
  };
}

function runCombatTimeline(): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('Attacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestCannon'] }),
      ]),
      makeObjectDef('Target', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('TestCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  const map = makeMap([
    makeMapObject('Attacker', 10, 10),
    makeMapObject('Target', 30, 10),
  ]);

  logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap());
  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 12; frame += 1) {
    logic.update(1 / 30);
    const targetState = logic.getEntityState(2);
    timeline.push(targetState ? targetState.health : -1);
  }

  return timeline;
}

function runArmorUpgradeCombatTimeline(): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('Attacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestRifle'] }),
      ]),
      makeObjectDef('Target', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('ArmorSet', 'ArmorSet', {
          Conditions: 'NONE',
          Armor: 'TargetArmor_Default',
        }),
        makeBlock('ArmorSet', 'ArmorSet', {
          Conditions: 'PLAYER_UPGRADE',
          Armor: 'TargetArmor_Upgraded',
        }),
        makeBlock('Behavior', 'ArmorUpgrade ModuleTag_ArmorUpgrade', {
          TriggeredBy: 'Upgrade_Armor',
        }),
      ]),
    ],
    weapons: [
      makeWeaponDef('TestRifle', {
        AttackRange: 140,
        PrimaryDamage: 40,
        DamageType: 'SMALL_ARMS',
        DelayBetweenShots: 100,
      }),
    ],
    armors: [
      makeArmorDef('TargetArmor_Default', {
        Default: 1,
        SMALL_ARMS: 1,
      }),
      makeArmorDef('TargetArmor_Upgraded', {
        Default: 1,
        SMALL_ARMS: 0.25,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  const map = makeMap([
    makeMapObject('Attacker', 10, 10),
    makeMapObject('Target', 30, 10),
  ]);

  logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap());
  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 10; frame += 1) {
    if (frame === 1) {
      logic.submitCommand({ type: 'applyUpgrade', entityId: 2, upgradeName: 'Upgrade_Armor' });
    }
    logic.update(1 / 30);
    const targetState = logic.getEntityState(2);
    timeline.push(targetState ? targetState.health : -1);
  }

  return timeline;
}

function runPrefireTypeCombatTimeline(preAttackType: 'PER_SHOT' | 'PER_ATTACK'): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('PrefireAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'PrefireCannon'] }),
      ]),
      makeObjectDef('PrefireTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('PrefireCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
        PreAttackDelay: 100,
        PreAttackType: preAttackType,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('PrefireAttacker', 10, 10), makeMapObject('PrefireTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 12; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return timeline;
}

function runPerClipPrefireTimeline(): {
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('PrefireClipAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'PrefireClipCannon'] }),
      ]),
      makeObjectDef('PrefireClipTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 220, InitialHealth: 220 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('PrefireClipCannon', {
        AttackRange: 120,
        PrimaryDamage: 20,
        DelayBetweenShots: 100,
        ClipSize: 2,
        ClipReloadTime: 200,
        PreAttackDelay: 100,
        PreAttackType: 'PER_CLIP',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('PrefireClipAttacker', 10, 10), makeMapObject('PrefireClipTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 18; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { targetHealthTimeline };
}

function runAutoReloadWhenIdleTimeline(autoReloadWhenIdleMs: number): {
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('AutoReloadAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AutoReloadCannon'] }),
      ]),
      makeObjectDef('AutoReloadTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('AutoReloadCannon', {
        AttackRange: 120,
        PrimaryDamage: 20,
        DelayBetweenShots: 100,
        ClipSize: 3,
        ClipReloadTime: 1000,
        PreAttackDelay: 100,
        PreAttackType: 'PER_CLIP',
        AutoReloadWhenIdle: autoReloadWhenIdleMs,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('AutoReloadAttacker', 10, 10), makeMapObject('AutoReloadTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 16; frame += 1) {
    if (frame === 4) {
      logic.submitCommand({ type: 'stop', entityId: 1 });
    }
    if (frame === 10) {
      logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
    }

    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { targetHealthTimeline };
}

function runWeaponSpeedDelayTimeline(): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('TravelDelayAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TravelDelayCannon'] }),
      ]),
      makeObjectDef('TravelDelayTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('TravelDelayCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        DelayBetweenShots: 1000,
        WeaponSpeed: 5,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('TravelDelayAttacker', 10, 10), makeMapObject('TravelDelayTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return timeline;
}

function runRadiusDamageAffectsTimeline(): {
  primaryHealthTimeline: number[];
  splashEnemyHealthTimeline: number[];
  splashAllyHealthTimeline: number[];
  attackerHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('RadiusAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'RadiusCannon'] }),
      ]),
      makeObjectDef('RadiusPrimaryTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('RadiusSplashEnemy', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('RadiusSplashAlly', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('RadiusCannon', {
        AttackRange: 140,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 8,
        SecondaryDamage: 15,
        SecondaryDamageRadius: 16,
        RadiusDamageAffects: 'ENEMIES',
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('RadiusAttacker', 10, 10),
      makeMapObject('RadiusPrimaryTarget', 30, 10),
      makeMapObject('RadiusSplashEnemy', 42, 10),
      makeMapObject('RadiusSplashAlly', 42, 16),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const primaryHealthTimeline: number[] = [];
  const splashEnemyHealthTimeline: number[] = [];
  const splashAllyHealthTimeline: number[] = [];
  const attackerHealthTimeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    primaryHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    splashEnemyHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    splashAllyHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
    attackerHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return {
    primaryHealthTimeline,
    splashEnemyHealthTimeline,
    splashAllyHealthTimeline,
    attackerHealthTimeline,
  };
}

function runDamageAtSelfPositionTimeline(): {
  farTargetHealthTimeline: number[];
  nearEnemyHealthTimeline: number[];
  nearAllyHealthTimeline: number[];
  attackerHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('SelfDamageAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SelfDamageBurst'] }),
      ]),
      makeObjectDef('SelfDamageFarTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('SelfDamageNearEnemy', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('SelfDamageNearAlly', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SelfDamageBurst', {
        AttackRange: 140,
        PrimaryDamage: 30,
        PrimaryDamageRadius: 8,
        DamageDealtAtSelfPosition: true,
        RadiusDamageAffects: 'ENEMIES',
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('SelfDamageAttacker', 10, 10),
      makeMapObject('SelfDamageFarTarget', 30, 10),
      makeMapObject('SelfDamageNearEnemy', 15, 10),
      makeMapObject('SelfDamageNearAlly', 15, 15),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const farTargetHealthTimeline: number[] = [];
  const nearEnemyHealthTimeline: number[] = [];
  const nearAllyHealthTimeline: number[] = [];
  const attackerHealthTimeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    farTargetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    nearEnemyHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    nearAllyHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
    attackerHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return {
    farTargetHealthTimeline,
    nearEnemyHealthTimeline,
    nearAllyHealthTimeline,
    attackerHealthTimeline,
  };
}

function runRadiusDamageAngleTimeline(): {
  primaryHealthTimeline: number[];
  inConeEnemyHealthTimeline: number[];
  outOfConeEnemyHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ConeAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 160, InitialHealth: 160 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ConeCannon'] }),
      ]),
      makeObjectDef('ConePrimaryTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 160, InitialHealth: 160 }),
      ]),
      makeObjectDef('ConeEnemyInside', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 160, InitialHealth: 160 }),
      ]),
      makeObjectDef('ConeEnemyOutside', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 160, InitialHealth: 160 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ConeCannon', {
        AttackRange: 220,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 8,
        SecondaryDamage: 20,
        SecondaryDamageRadius: 20,
        RadiusDamageAffects: 'ENEMIES',
        RadiusDamageAngle: 50,
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ConeAttacker', 20, 20),
      makeMapObject('ConePrimaryTarget', 30, 20),
      makeMapObject('ConeEnemyInside', 30, 30),
      makeMapObject('ConeEnemyOutside', 20, 34),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const primaryHealthTimeline: number[] = [];
  const inConeEnemyHealthTimeline: number[] = [];
  const outOfConeEnemyHealthTimeline: number[] = [];
  for (let frame = 0; frame < 3; frame += 1) {
    logic.update(1 / 30);
    primaryHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    inConeEnemyHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    outOfConeEnemyHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
  }

  return {
    primaryHealthTimeline,
    inConeEnemyHealthTimeline,
    outOfConeEnemyHealthTimeline,
  };
}

function runSuicideAndNotSimilarTimeline(): {
  attackerHealthTimeline: number[];
  farTargetHealthTimeline: number[];
  nearEnemyHealthTimeline: number[];
  nearAllyHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('TerrorUnit', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SuicideBlast'] }),
      ]),
      makeObjectDef('FarEnemy', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('NearEnemy', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SuicideBlast', {
        AttackRange: 220,
        PrimaryDamage: 30,
        PrimaryDamageRadius: 8,
        DamageDealtAtSelfPosition: true,
        RadiusDamageAffects: 'SELF ALLIES ENEMIES SUICIDE NOT_SIMILAR',
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('TerrorUnit', 20, 20),
      makeMapObject('FarEnemy', 40, 20),
      makeMapObject('NearEnemy', 25, 20),
      makeMapObject('TerrorUnit', 25, 25),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerHealthTimeline: number[] = [];
  const farTargetHealthTimeline: number[] = [];
  const nearEnemyHealthTimeline: number[] = [];
  const nearAllyHealthTimeline: number[] = [];
  for (let frame = 0; frame < 3; frame += 1) {
    logic.update(1 / 30);
    attackerHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
    farTargetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    nearEnemyHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    nearAllyHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
  }

  return {
    attackerHealthTimeline,
    farTargetHealthTimeline,
    nearEnemyHealthTimeline,
    nearAllyHealthTimeline,
  };
}

function runProjectileDeliveryTimeline(useProjectileObject: boolean): number[] {
  const weaponName = useProjectileObject ? 'ProjectileCannon' : 'DirectCannon';
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileTimingAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', weaponName] }),
      ]),
      makeObjectDef('ProjectileTimingTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
      }),
      makeWeaponDef('DirectCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ProjectileTimingAttacker', 10, 10), makeMapObject('ProjectileTimingTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runDirectImmediateDuelTimeline(): {
  firstHealthTimeline: number[];
  secondHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('DuelTankA', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'InstantDuelCannon'] }),
      ]),
      makeObjectDef('DuelTankB', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'InstantDuelCannon'] }),
      ]),
    ],
    weapons: [
      makeWeaponDef('InstantDuelCannon', {
        AttackRange: 120,
        PrimaryDamage: 200,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('DuelTankA', 10, 10), makeMapObject('DuelTankB', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

  const firstHealthTimeline: number[] = [];
  const secondHealthTimeline: number[] = [];
  for (let frame = 0; frame < 3; frame += 1) {
    logic.update(1 / 30);
    firstHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
    secondHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { firstHealthTimeline, secondHealthTimeline };
}

function runScaledProjectileDeliveryTimeline(useScaledSpeed: boolean): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ScaledProjectileAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ScaledProjectileCannon'] }),
      ]),
      makeObjectDef('ScaledProjectileTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ScaledProjectileCannon', {
        AttackRange: 120,
        MinimumAttackRange: 20,
        PrimaryDamage: 30,
        WeaponSpeed: 60,
        MinWeaponSpeed: 10,
        ScaleWeaponSpeed: useScaledSpeed,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ScaledProjectileAttacker', 10, 10), makeMapObject('ScaledProjectileTarget', 70, 10)], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runProjectileMovingTargetPointHitTimeline(targetMovesBeforeImpact: boolean): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectilePointHitAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectilePointHitCannon'] }),
      ]),
      makeObjectDef('ProjectilePointHitTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectilePointHitCannon', {
        AttackRange: 180,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorFast', 180),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ProjectilePointHitAttacker', 20, 20), makeMapObject('ProjectilePointHitTarget', 50, 20)], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  if (targetMovesBeforeImpact) {
    logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: 110, targetZ: 20 });
  }
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 7; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runProjectileIncidentalCollisionMaskTimeline(projectileCollidesWith: string): {
  targetHealthTimeline: number[];
  blockerHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileMaskAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileMaskCannon'] }),
      ]),
      makeObjectDef('ProjectileMaskTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ]),
      makeObjectDef('ProjectileMaskBlocker', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileMaskCannon', {
        AttackRange: 180,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: projectileCollidesWith,
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorFast', 180),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ProjectileMaskAttacker', 20, 20),
      makeMapObject('ProjectileMaskTarget', 50, 20),
      makeMapObject('ProjectileMaskBlocker', 50, 20),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: 110, targetZ: 20 });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  const blockerHealthTimeline: number[] = [];
  for (let frame = 0; frame < 7; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    blockerHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
  }

  return { targetHealthTimeline, blockerHealthTimeline };
}

function runProjectileContainedByCollisionTimeline(): {
  targetHealthTimeline: number[];
  containingAirfieldHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ContainingAirfield', 'America', ['STRUCTURE', 'FS_AIRFIELD'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [0, 0, 0],
          ExitDelay: 0,
        }),
        makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
          NumRows: 1,
          NumCols: 1,
        }),
      ]),
      makeObjectDef('EscapeTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ]),
      makeObjectDef('ContainedLauncher', 'America', ['AIRCRAFT'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ContainedLauncherCannon'] }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ], {
        BuildCost: 100,
        BuildTime: 0.1,
      }),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ContainedLauncherCannon', {
        AttackRange: 180,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: 'CONTROLLED_STRUCTURES',
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorFast', 180),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ContainingAirfield', 50, 20), makeMapObject('EscapeTarget', 50, 20)], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'ContainedLauncher' });

  let launcherId: number | null = null;
  for (let frame = 0; frame < 10; frame += 1) {
    logic.update(1 / 30);
    launcherId = logic.getEntityIdsByTemplate('ContainedLauncher')[0] ?? null;
    if (launcherId !== null) {
      break;
    }
  }
  if (launcherId === null) {
    throw new Error('ContainedLauncher did not spawn');
  }

  logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: 110, targetZ: 20 });
  logic.submitCommand({ type: 'attackEntity', entityId: launcherId, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  const containingAirfieldHealthTimeline: number[] = [];
  for (let frame = 0; frame < 7; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    containingAirfieldHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return { targetHealthTimeline, containingAirfieldHealthTimeline };
}

function runProjectileAirfieldReservedVictimCollisionTimeline(): {
  targetHealthTimeline: number[];
  airfieldHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('AirfieldCollisionAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AirfieldCollisionCannon'] }),
      ]),
      makeObjectDef('EnemyAirfield', 'China', ['STRUCTURE', 'FS_AIRFIELD'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [0, 0, 0],
          ExitDelay: 0,
        }),
        makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
          NumRows: 1,
          NumCols: 1,
        }),
      ]),
      makeObjectDef('ParkedTargetJet', 'China', ['AIRCRAFT'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ], {
        BuildCost: 100,
        BuildTime: 0.1,
      }),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('AirfieldCollisionCannon', {
        AttackRange: 180,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: 'ENEMIES STRUCTURES',
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorFast', 180),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('AirfieldCollisionAttacker', 20, 20), makeMapObject('EnemyAirfield', 50, 20)], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 2, unitTemplateName: 'ParkedTargetJet' });

  let targetId: number | null = null;
  for (let frame = 0; frame < 10; frame += 1) {
    logic.update(1 / 30);
    targetId = logic.getEntityIdsByTemplate('ParkedTargetJet')[0] ?? null;
    if (targetId !== null) {
      break;
    }
  }
  if (targetId === null) {
    throw new Error('ParkedTargetJet did not spawn');
  }

  logic.submitCommand({ type: 'moveTo', entityId: targetId, targetX: 110, targetZ: 20 });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: targetId });

  const targetHealthTimeline: number[] = [];
  const airfieldHealthTimeline: number[] = [];
  for (let frame = 0; frame < 7; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(targetId)?.health ?? -1);
    airfieldHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { targetHealthTimeline, airfieldHealthTimeline };
}

function runProjectileSneakyTargetingOffsetTimeline(enableSneakyOffset: boolean): number[] {
  const sneakyBehaviorBlocks = enableSneakyOffset
    ? [
      makeBlock('Behavior', 'JetAIUpdate ModuleTag_Sneaky', {
        SneakyOffsetWhenAttacking: 20,
        AttackersMissPersistTime: 1000,
      }),
    ]
    : [];

  const bundle = makeBundle({
    objects: [
      makeObjectDef('SneakyJet', 'China', ['AIRCRAFT'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SneakyJetGun'] }),
        ...sneakyBehaviorBlocks,
      ]),
      makeObjectDef('OffsetAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AttackSneakyTargetCannon'] }),
      ]),
      makeObjectDef('DummyTargetForJet', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SneakyJetGun', {
        AttackRange: 220,
        PrimaryDamage: 5,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
      }),
      makeWeaponDef('AttackSneakyTargetCannon', {
        AttackRange: 220,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: 'ENEMIES',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('SneakyJet', 50, 20),
      makeMapObject('OffsetAttacker', 20, 20),
      makeMapObject('DummyTargetForJet', 80, 20),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 7; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return targetHealthTimeline;
}

function runProjectileSneakyIncidentalImmunityTimeline(enableSneakyOffset: boolean): {
  targetHealthTimeline: number[];
  blockerHealthTimeline: number[];
} {
  const sneakyBehaviorBlocks = enableSneakyOffset
    ? [
      makeBlock('Behavior', 'JetAIUpdate ModuleTag_Sneaky', {
        SneakyOffsetWhenAttacking: 20,
        AttackersMissPersistTime: 1000,
      }),
    ]
    : [];

  const bundle = makeBundle({
    objects: [
      makeObjectDef('SneakyBlocker', 'China', ['AIRCRAFT'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SneakyJetGun'] }),
        ...sneakyBehaviorBlocks,
      ]),
      makeObjectDef('ProjectileIncidentalAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileIncidentalCannon'] }),
      ]),
      makeObjectDef('ProjectileIncidentalTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ]),
      makeObjectDef('DummyTargetForBlocker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SneakyJetGun', {
        AttackRange: 220,
        PrimaryDamage: 5,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
      }),
      makeWeaponDef('ProjectileIncidentalCannon', {
        AttackRange: 220,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: 'ENEMIES',
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorFast', 180),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('SneakyBlocker', 50, 20),
      makeMapObject('ProjectileIncidentalAttacker', 20, 20),
      makeMapObject('ProjectileIncidentalTarget', 50, 20),
      makeMapObject('DummyTargetForBlocker', 80, 20),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 4 });
  logic.submitCommand({ type: 'moveTo', entityId: 3, targetX: 110, targetZ: 20 });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 3 });

  const targetHealthTimeline: number[] = [];
  const blockerHealthTimeline: number[] = [];
  for (let frame = 0; frame < 7; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    blockerHealthTimeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return { targetHealthTimeline, blockerHealthTimeline };
}

function runProjectileSneakyCooldownRefreshTimeline(enableSneakyOffset: boolean): number[] {
  const sneakyBehaviorBlocks = enableSneakyOffset
    ? [
      makeBlock('Behavior', 'JetAIUpdate ModuleTag_Sneaky', {
        SneakyOffsetWhenAttacking: 20,
        AttackersMissPersistTime: 100,
      }),
    ]
    : [];

  const bundle = makeBundle({
    objects: [
      makeObjectDef('SneakyCooldownJet', 'China', ['AIRCRAFT'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SneakyCooldownJetGun'] }),
        ...sneakyBehaviorBlocks,
      ]),
      makeObjectDef('CooldownAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'CooldownAttackCannon'] }),
      ]),
      makeObjectDef('DummyTargetForCooldownJet', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SneakyCooldownJetGun', {
        AttackRange: 220,
        PrimaryDamage: 5,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
      }),
      makeWeaponDef('CooldownAttackCannon', {
        AttackRange: 220,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 5,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: 'ENEMIES',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('SneakyCooldownJet', 50, 20),
      makeMapObject('CooldownAttacker', 20, 20),
      makeMapObject('DummyTargetForCooldownJet', 80, 20),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 10; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return timeline;
}

function runProjectileSneakyPersistAfterStopTimeline(stopAtFrame: number | null): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('SneakyStopJet', 'China', ['AIRCRAFT'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SneakyStopJetGun'] }),
        makeBlock('Behavior', 'JetAIUpdate ModuleTag_Sneaky', {
          SneakyOffsetWhenAttacking: 20,
          AttackersMissPersistTime: 100,
        }),
      ]),
      makeObjectDef('StopTimelineAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'StopTimelineAttackCannon'] }),
      ]),
      makeObjectDef('DummyTargetForStopJet', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SneakyStopJetGun', {
        AttackRange: 220,
        PrimaryDamage: 5,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
      }),
      makeWeaponDef('StopTimelineAttackCannon', {
        AttackRange: 220,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 10,
        DelayBetweenShots: 100,
        ProjectileObject: 'DummyProjectile',
        ProjectileCollidesWith: 'ENEMIES',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('SneakyStopJet', 50, 20),
      makeMapObject('StopTimelineAttacker', 20, 20),
      makeMapObject('DummyTargetForStopJet', 80, 20),
    ], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 12; frame += 1) {
    if (stopAtFrame !== null && frame === stopAtFrame) {
      logic.submitCommand({ type: 'stop', entityId: 1 });
    }
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(1)?.health ?? -1);
  }

  return timeline;
}

function runDamageAtSelfScatterTargetTimeline(useScatterTarget: boolean): {
  targetHealthTimeline: number[];
  nearEnemyHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('SelfScatterAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 160, InitialHealth: 160 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SelfScatterCannon'] }),
      ]),
      makeObjectDef('SelfScatterTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('SelfScatterNearEnemy', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('SelfScatterCannon', {
        AttackRange: 160,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 6,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        DamageDealtAtSelfPosition: true,
        RadiusDamageAffects: 'ENEMIES',
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
        ...(useScatterTarget
          ? {
            ScatterTargetScalar: 30,
            ScatterTarget: [[1, 0]],
          }
          : {}),
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('SelfScatterAttacker', 20, 20),
      makeMapObject('SelfScatterTarget', 50, 20),
      makeMapObject('SelfScatterNearEnemy', 22, 20),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  const nearEnemyHealthTimeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    nearEnemyHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
  }

  return {
    targetHealthTimeline,
    nearEnemyHealthTimeline,
  };
}

function runProjectileSplashTimeline(): {
  primaryHealthTimeline: number[];
  splashHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileSplashAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 140, InitialHealth: 140 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileSplashCannon'] }),
      ]),
      makeObjectDef('ProjectileSplashPrimary', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('ProjectileSplashSecondary', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileSplashCannon', {
        AttackRange: 150,
        PrimaryDamage: 40,
        PrimaryDamageRadius: 8,
        SecondaryDamage: 20,
        SecondaryDamageRadius: 16,
        RadiusDamageAffects: 'ENEMIES',
        WeaponSpeed: 8,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ProjectileSplashAttacker', 10, 10),
      makeMapObject('ProjectileSplashPrimary', 30, 10),
      makeMapObject('ProjectileSplashSecondary', 42, 10),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const primaryHealthTimeline: number[] = [];
  const splashHealthTimeline: number[] = [];
  for (let frame = 0; frame < 5; frame += 1) {
    logic.update(1 / 30);
    primaryHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
    splashHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
  }

  return {
    primaryHealthTimeline,
    splashHealthTimeline,
  };
}

function runProjectileScatterTimeline(scatterRadius: number): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileScatterAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileScatterCannon'] }),
      ]),
      makeObjectDef('ProjectileScatterTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileScatterCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        PrimaryDamageRadius: 0.1,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        ScatterRadius: scatterRadius,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ProjectileScatterAttacker', 10, 10), makeMapObject('ProjectileScatterTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runProjectileInfantryInaccuracyTimeline(targetKind: 'INFANTRY' | 'VEHICLE'): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileInaccuracyAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileInaccuracyCannon'] }),
      ]),
      makeObjectDef('ProjectileInaccuracyTarget', 'China', [targetKind], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileInaccuracyCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        PrimaryDamageRadius: 0.1,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        ScatterRadius: 0,
        ScatterRadiusVsInfantry: 200,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ProjectileInaccuracyAttacker', 10, 10), makeMapObject('ProjectileInaccuracyTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runProjectileScatterTargetTimeline(useScatterTargets: boolean): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileScatterTargetAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 120, InitialHealth: 120 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileScatterTargetCannon'] }),
      ]),
      makeObjectDef('ProjectileScatterTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileScatterTargetCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        PrimaryDamageRadius: 0.1,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 1000,
        ProjectileObject: 'DummyProjectile',
        ...(useScatterTargets
          ? {
            ScatterTargetScalar: 30,
            ScatterTarget: [[1, 0], [-1, 0]],
          }
          : {}),
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ProjectileScatterTargetAttacker', 10, 10), makeMapObject('ProjectileScatterTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runProjectileScatterTargetReloadTimeline(): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ProjectileScatterReloadAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ProjectileScatterReloadCannon'] }),
      ]),
      makeObjectDef('ProjectileScatterReloadTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
      makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ProjectileScatterReloadCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        PrimaryDamageRadius: 0.1,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 100,
        ClipSize: 2,
        ClipReloadTime: 100,
        ProjectileObject: 'DummyProjectile',
        ScatterTargetScalar: 30,
        ScatterTarget: [[1, 0]],
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('ProjectileScatterReloadAttacker', 10, 10), makeMapObject('ProjectileScatterReloadTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const timeline: number[] = [];
  for (let frame = 0; frame < 12; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityState(2)?.health ?? -1);
  }
  return timeline;
}

function runFifoProductionTimeline(): {
  alphaCounts: number[];
  bravoCounts: number[];
  queuePercents: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef(
        'Factory',
        'America',
        ['STRUCTURE'],
        [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 3,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [12, 0, 0],
            NaturalRallyPoint: [28, 0, 0],
            ExitDelay: 0,
            InitialBurst: 0,
          }),
        ],
      ),
      makeObjectDef('InfantryAlpha', 'America', ['INFANTRY'], [], { BuildTime: 0.2, BuildCost: 100 }),
      makeObjectDef('InfantryBravo', 'America', ['INFANTRY'], [], { BuildTime: 0.2, BuildCost: 100 }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  const map = makeMap([makeMapObject('Factory', 40, 40)]);
  logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'InfantryAlpha' });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'InfantryBravo' });

  const alphaCounts: number[] = [];
  const bravoCounts: number[] = [];
  const queuePercents: number[] = [];
  for (let frame = 0; frame < 12; frame += 1) {
    logic.update(1 / 30);
    alphaCounts.push(logic.getEntityIdsByTemplate('InfantryAlpha').length);
    bravoCounts.push(logic.getEntityIdsByTemplate('InfantryBravo').length);
    const queue = logic.getProductionState(1);
    queuePercents.push(queue?.queue[0]?.percentComplete ?? -1);
  }

  return { alphaCounts, bravoCounts, queuePercents };
}

function runQuantityModifierDelayTimeline(exitDelayMs = 66): number[] {
  const bundle = makeBundle({
    objects: [
      makeObjectDef(
        'Barracks',
        'China',
        ['STRUCTURE'],
        [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 3,
            QuantityModifier: 'RedGuard 2',
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
            ExitDelay: exitDelayMs,
            InitialBurst: 0,
          }),
        ],
      ),
      makeObjectDef('RedGuard', 'China', ['INFANTRY'], [], { BuildTime: 0.1, BuildCost: 300 }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  const map = makeMap([makeMapObject('Barracks', 20, 20)]);
  logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'RedGuard' });

  const timeline: number[] = [];
  for (let frame = 0; frame < 6; frame += 1) {
    logic.update(1 / 30);
    timeline.push(logic.getEntityIdsByTemplate('RedGuard').length);
  }

  return timeline;
}

function runSupplyCenterExitProductionTimeline(): {
  producedCounts: number[];
  queueCounts: number[];
  credits: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('SupplyCenter', 'China', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'SupplyCenterProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [12, 0, 10],
          NaturalRallyPoint: [18, 0, 0],
        }),
      ]),
      makeObjectDef('SupplyTruck', 'China', ['VEHICLE'], [], {
        BuildTime: 0.1,
        BuildCost: 600,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('SupplyCenter', 20, 20)], 96, 96), makeRegistry(bundle), makeHeightmap(96, 96));

  logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'SupplyTruck' });

  const producedCounts: number[] = [];
  const queueCounts: number[] = [];
  const credits: number[] = [];
  for (let frame = 0; frame < 6; frame += 1) {
    logic.update(1 / 30);
    producedCounts.push(logic.getEntityIdsByTemplate('SupplyTruck').length);
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    credits.push(logic.getSideCredits('China'));
  }

  return {
    producedCounts,
    queueCounts,
    credits,
  };
}

function runEconomyProductionTimeline(): {
  credits: number[];
  queueCounts: number[];
  producedCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [12, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('VehicleA', 'America', ['VEHICLE'], [], { BuildTime: 0.1, BuildCost: 300 }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 12, 12)]), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'VehicleA' });
  logic.submitCommand({ type: 'cancelUnitProduction', entityId: 1, productionId: 1 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'VehicleA' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const producedCounts: number[] = [];
  for (let frame = 0; frame < 5; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    producedCounts.push(logic.getEntityIdsByTemplate('VehicleA').length);
  }

  return { credits, queueCounts, producedCounts };
}

function runUpgradeProductionTimeline(): {
  credits: number[];
  inProductionCounts: number[];
  completedCounts: number[];
  speeds: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('StrategyCenter', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
      ]),
      makeObjectDef('UpgradeableUnit', 'America', ['VEHICLE'], [
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorSlow', {}),
        makeBlock('LocomotorSet', 'SET_NORMAL_UPGRADED LocomotorFast', {}),
        makeBlock('Behavior', 'LocomotorSetUpgrade ModuleTag_Move', {
          TriggeredBy: 'Upgrade_Move',
        }),
      ]),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_Move', {
        Type: 'PLAYER',
        BuildTime: 0.1,
        BuildCost: 200,
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorSlow', 10),
      makeLocomotorDef('LocomotorFast', 20),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('StrategyCenter', 8, 8), makeMapObject('UpgradeableUnit', 16, 8)]),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 300 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });

  const credits: number[] = [];
  const inProductionCounts: number[] = [];
  const completedCounts: number[] = [];
  const speeds: number[] = [];
  for (let frame = 0; frame < 5; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    const upgradeState = logic.getSideUpgradeState('America');
    inProductionCounts.push(upgradeState.inProduction.length);
    completedCounts.push(upgradeState.completed.length);
    speeds.push(logic.getEntityState(2)?.speed ?? -1);
  }

  return { credits, inProductionCounts, completedCounts, speeds };
}

function runObjectUpgradeAffectabilityTimeline(): {
  credits: number[];
  queueCounts: number[];
  maxHealth: number[];
  speeds: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('UpgradeLab', 'America', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 4,
        }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorSlow', {}),
        makeBlock('LocomotorSet', 'SET_NORMAL_UPGRADED LocomotorFast', {}),
        makeBlock('Behavior', 'LocomotorSetUpgrade ModuleTag_Move', {
          TriggeredBy: 'Upgrade_Move_Object',
        }),
        makeBlock('Behavior', 'MaxHealthUpgrade ModuleTag_HP', {
          TriggeredBy: ['Upgrade_A', 'Upgrade_B'],
          RequiresAllTriggers: true,
          AddMaxHealth: 50,
          ChangeType: 'SAME_CURRENTHEALTH',
        }),
      ], {
        CommandSet: 'CommandSet_UpgradeLab',
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_Unused', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeUpgradeDef('Upgrade_A', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeUpgradeDef('Upgrade_B', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeUpgradeDef('Upgrade_Move_Object', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef('Command_UpgradeUnused', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_Unused',
      }),
      makeCommandButtonDef('Command_UpgradeB', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_B',
      }),
      makeCommandButtonDef('Command_UpgradeMoveObject', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_Move_Object',
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_UpgradeLab', {
        1: 'Command_UpgradeUnused',
        2: 'Command_UpgradeB',
        3: 'Command_UpgradeMoveObject',
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorSlow', 10),
      makeLocomotorDef('LocomotorFast', 20),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('UpgradeLab', 12, 12)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Unused' });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_B' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const maxHealth: number[] = [];
  const speeds: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    if (frame === 1) {
      logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_A' });
    } else if (frame === 2) {
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_B' });
    } else if (frame === 5) {
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move_Object' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    maxHealth.push(logic.getEntityState(1)?.maxHealth ?? -1);
    speeds.push(logic.getEntityState(1)?.speed ?? -1);
  }

  return { credits, queueCounts, maxHealth, speeds };
}

function runWeaponSetUpgradeCombatTimeline(): {
  credits: number[];
  queueCounts: number[];
  healthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('UpgradeTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', {
          Conditions: 'NONE',
          Weapon: ['PRIMARY', 'WeakCannon'],
        }),
        makeBlock('WeaponSet', 'WeaponSet', {
          Conditions: 'PLAYER_UPGRADE',
          Weapon: ['PRIMARY', 'StrongCannon'],
        }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'WeaponSetUpgrade ModuleTag_WeaponSet', {
          TriggeredBy: 'Upgrade_Weapon',
        }),
      ], {
        CommandSet: 'CommandSet_UpgradeTank',
      }),
      makeObjectDef('TargetTank', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('WeakCannon', {
        AttackRange: 120,
        PrimaryDamage: 20,
        DelayBetweenShots: 100,
      }),
      makeWeaponDef('StrongCannon', {
        AttackRange: 120,
        PrimaryDamage: 60,
        DelayBetweenShots: 100,
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_Weapon', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef('Command_UpgradeWeapon', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_Weapon',
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_UpgradeTank', {
        1: 'Command_UpgradeWeapon',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('UpgradeTank', 10, 10), makeMapObject('TargetTank', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 300 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Weapon' });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const healthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    healthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { credits, queueCounts, healthTimeline };
}

function runMaxSimEquivalentVariationTimeline(): {
  credits: number[];
  queueCounts: number[];
  baseCounts: number[];
  variationCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('BaseTank', 'America', ['VEHICLE'], [], {
        BuildTime: 0.1,
        BuildCost: 100,
        MaxSimultaneousOfType: 1,
        BuildVariations: ['TankVariant'],
      }),
      makeObjectDef('TankVariant', 'America', ['VEHICLE'], [], {
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('WarFactory', 10, 10), makeMapObject('TankVariant', 22, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BaseTank' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const baseCounts: number[] = [];
  const variationCounts: number[] = [];
  for (let frame = 0; frame < 3; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    baseCounts.push(logic.getEntityIdsByTemplate('BaseTank').length);
    variationCounts.push(logic.getEntityIdsByTemplate('TankVariant').length);
  }

  return { credits, queueCounts, baseCounts, variationCounts };
}

function runPrerequisiteEquivalentVariationTimeline(): {
  credits: number[];
  queueCounts: number[];
  producedCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('BaseTech', 'America', ['STRUCTURE'], [], {
        BuildVariations: ['TechVariant'],
      }),
      makeObjectDef('TechVariant', 'America', ['STRUCTURE'], []),
      makeObjectDef('AdvancedTank', 'America', ['VEHICLE'], [
        makeBlock('Prerequisite', 'Object BaseTech', {}),
      ], {
        BuildTime: 0.1,
        BuildCost: 120,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('WarFactory', 10, 10), makeMapObject('TechVariant', 20, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'AdvancedTank' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const producedCounts: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    producedCounts.push(logic.getEntityIdsByTemplate('AdvancedTank').length);
  }

  return { credits, queueCounts, producedCounts };
}

function runQuantityModifierEquivalentVariationTimeline(): {
  credits: number[];
  queueCounts: number[];
  baseCounts: number[];
  variationCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('Barracks', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
          QuantityModifier: 'BaseInf 2',
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('BaseInf', 'America', ['INFANTRY'], [], {
        BuildVariations: ['InfVariant'],
      }),
      makeObjectDef('InfVariant', 'America', ['INFANTRY'], [], {
        BuildTime: 0.1,
        BuildCost: 90,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('Barracks', 10, 10)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'InfVariant' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const baseCounts: number[] = [];
  const variationCounts: number[] = [];
  for (let frame = 0; frame < 5; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    baseCounts.push(logic.getEntityIdsByTemplate('BaseInf').length);
    variationCounts.push(logic.getEntityIdsByTemplate('InfVariant').length);
  }

  return { credits, queueCounts, baseCounts, variationCounts };
}

function runMaxSimultaneousTimeline(): {
  credits: number[];
  queueCounts: number[];
  unitCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 5,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('CappedUnit', 'America', ['VEHICLE'], [], {
        BuildTime: 0.1,
        BuildCost: 100,
        MaxSimultaneousOfType: 2,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('WarFactory', 10, 10), makeMapObject('CappedUnit', 30, 10)]),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'CappedUnit' });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'CappedUnit' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const unitCounts: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    unitCounts.push(logic.getEntityIdsByTemplate('CappedUnit').length);
  }

  return { credits, queueCounts, unitCounts };
}

function runPrerequisiteTimeline(hasPowerPlant: boolean, hasTechAlt: boolean): {
  credits: number[];
  queueCounts: number[];
  producedCounts: number[];
} {
  const mapObjects = [makeMapObject('WarFactory', 10, 10)];
  if (hasPowerPlant) {
    mapObjects.push(makeMapObject('PowerPlant', 20, 10));
  }
  if (hasTechAlt) {
    mapObjects.push(makeMapObject('TechAlt', 30, 10));
  }

  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 4,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], []),
      makeObjectDef('TechAlt', 'America', ['STRUCTURE'], []),
      makeObjectDef('AdvancedUnit', 'America', ['VEHICLE'], [
        makeBlock('Prerequisite', 'Object TechMain TechAlt', {}),
        makeBlock('Prerequisite', 'Object PowerPlant', {}),
      ], {
        BuildTime: 0.1,
        BuildCost: 150,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap(mapObjects, 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'AdvancedUnit' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const producedCounts: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    producedCounts.push(logic.getEntityIdsByTemplate('AdvancedUnit').length);
  }

  return { credits, queueCounts, producedCounts };
}

function runSciencePrerequisiteTimeline(params: {
  grantAtFrame: number | null;
  scienceGrantable?: boolean;
}): {
  credits: number[];
  queueCounts: number[];
  producedCounts: number[];
  scienceCounts: number[];
} {
  const scienceGrantable = params.scienceGrantable ?? true;
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 4,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('ScienceTank', 'America', ['VEHICLE'], [
        makeBlock('Prerequisite', 'Science SCIENCE_PROMO_1', {}),
      ], {
        BuildTime: 0.1,
        BuildCost: 150,
      }),
    ],
    sciences: [
      makeScienceDef('SCIENCE_PROMO_1', {
        IsGrantable: scienceGrantable ? 'Yes' : 'No',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 10, 10)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'ScienceTank' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const producedCounts: number[] = [];
  const scienceCounts: number[] = [];
  for (let frame = 0; frame < 5; frame += 1) {
    if (params.grantAtFrame === frame) {
      logic.submitCommand({ type: 'grantSideScience', side: 'America', scienceName: 'SCIENCE_PROMO_1' });
      logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'ScienceTank' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    producedCounts.push(logic.getEntityIdsByTemplate('ScienceTank').length);
    scienceCounts.push(logic.getSideScienceState('America').acquired.length);
  }

  return { credits, queueCounts, producedCounts, scienceCounts };
}

function runOnlyByAiBuildableTimeline(playerType: 'HUMAN' | 'COMPUTER'): {
  credits: number[];
  queueCounts: number[];
  producedCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('AiDrone', 'America', ['VEHICLE'], [], {
        Buildable: 'Only_By_AI',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 10, 10)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'AiDrone' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const producedCounts: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    producedCounts.push(logic.getEntityIdsByTemplate('AiDrone').length);
  }

  return { credits, queueCounts, producedCounts };
}

function runMaxSimultaneousLinkKeyTimeline(): {
  credits: number[];
  queueCounts: number[];
  alphaCounts: number[];
  bravoCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 2,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('ArmorAlpha', 'America', ['VEHICLE'], [], {
        MaxSimultaneousOfType: 1,
        MaxSimultaneousLinkKey: 'ARMOR_GROUP_ALPHA',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeObjectDef('ArmorBravo', 'America', ['VEHICLE'], [], {
        MaxSimultaneousOfType: 1,
        MaxSimultaneousLinkKey: 'ARMOR_GROUP_ALPHA',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('WarFactory', 10, 10), makeMapObject('ArmorAlpha', 26, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'ArmorBravo' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const alphaCounts: number[] = [];
  const bravoCounts: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    alphaCounts.push(logic.getEntityIdsByTemplate('ArmorAlpha').length);
    bravoCounts.push(logic.getEntityIdsByTemplate('ArmorBravo').length);
  }

  return { credits, queueCounts, alphaCounts, bravoCounts };
}

function runUpgradeCommandSetGateTimeline(matchesUpgradeButton: boolean): {
  credits: number[];
  queueCounts: number[];
  inProductionCounts: number[];
  completedCounts: number[];
} {
  const commandButtonName = matchesUpgradeButton ? 'Command_ResearchMove' : 'Command_NotAnUpgrade';
  const commandButtonUpgrade = matchesUpgradeButton ? 'Upgrade_Move' : 'Upgrade_Attack';
  const commandName = matchesUpgradeButton ? 'PLAYER_UPGRADE' : 'UNIT_BUILD';
  const bundle = makeBundle({
    objects: [
      makeObjectDef('StrategyCenter', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
      ], {
        CommandSet: 'CommandSet_StrategyCenter',
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_Move', {
        Type: 'PLAYER',
        BuildTime: 0.1,
        BuildCost: 150,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef(commandButtonName, {
        Command: commandName,
        Upgrade: commandButtonUpgrade,
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_StrategyCenter', {
        1: commandButtonName,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('StrategyCenter', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 300 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const inProductionCounts: number[] = [];
  const completedCounts: number[] = [];
  for (let frame = 0; frame < 4; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    const sideUpgradeState = logic.getSideUpgradeState('America');
    inProductionCounts.push(sideUpgradeState.inProduction.length);
    completedCounts.push(sideUpgradeState.completed.length);
  }

  return { credits, queueCounts, inProductionCounts, completedCounts };
}

function runCommandSetUpgradeTimeline(useAltTrigger: boolean): {
  credits: number[];
  queueCounts: number[];
  maxHealth: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('UpgradeHub', 'America', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
        makeBlock('Behavior', 'CommandSetUpgrade ModuleTag_CommandSet', {
          TriggeredBy: 'Upgrade_A',
          CommandSet: 'CommandSet_Hub_AfterA',
          CommandSetAlt: 'CommandSet_Hub_AfterA_Alt',
          TriggerAlt: 'Upgrade_Alt_Object',
        }),
        makeBlock('Behavior', 'MaxHealthUpgrade ModuleTag_UpgradeB', {
          TriggeredBy: 'Upgrade_B',
          AddMaxHealth: 50,
          ChangeType: 'SAME_CURRENTHEALTH',
        }),
        makeBlock('Behavior', 'MaxHealthUpgrade ModuleTag_UpgradeC', {
          TriggeredBy: 'Upgrade_C',
          AddMaxHealth: 80,
          ChangeType: 'SAME_CURRENTHEALTH',
        }),
      ], {
        CommandSet: 'CommandSet_Hub_Base',
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_A', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeUpgradeDef('Upgrade_B', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 120,
      }),
      makeUpgradeDef('Upgrade_C', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 140,
      }),
      makeUpgradeDef('Upgrade_Alt_Object', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 1,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef('Command_UpgradeA', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_A',
      }),
      makeCommandButtonDef('Command_UpgradeB', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_B',
      }),
      makeCommandButtonDef('Command_UpgradeC', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_C',
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_Hub_Base', {
        1: 'Command_UpgradeA',
      }),
      makeCommandSetDef('CommandSet_Hub_AfterA', {
        1: 'Command_UpgradeB',
      }),
      makeCommandSetDef('CommandSet_Hub_AfterA_Alt', {
        1: 'Command_UpgradeC',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('UpgradeHub', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  if (useAltTrigger) {
    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Alt_Object' });
  }

  // The first queue attempt for Upgrade_B must fail while the base command set is active.
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_B' });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_A' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const maxHealth: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    if (frame === 3) {
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_B' });
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_C' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    maxHealth.push(logic.getEntityState(1)?.maxHealth ?? -1);
  }

  return { credits, queueCounts, maxHealth };
}

function runParkingPlaceQueueTimeline(): {
  credits: number[];
  queueCounts: number[];
  jetCounts: number[];
  heliCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('Airfield', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
        makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
          NumRows: 1,
          NumCols: 1,
        }),
      ]),
      makeObjectDef('JetUnit', 'America', ['AIRCRAFT'], [], {
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeObjectDef('HelipadUnit', 'America', ['AIRCRAFT', 'PRODUCED_AT_HELIPAD'], [], {
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('Airfield', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'JetUnit' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const jetCounts: number[] = [];
  const heliCounts: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    if (frame === 3) {
      // This queue should be blocked because the single parking space is occupied by JetUnit.
      logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'JetUnit' });
    } else if (frame === 4) {
      // Source parity: PRODUCED_AT_HELIPAD bypasses parking reservation checks.
      logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'HelipadUnit' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    jetCounts.push(logic.getEntityIdsByTemplate('JetUnit').length);
    heliCounts.push(logic.getEntityIdsByTemplate('HelipadUnit').length);
  }

  return { credits, queueCounts, jetCounts, heliCounts };
}

function runParkingReservationQueueAndCancelTimeline(): {
  credits: number[];
  queueCounts: number[];
  jetQueuedCounts: number[];
  heliQueuedCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('Airfield', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 4,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
        makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
          NumRows: 1,
          NumCols: 1,
        }),
      ]),
      makeObjectDef('JetUnit', 'America', ['AIRCRAFT'], [], {
        BuildTime: 1,
        BuildCost: 100,
      }),
      makeObjectDef('HelipadUnit', 'America', ['AIRCRAFT', 'PRODUCED_AT_HELIPAD'], [], {
        BuildTime: 1,
        BuildCost: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('Airfield', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const jetQueuedCounts: number[] = [];
  const heliQueuedCounts: number[] = [];
  const capture = (): void => {
    const state = logic.getProductionState(1);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(state?.queueEntryCount ?? 0);
    jetQueuedCounts.push(
      state?.queue.filter((entry) => entry.type === 'UNIT' && entry.templateName.trim().toUpperCase() === 'JETUNIT').length ?? 0,
    );
    heliQueuedCounts.push(
      state?.queue.filter((entry) => entry.type === 'UNIT' && entry.templateName.trim().toUpperCase() === 'HELIPADUNIT').length ?? 0,
    );
  };

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'JetUnit' });
  logic.update(1 / 30);
  capture();

  // Source parity: queueCreateUnit reserves a parking exit slot for non-helipad units.
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'JetUnit' });
  logic.update(1 / 30);
  capture();

  // Source parity: PRODUCED_AT_HELIPAD bypasses parking-door reservation.
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'HelipadUnit' });
  logic.update(1 / 30);
  capture();

  const firstJetProductionId = logic.getProductionState(1)?.queue.find(
    (entry) => entry.type === 'UNIT' && entry.templateName.trim().toUpperCase() === 'JETUNIT',
  )?.productionId;
  if (firstJetProductionId !== undefined) {
    logic.submitCommand({
      type: 'cancelUnitProduction',
      entityId: 1,
      productionId: firstJetProductionId,
    });
  }
  logic.update(1 / 30);
  capture();

  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'JetUnit' });
  logic.update(1 / 30);
  capture();

  return { credits, queueCounts, jetQueuedCounts, heliQueuedCounts };
}

function runParkingQuantityStallTimeline(): {
  credits: number[];
  queueCounts: number[];
  jetCounts: number[];
  quantityProduced: number[];
  quantityTotal: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('Airfield', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
          QuantityModifier: 'JetUnit 2',
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
        makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
          NumRows: 1,
          NumCols: 1,
        }),
      ]),
      makeObjectDef('JetUnit', 'America', ['AIRCRAFT'], [], {
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('Airfield', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'JetUnit' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const jetCounts: number[] = [];
  const quantityProduced: number[] = [];
  const quantityTotal: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));

    const state = logic.getProductionState(1);
    queueCounts.push(state?.queueEntryCount ?? 0);
    const jetQueueEntry = state?.queue.find(
      (entry) => entry.type === 'UNIT' && entry.templateName.trim().toUpperCase() === 'JETUNIT',
    );
    quantityProduced.push(jetQueueEntry?.productionQuantityProduced ?? -1);
    quantityTotal.push(jetQueueEntry?.productionQuantityTotal ?? -1);
    jetCounts.push(logic.getEntityIdsByTemplate('JetUnit').length);
  }

  return { credits, queueCounts, jetCounts, quantityProduced, quantityTotal };
}

function runStatusBitsUpgradeTimeline(): {
  credits: number[];
  queueCounts: number[];
  statusFlagsTimeline: string[][];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('StatusLab', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_StatusA', {
          TriggeredBy: 'Upgrade_Status_A',
          StatusToSet: ['EMPED', 'UNSELECTABLE'],
        }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_StatusB', {
          TriggeredBy: 'Upgrade_Status_B',
          StatusToSet: 'STEALTHED',
          StatusToClear: 'EMPED',
        }),
      ], {
        CommandSet: 'CommandSet_StatusLab',
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_Status_A', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 120,
      }),
      makeUpgradeDef('Upgrade_Status_B', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 130,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef('Command_UpgradeStatusA', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_Status_A',
      }),
      makeCommandButtonDef('Command_UpgradeStatusB', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_Status_B',
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_StatusLab', {
        1: 'Command_UpgradeStatusA',
        2: 'Command_UpgradeStatusB',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('StatusLab', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Status_A' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const statusFlagsTimeline: string[][] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    if (frame === 3) {
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Status_B' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    statusFlagsTimeline.push(logic.getEntityState(1)?.statusFlags ?? []);
  }

  return { credits, queueCounts, statusFlagsTimeline };
}

function runStatusBitsCombatTimeline(): {
  credits: number[];
  queueCounts: number[];
  statusFlagsTimeline: string[][];
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('StatusTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'StatusCannon'] }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_NoAttack', {
          TriggeredBy: 'Upgrade_NoAttack',
          StatusToSet: 'NO_ATTACK',
        }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_AttackRestore', {
          TriggeredBy: 'Upgrade_AttackRestore',
          StatusToClear: 'NO_ATTACK',
        }),
      ], {
        CommandSet: 'CommandSet_StatusTank',
      }),
      makeObjectDef('TargetTank', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('StatusCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_NoAttack', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeUpgradeDef('Upgrade_AttackRestore', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 120,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef('Command_UpgradeNoAttack', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_NoAttack',
      }),
      makeCommandButtonDef('Command_UpgradeAttackRestore', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_AttackRestore',
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_StatusTank', {
        1: 'Command_UpgradeNoAttack',
        2: 'Command_UpgradeAttackRestore',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('StatusTank', 10, 10), makeMapObject('TargetTank', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_NoAttack' });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const statusFlagsTimeline: string[][] = [];
  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 10; frame += 1) {
    if (frame === 4) {
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_AttackRestore' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    statusFlagsTimeline.push(logic.getEntityState(1)?.statusFlags ?? []);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { credits, queueCounts, statusFlagsTimeline, targetHealthTimeline };
}

function runAimAndFiringStatusTimeline(): {
  statusFlagsTimeline: string[][];
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('AimStatusAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AimStatusCannon'] }),
      ]),
      makeObjectDef('AimStatusTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('AimStatusCannon', {
        AttackRange: 120,
        PrimaryDamage: 30,
        PreAttackDelay: 100,
        DelayBetweenShots: 1000,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('AimStatusAttacker', 10, 10), makeMapObject('AimStatusTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const statusFlagsTimeline: string[][] = [];
  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    if (frame === 5) {
      logic.submitCommand({ type: 'stop', entityId: 1 });
    }
    logic.update(1 / 30);
    statusFlagsTimeline.push(logic.getEntityState(1)?.statusFlags ?? []);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { statusFlagsTimeline, targetHealthTimeline };
}

function runStealthAttackGateTimeline(params: {
  continueAttackRange: number;
  detected: boolean;
  preAttackDelayMs: number;
}): {
  attackerStatusFlagsTimeline: string[][];
  attackerTargetTimeline: Array<number | null>;
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('StealthGateAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'StealthGateCannon'] }),
      ]),
      makeObjectDef('StealthGateTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_Stealthed', {
          TriggeredBy: 'Upgrade_Stealthed',
          StatusToSet: 'STEALTHED',
        }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_Detected', {
          TriggeredBy: 'Upgrade_Detected',
          StatusToSet: 'DETECTED',
        }),
      ]),
    ],
    weapons: [
      makeWeaponDef('StealthGateCannon', {
        AttackRange: 140,
        ContinueAttackRange: params.continueAttackRange,
        PrimaryDamage: 30,
        PreAttackDelay: params.preAttackDelayMs,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('StealthGateAttacker', 10, 10), makeMapObject('StealthGateTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'applyUpgrade', entityId: 2, upgradeName: 'Upgrade_Stealthed' });
  if (params.detected) {
    logic.submitCommand({ type: 'applyUpgrade', entityId: 2, upgradeName: 'Upgrade_Detected' });
  }
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerStatusFlagsTimeline: string[][] = [];
  const attackerTargetTimeline: Array<number | null> = [];
  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    attackerStatusFlagsTimeline.push(logic.getEntityState(1)?.statusFlags ?? []);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return {
    attackerStatusFlagsTimeline,
    attackerTargetTimeline,
    targetHealthTimeline,
  };
}

function runUpgradeRemovalMuxTimeline(): {
  credits: number[];
  queueCounts: number[];
  maxHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('UpgradeMuxLab', 'America', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
        makeBlock('Behavior', 'MaxHealthUpgrade ModuleTag_UpgradeB', {
          TriggeredBy: 'Upgrade_B',
          AddMaxHealth: 20,
          ChangeType: 'SAME_CURRENTHEALTH',
        }),
        makeBlock('Behavior', 'MaxHealthUpgrade ModuleTag_UpgradeA', {
          TriggeredBy: 'Upgrade_A',
          RemovesUpgrades: 'Upgrade_B',
          AddMaxHealth: 30,
          ChangeType: 'SAME_CURRENTHEALTH',
        }),
      ], {
        CommandSet: 'CommandSet_UpgradeMuxLab',
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_A', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
      makeUpgradeDef('Upgrade_B', {
        Type: 'OBJECT',
        BuildTime: 0.1,
        BuildCost: 100,
      }),
    ],
    commandButtons: [
      makeCommandButtonDef('Command_UpgradeA', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_A',
      }),
      makeCommandButtonDef('Command_UpgradeB', {
        Command: 'OBJECT_UPGRADE',
        Upgrade: 'Upgrade_B',
      }),
    ],
    commandSets: [
      makeCommandSetDef('CommandSet_UpgradeMuxLab', {
        1: 'Command_UpgradeA',
        2: 'Command_UpgradeB',
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(makeMap([makeMapObject('UpgradeMuxLab', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_B' });

  const credits: number[] = [];
  const queueCounts: number[] = [];
  const maxHealthTimeline: number[] = [];
  for (let frame = 0; frame < 10; frame += 1) {
    if (frame === 3) {
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_A' });
    } else if (frame === 6) {
      // Source parity: RemovesUpgrades clears object-upgrade ownership, allowing re-queue of Upgrade_B.
      logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_B' });
    }

    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
    maxHealthTimeline.push(logic.getEntityState(1)?.maxHealth ?? -1);
  }

  return { credits, queueCounts, maxHealthTimeline };
}

function runMinimumAttackRangeStationaryTimeline(): {
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('MinRangeTurret', 'America', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'MinRangeCannon'] }),
      ]),
      makeObjectDef('CloseTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('MinRangeCannon', {
        AttackRange: 120,
        MinimumAttackRange: 40,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('MinRangeTurret', 10, 10), makeMapObject('CloseTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { targetHealthTimeline };
}

function runMinimumAttackRangeRetreatTimeline(): {
  targetHealthTimeline: number[];
  attackerRangeTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('MinRangeTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'MinRangeCannon'] }),
      ]),
      makeObjectDef('CloseTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('MinRangeCannon', {
        AttackRange: 80,
        MinimumAttackRange: 40,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
    locomotors: [
      makeLocomotorDef('LocomotorFast', 180),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('MinRangeTank', 40, 10), makeMapObject('CloseTarget', 25, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const targetHealthTimeline: number[] = [];
  const attackerRangeTimeline: number[] = [];
  for (let frame = 0; frame < 16; frame += 1) {
    if (frame === 2) {
      // Move outside min range, then re-issue attack after movement settles.
      logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 85, targetZ: 10 });
    }
    if (frame === 10) {
      logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
    }
    logic.update(1 / 30);
    const attacker = logic.getEntityState(1);
    const target = logic.getEntityState(2);
    targetHealthTimeline.push(target?.health ?? -1);
    if (attacker && target) {
      const dx = target.x - attacker.x;
      const dz = target.z - attacker.z;
      attackerRangeTimeline.push(Math.sqrt(dx * dx + dz * dz));
    } else {
      attackerRangeTimeline.push(-1);
    }
  }

  return { targetHealthTimeline, attackerRangeTimeline };
}

function runContinueAttackRangeTimeline(continueAttackRange: number): {
  attackerTargetTimeline: Array<number | null>;
  chinaFollowupHealthTimeline: number[];
  glaFollowupHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ContinueRangeAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ContinueRangeCannon'] }),
      ]),
      makeObjectDef('InitialVictimChina', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('FollowupVictimChina', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('FarVictimChina', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('NearVictimGla', 'GLA', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ContinueRangeCannon', {
        AttackRange: 220,
        ContinueAttackRange: continueAttackRange,
        PrimaryDamage: 120,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ContinueRangeAttacker', 20, 20, { originalOwner: 'AmericaPlayer' }),
      makeMapObject('InitialVictimChina', 50, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('FollowupVictimChina', 56, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('FarVictimChina', 74, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('NearVictimGla', 52, 20, { originalOwner: 'GlaPlayerA' }),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.setTeamRelationship('America', 'GLA', 0);
  logic.setTeamRelationship('GLA', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const chinaFollowupHealthTimeline: number[] = [];
  const glaFollowupHealthTimeline: number[] = [];

  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    chinaFollowupHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    glaFollowupHealthTimeline.push(logic.getEntityState(5)?.health ?? -1);
  }

  return {
    attackerTargetTimeline,
    chinaFollowupHealthTimeline,
    glaFollowupHealthTimeline,
  };
}

function runContinueAttackSamePlayerFilterTimeline(): {
  attackerTargetTimeline: Array<number | null>;
  differentOwnerFollowupHealthTimeline: number[];
  sameOwnerFollowupHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ContinuePlayerFilterAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ContinuePlayerFilterCannon'] }),
      ]),
      makeObjectDef('ContinuePlayerFilterInitialVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinuePlayerFilterDifferentOwner', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinuePlayerFilterSameOwner', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ContinuePlayerFilterCannon', {
        AttackRange: 220,
        ContinueAttackRange: 20,
        PrimaryDamage: 120,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ContinuePlayerFilterAttacker', 20, 20, { originalOwner: 'AmericaPlayer' }),
      makeMapObject('ContinuePlayerFilterInitialVictim', 50, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinuePlayerFilterDifferentOwner', 52, 20, { originalOwner: 'ChinaPlayerB' }),
      makeMapObject('ContinuePlayerFilterSameOwner', 58, 20, { originalOwner: 'ChinaPlayerA' }),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const differentOwnerFollowupHealthTimeline: number[] = [];
  const sameOwnerFollowupHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    differentOwnerFollowupHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    sameOwnerFollowupHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
  }

  return {
    attackerTargetTimeline,
    differentOwnerFollowupHealthTimeline,
    sameOwnerFollowupHealthTimeline,
  };
}

function runMaskedTargetGateTimeline(): {
  attackerTargetTimeline: Array<number | null>;
  maskedTargetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('MaskedGateAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'MaskedGateCannon'] }),
      ]),
      makeObjectDef('MaskedGateTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_Masked', {
          TriggeredBy: 'Upgrade_Masked',
          StatusToSet: 'MASKED',
        }),
      ]),
    ],
    weapons: [
      makeWeaponDef('MaskedGateCannon', {
        AttackRange: 140,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('MaskedGateAttacker', 10, 10), makeMapObject('MaskedGateTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'applyUpgrade', entityId: 2, upgradeName: 'Upgrade_Masked' });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const maskedTargetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 6; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    maskedTargetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { attackerTargetTimeline, maskedTargetHealthTimeline };
}

function runUnattackableKindGateTimeline(): {
  attackerTargetTimeline: Array<number | null>;
  unattackableTargetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('UnattackableGateAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'UnattackableGateCannon'] }),
      ]),
      makeObjectDef('UnattackableGateTarget', 'China', ['VEHICLE', 'UNATTACKABLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('UnattackableGateCannon', {
        AttackRange: 140,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('UnattackableGateAttacker', 10, 10), makeMapObject('UnattackableGateTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const unattackableTargetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 6; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    unattackableTargetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { attackerTargetTimeline, unattackableTargetHealthTimeline };
}

function runContinueAttackRangeLegalityFilterTimeline(): {
  attackerTargetTimeline: Array<number | null>;
  maskedFollowupHealthTimeline: number[];
  unattackableFollowupHealthTimeline: number[];
  validFollowupHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ContinueLegalityAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ContinueLegalityCannon'] }),
      ]),
      makeObjectDef('ContinueLegalityInitialVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinueLegalityMaskedVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_Masked', {
          TriggeredBy: 'Upgrade_Masked',
          StatusToSet: 'MASKED',
        }),
      ]),
      makeObjectDef('ContinueLegalityUnattackableVictim', 'China', ['VEHICLE', 'UNATTACKABLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinueLegalityValidVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ContinueLegalityCannon', {
        AttackRange: 220,
        ContinueAttackRange: 20,
        PrimaryDamage: 120,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ContinueLegalityAttacker', 20, 20, { originalOwner: 'AmericaPlayer' }),
      makeMapObject('ContinueLegalityInitialVictim', 50, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueLegalityMaskedVictim', 52, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueLegalityUnattackableVictim', 54, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueLegalityValidVictim', 58, 20, { originalOwner: 'ChinaPlayerA' }),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'applyUpgrade', entityId: 3, upgradeName: 'Upgrade_Masked' });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const maskedFollowupHealthTimeline: number[] = [];
  const unattackableFollowupHealthTimeline: number[] = [];
  const validFollowupHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    maskedFollowupHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    unattackableFollowupHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
    validFollowupHealthTimeline.push(logic.getEntityState(5)?.health ?? -1);
  }

  return {
    attackerTargetTimeline,
    maskedFollowupHealthTimeline,
    unattackableFollowupHealthTimeline,
    validFollowupHealthTimeline,
  };
}

function runNoAttackFromAiGateTimeline(commandSource: 'PLAYER' | 'AI'): {
  attackerTargetTimeline: Array<number | null>;
  targetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('NoAttackFromAiAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'NoAttackFromAiCannon'] }),
      ]),
      makeObjectDef('NoAttackFromAiTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_NoAttackFromAi', {
          TriggeredBy: 'Upgrade_NoAttackFromAi',
          StatusToSet: 'NO_ATTACK_FROM_AI',
        }),
      ]),
    ],
    weapons: [
      makeWeaponDef('NoAttackFromAiCannon', {
        AttackRange: 140,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('NoAttackFromAiAttacker', 10, 10), makeMapObject('NoAttackFromAiTarget', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'applyUpgrade', entityId: 2, upgradeName: 'Upgrade_NoAttackFromAi' });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2, commandSource });

  const attackerTargetTimeline: Array<number | null> = [];
  const targetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 6; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    targetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return { attackerTargetTimeline, targetHealthTimeline };
}

function runContinueAttackNoAttackFromAiFilterTimeline(commandSource: 'PLAYER' | 'AI'): {
  attackerTargetTimeline: Array<number | null>;
  noAttackFromAiFollowupHealthTimeline: number[];
  validFollowupHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ContinueNoAttackFromAiAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ContinueNoAttackFromAiCannon'] }),
      ]),
      makeObjectDef('ContinueNoAttackFromAiInitialVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinueNoAttackFromAiFollowupFiltered', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'StatusBitsUpgrade ModuleTag_NoAttackFromAi', {
          TriggeredBy: 'Upgrade_NoAttackFromAi',
          StatusToSet: 'NO_ATTACK_FROM_AI',
        }),
      ]),
      makeObjectDef('ContinueNoAttackFromAiFollowupValid', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ContinueNoAttackFromAiCannon', {
        AttackRange: 220,
        ContinueAttackRange: 20,
        PrimaryDamage: 120,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ContinueNoAttackFromAiAttacker', 20, 20, { originalOwner: 'AmericaPlayer' }),
      makeMapObject('ContinueNoAttackFromAiInitialVictim', 50, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueNoAttackFromAiFollowupFiltered', 52, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueNoAttackFromAiFollowupValid', 58, 20, { originalOwner: 'ChinaPlayerA' }),
    ], 96, 96),
    makeRegistry(bundle),
    makeHeightmap(96, 96),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'applyUpgrade', entityId: 3, upgradeName: 'Upgrade_NoAttackFromAi' });
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2, commandSource });

  const attackerTargetTimeline: Array<number | null> = [];
  const noAttackFromAiFollowupHealthTimeline: number[] = [];
  const validFollowupHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    noAttackFromAiFollowupHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    validFollowupHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
  }

  return {
    attackerTargetTimeline,
    noAttackFromAiFollowupHealthTimeline,
    validFollowupHealthTimeline,
  };
}

function runOffMapTargetGateTimeline(): {
  attackerTargetTimeline: Array<number | null>;
  offMapTargetHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('OffMapGateAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'OffMapGateCannon'] }),
      ]),
      makeObjectDef('OffMapGateTarget', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('OffMapGateCannon', {
        AttackRange: 220,
        PrimaryDamage: 30,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('OffMapGateAttacker', 10, 10), makeMapObject('OffMapGateTarget', -2, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const offMapTargetHealthTimeline: number[] = [];
  for (let frame = 0; frame < 6; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    offMapTargetHealthTimeline.push(logic.getEntityState(2)?.health ?? -1);
  }

  return {
    attackerTargetTimeline,
    offMapTargetHealthTimeline,
  };
}

function runContinueAttackOffMapFilterTimeline(): {
  attackerTargetTimeline: Array<number | null>;
  offMapFollowupHealthTimeline: number[];
  onMapFollowupHealthTimeline: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('ContinueOffMapAttacker', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ContinueOffMapCannon'] }),
      ]),
      makeObjectDef('ContinueOffMapInitialVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinueOffMapFollowupOffMap', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      makeObjectDef('ContinueOffMapFollowupOnMap', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
    weapons: [
      makeWeaponDef('ContinueOffMapCannon', {
        AttackRange: 220,
        ContinueAttackRange: 20,
        PrimaryDamage: 120,
        PrimaryDamageRadius: 0,
        SecondaryDamage: 0,
        SecondaryDamageRadius: 0,
        WeaponSpeed: 999999,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([
      makeMapObject('ContinueOffMapAttacker', 10, 20, { originalOwner: 'AmericaPlayer' }),
      makeMapObject('ContinueOffMapInitialVictim', 0, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueOffMapFollowupOffMap', -1, 20, { originalOwner: 'ChinaPlayerA' }),
      makeMapObject('ContinueOffMapFollowupOnMap', 2, 20, { originalOwner: 'ChinaPlayerA' }),
    ], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

  const attackerTargetTimeline: Array<number | null> = [];
  const offMapFollowupHealthTimeline: number[] = [];
  const onMapFollowupHealthTimeline: number[] = [];
  for (let frame = 0; frame < 8; frame += 1) {
    logic.update(1 / 30);
    attackerTargetTimeline.push(logic.getEntityState(1)?.attackTargetEntityId ?? null);
    offMapFollowupHealthTimeline.push(logic.getEntityState(3)?.health ?? -1);
    onMapFollowupHealthTimeline.push(logic.getEntityState(4)?.health ?? -1);
  }

  return {
    attackerTargetTimeline,
    offMapFollowupHealthTimeline,
    onMapFollowupHealthTimeline,
  };
}

function runProducerDeathUnitRefundTimeline(): {
  credits: number[];
  alive: boolean[];
  producedCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 4,
        }),
        makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
          UnitCreatePoint: [8, 0, 0],
          ExitDelay: 0,
        }),
      ]),
      makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'KillerCannon'] }),
      ]),
      makeObjectDef('VehicleA', 'America', ['VEHICLE'], [], { BuildTime: 2, BuildCost: 100 }),
    ],
    weapons: [
      makeWeaponDef('KillerCannon', {
        AttackRange: 120,
        PrimaryDamage: 200,
        DelayBetweenShots: 100,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('WarFactory', 10, 10), makeMapObject('EnemyTank', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'VehicleA' });
  logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'VehicleA' });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

  const credits: number[] = [];
  const alive: boolean[] = [];
  const producedCounts: number[] = [];
  for (let frame = 0; frame < 3; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    alive.push(logic.getEntityState(1) !== null);
    producedCounts.push(logic.getEntityIdsByTemplate('VehicleA').length);
  }

  return { credits, alive, producedCounts };
}

function runProducerDeathUpgradeRefundTimeline(): {
  credits: number[];
  inProductionCounts: number[];
  completedCounts: number[];
} {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('StrategyCenter', 'America', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
          MaxQueueEntries: 3,
        }),
      ]),
      makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'KillerCannon'] }),
      ]),
    ],
    weapons: [
      makeWeaponDef('KillerCannon', {
        AttackRange: 120,
        PrimaryDamage: 200,
        DelayBetweenShots: 100,
      }),
    ],
    upgrades: [
      makeUpgradeDef('Upgrade_Move', {
        Type: 'PLAYER',
        BuildTime: 2,
        BuildCost: 200,
      }),
    ],
  });

  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);
  logic.loadMapObjects(
    makeMap([makeMapObject('StrategyCenter', 10, 10), makeMapObject('EnemyTank', 30, 10)], 64, 64),
    makeRegistry(bundle),
    makeHeightmap(64, 64),
  );

  logic.setTeamRelationship('America', 'China', 0);
  logic.setTeamRelationship('China', 'America', 0);
  logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
  logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });
  logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

  const credits: number[] = [];
  const inProductionCounts: number[] = [];
  const completedCounts: number[] = [];
  for (let frame = 0; frame < 3; frame += 1) {
    logic.update(1 / 30);
    credits.push(logic.getSideCredits('America'));
    const sideState = logic.getSideUpgradeState('America');
    inProductionCounts.push(sideState.inProduction.length);
    completedCounts.push(sideState.completed.length);
  }

  return { credits, inProductionCounts, completedCounts };
}

describe('GameLogicSubsystem combat + upgrades', () => {
  it('exposes renderable entity snapshots and keeps unresolved objects explicit', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ResolvedVehicle', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Draw', 'W3DModelDraw ModuleTag_Draw', {}, [
            makeBlock('ModelConditionState', 'DefaultModelConditionState', { Model: 'USAPrivateTank' }),
          ]),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const summary = logic.loadMapObjects(
      makeMap([makeMapObject('ResolvedVehicle', 10, 10), makeMapObject('MissingVehicle', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    const renderable = logic.getRenderableEntityStates();

    expect(summary.totalObjects).toBe(2);
    expect(summary.spawnedObjects).toBe(2);
    expect(summary.unresolvedObjects).toBe(1);
    expect(renderable).toHaveLength(2);
    expect(renderable).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          templateName: 'ResolvedVehicle',
          resolved: true,
          renderAssetPath: 'USAPrivateTank',
          renderAssetResolved: true,
          animationState: 'IDLE',
        }),
        expect.objectContaining({
          templateName: 'MissingVehicle',
          resolved: false,
          renderAssetPath: null,
          renderAssetResolved: false,
          animationState: 'IDLE',
        }),
      ]),
    );
  });

  it('reports render asset metadata independently from placeholder geometry visibility', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NoModelObject', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('NoModelObject', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const state = logic.getEntityState(1);
    expect(state).toEqual(expect.objectContaining({
      renderAssetPath: null,
      renderAssetResolved: false,
    }));
  });

  it('reads render assets from nested model condition blocks and supports FileName/ModelName', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NestedDrawUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Draw', 'W3DModelDraw ModuleTag_Draw', {}, [
            makeBlock('ModelConditionState', 'Default', { ModelName: 'USAPrivateTank' }),
            makeBlock('ModelConditionState', 'Damaged', { FileName: 'USAPrivateTank_Damaged' }),
          ]),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('NestedDrawUnit', 20, 20)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const state = logic.getEntityState(1);
    expect(state).toEqual(expect.objectContaining({
      renderAssetPath: 'USAPrivateTank',
      renderAssetResolved: true,
    }));
  });

  it('includes ordered render-asset candidates across object and nested model fields', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef(
          'CandidateUnit',
          'America',
          ['VEHICLE'],
          [
            makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
            makeBlock('Draw', 'W3DModelDraw ModuleTag_Draw', {}, [
              makeBlock('ModelConditionState', 'Default', { Model: 'NestedModelPrimary' }),
              makeBlock('ModelConditionState', 'Damaged', { ModelName: 'NestedModelSecondary' }),
              makeBlock('ModelConditionState', 'Destroyed', { FileName: 'NestedModelTertiary' }),
            ]),
          ],
          {
            Model: 'FieldModelPrimary',
            ModelName: 'FieldModelSecondary',
            FileName: 'FieldModelTertiary',
          },
        ),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('CandidateUnit', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const state = logic.getEntityState(1);
    expect(state).toEqual(expect.objectContaining({
      renderAssetPath: 'FieldModelPrimary',
      renderAssetResolved: true,
      renderAssetCandidates: [
        'FieldModelPrimary',
        'FieldModelSecondary',
        'FieldModelTertiary',
        'NestedModelPrimary',
        'NestedModelSecondary',
        'NestedModelTertiary',
      ],
    }));
  });

  it('extracts source-driven animation clip candidates from model condition state fields', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ClipMappedUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Draw', 'W3DModelDraw ModuleTag_Draw', {}, [
            makeBlock('ModelConditionState', 'DefaultModelConditionState', {
              IdleAnimation: 'Idle01',
            }),
            makeBlock('ModelConditionState', 'Moving', {
              Animation: 'Move01',
            }),
            makeBlock('ModelConditionState', 'Attacking', {
              Animation: 'Attack01',
            }),
            makeBlock('ModelConditionState', 'Dying', {
              Animation: 'Die01',
            }),
          ]),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('ClipMappedUnit', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const state = logic.getEntityState(1);
    expect(state?.renderAnimationStateClips).toEqual({
      IDLE: ['Idle01'],
      MOVE: ['Move01'],
      ATTACK: ['Attack01'],
      DIE: ['Die01'],
    });
  });

  it('marks NONE model tokens as unresolved even when template data exists', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NoRenderableToken', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Draw', 'W3DModelDraw ModuleTag_Draw', {}, [
            makeBlock('ModelConditionState', 'Default', { Model: 'NONE' }),
          ]),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('NoRenderableToken', 30, 30)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const state = logic.getEntityState(1);
    expect(state).toEqual(expect.objectContaining({
      renderAssetPath: null,
      renderAssetResolved: false,
    }));
  });

  it('transitions animation state from IDLE to MOVE and back when a move command is issued', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('MobileUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('LocomotorSet', 'SET_NORMAL Crawler', {}),
        ]),
      ],
      locomotors: [makeLocomotorDef('Crawler', 120)],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('MobileUnit', 10, 10)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    expect(logic.getEntityState(1)?.animationState).toBe('IDLE');
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 40, targetZ: 10 });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.animationState).toBe('MOVE');

    for (let frame = 0; frame < 80; frame += 1) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.animationState).toBe('IDLE');
  });

  it('transitions animation state to ATTACK while attacking and to IDLE on explicit stop', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Attacker', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AttackCannon'] }),
        ]),
        makeObjectDef('Target', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('AttackCannon', {
          AttackRange: 140,
          PrimaryDamage: 10,
          DelayBetweenShots: 100,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Attacker', 10, 10), makeMapObject('Target', 30, 10)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    expect(logic.getEntityState(1)?.animationState).toBe('IDLE');
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.animationState).toBe('ATTACK');

    logic.submitCommand({ type: 'stop', entityId: 1 });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.animationState).toBe('IDLE');
  });

  it('records DIE before entity cleanup when an entity is destroyed', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('DestroyMe', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('DestroyMe', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const logicWithPrivateAccess = logic as unknown as {
      markEntityDestroyed: (entityId: number, attackerId: number) => void;
    };
    logicWithPrivateAccess.markEntityDestroyed(1, 0);
    expect(logic.getEntityState(1)?.animationState).toBe('DIE');
    logic.update(1 / 30);
    expect(logic.getEntityState(1)).toBeNull();
    expect(logic.getRenderableEntityStates().some((entity) => entity.id === 1)).toBe(true);
    expect(logic.getRenderableEntityStates().find((entity) => entity.id === 1)?.animationState).toBe('DIE');

    logic.update(1 / 30);
    expect(logic.getRenderableEntityStates().some((entity) => entity.id === 1)).toBe(false);
  });

  it('applies deterministic direct-fire combat with source attack range and shot delay semantics', () => {
    const timeline = runCombatTimeline();
    expect(timeline).toEqual([70, 70, 70, 40, 40, 40, 10, 10, 10, -1, -1, -1]);
  });

  it('produces the same combat timeline across repeated runs', () => {
    const first = runCombatTimeline();
    const second = runCombatTimeline();
    expect(first).toEqual(second);
  });

  it('applies ArmorSet damage coefficients by DamageType and switches to PLAYER_UPGRADE armor on ArmorUpgrade', () => {
    const timeline = runArmorUpgradeCombatTimeline();
    expect(timeline).toEqual([160, 160, 160, 150, 150, 150, 140, 140, 140, 130]);
  });

  it('keeps armor-upgrade combat timing deterministic across repeated runs', () => {
    const first = runArmorUpgradeCombatTimeline();
    const second = runArmorUpgradeCombatTimeline();
    expect(first).toEqual(second);
  });

  it('applies PreAttackDelay with PreAttackType=PER_SHOT before every shot', () => {
    const timeline = runPrefireTypeCombatTimeline('PER_SHOT');
    expect(timeline).toEqual([200, 200, 200, 170, 170, 170, 170, 170, 170, 140, 140, 140]);
  });

  it('applies PreAttackDelay with PreAttackType=PER_ATTACK only on first shot per target', () => {
    const timeline = runPrefireTypeCombatTimeline('PER_ATTACK');
    expect(timeline).toEqual([200, 200, 200, 170, 170, 170, 140, 140, 140, 110, 110, 110]);
  });

  it('applies PreAttackType=PER_CLIP only on first shot after each clip reload', () => {
    const timeline = runPerClipPrefireTimeline();
    expect(timeline.targetHealthTimeline).toEqual([
      220,
      220,
      220,
      200,
      200,
      200,
      180,
      180,
      180,
      180,
      180,
      180,
      180,
      180,
      180,
      160,
      160,
      160,
    ]);
  });

  it('keeps PreAttackDelay timing deterministic across repeated runs', () => {
    const first = {
      perShot: runPrefireTypeCombatTimeline('PER_SHOT'),
      perAttack: runPrefireTypeCombatTimeline('PER_ATTACK'),
      perClip: runPerClipPrefireTimeline(),
    };
    const second = {
      perShot: runPrefireTypeCombatTimeline('PER_SHOT'),
      perAttack: runPrefireTypeCombatTimeline('PER_ATTACK'),
      perClip: runPerClipPrefireTimeline(),
    };
    expect(first).toEqual(second);
  });

  it('forces idle clip reload by AutoReloadWhenIdle before re-engagement', () => {
    const withAutoReload = runAutoReloadWhenIdleTimeline(200);
    expect(withAutoReload.targetHealthTimeline).toEqual([
      300,
      300,
      300,
      280,
      280,
      280,
      280,
      280,
      280,
      280,
      280,
      280,
      280,
      260,
      260,
      260,
    ]);

    const withoutAutoReload = runAutoReloadWhenIdleTimeline(0);
    expect(withoutAutoReload.targetHealthTimeline).toEqual([
      300,
      300,
      300,
      280,
      280,
      280,
      280,
      280,
      280,
      280,
      260,
      260,
      260,
      240,
      240,
      240,
    ]);
  });

  it('keeps AutoReloadWhenIdle timing deterministic across repeated runs', () => {
    const first = {
      enabled: runAutoReloadWhenIdleTimeline(200),
      disabled: runAutoReloadWhenIdleTimeline(0),
    };
    const second = {
      enabled: runAutoReloadWhenIdleTimeline(200),
      disabled: runAutoReloadWhenIdleTimeline(0),
    };
    expect(first).toEqual(second);
  });

  it('executes upgrade modules with TriggeredBy/RequiresAllTriggers and ActiveBody max-health change rules', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UpgradeableUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 50 }),
          makeBlock('LocomotorSet', 'SET_NORMAL LocomotorBase', {}),
          makeBlock('LocomotorSet', 'SET_NORMAL_UPGRADED LocomotorFast', {}),
          makeBlock('Behavior', 'LocomotorSetUpgrade ModuleTag_Move', {
            TriggeredBy: 'Upgrade_Move',
          }),
          makeBlock('Behavior', 'MaxHealthUpgrade ModuleTag_HP', {
            TriggeredBy: ['Upgrade_HP_A', 'Upgrade_HP_B'],
            RequiresAllTriggers: true,
            AddMaxHealth: 50,
            ChangeType: 'PRESERVE_RATIO',
          }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('LocomotorBase', 10),
        makeLocomotorDef('LocomotorFast', 20),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const map = makeMap([makeMapObject('UpgradeableUnit', 10, 10)]);
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap());

    expect(logic.getEntityState(1)).toMatchObject({
      health: 50,
      maxHealth: 100,
      activeLocomotorSet: 'SET_NORMAL',
      speed: 10,
      alive: true,
    });

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Move' });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)).toMatchObject({
      activeLocomotorSet: 'SET_NORMAL_UPGRADED',
      speed: 20,
    });

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_HP_A' });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)).toMatchObject({
      health: 50,
      maxHealth: 100,
    });

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_HP_B' });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)).toMatchObject({
      health: 75,
      maxHealth: 150,
    });

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_HP_B' });
    logic.update(1 / 30);
    expect(logic.getEntityState(1)).toMatchObject({
      health: 75,
      maxHealth: 150,
    });
  });

  it('processes FIFO unit production queue timing from BuildTime in logic frames', () => {
    const { alphaCounts, bravoCounts, queuePercents } = runFifoProductionTimeline();
    expect(alphaCounts).toEqual([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]);
    expect(bravoCounts).toEqual([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);
    expect(queuePercents[2]).toBeCloseTo(50, 6);
  });

  it('applies QuantityModifier production count and QueueProductionExitUpdate delay deterministically', () => {
    const first = runQuantityModifierDelayTimeline();
    const second = runQuantityModifierDelayTimeline();
    expect(first).toEqual([0, 0, 1, 1, 2, 2]);
    expect(second).toEqual(first);
  });

  it('interprets QueueProductionExitUpdate ExitDelay as duration milliseconds', () => {
    const timeline = runQuantityModifierDelayTimeline(2);
    expect(timeline).toEqual([0, 0, 1, 2, 2, 2]);
  });

  it('supports SupplyCenterProductionExitUpdate as a valid production exit module', () => {
    const timeline = runSupplyCenterExitProductionTimeline();
    expect(timeline.producedCounts).toEqual([0, 0, 1, 1, 1, 1]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0, 0, 0]);
    expect(timeline.credits).toEqual([400, 400, 400, 400, 400, 400]);
  });

  it('enforces ProductionUpdate MaxQueueEntries when queueing units', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Factory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 1,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
          }),
        ]),
        makeObjectDef('InfantryAlpha', 'America', ['INFANTRY'], [], { BuildTime: 0.1, BuildCost: 100 }),
        makeObjectDef('InfantryBravo', 'America', ['INFANTRY'], [], { BuildTime: 0.1, BuildCost: 100 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const map = makeMap([makeMapObject('Factory', 10, 10)]);
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(32, 32));

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'InfantryAlpha' });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'InfantryBravo' });
    logic.update(1 / 30);

    expect(logic.getProductionState(1)).toMatchObject({
      queueEntryCount: 1,
      queue: [{ templateName: 'InfantryAlpha' }],
    });
  });

  it('gates production by available credits and refunds canceled queue entries', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [10, 0, 0],
          }),
        ]),
        makeObjectDef('VehicleA', 'America', ['VEHICLE'], [], { BuildTime: 0.2, BuildCost: 300 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 15, 15)]), makeRegistry(bundle), makeHeightmap(64, 64));

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 250 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'VehicleA' });
    logic.update(1 / 30);
    expect(logic.getSideCredits('America')).toBe(250);
    expect(logic.getProductionState(1)?.queueEntryCount).toBe(0);

    logic.submitCommand({ type: 'addSideCredits', side: 'America', amount: 250 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'VehicleA' });
    logic.update(1 / 30);
    expect(logic.getSideCredits('America')).toBe(200);
    expect(logic.getProductionState(1)?.queueEntryCount).toBe(1);

    logic.submitCommand({ type: 'cancelUnitProduction', entityId: 1, productionId: 1 });
    logic.update(1 / 30);
    expect(logic.getSideCredits('America')).toBe(500);
    expect(logic.getProductionState(1)?.queueEntryCount).toBe(0);
  });

  it('produces deterministic economy+production timelines across repeated runs', () => {
    const first = runEconomyProductionTimeline();
    const second = runEconomyProductionTimeline();
    expect(first).toEqual(second);
    expect(first.credits).toEqual([200, 200, 200, 200, 200]);
    expect(first.queueCounts).toEqual([1, 1, 0, 0, 0]);
    expect(first.producedCounts).toEqual([0, 0, 1, 1, 1]);
  });

  it('keeps SupplyCenterProductionExitUpdate production timing deterministic across repeated runs', () => {
    const first = runSupplyCenterExitProductionTimeline();
    const second = runSupplyCenterExitProductionTimeline();
    expect(first).toEqual(second);
  });

  it('routes produced units through natural rally point then player rally point', () => {
    // Test the exit path logic directly via resolveQueueProductionExitPath.
    // Integration: when a factory has a player rally point set, produced units
    // should receive a two-waypoint path (natural  player rally point).
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Factory', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 3,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [12, 0, 0],
            NaturalRallyPoint: [28, 0, 0],
            ExitDelay: 0,
            InitialBurst: 0,
          }),
        ]),
        makeObjectDef('Soldier', 'America', ['INFANTRY'], [], { BuildTime: 0.1, BuildCost: 50 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const map = makeMap([makeMapObject('Factory', 40, 40)]);
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    // Set player rally point at (100, 80).
    logic.submitCommand({ type: 'setRallyPoint', entityId: 1, targetX: 100, targetZ: 80 });
    // Process the buffered commands so rally point is applied.
    logic.update(1 / 30);

    // Verify the rally point was stored.
    const factoryState = logic.getEntityState(1);
    expect(factoryState).not.toBeNull();
    expect(factoryState!.rallyPoint).toEqual({ x: 100, z: 80 });

    // Queue and produce a unit.
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'Soldier' });
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }

    const soldierIds = logic.getEntityIdsByTemplate('Soldier');
    expect(soldierIds.length).toBe(1);
  });

  it('keeps QueueProductionExitUpdate duration-based ExitDelay timing deterministic across repeated runs', () => {
    const first = runQuantityModifierDelayTimeline(2);
    const second = runQuantityModifierDelayTimeline(2);
    expect(first).toEqual(second);
  });

  it('processes player upgrade production timing and applies completed side upgrade effects', () => {
    const timeline = runUpgradeProductionTimeline();
    expect(timeline.credits).toEqual([100, 100, 100, 100, 100]);
    expect(timeline.inProductionCounts).toEqual([1, 1, 0, 0, 0]);
    expect(timeline.completedCounts).toEqual([0, 0, 1, 1, 1]);
    expect(timeline.speeds).toEqual([10, 10, 20, 20, 20]);
  });

  it('gates OBJECT upgrade queueing by source affectedByUpgrade semantics and applies valid upgrades on completion', () => {
    const timeline = runObjectUpgradeAffectabilityTimeline();
    expect(timeline.credits).toEqual([1000, 1000, 900, 900, 900, 800, 800, 800]);
    expect(timeline.queueCounts).toEqual([0, 0, 1, 1, 0, 1, 1, 0]);
    expect(timeline.maxHealth).toEqual([100, 100, 100, 100, 150, 150, 150, 150]);
    expect(timeline.speeds).toEqual([10, 10, 10, 10, 10, 10, 10, 20]);
  });

  it('keeps OBJECT-upgrade affectedByUpgrade gating deterministic across repeated runs', () => {
    const first = runObjectUpgradeAffectabilityTimeline();
    const second = runObjectUpgradeAffectabilityTimeline();
    expect(first).toEqual(second);
  });

  it('applies WeaponSetUpgrade via OBJECT upgrade production and switches combat damage profile on completion', () => {
    const timeline = runWeaponSetUpgradeCombatTimeline();
    expect(timeline.credits).toEqual([200, 200, 200, 200, 200, 200, 200, 200]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0, 0, 0, 0, 0]);
    expect(timeline.healthTimeline).toEqual([180, 180, 180, 120, 120, 120, 60, 60]);
  });

  it('keeps WeaponSetUpgrade production-to-combat transition deterministic across repeated runs', () => {
    const first = runWeaponSetUpgradeCombatTimeline();
    const second = runWeaponSetUpgradeCombatTimeline();
    expect(first).toEqual(second);
  });

  it('refunds canceled player-upgrade production and clears in-production state', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('StrategyCenter', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
        ]),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_Move', {
          Type: 'PLAYER',
          BuildTime: 0.2,
          BuildCost: 150,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('StrategyCenter', 6, 6)]), makeRegistry(bundle), makeHeightmap(64, 64));

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 200 });
    logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });
    logic.update(1 / 30);
    expect(logic.getSideCredits('America')).toBe(50);
    expect(logic.getSideUpgradeState('America').inProduction).toEqual(['UPGRADE_MOVE']);

    logic.submitCommand({ type: 'cancelUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });
    logic.update(1 / 30);
    expect(logic.getSideCredits('America')).toBe(200);
    expect(logic.getSideUpgradeState('America').inProduction).toEqual([]);
    expect(logic.getSideUpgradeState('America').completed).toEqual([]);
  });

  it('prevents queueing the same player upgrade on another producer while in production', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('StrategyCenter', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
        ]),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_Move', {
          Type: 'PLAYER',
          BuildTime: 0.5,
          BuildCost: 100,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('StrategyCenter', 6, 6), makeMapObject('StrategyCenter', 12, 6)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_Move' });
    logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 2, upgradeName: 'Upgrade_Move' });
    logic.update(1 / 30);

    expect(logic.getSideCredits('America')).toBe(400);
    expect(logic.getProductionState(1)?.queueEntryCount).toBe(1);
    expect(logic.getProductionState(2)?.queueEntryCount).toBe(0);
    expect(logic.getSideUpgradeState('America').inProduction).toEqual(['UPGRADE_MOVE']);
  });

  it('requires a matching PLAYER_UPGRADE/OBJECT_UPGRADE command button to queue upgrade production', () => {
    const allowed = runUpgradeCommandSetGateTimeline(true);
    expect(allowed.credits).toEqual([150, 150, 150, 150]);
    expect(allowed.queueCounts).toEqual([1, 1, 0, 0]);
    expect(allowed.inProductionCounts).toEqual([1, 1, 0, 0]);
    expect(allowed.completedCounts).toEqual([0, 0, 1, 1]);

    const blocked = runUpgradeCommandSetGateTimeline(false);
    expect(blocked.credits).toEqual([300, 300, 300, 300]);
    expect(blocked.queueCounts).toEqual([0, 0, 0, 0]);
    expect(blocked.inProductionCounts).toEqual([0, 0, 0, 0]);
    expect(blocked.completedCounts).toEqual([0, 0, 0, 0]);
  });

  it('keeps upgrade command-set gating deterministic across repeated runs', () => {
    const first = runUpgradeCommandSetGateTimeline(true);
    const second = runUpgradeCommandSetGateTimeline(true);
    expect(first).toEqual(second);
  });

  it('applies CommandSetUpgrade command-set overrides to gate follow-up object upgrades', () => {
    const noAlt = runCommandSetUpgradeTimeline(false);
    expect(noAlt.credits).toEqual([900, 900, 900, 780, 780, 780, 780, 780]);
    expect(noAlt.queueCounts).toEqual([1, 1, 0, 1, 1, 0, 0, 0]);
    expect(noAlt.maxHealth).toEqual([100, 100, 100, 100, 100, 150, 150, 150]);

    const withAlt = runCommandSetUpgradeTimeline(true);
    expect(withAlt.credits).toEqual([900, 900, 900, 760, 760, 760, 760, 760]);
    expect(withAlt.queueCounts).toEqual([1, 1, 0, 1, 1, 0, 0, 0]);
    expect(withAlt.maxHealth).toEqual([100, 100, 100, 100, 100, 180, 180, 180]);
  });

  it('keeps CommandSetUpgrade queue gating deterministic across repeated runs', () => {
    const first = {
      noAlt: runCommandSetUpgradeTimeline(false),
      withAlt: runCommandSetUpgradeTimeline(true),
    };
    const second = {
      noAlt: runCommandSetUpgradeTimeline(false),
      withAlt: runCommandSetUpgradeTimeline(true),
    };
    expect(first).toEqual(second);
  });

  it('enforces ParkingPlaceBehavior queue gating and preserves PRODUCED_AT_HELIPAD bypass behavior', () => {
    const timeline = runParkingPlaceQueueTimeline();
    expect(timeline.credits).toEqual([900, 900, 900, 900, 800, 800, 800, 800]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0, 1, 1, 0, 0]);
    expect(timeline.jetCounts).toEqual([0, 0, 1, 1, 1, 1, 1, 1]);
    expect(timeline.heliCounts).toEqual([0, 0, 0, 0, 0, 0, 1, 1]);
  });

  it('keeps ParkingPlaceBehavior queue gating deterministic across repeated runs', () => {
    const first = runParkingPlaceQueueTimeline();
    const second = runParkingPlaceQueueTimeline();
    expect(first).toEqual(second);
  });

  it('reserves ParkingPlaceBehavior queue space up front and releases it on cancel', () => {
    const timeline = runParkingReservationQueueAndCancelTimeline();
    expect(timeline.credits).toEqual([900, 900, 800, 900, 800]);
    expect(timeline.queueCounts).toEqual([1, 1, 2, 1, 2]);
    expect(timeline.jetQueuedCounts).toEqual([1, 1, 1, 0, 1]);
    expect(timeline.heliQueuedCounts).toEqual([0, 0, 1, 1, 1]);
  });

  it('keeps queue-time parking reservation + cancel-release deterministic across repeated runs', () => {
    const first = runParkingReservationQueueAndCancelTimeline();
    const second = runParkingReservationQueueAndCancelTimeline();
    expect(first).toEqual(second);
  });

  it('stalls QuantityModifier parking production at capacity until a slot is free', () => {
    const timeline = runParkingQuantityStallTimeline();
    expect(timeline.credits).toEqual([900, 900, 900, 900, 900, 900, 900, 900]);
    expect(timeline.queueCounts).toEqual([1, 1, 1, 1, 1, 1, 1, 1]);
    expect(timeline.jetCounts).toEqual([0, 0, 1, 1, 1, 1, 1, 1]);
    expect(timeline.quantityProduced).toEqual([0, 0, 1, 1, 1, 1, 1, 1]);
    expect(timeline.quantityTotal).toEqual([2, 2, 2, 2, 2, 2, 2, 2]);
  });

  it('keeps parking-capacity quantity stall timing deterministic across repeated runs', () => {
    const first = runParkingQuantityStallTimeline();
    const second = runParkingQuantityStallTimeline();
    expect(first).toEqual(second);
  });

  it('applies StatusBitsUpgrade set/clear semantics on object-upgrade completion timing', () => {
    const timeline = runStatusBitsUpgradeTimeline();
    expect(timeline.credits).toEqual([380, 380, 380, 250, 250, 250, 250, 250]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 1, 1, 0, 0, 0]);
    expect(timeline.statusFlagsTimeline).toEqual([
      [],
      [],
      ['EMPED', 'UNSELECTABLE'],
      ['EMPED', 'UNSELECTABLE'],
      ['EMPED', 'UNSELECTABLE'],
      ['STEALTHED', 'UNSELECTABLE'],
      ['STEALTHED', 'UNSELECTABLE'],
      ['STEALTHED', 'UNSELECTABLE'],
    ]);
  });

  it('keeps StatusBitsUpgrade timing deterministic across repeated runs', () => {
    const first = runStatusBitsUpgradeTimeline();
    const second = runStatusBitsUpgradeTimeline();
    expect(first).toEqual(second);
  });

  it('applies StatusBitsUpgrade NO_ATTACK set/clear semantics to combat timing', () => {
    const timeline = runStatusBitsCombatTimeline();
    expect(timeline.credits).toEqual([400, 400, 400, 400, 280, 280, 280, 280, 280, 280]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0, 1, 1, 0, 0, 0, 0]);
    expect(timeline.statusFlagsTimeline).toEqual([
      ['IS_ATTACKING', 'IS_FIRING_WEAPON'],
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['NO_ATTACK'],
      ['NO_ATTACK'],
      ['NO_ATTACK'],
      ['NO_ATTACK'],
      ['IS_ATTACKING', 'IS_FIRING_WEAPON'],
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IS_ATTACKING', 'IS_FIRING_WEAPON'],
    ]);
    expect(timeline.targetHealthTimeline).toEqual([170, 170, 170, 170, 170, 170, 140, 140, 140, 110]);
  });

  it('keeps StatusBitsUpgrade combat gating deterministic across repeated runs', () => {
    const first = runStatusBitsCombatTimeline();
    const second = runStatusBitsCombatTimeline();
    expect(first).toEqual(second);
  });

  it('tracks IS_AIMING_WEAPON and IS_FIRING_WEAPON transitions across pre-attack, fire, and stop timing', () => {
    const timeline = runAimAndFiringStatusTimeline();
    expect(timeline.statusFlagsTimeline).toEqual([
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IS_ATTACKING', 'IS_FIRING_WEAPON'],
      ['IS_AIMING_WEAPON', 'IS_ATTACKING'],
      [],
      [],
      [],
    ]);
    expect(timeline.targetHealthTimeline).toEqual([200, 200, 200, 170, 170, 170, 170, 170]);
  });

  it('keeps aiming/firing status-bit timing deterministic across repeated runs', () => {
    const first = runAimAndFiringStatusTimeline();
    const second = runAimAndFiringStatusTimeline();
    expect(first).toEqual(second);
  });

  it('blocks attacks against STEALTHED + undetected victims unless attacker currently has IGNORING_STEALTH', () => {
    const blocked = runStealthAttackGateTimeline({
      continueAttackRange: 0,
      detected: false,
      preAttackDelayMs: 0,
    });
    expect(blocked.attackerTargetTimeline).toEqual([null, null, null, null, null, null, null, null]);
    expect(blocked.targetHealthTimeline).toEqual([200, 200, 200, 200, 200, 200, 200, 200]);

    const detected = runStealthAttackGateTimeline({
      continueAttackRange: 0,
      detected: true,
      preAttackDelayMs: 0,
    });
    expect(detected.attackerTargetTimeline).toEqual([2, 2, 2, 2, 2, 2, 2, 2]);
    expect(detected.targetHealthTimeline).toEqual([170, 170, 170, 140, 140, 140, 110, 110]);
  });

  it('sets IGNORING_STEALTH during pre-fire aim for ContinueAttackRange and clears it after firing', () => {
    const timeline = runStealthAttackGateTimeline({
      continueAttackRange: 20,
      detected: false,
      preAttackDelayMs: 100,
    });
    expect(timeline.attackerStatusFlagsTimeline).toEqual([
      ['IGNORING_STEALTH', 'IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IGNORING_STEALTH', 'IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IGNORING_STEALTH', 'IS_AIMING_WEAPON', 'IS_ATTACKING'],
      ['IS_ATTACKING', 'IS_FIRING_WEAPON'],
      [],
      [],
      [],
      [],
    ]);
    expect(timeline.attackerTargetTimeline).toEqual([2, 2, 2, 2, null, null, null, null]);
    expect(timeline.targetHealthTimeline).toEqual([200, 200, 200, 170, 170, 170, 170, 170]);
  });

  it('keeps stealth-target gating and IGNORING_STEALTH timing deterministic across repeated runs', () => {
    const first = {
      blocked: runStealthAttackGateTimeline({
        continueAttackRange: 0,
        detected: false,
        preAttackDelayMs: 0,
      }),
      ignoringStealth: runStealthAttackGateTimeline({
        continueAttackRange: 20,
        detected: false,
        preAttackDelayMs: 100,
      }),
    };
    const second = {
      blocked: runStealthAttackGateTimeline({
        continueAttackRange: 0,
        detected: false,
        preAttackDelayMs: 0,
      }),
      ignoringStealth: runStealthAttackGateTimeline({
        continueAttackRange: 20,
        detected: false,
        preAttackDelayMs: 100,
      }),
    };
    expect(first).toEqual(second);
  });

  it('applies UpgradeMux RemovesUpgrades before module implementation and allows re-queue of removed object upgrades', () => {
    const timeline = runUpgradeRemovalMuxTimeline();
    expect(timeline.credits).toEqual([400, 400, 400, 300, 300, 300, 200, 200, 200, 200]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 1, 1, 0, 1, 1, 0, 0]);
    expect(timeline.maxHealthTimeline).toEqual([100, 100, 120, 120, 120, 150, 150, 150, 170, 170]);
  });

  it('keeps UpgradeMux RemovesUpgrades timing deterministic across repeated runs', () => {
    const first = runUpgradeRemovalMuxTimeline();
    const second = runUpgradeRemovalMuxTimeline();
    expect(first).toEqual(second);
  });

  it('enforces Weapon MinimumAttackRange by preventing stationary close-range fire', () => {
    const timeline = runMinimumAttackRangeStationaryTimeline();
    expect(timeline.targetHealthTimeline).toEqual([200, 200, 200, 200, 200, 200, 200, 200]);
  });

  it('resumes firing after moving a too-close attacker outside MinimumAttackRange and re-issuing attack', () => {
    const timeline = runMinimumAttackRangeRetreatTimeline();
    expect(timeline.targetHealthTimeline).toEqual([
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      170,
      170,
      170,
      140,
      140,
      140,
    ]);

    const firstDamageFrame = timeline.targetHealthTimeline.findIndex((health) => health < 200);
    expect(firstDamageFrame).toBe(10);
    const rangeAtFirstDamage = timeline.attackerRangeTimeline[firstDamageFrame];
    expect(rangeAtFirstDamage).toBeGreaterThanOrEqual(40);
  });

  it('keeps MinimumAttackRange retreat timing deterministic across repeated runs', () => {
    const first = runMinimumAttackRangeRetreatTimeline();
    const second = runMinimumAttackRangeRetreatTimeline();
    expect(first).toEqual(second);
  });

  it('reacquires a same-player follow-up victim around original victim position when ContinueAttackRange is enabled', () => {
    const timeline = runContinueAttackRangeTimeline(20);
    expect(timeline.attackerTargetTimeline).toEqual([3, 3, 3, null, null, null, null, null]);
    expect(timeline.chinaFollowupHealthTimeline).toEqual([100, 100, 100, -1, -1, -1, -1, -1]);
    expect(timeline.glaFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
  });

  it('does not reacquire follow-up victims when ContinueAttackRange is zero', () => {
    const timeline = runContinueAttackRangeTimeline(0);
    expect(timeline.attackerTargetTimeline).toEqual([null, null, null, null, null, null, null, null]);
    expect(timeline.chinaFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.glaFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
  });

  it('keeps ContinueAttackRange victim-reacquire timing deterministic across repeated runs', () => {
    const first = runContinueAttackRangeTimeline(20);
    const second = runContinueAttackRangeTimeline(20);
    expect(first).toEqual(second);
  });

  it('uses source same-player filtering for ContinueAttackRange victim reacquire instead of same-side proximity', () => {
    const timeline = runContinueAttackSamePlayerFilterTimeline();
    expect(timeline.attackerTargetTimeline).toEqual([4, 4, 4, null, null, null, null, null]);
    expect(timeline.differentOwnerFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.sameOwnerFollowupHealthTimeline).toEqual([100, 100, 100, -1, -1, -1, -1, -1]);
  });

  it('keeps same-player ContinueAttackRange filtering deterministic across repeated runs', () => {
    const first = runContinueAttackSamePlayerFilterTimeline();
    const second = runContinueAttackSamePlayerFilterTimeline();
    expect(first).toEqual(second);
  });

  it('rejects OBJECT_STATUS_MASKED targets from attack command assignment and combat damage', () => {
    const timeline = runMaskedTargetGateTimeline();
    expect(timeline.attackerTargetTimeline).toEqual([null, null, null, null, null, null]);
    expect(timeline.maskedTargetHealthTimeline).toEqual([150, 150, 150, 150, 150, 150]);
  });

  it('rejects KINDOF_UNATTACKABLE targets from attack command assignment and combat damage', () => {
    const timeline = runUnattackableKindGateTimeline();
    expect(timeline.attackerTargetTimeline).toEqual([null, null, null, null, null, null]);
    expect(timeline.unattackableTargetHealthTimeline).toEqual([150, 150, 150, 150, 150, 150]);
  });

  it('skips MASKED and UNATTACKABLE follow-up candidates during ContinueAttackRange victim reacquire', () => {
    const timeline = runContinueAttackRangeLegalityFilterTimeline();
    expect(timeline.attackerTargetTimeline).toEqual([5, 5, 5, null, null, null, null, null]);
    expect(timeline.maskedFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.unattackableFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.validFollowupHealthTimeline).toEqual([100, 100, 100, -1, -1, -1, -1, -1]);
  });

  it('keeps MASKED/UNATTACKABLE target legality timing deterministic across repeated runs', () => {
    const first = {
      masked: runMaskedTargetGateTimeline(),
      unattackable: runUnattackableKindGateTimeline(),
      continueFilter: runContinueAttackRangeLegalityFilterTimeline(),
    };
    const second = {
      masked: runMaskedTargetGateTimeline(),
      unattackable: runUnattackableKindGateTimeline(),
      continueFilter: runContinueAttackRangeLegalityFilterTimeline(),
    };
    expect(first).toEqual(second);
  });

  it('applies NO_ATTACK_FROM_AI target legality by command source (AI blocked, PLAYER allowed)', () => {
    const playerCommand = runNoAttackFromAiGateTimeline('PLAYER');
    expect(playerCommand.attackerTargetTimeline).toEqual([2, 2, 2, 2, 2, 2]);
    expect(playerCommand.targetHealthTimeline).toEqual([120, 120, 120, 90, 90, 90]);

    const aiCommand = runNoAttackFromAiGateTimeline('AI');
    expect(aiCommand.attackerTargetTimeline).toEqual([null, null, null, null, null, null]);
    expect(aiCommand.targetHealthTimeline).toEqual([150, 150, 150, 150, 150, 150]);
  });

  it('uses stored command source when filtering ContinueAttackRange reacquire against NO_ATTACK_FROM_AI', () => {
    const playerCommand = runContinueAttackNoAttackFromAiFilterTimeline('PLAYER');
    expect(playerCommand.attackerTargetTimeline).toEqual([3, 3, 3, 4, 4, 4, null, null]);
    expect(playerCommand.noAttackFromAiFollowupHealthTimeline).toEqual([100, 100, 100, -1, -1, -1, -1, -1]);
    expect(playerCommand.validFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, -1, -1]);

    const aiCommand = runContinueAttackNoAttackFromAiFilterTimeline('AI');
    expect(aiCommand.attackerTargetTimeline).toEqual([4, 4, 4, null, null, null, null, null]);
    expect(aiCommand.noAttackFromAiFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
    expect(aiCommand.validFollowupHealthTimeline).toEqual([100, 100, 100, -1, -1, -1, -1, -1]);
  });

  it('keeps NO_ATTACK_FROM_AI command-source legality deterministic across repeated runs', () => {
    const first = {
      playerGate: runNoAttackFromAiGateTimeline('PLAYER'),
      aiGate: runNoAttackFromAiGateTimeline('AI'),
      playerContinue: runContinueAttackNoAttackFromAiFilterTimeline('PLAYER'),
      aiContinue: runContinueAttackNoAttackFromAiFilterTimeline('AI'),
    };
    const second = {
      playerGate: runNoAttackFromAiGateTimeline('PLAYER'),
      aiGate: runNoAttackFromAiGateTimeline('AI'),
      playerContinue: runContinueAttackNoAttackFromAiFilterTimeline('PLAYER'),
      aiContinue: runContinueAttackNoAttackFromAiFilterTimeline('AI'),
    };
    expect(first).toEqual(second);
  });

  it('rejects attack command assignment when attacker/target map status differs (on-map vs off-map)', () => {
    const timeline = runOffMapTargetGateTimeline();
    expect(timeline.attackerTargetTimeline).toEqual([null, null, null, null, null, null]);
    expect(timeline.offMapTargetHealthTimeline).toEqual([150, 150, 150, 150, 150, 150]);
  });

  it('skips off-map follow-up victims during ContinueAttackRange reacquire and selects on-map victims', () => {
    const timeline = runContinueAttackOffMapFilterTimeline();
    expect(timeline.attackerTargetTimeline).toEqual([4, 4, 4, null, null, null, null, null]);
    expect(timeline.offMapFollowupHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.onMapFollowupHealthTimeline).toEqual([100, 100, 100, -1, -1, -1, -1, -1]);
  });

  it('keeps off-map map-status attack legality deterministic across repeated runs', () => {
    const first = {
      directGate: runOffMapTargetGateTimeline(),
      continueFilter: runContinueAttackOffMapFilterTimeline(),
    };
    const second = {
      directGate: runOffMapTargetGateTimeline(),
      continueFilter: runContinueAttackOffMapFilterTimeline(),
    };
    expect(first).toEqual(second);
  });

  it('delays non-projectile damage resolution by WeaponSpeed distance travel time', () => {
    const timeline = runWeaponSpeedDelayTimeline();
    expect(timeline).toEqual([100, 100, 100, 100, 70, 70, 70, 70]);
  });

  it('applies radius primary/secondary damage tiers with RadiusDamageAffects relationship masks', () => {
    const timeline = runRadiusDamageAffectsTimeline();
    expect(timeline.primaryHealthTimeline).toEqual([110, 110, 110, 110]);
    expect(timeline.splashEnemyHealthTimeline).toEqual([135, 135, 135, 135]);
    expect(timeline.splashAllyHealthTimeline).toEqual([150, 150, 150, 150]);
    expect(timeline.attackerHealthTimeline).toEqual([150, 150, 150, 150]);
  });

  it('applies DamageDealtAtSelfPosition at source location instead of the direct target location', () => {
    const timeline = runDamageAtSelfPositionTimeline();
    expect(timeline.farTargetHealthTimeline).toEqual([150, 150, 150, 150]);
    expect(timeline.nearEnemyHealthTimeline).toEqual([120, 120, 120, 120]);
    expect(timeline.nearAllyHealthTimeline).toEqual([150, 150, 150, 150]);
    expect(timeline.attackerHealthTimeline).toEqual([150, 150, 150, 150]);
  });

  it('keeps weapon travel-delay/radius/self-position damage timelines deterministic across repeated runs', () => {
    const first = {
      delay: runWeaponSpeedDelayTimeline(),
      radius: runRadiusDamageAffectsTimeline(),
      selfPosition: runDamageAtSelfPositionTimeline(),
    };
    const second = {
      delay: runWeaponSpeedDelayTimeline(),
      radius: runRadiusDamageAffectsTimeline(),
      selfPosition: runDamageAtSelfPositionTimeline(),
    };
    expect(first).toEqual(second);
  });

  it('applies RadiusDamageAngle cone gating using source-facing orientation for radius victims', () => {
    const timeline = runRadiusDamageAngleTimeline();
    expect(timeline.primaryHealthTimeline).toEqual([120, 120, 120]);
    expect(timeline.inConeEnemyHealthTimeline).toEqual([140, 140, 140]);
    expect(timeline.outOfConeEnemyHealthTimeline).toEqual([160, 160, 160]);
  });

  it('applies RadiusDamageAffects SUICIDE and NOT_SIMILAR semantics for self-centered blast damage', () => {
    const timeline = runSuicideAndNotSimilarTimeline();
    expect(timeline.attackerHealthTimeline).toEqual([-1, -1, -1]);
    expect(timeline.farTargetHealthTimeline).toEqual([150, 150, 150]);
    expect(timeline.nearEnemyHealthTimeline).toEqual([120, 120, 120]);
    expect(timeline.nearAllyHealthTimeline).toEqual([150, 150, 150]);
  });

  it('keeps RadiusDamageAngle and SUICIDE/NOT_SIMILAR blast timelines deterministic across repeated runs', () => {
    const first = {
      cone: runRadiusDamageAngleTimeline(),
      suicide: runSuicideAndNotSimilarTimeline(),
    };
    const second = {
      cone: runRadiusDamageAngleTimeline(),
      suicide: runSuicideAndNotSimilarTimeline(),
    };
    expect(first).toEqual(second);
  });

  it('defers projectile-weapon impact by at least one logic frame versus direct-hit delivery', () => {
    const direct = runProjectileDeliveryTimeline(false);
    expect(direct).toEqual([70, 70, 70, 70]);

    const projectile = runProjectileDeliveryTimeline(true);
    expect(projectile).toEqual([100, 70, 70, 70]);
  });

  it('resolves zero-frame direct-hit damage immediately so earlier shooters can kill before later shooters fire', () => {
    const timeline = runDirectImmediateDuelTimeline();
    expect(timeline.firstHealthTimeline).toEqual([120, 120, 120]);
    expect(timeline.secondHealthTimeline).toEqual([-1, -1, -1]);
  });

  it('applies MinWeaponSpeed/ScaleWeaponSpeed projectile launch-speed scaling to impact timing', () => {
    const unscaled = runScaledProjectileDeliveryTimeline(false);
    expect(unscaled).toEqual([100, 70, 70, 70]);

    const scaled = runScaledProjectileDeliveryTimeline(true);
    expect(scaled).toEqual([100, 100, 70, 70]);
  });

  it('applies projectile-delivery splash damage at impact time using the same radius tiers', () => {
    const timeline = runProjectileSplashTimeline();
    expect(timeline.primaryHealthTimeline).toEqual([150, 150, 150, 110, 110]);
    expect(timeline.splashHealthTimeline).toEqual([150, 150, 150, 130, 130]);
  });

  it('resolves projectile point-hit damage against launch-resolved impact position so fast movers can evade', () => {
    const stationary = runProjectileMovingTargetPointHitTimeline(false);
    expect(stationary).toEqual([100, 100, 100, 60, 60, 60, 60]);

    const moving = runProjectileMovingTargetPointHitTimeline(true);
    expect(moving).toEqual([100, 100, 100, 100, 100, 100, 100]);
  });

  it('applies ProjectileCollidesWith ENEMIES mask to incidental point-impact collisions at launch-resolved impact positions', () => {
    const timeline = runProjectileIncidentalCollisionMaskTimeline('ENEMIES');
    expect(timeline.targetHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.blockerHealthTimeline).toEqual([100, 100, 100, 60, 60, 60, 60]);
  });

  it('skips incidental point-impact collisions when ProjectileCollidesWith mask excludes the collided object relationship', () => {
    const timeline = runProjectileIncidentalCollisionMaskTimeline('ALLIES');
    expect(timeline.targetHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.blockerHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
  });

  it('ignores incidental projectile collisions with launcher container per source getContainedBy exclusion', () => {
    const timeline = runProjectileContainedByCollisionTimeline();
    expect(timeline.targetHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.containingAirfieldHealthTimeline).toEqual([500, 500, 500, 500, 500, 500, 500]);
  });

  it('ignores incidental projectile collisions with FS_AIRFIELD when the intended victim is reserved there', () => {
    const timeline = runProjectileAirfieldReservedVictimCollisionTimeline();
    expect(timeline.targetHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
    expect(timeline.airfieldHealthTimeline).toEqual([500, 500, 500, 500, 500, 500, 500]);
  });

  it('converts sneaky-targeted projectile shots into position-shots using SneakyOffsetWhenAttacking during attackers-miss window', () => {
    const noSneaky = runProjectileSneakyTargetingOffsetTimeline(false);
    expect(noSneaky).toEqual([100, 100, 100, 60, 60, 60, 60]);

    const withSneaky = runProjectileSneakyTargetingOffsetTimeline(true);
    expect(withSneaky).toEqual([100, 100, 100, 100, 100, 100, 100]);
  });

  it('skips incidental projectile collisions with sneaky-offset units while attackers-miss immunity is active', () => {
    const noSneaky = runProjectileSneakyIncidentalImmunityTimeline(false);
    expect(noSneaky.targetHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
    expect(noSneaky.blockerHealthTimeline).toEqual([100, 100, 100, 60, 60, 60, 60]);

    const withSneaky = runProjectileSneakyIncidentalImmunityTimeline(true);
    expect(withSneaky.targetHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
    expect(withSneaky.blockerHealthTimeline).toEqual([100, 100, 100, 100, 100, 100, 100]);
  });

  it('refreshes attackers-miss sneaky immunity every frame while IS_ATTACKING is active, even between long-cooldown shots', () => {
    const noSneaky = runProjectileSneakyCooldownRefreshTimeline(false);
    expect(noSneaky).toEqual([100, 100, 100, 100, 100, 100, 60, 60, 60, 60]);

    const withSneaky = runProjectileSneakyCooldownRefreshTimeline(true);
    expect(withSneaky).toEqual([100, 100, 100, 100, 100, 100, 100, 100, 100, 100]);
  });

  it('keeps attackers-miss sneaky immunity for configured persist frames after stop, then allows hits after expiry', () => {
    const keepAttacking = runProjectileSneakyPersistAfterStopTimeline(null);
    expect(keepAttacking).toEqual([100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100]);

    const stopEarly = runProjectileSneakyPersistAfterStopTimeline(2);
    // After persist expires, a previously sneaky-offset projectile still in flight can collide
    // with the real entity position (source parity: C++ projectiles are physical objects that
    // detect collisions each frame along their flight path).
    expect(stopEarly).toEqual([100, 100, 100, 100, 100, 100, 60, 60, 60, 20, 20, 20]);
  });

  it('keeps projectile-delivery timing and splash deterministic across repeated runs', () => {
    const first = {
      directImmediate: runDirectImmediateDuelTimeline(),
      delivery: runProjectileDeliveryTimeline(true),
      scaledSpeed: runScaledProjectileDeliveryTimeline(true),
      splash: runProjectileSplashTimeline(),
      movingPointHit: runProjectileMovingTargetPointHitTimeline(true),
      incidentalEnemyMask: runProjectileIncidentalCollisionMaskTimeline('ENEMIES'),
      incidentalAllyMask: runProjectileIncidentalCollisionMaskTimeline('ALLIES'),
      containedBy: runProjectileContainedByCollisionTimeline(),
      airfieldReservedVictim: runProjectileAirfieldReservedVictimCollisionTimeline(),
      sneakyOffset: runProjectileSneakyTargetingOffsetTimeline(true),
      sneakyIncidentalImmunity: runProjectileSneakyIncidentalImmunityTimeline(true),
      sneakyCooldownRefresh: runProjectileSneakyCooldownRefreshTimeline(true),
      sneakyPersistAfterStop: runProjectileSneakyPersistAfterStopTimeline(2),
    };
    const second = {
      directImmediate: runDirectImmediateDuelTimeline(),
      delivery: runProjectileDeliveryTimeline(true),
      scaledSpeed: runScaledProjectileDeliveryTimeline(true),
      splash: runProjectileSplashTimeline(),
      movingPointHit: runProjectileMovingTargetPointHitTimeline(true),
      incidentalEnemyMask: runProjectileIncidentalCollisionMaskTimeline('ENEMIES'),
      incidentalAllyMask: runProjectileIncidentalCollisionMaskTimeline('ALLIES'),
      containedBy: runProjectileContainedByCollisionTimeline(),
      airfieldReservedVictim: runProjectileAirfieldReservedVictimCollisionTimeline(),
      sneakyOffset: runProjectileSneakyTargetingOffsetTimeline(true),
      sneakyIncidentalImmunity: runProjectileSneakyIncidentalImmunityTimeline(true),
      sneakyCooldownRefresh: runProjectileSneakyCooldownRefreshTimeline(true),
      sneakyPersistAfterStop: runProjectileSneakyPersistAfterStopTimeline(2),
    };
    expect(first).toEqual(second);
  });

  it('uses projectile scatter to launch at a position and miss tiny-radius impacts deterministically', () => {
    const noScatter = runProjectileScatterTimeline(0);
    expect(noScatter).toEqual([100, 70, 70, 70]);

    // With scatter=200 and PrimaryDamageRadius=0.1, the deterministic random scatter
    // offset lands within the entity's bounding sphere adjusted hit zone (~0.56 units
    // for vehicles with baseHeight=1.5). Source parity: FROM_BOUNDINGSPHERE_3D makes
    // larger entities easier to hit by subtracting BSR from distance.
    const withScatter = runProjectileScatterTimeline(200);
    expect(withScatter).toEqual([100, 70, 70, 70]);
  });

  it('applies ScatterRadiusVsInfantry only when the projectile target is infantry', () => {
    // Infantry target gets scatter=200 applied; with BSR-adjusted hit zone, the
    // deterministic scatter still lands close enough to hit (same as scatter test above).
    const infantryTarget = runProjectileInfantryInaccuracyTimeline('INFANTRY');
    expect(infantryTarget).toEqual([100, 70, 70, 70]);

    const vehicleTarget = runProjectileInfantryInaccuracyTimeline('VEHICLE');
    expect(vehicleTarget).toEqual([100, 70, 70, 70]);
  });

  it('keeps projectile scatter and infantry-inaccuracy timelines deterministic across repeated runs', () => {
    const first = {
      scatter: runProjectileScatterTimeline(200),
      infantry: runProjectileInfantryInaccuracyTimeline('INFANTRY'),
      vehicle: runProjectileInfantryInaccuracyTimeline('VEHICLE'),
    };
    const second = {
      scatter: runProjectileScatterTimeline(200),
      infantry: runProjectileInfantryInaccuracyTimeline('INFANTRY'),
      vehicle: runProjectileInfantryInaccuracyTimeline('VEHICLE'),
    };
    expect(first).toEqual(second);
  });

  it('applies ScatterTarget pattern offsets by firing at position-shots instead of the direct target object', () => {
    const withoutPattern = runProjectileScatterTargetTimeline(false);
    expect(withoutPattern).toEqual([100, 70, 70, 70]);

    const withPattern = runProjectileScatterTargetTimeline(true);
    expect(withPattern).toEqual([100, 100, 100, 100]);
  });

  it('rebuilds ScatterTarget unused-list on clip reload and repeats the deterministic offset cycle', () => {
    const timeline = runProjectileScatterTargetReloadTimeline();
    expect(timeline).toEqual([
      200,
      200,
      200,
      200,
      170,
      170,
      170,
      170,
      170,
      170,
      140,
      140,
    ]);
  });

  it('keeps ScatterTarget offset and reload-cycle timelines deterministic across repeated runs', () => {
    const first = {
      pattern: runProjectileScatterTargetTimeline(true),
      reloadCycle: runProjectileScatterTargetReloadTimeline(),
      selfPositionScatter: runDamageAtSelfScatterTargetTimeline(true),
    };
    const second = {
      pattern: runProjectileScatterTargetTimeline(true),
      reloadCycle: runProjectileScatterTargetReloadTimeline(),
      selfPositionScatter: runDamageAtSelfScatterTargetTimeline(true),
    };
    expect(first).toEqual(second);
  });

  it('detonates projectile early when it collides with an entity along the flight path', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Attacker at 0,0 fires a slow projectile at a target at 50,0.
    // A blocker sits at 25,0 (halfway). The projectile should collide mid-flight.
    const attackerDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SlowMissile'] }),
    ]);
    const blockerDef = makeObjectDef('Blocker', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });
    const targetDef = makeObjectDef('Target', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);
    // DummyProjectile object for the projectile weapon.
    const projectileDef = makeObjectDef('SlowMissileProjectile', 'Neutral', ['PROJECTILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
    ]);

    const weaponDef = makeWeaponDef('SlowMissile', {
      PrimaryDamage: 50,
      PrimaryDamageRadius: 0,
      AttackRange: 200,
      WeaponSpeed: 5, // 5 units/frame  10 frames to reach 50 units away
      DelayBetweenShots: 9999,
      ProjectileObject: 'SlowMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, blockerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('Attacker', 0, 0),
      makeMapObject('Blocker', 25, 0),  // Halfway along the flight path
      makeMapObject('Target', 50, 0),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });

    // Collect health timelines for both blocker and target.
    const blockerHealth: number[] = [];
    const targetHealth: number[] = [];
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
      const blocker = [...(logic as any).spawnedEntities.values()].find(
        (e: any) => e.templateName === 'Blocker',
      );
      const target = [...(logic as any).spawnedEntities.values()].find(
        (e: any) => e.templateName === 'Target',
      );
      blockerHealth.push(blocker ? blocker.health : 0);
      targetHealth.push(target ? target.health : 0);
    }

    // The projectile should hit the blocker before reaching the target.
    // Blocker is at ~25 units, speed is 5/frame  hits around frame 5.
    // Target at 50 units should NOT take damage.
    expect(blockerHealth[blockerHealth.length - 1]).toBeLessThan(200);
    expect(targetHealth[targetHealth.length - 1]).toBe(200);
  });

  it('projectile passes through allies without collision when ProjectileCollidesWith excludes ALLIES', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Attacker fires through an allied unit. Projectile should pass through.
    const attackerDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SlowMissile'] }),
    ]);
    const allyDef = makeObjectDef('AllyBlocker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });
    const targetDef = makeObjectDef('Target', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });
    const projectileDef = makeObjectDef('SlowMissileProjectile', 'Neutral', ['PROJECTILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
    ]);

    const weaponDef = makeWeaponDef('SlowMissile', {
      PrimaryDamage: 50,
      PrimaryDamageRadius: 0,
      AttackRange: 200,
      WeaponSpeed: 5,
      DelayBetweenShots: 9999,
      ProjectileObject: 'SlowMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES', // Does NOT include ALLIES
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, allyDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('Attacker', 0, 0),
      makeMapObject('AllyBlocker', 25, 0),
      makeMapObject('Target', 50, 0),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });

    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    const ally = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'AllyBlocker',
    );
    const target = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'Target',
    );

    // Ally should be unharmed; target should take damage from the projectile.
    expect(ally.health).toBe(200);
    expect(target.health).toBeLessThan(200);
  });

  it('does not collide with the launcher itself during flight', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Attacker fires at a distant target. Ensure the projectile doesn't hit the
    // attacker's own collision radius (launcher exclusion).
    const attackerDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SlowMissile'] }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });
    const targetDef = makeObjectDef('Target', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });
    const projectileDef = makeObjectDef('SlowMissileProjectile', 'Neutral', ['PROJECTILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
    ]);

    const weaponDef = makeWeaponDef('SlowMissile', {
      PrimaryDamage: 50,
      PrimaryDamageRadius: 0,
      AttackRange: 200,
      WeaponSpeed: 5,
      DelayBetweenShots: 9999,
      ProjectileObject: 'SlowMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES ALLIES', // Collides with everything
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('Attacker', 0, 0),
      makeMapObject('Target', 50, 0),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    const attacker = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'Attacker',
    );
    const target = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'Target',
    );

    // Attacker should not be damaged by its own projectile.
    expect(attacker.health).toBe(100);
    // Target should take damage.
    expect(target.health).toBeLessThan(200);
  });

  it('homes onto moving targets when projectile object has MissileAIUpdate', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const attackerDef = makeObjectDef('HomingAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'HomingMissileWeapon'] }),
    ]);
    const targetDef = makeObjectDef('MovingTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);
    const projectileDef = makeObjectDef('HomingMissileProjectile', 'Neutral', ['PROJECTILE', 'SMALL_MISSILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
      makeBlock('Behavior', 'MissileAIUpdate ModuleTag_MissileAI', {
        TryToFollowTarget: 'Yes',
        InitialVelocity: 6,
        DistanceToTravelBeforeTurning: 0,
        DistanceToTargetForLock: 8,
        FuelLifetime: 5000,
        IgnitionDelay: 0,
      }),
    ]);
    const weaponDef = makeWeaponDef('HomingMissileWeapon', {
      PrimaryDamage: 80,
      PrimaryDamageRadius: 0,
      AttackRange: 300,
      WeaponSpeed: 6,
      DelayBetweenShots: 9999,
      ProjectileObject: 'HomingMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('HomingAttacker', 0, 0),
      makeMapObject('MovingTarget', 6, 0),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
    logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: 60, targetZ: 60 });

    for (let i = 0; i < 45; i++) {
      logic.update(1 / 30);
    }

    const target = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'MovingTarget',
    );
    expect(target.health).toBeLessThan(200);
  });

  it('keeps MissileAI projectiles unarmed during ignition delay so early collisions are ignored', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const attackerDef = makeObjectDef('DelayedMissileAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'DelayedMissileWeapon'] }),
    ]);
    const blockerDef = makeObjectDef('IgnitionDelayBlocker', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 4, GeometryMinorRadius: 4 });
    const targetDef = makeObjectDef('IgnitionDelayTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);
    const projectileDef = makeObjectDef('DelayedMissileProjectile', 'Neutral', ['PROJECTILE', 'SMALL_MISSILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
      makeBlock('Behavior', 'MissileAIUpdate ModuleTag_MissileAI', {
        TryToFollowTarget: 'Yes',
        InitialVelocity: 4,
        IgnitionDelay: 1000, // ~30 frames
        DistanceToTravelBeforeTurning: 0,
        DistanceToTargetForLock: 8,
        FuelLifetime: 5000,
      }),
    ]);
    const weaponDef = makeWeaponDef('DelayedMissileWeapon', {
      PrimaryDamage: 80,
      PrimaryDamageRadius: 0,
      AttackRange: 300,
      WeaponSpeed: 4,
      DelayBetweenShots: 9999,
      ProjectileObject: 'DelayedMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, blockerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('DelayedMissileAttacker', 0, 0),
      makeMapObject('IgnitionDelayBlocker', 1, 0),
      makeMapObject('IgnitionDelayTarget', 8, 0),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });

    for (let i = 0; i < 20; i++) {
      logic.update(1 / 30);
    }

    const blocker = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'IgnitionDelayBlocker',
    );
    expect(blocker.health).toBe(200);
  });

  it('detonates MissileAI projectiles on fuel expiry when DetonateOnNoFuel is enabled', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const attackerDef = makeObjectDef('FuelLimitedAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'FuelLimitedMissileWeapon'] }),
    ]);
    const targetDef = makeObjectDef('FuelLimitedTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);
    const projectileDef = makeObjectDef('FuelLimitedMissileProjectile', 'Neutral', ['PROJECTILE', 'SMALL_MISSILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
      makeBlock('Behavior', 'MissileAIUpdate ModuleTag_MissileAI', {
        TryToFollowTarget: 'Yes',
        InitialVelocity: 6,
        FuelLifetime: 100, // ~3 frames
        DetonateOnNoFuel: 'Yes',
        IgnitionDelay: 0,
        DistanceToTravelBeforeTurning: 0,
        DistanceToTargetForLock: 1,
      }),
    ]);
    const weaponDef = makeWeaponDef('FuelLimitedMissileWeapon', {
      PrimaryDamage: 80,
      PrimaryDamageRadius: 0,
      AttackRange: 400,
      WeaponSpeed: 6,
      DelayBetweenShots: 9999,
      ProjectileObject: 'FuelLimitedMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('FuelLimitedAttacker', 0, 0),
      makeMapObject('FuelLimitedTarget', 200, 0),
    ], 256, 256);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    for (let i = 0; i < 25; i++) {
      logic.update(1 / 30);
    }

    const target = [...(logic as any).spawnedEntities.values()].find(
      (e: any) => e.templateName === 'FuelLimitedTarget',
    );
    expect(target.health).toBe(200);
  });

  it('uses lock approach height and enters KILL state for non-tracking MissileAI shots', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const attackerDef = makeObjectDef('LockDiveAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'LockDiveMissileWeapon'] }),
    ]);
    const targetDef = makeObjectDef('LockDiveTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const projectileDef = makeObjectDef('LockDiveMissileProjectile', 'Neutral', ['PROJECTILE', 'SMALL_MISSILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
      makeBlock('Behavior', 'MissileAIUpdate ModuleTag_MissileAI', {
        TryToFollowTarget: 'No',
        InitialVelocity: 6,
        IgnitionDelay: 1000,
        DistanceToTravelBeforeTurning: 0,
        DistanceToTargetForLock: 20,
        FuelLifetime: 8000,
      }),
    ]);
    const weaponDef = makeWeaponDef('LockDiveMissileWeapon', {
      PrimaryDamage: 50,
      PrimaryDamageRadius: 0,
      AttackRange: 500,
      WeaponSpeed: 6,
      DelayBetweenShots: 9999,
      ProjectileObject: 'LockDiveMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('LockDiveAttacker', 0, 0),
      makeMapObject('LockDiveTarget', 180, 0),
    ], 256, 256);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        attackWeapon: unknown;
      }>;
      queueWeaponDamageEvent: (
        attacker: { attackWeapon: unknown },
        target: unknown,
        weapon: unknown,
      ) => void;
      frameCounter: number;
      updateMissileAIEvents: () => void;
      pendingWeaponDamageEvents: Array<{
        missileAIState: {
          state: string;
          trackingTarget: boolean;
          targetY: number;
          originalTargetY: number;
        } | null;
      }>;
    };
    const findMissileEvent = () =>
      privateApi.pendingWeaponDamageEvents.find((event) => event.missileAIState !== null);

    const attacker = privateApi.spawnedEntities.get(1);
    const target = privateApi.spawnedEntities.get(2);
    if (!attacker || !target || !attacker.attackWeapon) {
      throw new Error('Expected attacker/target with attack weapon');
    }
    privateApi.queueWeaponDamageEvent(attacker, target, attacker.attackWeapon);

    const initialEvent = findMissileEvent();
    expect(initialEvent).toBeDefined();
    const initialState = initialEvent?.missileAIState;
    expect(initialState?.trackingTarget).toBe(false);
    expect(initialState?.targetY ?? 0).toBeGreaterThan(initialState?.originalTargetY ?? 0);

    let sawKillState = false;
    for (let i = 0; i < 220; i++) {
      privateApi.frameCounter += 1;
      privateApi.updateMissileAIEvents();
      const event = findMissileEvent();
      if (!event || !event.missileAIState) {
        break;
      }
      if (event.missileAIState.state === 'KILL') {
        sawKillState = true;
        expect(event.missileAIState.targetY).toBeCloseTo(event.missileAIState.originalTargetY, 5);
        break;
      }
    }

    expect(sawKillState).toBe(true);
  });

  it('enters KILL_SELF when a tracking MissileAI target disappears and tears down without impact FX', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const attackerDef = makeObjectDef('LostTargetAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'LostTargetMissileWeapon'] }),
    ]);
    const targetDef = makeObjectDef('LostTargetVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);
    const projectileDef = makeObjectDef('LostTargetMissileProjectile', 'Neutral', ['PROJECTILE', 'SMALL_MISSILE'], [
      makeBlock('Body', 'InactiveBody ModuleTag_Body', {}),
      makeBlock('Behavior', 'MissileAIUpdate ModuleTag_MissileAI', {
        TryToFollowTarget: 'Yes',
        InitialVelocity: 6,
        IgnitionDelay: 0,
        FuelLifetime: 8000,
        KillSelfDelay: 100, // ~3 frames
        DistanceToTravelBeforeTurning: 0,
        DistanceToTargetForLock: 0,
      }),
    ]);
    const weaponDef = makeWeaponDef('LostTargetMissileWeapon', {
      PrimaryDamage: 100,
      PrimaryDamageRadius: 10,
      AttackRange: 800,
      WeaponSpeed: 6,
      DelayBetweenShots: 9999,
      ProjectileObject: 'LostTargetMissileProjectile',
      ProjectileCollidesWith: 'ENEMIES',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, targetDef, projectileDef],
      weapons: [weaponDef],
    }));
    const map = makeMap([
      makeMapObject('LostTargetAttacker', 0, 0),
      makeMapObject('LostTargetVictim', 350, 0),
    ], 512, 512);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const privateApi = logic as unknown as {
      frameCounter: number;
      spawnedEntities: Map<number, {
        attackWeapon: unknown;
        destroyed: boolean;
      }>;
      queueWeaponDamageEvent: (
        attacker: { attackWeapon: unknown },
        target: unknown,
        weapon: unknown,
      ) => void;
      updateMissileAIEvents: () => void;
      updatePendingWeaponDamage: () => void;
      pendingWeaponDamageEvents: Array<{
        executeFrame: number;
        suppressImpactVisual: boolean;
        missileAIProfile: { killSelfDelayFrames: number } | null;
        missileAIState: { state: string } | null;
      }>;
      visualEventBuffer: Array<{ type: string }>;
    };
    const findMissileEvent = () =>
      privateApi.pendingWeaponDamageEvents.find((event) => event.missileAIState !== null);

    const attacker = privateApi.spawnedEntities.get(1);
    const target = privateApi.spawnedEntities.get(2);
    if (!attacker || !target || !attacker.attackWeapon) {
      throw new Error('Expected attacker/target with attack weapon');
    }

    privateApi.queueWeaponDamageEvent(attacker, target, attacker.attackWeapon);
    const event = findMissileEvent();
    expect(event).toBeDefined();

    // Simulate tracked target disappearing mid-flight.
    target.destroyed = true;

    privateApi.frameCounter += 1;
    privateApi.updateMissileAIEvents();

    expect(event?.missileAIState?.state).toBe('KILL_SELF');
    expect(event?.suppressImpactVisual).toBe(true);
    const killDelayFrames = event?.missileAIProfile?.killSelfDelayFrames ?? 0;
    expect(killDelayFrames).toBeGreaterThan(0);

    for (let i = 0; i < killDelayFrames - 1; i++) {
      privateApi.frameCounter += 1;
      privateApi.updateMissileAIEvents();
      expect(event?.executeFrame).toBe(Number.MAX_SAFE_INTEGER);
    }

    privateApi.frameCounter += 1;
    privateApi.updateMissileAIEvents();
    expect(event?.executeFrame).toBe(privateApi.frameCounter);

    privateApi.visualEventBuffer.length = 0;
    privateApi.updatePendingWeaponDamage();
    const impactFx = privateApi.visualEventBuffer.find((entry) => entry.type === 'WEAPON_IMPACT');
    expect(impactFx).toBeUndefined();
  });

  it('keeps DamageDealtAtSelfPosition anchored at source even when ScatterTarget offsets are present', () => {
    const withoutScatterTarget = runDamageAtSelfScatterTargetTimeline(false);
    expect(withoutScatterTarget.targetHealthTimeline).toEqual([150, 150, 150, 150]);
    expect(withoutScatterTarget.nearEnemyHealthTimeline).toEqual([110, 110, 110, 110]);

    const withScatterTarget = runDamageAtSelfScatterTargetTimeline(true);
    expect(withScatterTarget.targetHealthTimeline).toEqual([150, 150, 150, 150]);
    expect(withScatterTarget.nearEnemyHealthTimeline).toEqual([110, 110, 110, 110]);
  });

  it('enforces MaxSimultaneousOfType using existing and queued units', () => {
    const timeline = runMaxSimultaneousTimeline();
    expect(timeline.credits).toEqual([900, 900, 900, 900]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0]);
    expect(timeline.unitCounts).toEqual([1, 1, 2, 2]);
  });

  it('keeps MaxSimultaneous rejection credit behavior deterministic across repeated runs', () => {
    const first = runMaxSimultaneousTimeline();
    const second = runMaxSimultaneousTimeline();
    expect(first).toEqual(second);
  });

  it('treats build variations as equivalent for MaxSimultaneousOfType gating', () => {
    const timeline = runMaxSimEquivalentVariationTimeline();
    expect(timeline.credits).toEqual([500, 500, 500]);
    expect(timeline.queueCounts).toEqual([0, 0, 0]);
    expect(timeline.baseCounts).toEqual([0, 0, 0]);
    expect(timeline.variationCounts).toEqual([1, 1, 1]);
  });

  it('treats build variations as equivalent for prerequisite ownership checks', () => {
    const timeline = runPrerequisiteEquivalentVariationTimeline();
    expect(timeline.credits).toEqual([380, 380, 380, 380]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0]);
    expect(timeline.producedCounts).toEqual([0, 0, 1, 1]);
  });

  it('treats build variations as equivalent for QuantityModifier production count', () => {
    const timeline = runQuantityModifierEquivalentVariationTimeline();
    expect(timeline.credits).toEqual([410, 410, 410, 410, 410]);
    expect(timeline.queueCounts).toEqual([1, 1, 0, 0, 0]);
    expect(timeline.baseCounts).toEqual([0, 0, 0, 0, 0]);
    expect(timeline.variationCounts).toEqual([0, 0, 2, 2, 2]);
  });

  it('keeps build-variation equivalence production behavior deterministic across repeated runs', () => {
    const first = {
      maxSim: runMaxSimEquivalentVariationTimeline(),
      prereq: runPrerequisiteEquivalentVariationTimeline(),
      quantity: runQuantityModifierEquivalentVariationTimeline(),
    };
    const second = {
      maxSim: runMaxSimEquivalentVariationTimeline(),
      prereq: runPrerequisiteEquivalentVariationTimeline(),
      quantity: runQuantityModifierEquivalentVariationTimeline(),
    };
    expect(first).toEqual(second);
  });

  it('enforces MaxSimultaneousOfType across producers on the same side', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
          }),
        ]),
        makeObjectDef('CappedUnit', 'America', ['VEHICLE'], [], {
          BuildTime: 0.2,
          BuildCost: 100,
          MaxSimultaneousOfType: 1,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('WarFactory', 8, 8), makeMapObject('WarFactory', 20, 8)]),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'CappedUnit' });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 2, unitTemplateName: 'CappedUnit' });
    logic.update(1 / 30);

    expect(logic.getSideCredits('America')).toBe(900);
    expect(logic.getProductionState(1)?.queueEntryCount).toBe(1);
    expect(logic.getProductionState(2)?.queueEntryCount).toBe(0);
  });

  it('enforces AND/OR object prerequisites before queueing production', () => {
    const blockedNoTech = runPrerequisiteTimeline(true, false);
    expect(blockedNoTech.credits).toEqual([1000, 1000, 1000, 1000]);
    expect(blockedNoTech.queueCounts).toEqual([0, 0, 0, 0]);
    expect(blockedNoTech.producedCounts).toEqual([0, 0, 0, 0]);

    const blockedNoPower = runPrerequisiteTimeline(false, true);
    expect(blockedNoPower.credits).toEqual([1000, 1000, 1000, 1000]);
    expect(blockedNoPower.queueCounts).toEqual([0, 0, 0, 0]);
    expect(blockedNoPower.producedCounts).toEqual([0, 0, 0, 0]);

    const allowed = runPrerequisiteTimeline(true, true);
    expect(allowed.credits).toEqual([850, 850, 850, 850]);
    expect(allowed.queueCounts).toEqual([1, 1, 0, 0]);
    expect(allowed.producedCounts).toEqual([0, 0, 1, 1]);
  });

  it('enforces Science prerequisites and unlocks production after grantSideScience', () => {
    const timeline = runSciencePrerequisiteTimeline({ grantAtFrame: 1 });
    expect(timeline.credits).toEqual([500, 350, 350, 350, 350]);
    expect(timeline.queueCounts).toEqual([0, 1, 1, 0, 0]);
    expect(timeline.producedCounts).toEqual([0, 0, 0, 1, 1]);
    expect(timeline.scienceCounts).toEqual([0, 1, 1, 1, 1]);
  });

  it('rejects granting non-grantable sciences and keeps science-gated production blocked', () => {
    const timeline = runSciencePrerequisiteTimeline({ grantAtFrame: 1, scienceGrantable: false });
    expect(timeline.credits).toEqual([500, 500, 500, 500, 500]);
    expect(timeline.queueCounts).toEqual([0, 0, 0, 0, 0]);
    expect(timeline.producedCounts).toEqual([0, 0, 0, 0, 0]);
    expect(timeline.scienceCounts).toEqual([0, 0, 0, 0, 0]);
  });

  it('keeps science-prerequisite unlock timing deterministic across repeated runs', () => {
    const first = runSciencePrerequisiteTimeline({ grantAtFrame: 1 });
    const second = runSciencePrerequisiteTimeline({ grantAtFrame: 1 });
    expect(first).toEqual(second);
  });

  it('enforces Buildable=Only_By_AI against side player type', () => {
    const humanTimeline = runOnlyByAiBuildableTimeline('HUMAN');
    expect(humanTimeline.credits).toEqual([500, 500, 500, 500]);
    expect(humanTimeline.queueCounts).toEqual([0, 0, 0, 0]);
    expect(humanTimeline.producedCounts).toEqual([0, 0, 0, 0]);

    const computerTimeline = runOnlyByAiBuildableTimeline('COMPUTER');
    expect(computerTimeline.credits).toEqual([400, 400, 400, 400]);
    expect(computerTimeline.queueCounts).toEqual([1, 1, 0, 0]);
    expect(computerTimeline.producedCounts).toEqual([0, 0, 1, 1]);
  });

  it('keeps Buildable=Only_By_AI queue gating deterministic across repeated runs', () => {
    const first = runOnlyByAiBuildableTimeline('COMPUTER');
    const second = runOnlyByAiBuildableTimeline('COMPUTER');
    expect(first).toEqual(second);
  });

  it('enforces MaxSimultaneousLinkKey counts for max-sim production gating', () => {
    const timeline = runMaxSimultaneousLinkKeyTimeline();
    expect(timeline.credits).toEqual([500, 500, 500, 500]);
    expect(timeline.queueCounts).toEqual([0, 0, 0, 0]);
    expect(timeline.alphaCounts).toEqual([1, 1, 1, 1]);
    expect(timeline.bravoCounts).toEqual([0, 0, 0, 0]);
  });

  it('keeps MaxSimultaneousLinkKey max-sim gating deterministic across repeated runs', () => {
    const first = runMaxSimultaneousLinkKeyTimeline();
    const second = runMaxSimultaneousLinkKeyTimeline();
    expect(first).toEqual(second);
  });

  it('honors Buildable=Ignore_Prerequisites while preserving deterministic timing', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
            ExitDelay: 0,
          }),
        ]),
        makeObjectDef('IgnorePrereqUnit', 'America', ['VEHICLE'], [
          makeBlock('Prerequisite', 'Object MissingTech', {}),
        ], {
          Buildable: 'Ignore_Prerequisites',
          BuildTime: 0.1,
          BuildCost: 120,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 10, 10)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'IgnorePrereqUnit' });

    const queueCounts: number[] = [];
    const producedCounts: number[] = [];
    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
      queueCounts.push(logic.getProductionState(1)?.queueEntryCount ?? 0);
      producedCounts.push(logic.getEntityIdsByTemplate('IgnorePrereqUnit').length);
    }

    expect(logic.getSideCredits('America')).toBe(380);
    expect(queueCounts).toEqual([1, 1, 0, 0]);
    expect(producedCounts).toEqual([0, 0, 1, 1]);
  });

  it('rejects queueUnitProduction when command-set buttons do not expose the requested template', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
            ExitDelay: 0,
          }),
        ], {
          CommandSet: 'CommandSet_WarFactory',
        }),
        makeObjectDef('AllowedUnit', 'America', ['VEHICLE'], [], {
          BuildCost: 100,
          BuildTime: 0.1,
        }),
        makeObjectDef('BlockedUnit', 'America', ['VEHICLE'], [], {
          BuildCost: 100,
          BuildTime: 0.1,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_AllowedUnit', {
          Command: 'UNIT_BUILD',
          Object: 'AllowedUnit',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_WarFactory', {
          1: 'Command_AllowedUnit',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 12, 12)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BlockedUnit' });
    logic.update(1 / 30);

    expect(logic.getProductionState(1)?.queueEntryCount ?? 0).toBe(0);
    expect(logic.getEntityIdsByTemplate('BlockedUnit')).toEqual([]);
    expect(logic.getSideCredits('America')).toBe(500);
  });

  it('rejects queueUnitProduction when the producer is SCRIPT_DISABLED', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
            ExitDelay: 0,
          }),
        ], {
          CommandSet: 'CommandSet_WarFactory',
        }),
        makeObjectDef('AllowedUnit', 'America', ['VEHICLE'], [], {
          BuildCost: 100,
          BuildTime: 0.1,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_AllowedUnit', {
          Command: 'UNIT_BUILD',
          Object: 'AllowedUnit',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_WarFactory', {
          1: 'Command_AllowedUnit',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('WarFactory', 12, 12)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });

    const internalProducer = (
      logic as unknown as {
        spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
      }
    ).spawnedEntities.get(1);
    expect(internalProducer).toBeDefined();
    internalProducer!.objectStatusFlags.add('SCRIPT_DISABLED');

    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'AllowedUnit' });
    logic.update(1 / 30);

    expect(logic.getProductionState(1)?.queueEntryCount ?? 0).toBe(0);
    expect(logic.getEntityIdsByTemplate('AllowedUnit')).toEqual([]);
    expect(logic.getSideCredits('America')).toBe(500);
  });

  it('refunds all queued unit production when a producer dies before completion', () => {
    const timeline = runProducerDeathUnitRefundTimeline();
    expect(timeline.credits).toEqual([500, 500, 500]);
    expect(timeline.alive).toEqual([false, false, false]);
    expect(timeline.producedCounts).toEqual([0, 0, 0]);
  });

  it('refunds queued player upgrades and clears in-production state when a producer dies', () => {
    const timeline = runProducerDeathUpgradeRefundTimeline();
    expect(timeline.credits).toEqual([500, 500, 500]);
    expect(timeline.inProductionCounts).toEqual([0, 0, 0]);
    expect(timeline.completedCounts).toEqual([0, 0, 0]);
  });

  it('keeps producer-death refund behavior deterministic across repeated runs', () => {
    const first = runProducerDeathUnitRefundTimeline();
    const second = runProducerDeathUnitRefundTimeline();
    expect(first).toEqual(second);
  });

  it('routes constructBuilding commands through dozer placement and cost spending', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], []),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Dozer', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    expect(logic.getSideCredits('America')).toBe(300);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([2]);
  });

  it('keeps dozer construction task on AI move commands and cancels it on player move commands', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], []),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          BuildTime: 10,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 8, 8)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [40, 0, 40],
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(0);

    const privateApi = logic as unknown as {
      pendingConstructionActions: Map<number, number>;
      spawnedEntities: Map<number, { builderId: number; destroyed: boolean }>;
    };

    const buildingId = privateApi.pendingConstructionActions.get(1);
    expect(buildingId).toBeDefined();
    expect(privateApi.spawnedEntities.get(buildingId!)?.builderId).toBe(1);

    logic.submitCommand({
      type: 'moveTo',
      entityId: 1,
      targetX: 50,
      targetZ: 50,
      commandSource: 'AI',
    });
    logic.update(0);

    expect(privateApi.pendingConstructionActions.get(1)).toBe(buildingId);
    expect(privateApi.spawnedEntities.get(buildingId!)?.builderId).toBe(1);

    logic.submitCommand({
      type: 'moveTo',
      entityId: 1,
      targetX: 60,
      targetZ: 60,
      commandSource: 'PLAYER',
    });
    logic.update(0);

    expect(privateApi.pendingConstructionActions.has(1)).toBe(false);
    expect(privateApi.spawnedEntities.get(buildingId!)?.builderId).toBe(0);
  });

  it('rejects constructBuilding when dozer command-set buttons do not expose the template', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          CommandSet: 'CommandSet_Dozer',
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
        }),
        makeObjectDef('Barracks', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ConstructBarracks', {
          Command: 'DOZER_CONSTRUCT',
          Object: 'Barracks',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_Dozer', {
          1: 'Command_ConstructBarracks',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Dozer', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    expect(logic.getSideCredits('America')).toBe(500);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([]);
  });

  it('clears removable blockers when constructing over them', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('Shrubbery', 'America', ['SHRUBBERY'], [], {
          GeometryMajorRadius: 4,
          GeometryMinorRadius: 4,
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 8, 8), makeMapObject('Shrubbery', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    expect(logic.getEntityIdsByTemplate('Shrubbery')).toEqual([]);
    expect(logic.getSideCredits('America')).toBe(300);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([3]);
  });

  it('moves allied mobile blockers instead of failing construction on overlap', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('AllyCarrier', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], {
          BuildCost: 0,
          GeometryMajorRadius: 4,
          GeometryMinorRadius: 4,
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 8, 8), makeMapObject('AllyCarrier', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    const ally = (
      logic as unknown as {
        spawnedEntities: Map<number, { destroyed: boolean; moving: boolean }>;
      }
    ).spawnedEntities.get(2);
    expect(ally).toBeDefined();
    expect(ally!.destroyed).toBe(false);
    expect(ally!.moving).toBe(true);
    expect(logic.getSideCredits('America')).toBe(300);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([3]);
  });

  it('fails construction when blocked by enemy or immobile objects', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('EnemyBunker', 'China', ['STRUCTURE', 'IMMOBILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], {
          BuildCost: 0,
          GeometryMajorRadius: 4,
          GeometryMinorRadius: 4,
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 8, 8), makeMapObject('EnemyBunker', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    expect(logic.getSideCredits('America')).toBe(500);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([]);
  });

  it('rejects construction on water terrain cells', () => {
    const sz = 32;
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Water area covers cells (10,10) to (25,25) in world units (100-250).
    const mapData: MapDataJSON = {
      heightmap: {
        width: sz,
        height: sz,
        borderSize: 0,
        data: uint8ArrayToBase64(new Uint8Array(sz * sz).fill(0)),
      },
      objects: [makeMapObject('Dozer', 5, 5)],
      triggers: [{
        name: 'WaterArea',
        id: 1,
        isWaterArea: true,
        isRiver: false,
        points: [
          { x: 100, y: 100 },
          { x: 250, y: 100 },
          { x: 250, y: 250 },
          { x: 100, y: 250 },
        ],
      }],
      textureClasses: [],
      blendTileCount: 0,
    };

    const heightmap = HeightmapGrid.fromJSON(mapData.heightmap);
    logic.loadMapObjects(mapData, makeRegistry(bundle), heightmap);

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    // Try to build in the water area.
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [150, 0, 150],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    // Construction should fail  water cells block placement.
    expect(logic.getSideCredits('America')).toBe(1000);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([]);
  });

  it('rejects construction on cliff terrain cells', () => {
    const sz = 32;
    // Create a heightmap with a cliff in the middle (rows 14-16 have height 200).
    const heightData = new Uint8Array(sz * sz).fill(0);
    for (let z = 14; z <= 16; z++) {
      for (let x = 0; x < sz; x++) {
        // Height value 200  world height = 200 * MAP_HEIGHT_SCALE = 200 * 0.625 = 125
        // vs 0 height for surrounding cells. Delta = 125 >> CLIFF_HEIGHT_DELTA(9.8).
        heightData[z * sz + x] = 200;
      }
    }

    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const mapData: MapDataJSON = {
      heightmap: {
        width: sz,
        height: sz,
        borderSize: 0,
        data: uint8ArrayToBase64(heightData),
      },
      objects: [makeMapObject('Dozer', 5, 5)],
      triggers: [],
      textureClasses: [],
      blendTileCount: 0,
    };

    const heightmap = HeightmapGrid.fromJSON(mapData.heightmap);
    logic.loadMapObjects(mapData, makeRegistry(bundle), heightmap);

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    // Try to build at the cliff edge (row ~14-15, world z  140-150).
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [100, 0, 145],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    // Construction should fail  cliff terrain blocks placement.
    expect(logic.getSideCredits('America')).toBe(1000);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America')).toEqual([]);
  });

  it('allows construction on flat valid terrain', () => {
    const sz = 32;
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [], {
          BuildCost: 200,
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const mapData: MapDataJSON = {
      heightmap: {
        width: sz,
        height: sz,
        borderSize: 0,
        data: uint8ArrayToBase64(new Uint8Array(sz * sz).fill(0)),
      },
      objects: [makeMapObject('Dozer', 5, 5)],
      triggers: [],
      textureClasses: [],
      blendTileCount: 0,
    };

    const heightmap = HeightmapGrid.fromJSON(mapData.heightmap);
    logic.loadMapObjects(mapData, makeRegistry(bundle), heightmap);

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    // Build on flat terrain away from map edges.
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PowerPlant',
      targetPosition: [150, 0, 150],
      angle: 0,
      lineEndPosition: null,
    });

    logic.update(1 / 30);

    // Construction should succeed  flat terrain, no obstacles.
    expect(logic.getSideCredits('America')).toBe(800);
    expect(logic.getEntityIdsByTemplateAndSide('PowerPlant', 'America').length).toBe(1);
  });

  it('continues line-building after blocked first tile', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['VEHICLE', 'DOZER'], [], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('EnemyBunker', 'China', ['STRUCTURE', 'IMMOBILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], {
          BuildCost: 0,
          GeometryMajorRadius: 1,
          GeometryMinorRadius: 1,
        }),
        makeObjectDef('LineWall', 'America', ['STRUCTURE', 'LINEBUILD'], [], {
          BuildCost: 50,
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 8, 8), makeMapObject('EnemyBunker', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'LineWall',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: [40, 0, 20],
    });

    logic.update(1 / 30);

    const wallIds = logic.getEntityIdsByTemplateAndSide('LineWall', 'America');
    expect(wallIds).toHaveLength(1);
    const firstWall = (
      logic as unknown as {
        spawnedEntities: Map<number, { x: number }>;
      }
    ).spawnedEntities.get(wallIds[0]!);
    expect(firstWall?.x).toBeGreaterThan(20);
    expect(logic.getSideCredits('America')).toBe(450);
  });

  it('runs sell command teardown and refunds structure value after sell timer completes', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE'], [], {
          BuildCost: 300,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('CommandCenter', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.submitCommand({ type: 'sell', entityId: 1 });

    for (let frame = 0; frame < 190; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getEntityState(1)).toBeNull();
    expect(logic.getSideCredits('America')).toBe(300);
  });

  it('uses configured sell percentage when fallbacking RefundValue', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE'], [], {
          BuildCost: 300,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { sellPercentage: 0.5 });
    logic.loadMapObjects(makeMap([makeMapObject('CommandCenter', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.submitCommand({ type: 'sell', entityId: 1 });

    for (let frame = 0; frame < 190; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getEntityState(1)).toBeNull();
    expect(logic.getSideCredits('America')).toBe(150);
  });

  it('prefers RefundValue over sell percentage when computing sell refunds', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE'], [], {
          BuildCost: 300,
          RefundValue: 275,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { sellPercentage: 0.1 });
    logic.loadMapObjects(makeMap([makeMapObject('CommandCenter', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.submitCommand({ type: 'sell', entityId: 1 });

    for (let frame = 0; frame < 190; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getEntityState(1)).toBeNull();
    expect(logic.getSideCredits('America')).toBe(275);
  });

  it('skips PowerPlantUpgrade side effects while the source object is disabled', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Behavior', 'PowerPlantUpgrade ModuleTag_Power', {
            TriggeredBy: 'Upgrade_Power',
          }),
        ], {
          EnergyBonus: 12,
        }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_Power', {
          Type: 'OBJECT',
          BuildTime: 0.1,
          BuildCost: 0,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('PowerPlant', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

    const logicWithPrivateAccess = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const building = logicWithPrivateAccess.spawnedEntities.get(1);
    expect(building).toBeDefined();
    building!.objectStatusFlags.add('DISABLED_HACKED');

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Power' });
    logic.update(1 / 30);

    expect(logic.getSidePowerState('America').powerBonus).toBe(0);
  });

  it('skips RadarUpgrade side effects while the source object is disabled', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('RadarPlant', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'RadarUpgrade ModuleTag_Radar', {
            TriggeredBy: 'Upgrade_Radar',
            DisableProof: true,
          }),
        ]),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_Radar', {
          Type: 'OBJECT',
          BuildTime: 0.1,
          BuildCost: 0,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('RadarPlant', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

    const logicWithPrivateAccess = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const building = logicWithPrivateAccess.spawnedEntities.get(1);
    expect(building).toBeDefined();
    building!.objectStatusFlags.add('DISABLED_HACKED');

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Radar' });
    logic.update(1 / 30);

    expect(logic.getSideRadarState('America')).toEqual({
      radarCount: 0,
      disableProofRadarCount: 0,
      radarDisabled: false,
    });
  });

  it('keeps disabled capture source upgrade side effects on the original side', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UpgradeHub', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'PowerPlantUpgrade ModuleTag_Power', {
            TriggeredBy: 'Upgrade_Power',
          }),
          makeBlock('Behavior', 'RadarUpgrade ModuleTag_Radar', {
            TriggeredBy: 'Upgrade_Radar',
            DisableProof: true,
          }),
        ], {
          EnergyBonus: 10,
        }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_Power', {
          Type: 'OBJECT',
          BuildTime: 0.1,
          BuildCost: 0,
        }),
        makeUpgradeDef('Upgrade_Radar', {
          Type: 'OBJECT',
          BuildTime: 0.1,
          BuildCost: 0,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('UpgradeHub', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Power' });
    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Radar' });
    logic.update(1 / 30);
    expect(logic.getSidePowerState('America').powerBonus).toBe(10);
    expect(logic.getSideRadarState('America')).toEqual({
      radarCount: 1,
      disableProofRadarCount: 1,
      radarDisabled: false,
    });

    const logicWithPrivateAccess = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const building = logicWithPrivateAccess.spawnedEntities.get(1);
    expect(building).toBeDefined();
    building!.objectStatusFlags.add('DISABLED_HACKED');

    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'China' });
    logic.update(1 / 30);

    expect(logic.getEntityIdsByTemplateAndSide('UpgradeHub', 'China')).toEqual([1]);
    expect(logic.getSidePowerState('America').powerBonus).toBe(10);
    expect(logic.getSideRadarState('America')).toEqual({
      radarCount: 1,
      disableProofRadarCount: 1,
      radarDisabled: false,
    });
    expect(logic.getSidePowerState('China').powerBonus).toBe(0);
    expect(logic.getSideRadarState('China')).toEqual({
      radarCount: 0,
      disableProofRadarCount: 0,
      radarDisabled: false,
    });
  });

  it('toggles overcharge state, drains health, and auto-disables below threshold', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OverchargePlant', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'OverchargeBehavior ModuleTag_Overcharge', {
            HealthPercentToDrainPerSecond: '50%',
            NotAllowedWhenHealthBelowPercent: '50%',
          }),
        ], {
          EnergyBonus: 10,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('OverchargePlant', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));

    logic.submitCommand({ type: 'toggleOvercharge', entityId: 1 });
    logic.update(1 / 30);
    expect(logic.getSidePowerState('America').powerBonus).toBe(10);

    for (let frame = 0; frame < 40; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getEntityState(1)?.health ?? 0).toBeLessThan(50);
    expect(logic.getSidePowerState('America').powerBonus).toBe(0);

    logic.submitCommand({ type: 'toggleOvercharge', entityId: 1 });
    logic.update(1 / 30);
    expect(logic.getSidePowerState('America').powerBonus).toBe(0);
  });

  it('places and deletes owned beacons through command paths', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericaBeacon', 'America', ['STRUCTURE', 'BEACON'], []),
      ],
      factions: [
        {
          name: 'FactionAmerica',
          side: 'America',
          fields: {
            BeaconName: 'AmericaBeacon',
          },
        },
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.setPlayerSide(0, 'America');

    logic.submitCommand({
      type: 'placeBeacon',
      targetPosition: [20, 0, 20],
    });
    logic.update(1 / 30);

    const beaconId = logic.getEntityIdsByTemplateAndSide('AmericaBeacon', 'America')[0];
    expect(beaconId).toBeDefined();
    expect(logic.getEntityState(beaconId!)).not.toBeNull();

    logic.submitCommand({
      type: 'beaconDelete',
      entityId: beaconId!,
    });
    logic.update(1 / 30);

    expect(logic.getEntityState(beaconId!)).toBeNull();
  });

  it('resolves enterObject hijack actions by transferring target ownership and consuming source unit', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hijacker', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
        ]),
        makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], []),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Hijacker', 8, 8), makeMapObject('EnemyVehicle', 10, 8)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'hijackVehicle',
    });

    logic.update(1 / 30);

    expect(logic.getEntityState(1)).toBeNull();
    expect(logic.getEntityIdsByTemplateAndSide('EnemyVehicle', 'America')).toEqual([2]);
  });

  it('rejects invalid enterObject hijack actions at command issue time', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hijacker', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
          makeBlock('LocomotorSet', 'SET_NORMAL FastLocomotor', {}),
        ]),
        makeObjectDef('FriendlyVehicle', 'America', ['VEHICLE'], []),
      ],
      locomotors: [
        makeLocomotorDef('FastLocomotor', 120),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Hijacker', 8, 8), makeMapObject('FriendlyVehicle', 30, 8)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'hijackVehicle',
    });

    for (let frame = 0; frame < 20; frame += 1) {
      logic.update(1 / 30);
    }

    const hijacker = logic.getEntityState(1);
    const target = logic.getEntityState(2);
    expect(hijacker).not.toBeNull();
    expect(target).not.toBeNull();
    expect(hijacker!.x).toBeCloseTo(8, 1);
    expect(target!.statusFlags).not.toContain('HIJACKED');
    expect(logic.getEntityIdsByTemplateAndSide('FriendlyVehicle', 'America')).toEqual([2]);
  });

  it('starts HackInternet command loops and deposits periodic side credits', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InternetHacker', 'China', ['INFANTRY'], [
          makeBlock('Behavior', 'HackInternetAIUpdate ModuleTag_Hack', {
            UnpackTime: 0,
            CashUpdateDelay: 0,
            RegularCashAmount: 25,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('InternetHacker', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 0 });
    logic.submitCommand({ type: 'hackInternet', entityId: 1 });

    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getSideCredits('China')).toBe(75);
  });

  it('allows HackInternet on non-mobile objects', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InternetCenter', 'China', ['STRUCTURE'], [
          makeBlock('Behavior', 'HackInternetAIUpdate ModuleTag_Hack', {
            UnpackTime: 0,
            CashUpdateDelay: 0,
            RegularCashAmount: 30,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('InternetCenter', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 0 });
    logic.submitCommand({ type: 'hackInternet', entityId: 1 });

    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getSideCredits('China')).toBe(90);
  });

  it('defers commands during HackInternet pack-up and executes them after PackTime', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InternetHacker', 'China', ['INFANTRY'], [
          makeBlock('Behavior', 'HackInternetAIUpdate ModuleTag_Hack', {
            UnpackTime: 0,
            PackTime: 1000,
            CashUpdateDelay: 0,
            RegularCashAmount: 25,
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL HackerLocomotor', {}),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('HackerLocomotor', 60),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('InternetHacker', 8, 8)], 64, 64), makeRegistry(bundle), makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 0 });
    logic.submitCommand({ type: 'hackInternet', entityId: 1 });

    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
    }
    expect(logic.getSideCredits('China')).toBe(75);

    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 120, targetZ: 8 });
    for (let frame = 0; frame < 20; frame += 1) {
      logic.update(1 / 30);
    }

    const duringPack = logic.getEntityState(1);
    expect(duringPack).not.toBeNull();
    expect(duringPack!.x).toBeCloseTo(8, 1);
    expect(logic.getSideCredits('China')).toBe(75);

    for (let frame = 0; frame < 25; frame += 1) {
      logic.update(1 / 30);
    }
    const afterPack = logic.getEntityState(1);
    expect(afterPack).not.toBeNull();
    expect(afterPack!.x).toBeGreaterThan(10);
    expect(logic.getSideCredits('China')).toBe(75);
  });

  it('executes railed transport paths from waypoint prefixes outside index command internals', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('RailedTruck', 'China', ['VEHICLE'], [
          makeBlock('LocomotorSet', 'SET_NORMAL RailedLocomotor', {}),
          makeBlock('Behavior', 'RailedTransportAIUpdate ModuleTag_Railed', {
            PathPrefixName: 'TrainRoute',
          }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('RailedLocomotor', 60),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const map = makeMap([makeMapObject('RailedTruck', 88, 10)], 256, 64);
    map.waypoints = {
      nodes: [
        { id: 11, name: 'TrainRouteStart01', position: { x: 30, y: 10, z: 0 }, biDirectional: false },
        { id: 12, name: 'TrainRouteMid01', position: { x: 60, y: 10, z: 0 }, biDirectional: false },
        { id: 13, name: 'TrainRouteEnd01', position: { x: 90, y: 10, z: 0 }, biDirectional: false },
        { id: 21, name: 'TrainRouteStart02', position: { x: 150, y: 10, z: 0 }, biDirectional: false },
        { id: 22, name: 'TrainRouteEnd02', position: { x: 170, y: 10, z: 0 }, biDirectional: false },
      ],
      links: [
        { waypoint1: 11, waypoint2: 12 },
        { waypoint1: 12, waypoint2: 13 },
        { waypoint1: 21, waypoint2: 22 },
      ],
    };

    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(256, 64));
    logic.update(1 / 30);

    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 230, targetZ: 10 });
    for (let frame = 0; frame < 120; frame += 1) {
      logic.update(1 / 30);
    }
    const afterIgnoredMove = logic.getEntityState(1);
    expect(afterIgnoredMove).not.toBeNull();
    expect(afterIgnoredMove!.x).toBeLessThan(120);

    logic.submitCommand({ type: 'executeRailedTransport', entityId: 1 });
    for (let frame = 0; frame < 220; frame += 1) {
      logic.update(1 / 30);
    }

    const afterFirstTransit = logic.getEntityState(1);
    expect(afterFirstTransit).not.toBeNull();
    expect(afterFirstTransit!.x).toBeGreaterThan(165);

    logic.submitCommand({ type: 'executeRailedTransport', entityId: 1 });
    for (let frame = 0; frame < 260; frame += 1) {
      logic.update(1 / 30);
    }

    const afterSecondTransit = logic.getEntityState(1);
    expect(afterSecondTransit).not.toBeNull();
    expect(afterSecondTransit!.x).toBeLessThanOrEqual(95);
  });

  it('blocks evacuate while a railed transport is in transit', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('RailedCarrier', 'China', ['VEHICLE', 'TRANSPORT'], [
          makeBlock('LocomotorSet', 'SET_NORMAL RailedLocomotor', {}),
          makeBlock('Behavior', 'RailedTransportAIUpdate ModuleTag_Railed', {
            PathPrefixName: 'TransitRoute',
          }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 1,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [0, 0, 0],
            ExitDelay: 0,
          }),
          makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
            NumRows: 1,
            NumCols: 1,
          }),
        ]),
        makeObjectDef('RailedPassenger', 'China', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL PassengerLocomotor', {}),
        ], {
          BuildCost: 0,
          BuildTime: 0.1,
        }),
      ],
      locomotors: [
        makeLocomotorDef('RailedLocomotor', 60),
        makeLocomotorDef('PassengerLocomotor', 30),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const map = makeMap([makeMapObject('RailedCarrier', 140, 10)], 256, 64);
    map.waypoints = {
      nodes: [
        { id: 1, name: 'TransitRouteStart01', position: { x: 20, y: 10, z: 0 }, biDirectional: false },
        { id: 2, name: 'TransitRouteEnd01', position: { x: 140, y: 10, z: 0 }, biDirectional: false },
      ],
      links: [
        { waypoint1: 1, waypoint2: 2 },
      ],
    };
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(256, 64));

    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'RailedPassenger' });
    for (let frame = 0; frame < 6; frame += 1) {
      logic.update(1 / 30);
    }
    const passengerId = logic.getEntityIdsByTemplate('RailedPassenger')[0];
    expect(passengerId).toBeDefined();

    logic.submitCommand({ type: 'executeRailedTransport', entityId: 1 });
    for (let frame = 0; frame < 15; frame += 1) {
      logic.update(1 / 30);
    }

    const passengerBeforeEvac = logic.getEntityState(passengerId!);
    const carrierDuringTransit = logic.getEntityState(1);
    expect(passengerBeforeEvac).not.toBeNull();
    expect(carrierDuringTransit).not.toBeNull();

    logic.submitCommand({ type: 'evacuate', entityId: 1 });
    for (let frame = 0; frame < 5; frame += 1) {
      logic.update(1 / 30);
    }

    const passengerAfterEvac = logic.getEntityState(passengerId!);
    const carrierAfterEvac = logic.getEntityState(1);
    expect(passengerAfterEvac).not.toBeNull();
    expect(carrierAfterEvac).not.toBeNull();
    expect(passengerAfterEvac!.x).toBeGreaterThan(130);
    expect(Math.abs(passengerAfterEvac!.x - passengerBeforeEvac!.x)).toBeLessThan(1);
    expect(carrierAfterEvac!.x).toBeLessThan(passengerAfterEvac!.x - 10);
  });

  it('ignores combatDrop when source transport has no passengers', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EmptyTransport', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
            NumRows: 1,
            NumCols: 1,
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL TransportLoco', {}),
        ]),
        makeObjectDef('EnemyTarget', 'China', ['VEHICLE'], []),
      ],
      locomotors: [
        makeLocomotorDef('TransportLoco', 90),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('EmptyTransport', 8, 8), makeMapObject('EnemyTarget', 120, 8)], 128, 64),
      makeRegistry(bundle),
      makeHeightmap(128, 64),
    );
    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: 2,
      targetPosition: null,
    });

    for (let frame = 0; frame < 30; frame += 1) {
      logic.update(1 / 30);
    }

    const transport = logic.getEntityState(1);
    expect(transport).not.toBeNull();
    expect(transport!.x).toBeCloseTo(8, 1);
  });

  it('ignores combatDrop when contained passengers are not CAN_RAPPEL', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CombatTransport', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 1,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [0, 0, 0],
            ExitDelay: 0,
          }),
          makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
            NumRows: 1,
            NumCols: 1,
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL TransportLoco', {}),
        ]),
        makeObjectDef('EnemyTarget', 'China', ['VEHICLE'], []),
        makeObjectDef('DropInfantry', 'America', ['INFANTRY'], [], {
          BuildCost: 0,
          BuildTime: 0.1,
        }),
      ],
      locomotors: [
        makeLocomotorDef('TransportLoco', 90),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('CombatTransport', 8, 8), makeMapObject('EnemyTarget', 120, 8)], 128, 64),
      makeRegistry(bundle),
      makeHeightmap(128, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'DropInfantry' });
    for (let frame = 0; frame < 6; frame += 1) {
      logic.update(1 / 30);
    }

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: 2,
      targetPosition: null,
    });
    for (let frame = 0; frame < 30; frame += 1) {
      logic.update(1 / 30);
    }

    const transport = logic.getEntityState(1);
    expect(transport).not.toBeNull();
    expect(transport!.x).toBeCloseTo(8, 1);
  });

  it('routes combatDrop commands to passenger evacuate + target attack intents', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CombatTransport', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 1,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [0, 0, 0],
            ExitDelay: 0,
          }),
          makeBlock('Behavior', 'ParkingPlaceBehavior ModuleTag_Parking', {
            NumRows: 1,
            NumCols: 1,
          }),
        ]),
        makeObjectDef('EnemyTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('DropInfantry', 'America', ['INFANTRY', 'CAN_RAPPEL'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'DropRifle'] }),
        ], {
          BuildCost: 0,
          BuildTime: 0.1,
        }),
      ],
      weapons: [
        makeWeaponDef('DropRifle', {
          AttackRange: 80,
          PrimaryDamage: 5,
          DelayBetweenShots: 100,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('CombatTransport', 8, 8), makeMapObject('EnemyTarget', 10, 8)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'DropInfantry' });
    for (let frame = 0; frame < 6; frame += 1) {
      logic.update(1 / 30);
    }

    const passengerId = logic.getEntityIdsByTemplate('DropInfantry')[0];
    expect(passengerId).toBeDefined();

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: 2,
      targetPosition: null,
    });
    for (let frame = 0; frame < 8; frame += 1) {
      logic.update(1 / 30);
    }

    const passengerState = logic.getEntityState(passengerId!);
    expect(passengerState).not.toBeNull();
    expect(passengerState?.attackTargetEntityId).toBe(2);
  });

  it('uses ChinookAIUpdate staged combat drop and only rappels CAN_RAPPEL passengers', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
            NumRopes: 1,
            PerRopeDelayMin: 100,
            PerRopeDelayMax: 100,
            WaitForRopesToDrop: false,
            MinDropHeight: 0,
          }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 5,
            InitialPayload: 0,
          }),
        ]),
        makeObjectDef('Rappeller', 'America', ['INFANTRY', 'CAN_RAPPEL'], []),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], []),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyChinook', 8, 8), // id 1
        makeMapObject('Rappeller', 8, 8),     // id 2
        makeMapObject('Passenger', 8, 8),     // id 3
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        chinookAIProfile: {
          numRopes: number;
          perRopeDelayMinFrames: number;
          perRopeDelayMaxFrames: number;
          waitForRopesToDrop: boolean;
        } | null;
        transportContainerId: number | null;
      }>;
    };

    const chinook = priv.spawnedEntities.get(1)!;
    expect(chinook.chinookAIProfile).toBeTruthy();
    expect(chinook.chinookAIProfile?.numRopes).toBe(1);
    expect(chinook.chinookAIProfile?.perRopeDelayMinFrames).toBe(3);
    expect(chinook.chinookAIProfile?.perRopeDelayMaxFrames).toBe(3);
    expect(chinook.chinookAIProfile?.waitForRopesToDrop).toBe(false);

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
    }

    expect(priv.spawnedEntities.get(2)?.transportContainerId).toBe(1);
    expect(priv.spawnedEntities.get(3)?.transportContainerId).toBe(1);

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: null,
      targetPosition: [8, 0, 8],
    });
    for (let frame = 0; frame < 12; frame += 1) {
      logic.update(1 / 30);
    }

    // Only CAN_RAPPEL passenger should exit during Chinook combat drop.
    expect(priv.spawnedEntities.get(2)?.transportContainerId).toBeNull();
    expect(priv.spawnedEntities.get(3)?.transportContainerId).toBe(1);
  });

  it('blocks manual exitContainer while Chinook combat drop is active', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
            NumRopes: 1,
            PerRopeDelayMin: 0,
            PerRopeDelayMax: 0,
            WaitForRopesToDrop: false,
            MinDropHeight: 30,
            RappelSpeed: 30,
          }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 5,
            InitialPayload: 0,
          }),
        ]),
        makeObjectDef('Rappeller', 'America', ['INFANTRY', 'CAN_RAPPEL'], []),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], []),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyChinook', 8, 8), // id 1
        makeMapObject('Rappeller', 8, 8),     // id 2
        makeMapObject('Passenger', 8, 8),     // id 3
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
    };

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    for (let frame = 0; frame < 5; frame += 1) {
      logic.update(1 / 30);
    }
    expect(priv.spawnedEntities.get(2)?.transportContainerId).toBe(1);
    expect(priv.spawnedEntities.get(3)?.transportContainerId).toBe(1);

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: null,
      targetPosition: [8, 0, 8],
    });
    for (let frame = 0; frame < 6; frame += 1) {
      logic.update(1 / 30);
    }

    // Manual exit is ignored while combat drop owns passenger release.
    logic.submitCommand({ type: 'exitContainer', entityId: 3 });
    for (let frame = 0; frame < 6; frame += 1) {
      logic.update(1 / 30);
    }

    expect(priv.spawnedEntities.get(3)?.transportContainerId).toBe(1);
  });

  it('ignores combat-drop target building for Chinook pathing only while drop is active', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
            NumRopes: 1,
            PerRopeDelayMin: 0,
            PerRopeDelayMax: 0,
            WaitForRopesToDrop: false,
            MinDropHeight: 30,
            RappelSpeed: 120,
          }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 5,
            InitialPayload: 0,
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL ChinookLocomotor', {}),
        ]),
        makeObjectDef('DropTarget', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
        ]),
        makeObjectDef('Rappeller', 'America', ['INFANTRY', 'CAN_RAPPEL'], []),
      ],
      locomotors: [
        makeLocomotorDef('ChinookLocomotor', 120),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyChinook', 8, 8), // id 1
        makeMapObject('DropTarget', 8, 8),    // id 2
        makeMapObject('Rappeller', 8, 8),     // id 3
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null; ignoredMovementObstacleId: number | null }>;
      pendingCombatDropActions: Map<number, unknown>;
    };

    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    for (let frame = 0; frame < 12; frame += 1) {
      logic.update(1 / 30);
      if (priv.spawnedEntities.get(3)?.transportContainerId === 1) {
        break;
      }
    }
    expect(priv.spawnedEntities.get(3)?.transportContainerId).toBe(1);

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: 2,
      targetPosition: null,
    });

    for (let frame = 0; frame < 30; frame += 1) {
      logic.update(1 / 30);
      if (priv.pendingCombatDropActions.has(1)) {
        break;
      }
    }

    expect(priv.pendingCombatDropActions.has(1)).toBe(true);
    expect(priv.spawnedEntities.get(1)?.ignoredMovementObstacleId).toBe(2);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount(attackerId: number | null, target: unknown, amount: number, damageType: string): void;
    };
    const dropTarget = priv.spawnedEntities.get(2);
    expect(dropTarget).toBeDefined();
    privateApi.applyWeaponDamageAmount(null, dropTarget as unknown as never, 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(priv.spawnedEntities.get(1)?.ignoredMovementObstacleId).toBeNull();
  });

  it('records no-target special power dispatch on source entity module', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerSource', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule SourceNoTarget', {
            SpecialPowerTemplate: 'SpecialPowerNoTarget',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerNoTarget', { ReloadTime: 0 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SpecialPowerSource', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_NO_TARGET',
      specialPowerName: 'SpecialPowerNoTarget',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    logic.update(0);

    const sourceState = logic.getEntityState(1);
    expect(sourceState?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SPECIALPOWERNOTARGET',
      moduleType: 'SPECIALPOWERMODULE',
      dispatchType: 'NO_TARGET',
      commandOption: 0,
      commandButtonId: 'CMD_NO_TARGET',
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
  });

  it('records position-target special power dispatch on source entity module', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerSource', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule SourcePos', {
            SpecialPowerTemplate: 'SpecialPowerAtPos',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerAtPos', { ReloadTime: 0 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SpecialPowerSource', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_POSITION',
      specialPowerName: 'SpecialPowerAtPos',
      commandOption: 0x20,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: 100,
      targetZ: 260,
    });
    logic.update(0);

    const sourceState = logic.getEntityState(1);
    expect(sourceState?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SPECIALPOWERATPOS',
      moduleType: 'SPECIALPOWERMODULE',
      dispatchType: 'POSITION',
      commandOption: 0x20,
      commandButtonId: 'CMD_POSITION',
      targetEntityId: null,
      targetX: 100,
      targetZ: 260,
    });
  });

  it('records object-target special power dispatch on source entity module', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerSource', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule SourceObject', {
            SpecialPowerTemplate: 'SpecialPowerAtObject',
          }),
        ]),
        makeObjectDef('EnemyTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerAtObject', { ReloadTime: 0 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SpecialPowerSource', 10, 10), makeMapObject('EnemyTarget', 24, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_OBJECT',
      specialPowerName: 'SpecialPowerAtObject',
      commandOption: 0x1,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: 2,
      targetX: 0,
      targetZ: 0,
    });
    logic.update(0);

    const sourceState = logic.getEntityState(1);
    expect(sourceState?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SPECIALPOWERATOBJECT',
      moduleType: 'SPECIALPOWERMODULE',
      dispatchType: 'OBJECT',
      commandOption: 0x1,
      commandButtonId: 'CMD_OBJECT',
      targetEntityId: 2,
      targetX: null,
      targetZ: null,
    });
  });

  it('ignores special power dispatch when source entity is missing matching module', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerSource', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule SourceObject', {
            SpecialPowerTemplate: 'SpecialPowerKnown',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerMissing', { ReloadTime: 0 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SpecialPowerSource', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_MISSING',
      specialPowerName: 'SpecialPowerMissing',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    logic.update(0);

    const sourceState = logic.getEntityState(1);
    expect(sourceState?.lastSpecialPowerDispatch).toBeNull();
  });

  it('runs supply chain economy: truck gathers from warehouse and deposits at supply center', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const warehouseDef = makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
        StartingBoxes: 10,
        DeleteWhenEmpty: false,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const supplyCenterDef = makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const supplyTruckDef = makeObjectDef('SupplyTruck', 'America', ['VEHICLE', 'HARVESTER'], [
      makeBlock('Behavior', 'SupplyTruckAIUpdate ModuleTag_SupplyTruckAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [warehouseDef, supplyCenterDef, supplyTruckDef],
    }));

    // Place warehouse at (10,10), supply center at (35,10), truck at (10,10) (near warehouse).
    // Use 64x64 map to ensure positions are within grid bounds for pathfinding.
    const map = makeMap([
      makeMapObject('SupplyWarehouse', 10, 10),
      makeMapObject('SupplyCenter', 35, 10),
      makeMapObject('SupplyTruck', 10, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));

    // Set credits to 0 for America.
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.update(0);

    const initialCredits = logic.getSideCredits('America');
    expect(initialCredits).toBe(0);

    // Run many frames to let the supply truck AI gather and deposit.
    // With 0 action delay, the truck should:
    // 1. Find warehouse (nearby), start gathering  ~5 frames (3 boxes + transitions)
    // 2. Move to supply center (25 world units at speed 18, ~42 frames) and deposit
    // Deposit value = 3 boxes * 100 credits/box = 300
    for (let i = 0; i < 300; i++) {
      logic.update(0.033);
    }

    const creditsAfter = logic.getSideCredits('America');
    // At least one deposit should have occurred (300 credits for 3 boxes).
    expect(creditsAfter).toBeGreaterThanOrEqual(300);
  });

  it('doubles supply warehouse scan distance for AI-controlled supply trucks', () => {
    const runScenario = (playerType: 'HUMAN' | 'COMPUTER'): number | null => {
      const logic = new GameLogicSubsystem(new THREE.Scene());

      const warehouseDef = makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
          StartingBoxes: 10,
          DeleteWhenEmpty: false,
        }),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]);

      const supplyCenterDef = makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]);

      const supplyTruckDef = makeObjectDef('SupplyTruck', 'America', ['VEHICLE', 'HARVESTER'], [
        makeBlock('Behavior', 'SupplyTruckAIUpdate ModuleTag_SupplyTruckAI', {
          MaxBoxes: 3,
          SupplyCenterActionDelay: 0,
          SupplyWarehouseActionDelay: 0,
          SupplyWarehouseScanDistance: 100,
        }),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]);

      const registry = makeRegistry(makeBundle({
        objects: [warehouseDef, supplyCenterDef, supplyTruckDef],
      }));

      const map = makeMap([
        makeMapObject('SupplyWarehouse', 190, 10),
        makeMapObject('SupplyCenter', 200, 10),
        makeMapObject('SupplyTruck', 10, 10),
      ], 64, 64);

      logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
      logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType });
      logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
      logic.update(0);

      for (let i = 0; i < 5; i++) {
        logic.update(1 / 30);
      }

      const priv = logic as unknown as {
        supplyTruckStates: Map<number, { targetWarehouseId: number | null }>;
      };
      return priv.supplyTruckStates.get(3)?.targetWarehouseId ?? null;
    };

    const humanTarget = runScenario('HUMAN');
    const aiTarget = runScenario('COMPUTER');

    expect(humanTarget).toBeNull();
    expect(aiTarget).toBe(1);
  });

  it('treats WorkerAIUpdate units as supply gatherers with supply truck delays/scan', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const warehouseDef = makeObjectDef('SupplyWarehouse', 'GLA', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
        StartingBoxes: 10,
        DeleteWhenEmpty: false,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const supplyCenterDef = makeObjectDef('SupplyCenter', 'GLA', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const workerDef = makeObjectDef('GLAWorker', 'GLA', ['INFANTRY', 'DOZER', 'HARVESTER'], [
      makeBlock('Behavior', 'WorkerAIUpdate ModuleTag_WorkerAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
        RepairHealthPercentPerSecond: '2%',
        BoredTime: 3000,
        BoredRange: 250,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [warehouseDef, supplyCenterDef, workerDef],
    }));

    const map = makeMap([
      makeMapObject('SupplyWarehouse', 10, 10),
      makeMapObject('SupplyCenter', 35, 10),
      makeMapObject('GLAWorker', 10, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'GLA', amount: 0 });
    logic.update(0);

    for (let i = 0; i < 300; i++) {
      logic.update(0.033);
    }

    expect(logic.getSideCredits('GLA')).toBeGreaterThanOrEqual(300);
  });

  it('regroups supply trucks to a friendly structure when no legal dock exists', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const commandCenterDef = makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'COMMANDCENTER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ]);

    const supplyTruckDef = makeObjectDef('SupplyTruck', 'America', ['VEHICLE', 'HARVESTER'], [
      makeBlock('Behavior', 'SupplyTruckAIUpdate ModuleTag_SupplyTruckAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    logic.loadMapObjects(
      makeMap([
        makeMapObject('CommandCenter', 90, 10), // id 1
        makeMapObject('SupplyTruck', 10, 10),   // id 2
      ], 128, 128),
      makeRegistry(makeBundle({
        objects: [commandCenterDef, supplyTruckDef],
      })),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      supplyTruckStates: Map<number, {
        aiState: number;
        currentBoxes: number;
        targetWarehouseId: number | null;
        targetDepotId: number | null;
        actionDelayFinishFrame: number;
        preferredDockId: number | null;
        forceBusy: boolean;
      }>;
      commandQueue: Array<{
        type: string;
        entityId?: number;
        targetX?: number;
        targetZ?: number;
        commandSource?: string;
      }>;
    };

    // Carrying boxes forces depot search; with no SupplyCenterDockUpdate available it must regroup.
    priv.supplyTruckStates.set(2, {
      aiState: 0,
      currentBoxes: 2,
      targetWarehouseId: null,
      targetDepotId: null,
      actionDelayFinishFrame: 0,
      preferredDockId: null,
      forceBusy: false,
    });

    logic.update(1 / 30);
    expect(priv.supplyTruckStates.get(2)?.aiState).toBe(5); // WAITING
    expect(priv.commandQueue).toContainEqual({
      type: 'moveTo',
      entityId: 2,
      targetX: 90,
      targetZ: 10,
      commandSource: 'AI',
    });
  });

  it('prefers CASH_GENERATOR regroup targets over nearer command centers', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const cashGeneratorDef = makeObjectDef('CashGen', 'America', ['STRUCTURE', 'CASH_GENERATOR'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ]);

    const commandCenterDef = makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'COMMANDCENTER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ]);

    const supplyTruckDef = makeObjectDef('SupplyTruck', 'America', ['VEHICLE', 'HARVESTER'], [
      makeBlock('Behavior', 'SupplyTruckAIUpdate ModuleTag_SupplyTruckAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 50,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    logic.loadMapObjects(
      makeMap([
        makeMapObject('CashGen', 90, 10),       // id 1 (farther but higher priority)
        makeMapObject('CommandCenter', 30, 10), // id 2 (nearer but lower priority)
        makeMapObject('SupplyTruck', 10, 10),   // id 3
      ], 128, 128),
      makeRegistry(makeBundle({
        objects: [cashGeneratorDef, commandCenterDef, supplyTruckDef],
      })),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      supplyTruckStates: Map<number, {
        aiState: number;
        currentBoxes: number;
        targetWarehouseId: number | null;
        targetDepotId: number | null;
        actionDelayFinishFrame: number;
        preferredDockId: number | null;
        forceBusy: boolean;
      }>;
      commandQueue: Array<{
        type: string;
        entityId?: number;
        targetX?: number;
        targetZ?: number;
        commandSource?: string;
      }>;
    };

    priv.supplyTruckStates.set(3, {
      aiState: 0,
      currentBoxes: 0,
      targetWarehouseId: null,
      targetDepotId: null,
      actionDelayFinishFrame: 0,
      preferredDockId: null,
      forceBusy: false,
    });

    logic.update(1 / 30);
    expect(priv.supplyTruckStates.get(3)?.aiState).toBe(5); // WAITING
    expect(priv.commandQueue).toContainEqual({
      type: 'moveTo',
      entityId: 3,
      targetX: 90,
      targetZ: 10,
      commandSource: 'AI',
    });
  });

  it('clears worker preferred dock when entering a repair dozer task', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const warehouseDef = makeObjectDef('SupplyWarehouse', 'GLA', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
        StartingBoxes: 10,
        DeleteWhenEmpty: false,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const workerDef = makeObjectDef('GLAWorker', 'GLA', ['INFANTRY', 'DOZER', 'HARVESTER'], [
      makeBlock('Behavior', 'WorkerAIUpdate ModuleTag_WorkerAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
        RepairHealthPercentPerSecond: '2%',
        BoredTime: 3000,
        BoredRange: 250,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const damagedStructureDef = makeObjectDef('GLADamagedStructure', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ]);

    logic.loadMapObjects(
      makeMap([
        makeMapObject('GLAWorker', 20, 20),         // id 1
        makeMapObject('SupplyWarehouse', 10, 10),   // id 2
        makeMapObject('GLADamagedStructure', 20, 20), // id 3
      ], 128, 128),
      makeRegistry(makeBundle({
        objects: [warehouseDef, workerDef, damagedStructureDef],
      })),
      makeHeightmap(128, 128),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'GLA', amount: 1000 });
    logic.update(0);

    const priv = logic as unknown as {
      supplyTruckStates: Map<number, {
        aiState: number;
        currentBoxes: number;
        targetWarehouseId: number | null;
        targetDepotId: number | null;
        actionDelayFinishFrame: number;
        preferredDockId: number | null;
        forceBusy: boolean;
      }>;
      pendingRepairActions: Map<number, number>;
    };

    priv.supplyTruckStates.set(1, {
      aiState: 0,
      currentBoxes: 0,
      targetWarehouseId: null,
      targetDepotId: null,
      actionDelayFinishFrame: 0,
      preferredDockId: 2,
      forceBusy: false,
    });

    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 3 });
    logic.update(0);

    expect(priv.pendingRepairActions.get(1)).toBe(3);
    expect(priv.supplyTruckStates.get(1)?.preferredDockId).toBeNull();
  });

  it('clears worker preferred dock when entering a build dozer task', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const warehouseDef = makeObjectDef('SupplyWarehouse', 'GLA', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
        StartingBoxes: 10,
        DeleteWhenEmpty: false,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const workerDef = makeObjectDef('GLAWorker', 'GLA', ['INFANTRY', 'DOZER', 'HARVESTER'], [
      makeBlock('Behavior', 'WorkerAIUpdate ModuleTag_WorkerAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
        RepairHealthPercentPerSecond: '2%',
        BoredTime: 3000,
        BoredRange: 250,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], {
      CommandSet: 'WorkerConstructSet',
    });

    const buildableDef = makeObjectDef('GLAShack', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], {
      BuildCost: 300,
      BuildTime: 1.0,
    });

    const registry = makeRegistry(makeBundle({
      objects: [warehouseDef, workerDef, buildableDef],
      commandButtons: [
        makeCommandButtonDef('Command_ConstructShack', {
          Command: 'DOZER_CONSTRUCT',
          Object: 'GLAShack',
        }),
      ],
      commandSets: [
        makeCommandSetDef('WorkerConstructSet', {
          1: 'Command_ConstructShack',
        }),
      ],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('GLAWorker', 20, 20),       // id 1
        makeMapObject('SupplyWarehouse', 10, 10), // id 2
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'GLA', amount: 1000 });
    logic.update(0);

    const priv = logic as unknown as {
      supplyTruckStates: Map<number, {
        aiState: number;
        currentBoxes: number;
        targetWarehouseId: number | null;
        targetDepotId: number | null;
        actionDelayFinishFrame: number;
        preferredDockId: number | null;
        forceBusy: boolean;
      }>;
      pendingConstructionActions: Map<number, number>;
    };

    priv.supplyTruckStates.set(1, {
      aiState: 0,
      currentBoxes: 0,
      targetWarehouseId: null,
      targetDepotId: null,
      actionDelayFinishFrame: 0,
      preferredDockId: 2,
      forceBusy: false,
    });

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'GLAShack',
      targetPosition: [40, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(0);

    expect(priv.pendingConstructionActions.has(1)).toBe(true);
    expect(priv.supplyTruckStates.get(1)?.preferredDockId).toBeNull();
  });

  it('applies ChinookAIUpdate UpgradedSupplyBoost when Upgrade_AmericaSupplyLines is completed', () => {
    const runScenario = (withUpgrade: boolean): number => {
      const logic = new GameLogicSubsystem(new THREE.Scene());

      const warehouseDef = makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
          StartingBoxes: 10,
          DeleteWhenEmpty: false,
        }),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]);

      const supplyCenterDef = makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]);

      const chinookDef = makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'HARVESTER'], [
        makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
          MaxBoxes: 3,
          SupplyCenterActionDelay: 0,
          SupplyWarehouseActionDelay: 0,
          SupplyWarehouseScanDistance: 500,
          UpgradedSupplyBoost: 45,
        }),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      ]);

      const registry = makeRegistry(makeBundle({
        objects: [warehouseDef, supplyCenterDef, chinookDef],
      }));

      const map = makeMap([
        makeMapObject('SupplyWarehouse', 10, 10),
        makeMapObject('SupplyCenter', 35, 10),
        makeMapObject('SupplyChinook', 10, 10),
      ], 64, 64);

      logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
      logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
      logic.update(0);

      const priv = logic as unknown as {
        spawnedEntities: Map<number, { templateName: string; supplyTruckProfile: { upgradedSupplyBoost: number } | null }>;
        setSideUpgradeCompleted: (side: string, upgradeName: string, enabled: boolean) => void;
      };
      const chinook = [...priv.spawnedEntities.values()].find((e) => e.templateName === 'SupplyChinook');
      expect(chinook?.supplyTruckProfile?.upgradedSupplyBoost).toBe(45);

      if (withUpgrade) {
        priv.setSideUpgradeCompleted('America', 'Upgrade_AmericaSupplyLines', true);
      }

      for (let i = 0; i < 300; i++) {
        logic.update(0.033);
      }

      return logic.getSideCredits('America');
    };

    const withoutUpgrade = runScenario(false);
    const withUpgrade = runScenario(true);
    const boostDelta = withUpgrade - withoutUpgrade;

    expect(withUpgrade).toBeGreaterThan(withoutUpgrade);
    expect(boostDelta).toBeGreaterThanOrEqual(45);
    expect(boostDelta % 45).toBe(0);
  });

  it('pauses Chinook supply gathering while carrying passengers', () => {
    const runScenario = (withPassenger: boolean): number => {
      const logic = new GameLogicSubsystem(new THREE.Scene());

      const warehouseDef = makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
          StartingBoxes: 10,
          DeleteWhenEmpty: false,
        }),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]);

      const supplyCenterDef = makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
        makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]);

      const chinookDef = makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT', 'HARVESTER'], [
        makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
          MaxBoxes: 3,
          SupplyCenterActionDelay: 0,
          SupplyWarehouseActionDelay: 0,
          SupplyWarehouseScanDistance: 500,
        }),
        makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
          Slots: 5,
          InitialPayload: 0,
        }),
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      ]);

      const passengerDef = makeObjectDef('Passenger', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]);

      const registry = makeRegistry(makeBundle({
        objects: [warehouseDef, supplyCenterDef, chinookDef, passengerDef],
      }));

      logic.loadMapObjects(
        makeMap([
          makeMapObject('SupplyWarehouse', 10, 10), // id 1
          makeMapObject('SupplyCenter', 35, 10),    // id 2
          makeMapObject('SupplyChinook', 10, 10),   // id 3
          makeMapObject('Passenger', 10, 10),       // id 4
        ], 64, 64),
        registry,
        makeHeightmap(64, 64),
      );

      logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
      logic.update(0);

      if (withPassenger) {
        logic.submitCommand({ type: 'enterTransport', entityId: 4, targetTransportId: 3 });
        for (let frame = 0; frame < 5; frame += 1) {
          logic.update(1 / 30);
        }
      }

      for (let i = 0; i < 300; i++) {
        logic.update(0.033);
      }
      return logic.getSideCredits('America');
    };

    const baselineCredits = runScenario(false);
    const withPassengerCredits = runScenario(true);

    expect(baselineCredits).toBeGreaterThanOrEqual(300);
    expect(withPassengerCredits).toBe(0);
  });

  it('clears Chinook carried supply boxes when combat drop begins', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const warehouseDef = makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
        StartingBoxes: 10,
        DeleteWhenEmpty: false,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const supplyCenterDef = makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const chinookDef = makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT', 'HARVESTER'], [
      makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
        MaxBoxes: 3,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
        NumRopes: 1,
        PerRopeDelayMin: 100,
        PerRopeDelayMax: 100,
        WaitForRopesToDrop: false,
        MinDropHeight: 0,
      }),
      makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
        Slots: 5,
        InitialPayload: 0,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
    ]);

    const rappellerDef = makeObjectDef('Rappeller', 'America', ['INFANTRY', 'CAN_RAPPEL'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [warehouseDef, supplyCenterDef, chinookDef, rappellerDef],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyWarehouse', 10, 10), // id 1
        makeMapObject('SupplyCenter', 35, 10),    // id 2
        makeMapObject('SupplyChinook', 10, 10),   // id 3
        makeMapObject('Rappeller', 10, 10),       // id 4
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      supplyTruckStates: Map<number, { currentBoxes: number }>;
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
    };

    let carriedBoxes = 0;
    for (let i = 0; i < 240; i++) {
      logic.update(1 / 30);
      carriedBoxes = priv.supplyTruckStates.get(3)?.currentBoxes ?? 0;
      if (carriedBoxes > 0) {
        break;
      }
    }
    expect(carriedBoxes).toBeGreaterThan(0);

    logic.submitCommand({ type: 'enterTransport', entityId: 4, targetTransportId: 3 });
    for (let frame = 0; frame < 5; frame += 1) {
      logic.update(1 / 30);
    }
    expect(priv.spawnedEntities.get(4)?.transportContainerId).toBe(3);

    const chinookBeforeDrop = logic.getEntityState(3);
    expect(chinookBeforeDrop).not.toBeNull();

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 3,
      targetObjectId: null,
      targetPosition: [chinookBeforeDrop!.x, 0, chinookBeforeDrop!.z],
    });

    let boxesAfterDrop = priv.supplyTruckStates.get(3)?.currentBoxes ?? -1;
    for (let frame = 0; frame < 30; frame += 1) {
      logic.update(1 / 30);
      boxesAfterDrop = priv.supplyTruckStates.get(3)?.currentBoxes ?? -1;
      if (boxesAfterDrop === 0) {
        break;
      }
    }

    expect(boxesAfterDrop).toBe(0);
  });

  it('keeps Chinook and rappeller held until rappel descent completes', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
            NumRopes: 1,
            PerRopeDelayMin: 0,
            PerRopeDelayMax: 0,
            WaitForRopesToDrop: false,
            MinDropHeight: 30,
            RappelSpeed: 30,
          }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 5,
            InitialPayload: 0,
          }),
        ]),
        makeObjectDef('Rappeller', 'America', ['INFANTRY', 'CAN_RAPPEL'], []),
      ],
    });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyChinook', 8, 8), // id 1
        makeMapObject('Rappeller', 8, 8),     // id 2
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
    }

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: null,
      targetPosition: [8, 0, 8],
    });

    for (let frame = 0; frame < 8; frame += 1) {
      logic.update(1 / 30);
    }

    const chinookDuring = logic.getEntityState(1);
    const rappellerDuring = logic.getEntityState(2);
    expect(chinookDuring?.statusFlags ?? []).toContain('DISABLED_HELD');
    expect(rappellerDuring?.statusFlags ?? []).toContain('DISABLED_HELD');
    expect(chinookDuring?.y ?? 0).toBeGreaterThan(15);

    for (let frame = 0; frame < 80; frame += 1) {
      logic.update(1 / 30);
    }

    const chinookAfter = logic.getEntityState(1);
    const rappellerAfter = logic.getEntityState(2);
    expect(chinookAfter?.statusFlags ?? []).not.toContain('DISABLED_HELD');
    expect(rappellerAfter?.statusFlags ?? []).not.toContain('DISABLED_HELD');
  });

  it('replays deferred Chinook command after combat drop finishes', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyChinook', 'America', ['AIRCRAFT', 'TRANSPORT'], [
          makeBlock('Behavior', 'ChinookAIUpdate ModuleTag_ChinookAI', {
            NumRopes: 1,
            PerRopeDelayMin: 0,
            PerRopeDelayMax: 0,
            WaitForRopesToDrop: false,
            MinDropHeight: 30,
            RappelSpeed: 30,
          }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 5,
            InitialPayload: 0,
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL ChinookLocomotor', {}),
        ]),
        makeObjectDef('Rappeller', 'America', ['INFANTRY', 'CAN_RAPPEL'], []),
      ],
      locomotors: [
        makeLocomotorDef('ChinookLocomotor', 120),
      ],
    });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyChinook', 8, 8), // id 1
        makeMapObject('Rappeller', 8, 8),     // id 2
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
      pendingCombatDropActions: Map<number, unknown>;
      pendingChinookCommandByEntityId: Map<number, unknown>;
    };

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    for (let frame = 0; frame < 12; frame += 1) {
      logic.update(1 / 30);
      if (priv.spawnedEntities.get(2)?.transportContainerId === 1) {
        break;
      }
    }
    expect(priv.spawnedEntities.get(2)?.transportContainerId).toBe(1);

    logic.submitCommand({
      type: 'combatDrop',
      entityId: 1,
      targetObjectId: null,
      targetPosition: [8, 0, 8],
    });
    const startX = logic.getEntityState(1)?.x ?? 0;
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 30, targetZ: 8 });

    logic.update(1 / 30);
    expect(priv.pendingCombatDropActions.has(1)).toBe(true);
    expect(priv.pendingChinookCommandByEntityId.has(1)).toBe(true);

    for (let frame = 0; frame < 120; frame += 1) {
      logic.update(1 / 30);
    }
    expect(priv.pendingChinookCommandByEntityId.has(1)).toBe(false);
    const movedState = logic.getEntityState(1);
    expect(movedState?.x ?? 0).toBeGreaterThan(startX + 3);
  });

  it('uses DozerAIUpdate RepairHealthPercentPerSecond during repair', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const buildingDef = makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    const registry = makeRegistry(makeBundle({
      objects: [dozerDef, buildingDef],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),
        makeMapObject('USABarracks', 20, 20),
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.update(0);

    const before = logic.getEntityState(2)!.health;
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2 });
    logic.update(1 / 30);
    const after = logic.getEntityState(2)!.health;

    // 30% per second on 500 max HP => 5 HP per frame.
    expect(after - before).toBeCloseTo(5, 4);
  });

  it('repairs structures even when side credits are zero', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const buildingDef = makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    const registry = makeRegistry(makeBundle({
      objects: [dozerDef, buildingDef],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),
        makeMapObject('USABarracks', 20, 20),
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.update(0);

    const creditsBefore = logic.getSideCredits('America');
    const healthBefore = logic.getEntityState(2)!.health;

    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2 });
    logic.update(1 / 30);

    const healthAfter = logic.getEntityState(2)!.health;
    const creditsAfter = logic.getSideCredits('America');

    expect(healthAfter).toBeGreaterThan(healthBefore);
    expect(creditsAfter).toBe(creditsBefore);
  });

  it('ignores duplicate repair command on current target and allows switching targets', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '5%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const buildingDef = makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),    // id 1
        makeMapObject('USABarracks', 20, 20), // id 2
        makeMapObject('USABarracks', 24, 20), // id 3
      ], 64, 64),
      makeRegistry(makeBundle({
        objects: [dozerDef, buildingDef],
      })),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        dozerRepairTaskOrderFrame: number;
      }>;
      pendingRepairActions: Map<number, number>;
    };

    // Keep both buildings damaged to avoid task auto-completion during the test.
    priv.spawnedEntities.get(2)!.health = 500;
    priv.spawnedEntities.get(3)!.health = 500;

    logic.update(0);
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2 });
    logic.update(1 / 30);

    const firstRepairOrderFrame = priv.spawnedEntities.get(1)!.dozerRepairTaskOrderFrame;
    expect(priv.pendingRepairActions.get(1)).toBe(2);

    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }

    // Duplicate command against the current target should be ignored.
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2 });
    logic.update(1 / 30);
    expect(priv.pendingRepairActions.get(1)).toBe(2);
    expect(priv.spawnedEntities.get(1)!.dozerRepairTaskOrderFrame).toBe(firstRepairOrderFrame);

    // Switching to a different target should still be accepted.
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 3 });
    logic.update(1 / 30);
    expect(priv.pendingRepairActions.get(1)).toBe(3);
    expect(priv.spawnedEntities.get(1)!.dozerRepairTaskOrderFrame).toBeGreaterThan(firstRepairOrderFrame);
  });

  it('allows dozers to repair neutral structures', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const neutralBuildingDef = makeObjectDef('CivilianBuilding', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),
        makeMapObject('CivilianBuilding', 20, 20),
      ], 64, 64),
      makeRegistry(makeBundle({
        objects: [dozerDef, neutralBuildingDef],
      })),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        constructionPercent: number;
        objectStatusFlags: Set<string>;
      }>;
    };
    const civilianBuilding = priv.spawnedEntities.get(2)!;
    civilianBuilding.constructionPercent = -1;
    civilianBuilding.objectStatusFlags.delete('UNDER_CONSTRUCTION');

    logic.setTeamRelationship('America', 'Civilian', 1);
    logic.setTeamRelationship('Civilian', 'America', 1);
    logic.update(0);
    const before = logic.getEntityState(2)!.health;
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2, commandSource: 'AI' });
    logic.update(1 / 30);
    const after = logic.getEntityState(2)!.health;
    expect(after).toBeGreaterThan(before);
  });

  it('rejects bridge tower targets for dozer repair commands', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const bridgeTowerDef = makeObjectDef('BridgeTower', 'America', ['STRUCTURE', 'BRIDGE_TOWER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),  // id 1
        makeMapObject('BridgeTower', 20, 20), // id 2
      ], 64, 64),
      makeRegistry(makeBundle({
        objects: [dozerDef, bridgeTowerDef],
      })),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      pendingRepairActions: Map<number, number>;
    };

    logic.update(0);
    const before = logic.getEntityState(2)!.health;

    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2 });
    logic.update(1 / 30);

    const after = logic.getEntityState(2)!.health;
    expect(after).toBe(before);
    expect(priv.pendingRepairActions.has(1)).toBe(false);
  });

  it('does not switch an under-construction building to repair when another builder is active', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const buildingDef = makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),    // id 1 (active builder)
        makeMapObject('USADozer', 24, 20),    // id 2 (attempting repair)
        makeMapObject('USABarracks', 22, 20), // id 3
      ], 64, 64),
      makeRegistry(makeBundle({
        objects: [dozerDef, buildingDef],
      })),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        constructionPercent: number;
        buildTotalFrames: number;
        builderId: number;
        objectStatusFlags: Set<string>;
      }>;
      pendingConstructionActions: Map<number, number>;
      pendingRepairActions: Map<number, number>;
    };

    const building = priv.spawnedEntities.get(3)!;
    building.health = 250;
    building.constructionPercent = 50;
    building.buildTotalFrames = 300;
    building.builderId = 1;
    building.objectStatusFlags.add('UNDER_CONSTRUCTION');
    priv.pendingConstructionActions.set(1, 3);

    logic.update(0);
    logic.submitCommand({ type: 'repairBuilding', entityId: 2, targetBuildingId: 3 });
    logic.update(1 / 30);

    expect(priv.pendingConstructionActions.has(2)).toBe(false);
    expect(priv.pendingRepairActions.has(2)).toBe(false);
    expect(priv.spawnedEntities.get(3)?.builderId).toBe(1);
  });

  it('does not allow repair commands while dozer is contained in a transport', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const transportDef = makeObjectDef('TransportTruck', 'America', ['VEHICLE', 'TRANSPORT'], [
      makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
        Slots: 5,
        InitialPayload: 0,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
    ], { GeometryMajorRadius: 8, GeometryMinorRadius: 8 });

    const buildingDef = makeObjectDef('CivilianBuilding', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),      // id 1
        makeMapObject('TransportTruck', 20, 20),// id 2
        makeMapObject('USABarracks', 20, 20),   // id 3
      ], 64, 64),
      makeRegistry(makeBundle({
        objects: [dozerDef, transportDef, buildingDef],
      })),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
      pendingRepairActions: Map<number, number>;
    };

    logic.submitCommand({ type: 'enterTransport', entityId: 1, targetTransportId: 2 });
    for (let frame = 0; frame < 6; frame += 1) {
      logic.update(1 / 30);
      if (priv.spawnedEntities.get(1)?.transportContainerId === 2) {
        break;
      }
    }
    expect(priv.spawnedEntities.get(1)?.transportContainerId).toBe(2);

    const healthBefore = logic.getEntityState(3)!.health;
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 3 });
    logic.update(1 / 30);
    const healthAfter = logic.getEntityState(3)!.health;

    expect(healthAfter).toBe(healthBefore);
    expect(priv.pendingRepairActions.has(1)).toBe(false);
  });

  it('blocks player repair commands on shrouded targets', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '30%',
        BoredTime: 999999,
        BoredRange: 300,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], {
      GeometryMajorRadius: 5,
      GeometryMinorRadius: 5,
      VisionRange: 30,
    });

    const buildingDef = makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 10, 10),      // id 1
        makeMapObject('CivilianBuilding', 200, 200), // id 2
      ], 256, 256),
      makeRegistry(makeBundle({
        objects: [dozerDef, buildingDef],
      })),
      makeHeightmap(256, 256),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        constructionPercent: number;
        objectStatusFlags: Set<string>;
      }>;
      pendingRepairActions: Map<number, number>;
    };
    const targetBuilding = priv.spawnedEntities.get(2)!;
    targetBuilding.constructionPercent = -1;
    targetBuilding.objectStatusFlags.delete('UNDER_CONSTRUCTION');

    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'HUMAN' });
    logic.setTeamRelationship('America', 'Civilian', 1);
    logic.setTeamRelationship('Civilian', 'America', 1);
    logic.update(1 / 30);

    expect(logic.getCellVisibility('America', 200, 200)).toBe(CELL_SHROUDED);
    logic.submitCommand({ type: 'repairBuilding', entityId: 1, targetBuildingId: 2 });
    logic.update(1 / 30);
    expect(priv.pendingRepairActions.has(1)).toBe(false);
  });

  it('idle dozer auto-seeks nearby repairs after bored time', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
        RepairHealthPercentPerSecond: '20%',
        BoredTime: 100, // ~3 frames
        BoredRange: 120,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    const buildingDef = makeObjectDef('USAPowerPlant', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 300 }),
    ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 });

    const registry = makeRegistry(makeBundle({
      objects: [dozerDef, buildingDef],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20),
        makeMapObject('USAPowerPlant', 23, 20),
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.update(0);

    const before = logic.getEntityState(2)!.health;
    for (let i = 0; i < 12; i++) {
      logic.update(1 / 30);
    }
    const after = logic.getEntityState(2)!.health;
    expect(after).toBeGreaterThan(before);
  });

  it('deletes warehouse when empty if DeleteWhenEmpty is true', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const warehouseDef = makeObjectDef('DepletableWarehouse', 'America', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_SupplyDock', {
        StartingBoxes: 1,
        DeleteWhenEmpty: true,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const supplyCenterDef = makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
      makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const supplyTruckDef = makeObjectDef('SupplyTruck', 'America', ['VEHICLE', 'HARVESTER'], [
      makeBlock('Behavior', 'SupplyTruckAIUpdate ModuleTag_SupplyTruckAI', {
        MaxBoxes: 5,
        SupplyCenterActionDelay: 0,
        SupplyWarehouseActionDelay: 0,
        SupplyWarehouseScanDistance: 500,
      }),
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [warehouseDef, supplyCenterDef, supplyTruckDef],
    }));

    const map = makeMap([
      makeMapObject('DepletableWarehouse', 10, 10),
      makeMapObject('SupplyCenter', 35, 10),
      makeMapObject('SupplyTruck', 10, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 0 });
    logic.update(0);

    // Run frames until warehouse should be depleted and credits deposited.
    for (let i = 0; i < 300; i++) {
      logic.update(0.033);
    }

    // Warehouse entity (id=1) should be destroyed  getEntityState returns null
    // for destroyed entities after cleanup, or alive=false during death frame.
    const warehouseState = logic.getEntityState(1);
    // Entity is either null (cleaned up) or alive=false (destroyed).
    expect(warehouseState === null || warehouseState.alive === false).toBe(true);

    // Should have received 100 credits (1 box * 100).
    const credits = logic.getSideCredits('America');
    expect(credits).toBe(100);
  });

  it('does not initialize supply chain state for non-supply entities', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const plainDef = makeObjectDef('PlainVehicle', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const registry = makeRegistry(makeBundle({ objects: [plainDef] }));
    const map = makeMap([makeMapObject('PlainVehicle', 50, 50)]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // A plain vehicle should exist and work fine with no supply chain errors.
    logic.update(0);
    logic.update(0.033);

    const entity = logic.getEntityState(1);
    expect(entity?.alive).toBe(true);
  });

  it('awards experience points to attacker on victim kill and levels up', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const attackerDef = makeObjectDef('VetAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'VetCannon'] }),
    ], {
      // ExperienceRequired: [regular=0, veteran=50, elite=200, heroic=500]
      ExperienceRequired: '0 50 200 500',
      // XP the attacker is worth if killed at each level
      ExperienceValue: '10 20 40 80',
    });

    // Victim is worth 100 XP at REGULAR level.
    const victimDef = makeObjectDef('VetVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
    ], {
      ExperienceRequired: '0 100 200 300',
      ExperienceValue: '100 200 300 400',
    });

    const registry = makeRegistry(makeBundle({
      objects: [attackerDef, victimDef],
      weapons: [
        makeWeaponDef('VetCannon', {
          AttackRange: 120,
          PrimaryDamage: 50,
          DelayBetweenShots: 100,
        }),
      ],
    }));

    const map = makeMap([
      makeMapObject('VetAttacker', 10, 10),
      makeMapObject('VetVictim', 20, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0); // enemies

    // Attacker starts at REGULAR level with 0 XP.
    const attackerBefore = logic.getEntityState(1);
    expect(attackerBefore?.veterancyLevel).toBe(0); // REGULAR
    expect(attackerBefore?.currentExperience).toBe(0);

    // Order attack on victim.
    logic.submitCommand({
      type: 'attackEntity',
      entityId: 1,
      targetEntityId: 2,
    });

    // Run frames until victim is killed (10hp, 50 damage  1 shot kill).
    for (let i = 0; i < 30; i++) {
      logic.update(0.033);
    }

    // Victim should be dead (removed from entity map after cleanup).
    const victimState = logic.getEntityState(2);
    expect(victimState).toBeNull();

    // Attacker should have gained 100 XP (victim value at REGULAR level).
    // With threshold of 50 for VETERAN, the attacker should now be VETERAN.
    const attackerAfter = logic.getEntityState(1);
    expect(attackerAfter?.currentExperience).toBe(100);
    expect(attackerAfter?.veterancyLevel).toBe(1); // VETERAN
  });

  it('does not award experience for killing allies', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());

    const killerDef = makeObjectDef('AllyKiller', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AllyGun'] }),
    ], {
      ExperienceRequired: '0 50 200 500',
      ExperienceValue: '10 20 40 80',
    });

    const allyDef = makeObjectDef('AllyTarget', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
    ], {
      ExperienceRequired: '0 100 200 300',
      ExperienceValue: '100 200 300 400',
    });

    const registry = makeRegistry(makeBundle({
      objects: [killerDef, allyDef],
      weapons: [
        makeWeaponDef('AllyGun', {
          AttackRange: 120,
          PrimaryDamage: 50,
          DelayBetweenShots: 100,
        }),
      ],
    }));

    const map = makeMap([
      makeMapObject('AllyKiller', 10, 10),
      makeMapObject('AllyTarget', 20, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'America', 2); // allies

    // Force attack on ally.
    logic.submitCommand({
      type: 'attackEntity',
      entityId: 1,
      targetEntityId: 2,
    });

    for (let i = 0; i < 30; i++) {
      logic.update(0.033);
    }

    // Attacker should have 0 XP (no XP for killing allies).
    const killerState = logic.getEntityState(1);
    expect(killerState?.currentExperience).toBe(0);
    expect(killerState?.veterancyLevel).toBe(0);
  });

  it('reveals fog of war around units with VisionRange', () => {
    const logic = new GameLogicSubsystem();

    const scoutDef = makeObjectDef('Scout', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ], {
      VisionRange: 50,
    });

    const registry = makeRegistry(makeBundle({
      objects: [scoutDef],
    }));

    const map = makeMap([
      makeMapObject('Scout', 30, 30),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));

    // Run one frame to update fog of war.
    logic.update(0.033);

    // Position near the scout should be CLEAR for America.
    expect(logic.getCellVisibility('America', 30, 30)).toBe(CELL_CLEAR);

    // Position far away should be SHROUDED for America.
    expect(logic.getCellVisibility('America', 600, 600)).toBe(CELL_SHROUDED);

    // Unknown side should see everything as SHROUDED.
    expect(logic.getCellVisibility('China', 30, 30)).toBe(CELL_SHROUDED);
  });

  it('transitions cells from CLEAR to FOGGED when unit moves away', () => {
    const logic = new GameLogicSubsystem();

    const scoutDef = makeObjectDef('Scout', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Locomotor', 'Locomotor', {
        Speed: 20,
      }),
    ], {
      VisionRange: 30,
      Speed: 20,
    });

    const registry = makeRegistry(makeBundle({
      objects: [scoutDef],
    }));

    const map = makeMap([
      makeMapObject('Scout', 10, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));

    // Run a frame to establish vision.
    logic.update(0.033);
    expect(logic.getCellVisibility('America', 10, 10)).toBe(CELL_CLEAR);

    // Move the entity far away.
    logic.submitCommand({
      type: 'move',
      entityId: 1,
      x: 600,
      z: 600,
    });

    // Run enough frames for the entity to move significantly.
    for (let i = 0; i < 60; i++) {
      logic.update(0.033);
    }

    // The original position should now be FOGGED (was seen, but no longer actively visible).
    const vis = logic.getCellVisibility('America', 10, 10);
    expect(vis === CELL_FOGGED || vis === CELL_CLEAR).toBe(true);
  });

  it('returns CELL_CLEAR everywhere when no fog of war grid is loaded', () => {
    const logic = new GameLogicSubsystem();

    // Without loading a map (no heightmap  no FoW grid), getCellVisibility returns CLEAR.
    expect(logic.getCellVisibility('America', 50, 50)).toBe(CELL_CLEAR);
  });

  it('isPositionVisible returns true for positions in vision range', () => {
    const logic = new GameLogicSubsystem();

    const scoutDef = makeObjectDef('Scout', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ], {
      VisionRange: 50,
    });

    const registry = makeRegistry(makeBundle({
      objects: [scoutDef],
    }));

    const map = makeMap([
      makeMapObject('Scout', 30, 30),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.update(0.033);

    expect(logic.isPositionVisible('America', 30, 30)).toBe(true);
    expect(logic.isPositionVisible('America', 600, 600)).toBe(false);
  });

  it('executes area damage special power at target position', () => {
    const logic = new GameLogicSubsystem();

    const sourceDef = makeObjectDef('PowerSource', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'OCLSpecialPower BombModule', {
        SpecialPowerTemplate: 'SuperweaponCarpetBomb',
      }),
    ]);

    const targetDef = makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [sourceDef, targetDef],
      specialPowers: [
        makeSpecialPowerDef('SuperweaponCarpetBomb', { ReloadTime: 0 }),
      ],
    }));

    const map = makeMap([
      makeMapObject('PowerSource', 10, 10),
      makeMapObject('EnemyTank', 30, 30),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0); // enemies

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_BOMB',
      specialPowerName: 'SuperweaponCarpetBomb',
      commandOption: 0x20, // COMMAND_OPTION_NEED_TARGET_POS
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: 30,
      targetZ: 30,
    });
    logic.update(0);

    // The enemy tank at (30,30) should have taken area damage.
    // With default 500 area damage vs 200 HP, the target should be destroyed.
    const targetState = logic.getEntityState(2);
    expect(targetState === null || (targetState.health < 200)).toBe(true);
  });

  it('executes cash hack special power to steal enemy credits', () => {
    const logic = new GameLogicSubsystem();

    const hackerDef = makeObjectDef('Hacker', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
      makeBlock('Behavior', 'CashHackSpecialPower HackModule', {
        SpecialPowerTemplate: 'SpecialPowerCashHack',
      }),
    ]);

    const enemyBuildingDef = makeObjectDef('EnemyHQ', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [hackerDef, enemyBuildingDef],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerCashHack', { ReloadTime: 0 }),
      ],
    }));

    const map = makeMap([
      makeMapObject('Hacker', 10, 10),
      makeMapObject('EnemyHQ', 20, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('China', 'America', 0); // enemies

    // Give enemy some credits.
    logic.setSideCredits('America', 5000);
    const chinaBefore = logic.getSideCredits('China');

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_HACK',
      specialPowerName: 'SpecialPowerCashHack',
      commandOption: 0x01, // COMMAND_OPTION_NEED_TARGET_ENEMY_OBJECT
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: 2,
      targetX: null,
      targetZ: null,
    });
    logic.update(0);

    // China should have gained credits.
    const chinaAfter = logic.getSideCredits('China');
    expect(chinaAfter).toBeGreaterThan(chinaBefore);

    // America should have lost credits.
    expect(logic.getSideCredits('America')).toBeLessThan(5000);
  });

  it('executes defector special power to convert enemy unit', () => {
    const logic = new GameLogicSubsystem();

    const defectorDef = makeObjectDef('Defector', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
      makeBlock('Behavior', 'DefectorSpecialPower DefectModule', {
        SpecialPowerTemplate: 'SpecialPowerDefector',
      }),
    ]);

    const enemyUnitDef = makeObjectDef('EnemyUnit', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [defectorDef, enemyUnitDef],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerDefector', { ReloadTime: 0 }),
      ],
    }));

    const map = makeMap([
      makeMapObject('Defector', 10, 10),
      makeMapObject('EnemyUnit', 20, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0); // enemies

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_DEFECT',
      specialPowerName: 'SpecialPowerDefector',
      commandOption: 0x01, // COMMAND_OPTION_NEED_TARGET_ENEMY_OBJECT
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: 2,
      targetX: null,
      targetZ: null,
    });
    logic.update(0);

    // The enemy unit should still be alive (defect, not destroyed).
    const convertedState = logic.getEntityState(2);
    expect(convertedState).not.toBeNull();
    expect(convertedState?.alive).toBe(true);
  });

  it('skirmish AI sends combat units to attack enemy when force threshold met', () => {
    const logic = new GameLogicSubsystem();

    // Create an AI base with several combat units.
    const aiTankDef = makeObjectDef('AITank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('Locomotor', 'Locomotor', { Speed: 15 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankGun'] }),
    ], { Speed: 15 });

    // High HP so the building survives long enough for the test to observe attack state.
    const enemyBuildingDef = makeObjectDef('EnemyHQ', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50000, InitialHealth: 50000 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [aiTankDef, enemyBuildingDef],
      weapons: [
        makeWeaponDef('TankGun', {
          AttackRange: 100,
          PrimaryDamage: 30,
          DelayBetweenShots: 100,
        }),
      ],
    }));

    // Place 5 AI tanks near each other and an enemy building far away.
    const map = makeMap([
      makeMapObject('AITank', 10, 10),
      makeMapObject('AITank', 15, 10),
      makeMapObject('AITank', 10, 15),
      makeMapObject('AITank', 15, 15),
      makeMapObject('AITank', 12, 12),
      makeMapObject('EnemyHQ', 50, 50),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('China', 'America', 0); // enemies

    // Enable skirmish AI for China.
    logic.enableSkirmishAI('China');

    // Run enough frames for AI to discover enemy and issue attack (90+ frames for combat eval).
    for (let i = 0; i < 100; i++) {
      logic.update(0.033);
    }

    // Verify at least some AI tanks are attacking the enemy building.
    let attackingCount = 0;
    for (let id = 1; id <= 5; id++) {
      const state = logic.getEntityState(id);
      if (state && state.attackTargetEntityId !== null) {
        attackingCount++;
      }
    }

    // AI should have issued attack commands to its idle units.
    expect(attackingCount).toBeGreaterThan(0);
  });

  it('skirmish AI replaces lost dozer by queueing production at a factory', () => {
    const logic = new GameLogicSubsystem();

    // Command center that can produce dozers.
    const commandCenterDef = makeObjectDef('CommandCenter', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2000, InitialHealth: 2000 }),
      makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
        MaxQueueEntries: 4,
      }),
      makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
        UnitCreatePoint: [0, 0, 5],
        ExitDelay: 0,
      }),
    ], {
      CommandSet: 'CommandCenterCommandSet',
    });

    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ], {
      BuildCost: 200,
      BuildTime: 0.1,
    });

    // Dummy enemy so AI has something to worry about.
    const enemyDef = makeObjectDef('EnemyUnit', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [commandCenterDef, dozerDef, enemyDef],
      commandButtons: [
        makeCommandButtonDef('Command_ConstructUSADozer', {
          Command: 'UNIT_BUILD',
          Object: 'USADozer',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandCenterCommandSet', {
          '1': 'Command_ConstructUSADozer',
        }),
      ],
    }));

    // Place only a command center (no dozer) and a distant enemy.
    const map = makeMap([
      makeMapObject('CommandCenter', 10, 10),
      makeMapObject('EnemyUnit', 50, 50),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 5000 });
    logic.enableSkirmishAI('America');

    // Run enough frames for dozer evaluation (60+ frames).
    for (let i = 0; i < 80; i++) {
      logic.update(1 / 30);
    }

    // Check that the command center has something in its production queue (dozer).
    const ccState = logic.getEntityState(1);
    // The AI should have queued a dozer or one should already be spawned.
    let hasDozer = false;
    for (const [, state] of (logic as any).spawnedEntities) {
      if (state.templateName.toUpperCase().includes('DOZER') && !state.destroyed) {
        hasDozer = true;
        break;
      }
    }
    // At minimum, the production queue should have been used.
    expect(ccState).not.toBeNull();
    // AI queued a dozer (it may have already spawned or still be in queue).
    const ccEntity = (logic as any).spawnedEntities.get(1);
    expect(hasDozer || ccEntity.productionQueue.length > 0).toBe(true);
  });

  it('skirmish AI researches upgrades at idle buildings', () => {
    const logic = new GameLogicSubsystem();

    const factoryDef = makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2000, InitialHealth: 2000 }),
      makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
        MaxQueueEntries: 4,
      }),
    ], {
      CommandSet: 'WarFactoryCommandSet',
    });

    const upgradeDef = makeUpgradeDef('Upgrade_WeaponBoost', {
      BuildCost: 500,
      BuildTime: 0.5,
      Type: 'PLAYER',
    });

    const registry = makeRegistry(makeBundle({
      objects: [factoryDef],
      upgrades: [upgradeDef],
      commandButtons: [
        makeCommandButtonDef('Command_UpgradeWeaponBoost', {
          Command: 'PLAYER_UPGRADE',
          Upgrade: 'Upgrade_WeaponBoost',
        }),
      ],
      commandSets: [
        makeCommandSetDef('WarFactoryCommandSet', {
          '1': 'Command_UpgradeWeaponBoost',
        }),
      ],
    }));

    const map = makeMap([makeMapObject('WarFactory', 10, 10)], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 5000 });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'COMPUTER' });
    logic.enableSkirmishAI('America');

    // Run enough frames for upgrade evaluation (120+ frames).
    for (let i = 0; i < 150; i++) {
      logic.update(1 / 30);
    }

    // Check if upgrade was queued or completed.
    const factoryEntity = (logic as any).spawnedEntities.get(1);
    const wasQueued = factoryEntity.productionQueue.length > 0
      || (logic as any).hasSideUpgradeCompleted('America', 'UPGRADE_WEAPONBOOST');
    expect(wasQueued).toBe(true);
  });

  it('skirmish AI sets rally points on factory buildings toward enemy', () => {
    const logic = new GameLogicSubsystem();

    const factoryDef = makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2000, InitialHealth: 2000 }),
      makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
        MaxQueueEntries: 4,
      }),
      makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
        UnitCreatePoint: [0, 0, 5],
        ExitDelay: 0,
      }),
    ]);

    const enemyDef = makeObjectDef('EnemyHQ', 'China', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50000, InitialHealth: 50000 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [factoryDef, enemyDef],
    }));

    // Factory at (10,10), enemy at (50,50).
    const map = makeMap([
      makeMapObject('WarFactory', 10, 10),
      makeMapObject('EnemyHQ', 50, 50),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.enableSkirmishAI('America');

    // Run frames for AI initialization + rally point setting.
    for (let i = 0; i < 100; i++) {
      logic.update(1 / 30);
    }

    // Rally point should be set on the factory, somewhere between factory and enemy.
    const factoryState = logic.getEntityState(1);
    expect(factoryState).not.toBeNull();
    if (factoryState!.rallyPoint) {
      // Rally point should be between factory (10,10) and enemy (50,50).
      expect(factoryState!.rallyPoint.x).toBeGreaterThan(10);
      expect(factoryState!.rallyPoint.z).toBeGreaterThan(10);
    }
  });

  it('skirmish AI uses multiple idle dozers for parallel construction', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Use simpler setup without command sets to rely on permissive fallback.
    const dozerDef = makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
        MaxQueueEntries: 4,
        QuantityModifier: ['USAPowerPlant 1', 'USABarracks 1'],
      }),
    ], {
      Speed: 30,
      GeometryMajorRadius: 3,
      GeometryMinorRadius: 3,
    });

    const powerPlantDef = makeObjectDef('USAPowerPlant', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], {
      BuildCost: 500,
      BuildTime: 2,
      EnergyBonus: 10,
      GeometryMajorRadius: 5,
      GeometryMinorRadius: 5,
    });

    const barracksDef = makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], {
      BuildCost: 500,
      BuildTime: 2,
      GeometryMajorRadius: 5,
      GeometryMinorRadius: 5,
    });

    const enemyDef = makeObjectDef('EnemyHQ', 'China', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50000, InitialHealth: 50000 }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [dozerDef, powerPlantDef, barracksDef, enemyDef],
      locomotors: [makeLocomotorDef('DozerLocomotor', 30)],
    }));

    // Two dozers spaced apart.
    const map = makeMap([
      makeMapObject('USADozer', 10, 10),
      makeMapObject('USADozer', 10, 15),
      makeMapObject('EnemyHQ', 50, 50),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 10000 });
    logic.enableSkirmishAI('America');

    // Run enough frames for structure evaluation + construction start.
    for (let i = 0; i < 90; i++) {
      logic.update(1 / 30);
    }

    // Count spawned structures (beyond the initial 3 entities).
    let structureCount = 0;
    for (const entity of (logic as any).spawnedEntities.values()) {
      if (entity.kindOf.has('STRUCTURE') && !entity.destroyed
        && entity.side?.toUpperCase() === 'AMERICA') {
        structureCount++;
      }
    }

    // AI should have started building at least one structure.
    expect(structureCount).toBeGreaterThanOrEqual(1);
  });
});

//  MinefieldBehavior collision-based detonation 

describe('mine detonation', () => {
  function makeMineSetup(opts: {
    detonatedBy?: string;
    numVirtualMines?: number;
    workersDetonate?: boolean;
    enemyKindOf?: string[];
    enemyGeomRadius?: number;
    mineGeomRadius?: number;
    mineHealth?: number;
    weaponDamage?: number;
    weaponRadius?: number;
  } = {}) {
    const mineDef = makeObjectDef('TestMine', 'America', ['MINE', 'IMMOBILE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', {
        MaxHealth: opts.mineHealth ?? 100,
        InitialHealth: opts.mineHealth ?? 100,
      }),
      makeBlock('Behavior', 'MinefieldBehavior ModuleTag_Minefield', {
        DetonationWeapon: 'MineDetonationWeapon',
        NumVirtualMines: opts.numVirtualMines ?? 1,
        ...(opts.detonatedBy ? { DetonatedBy: opts.detonatedBy } : {}),
        ...(opts.workersDetonate !== undefined ? { WorkersDetonate: opts.workersDetonate } : {}),
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: opts.mineGeomRadius ?? 5,
      GeometryMinorRadius: opts.mineGeomRadius ?? 5,
    });

    const enemyDef = makeObjectDef(
      'EnemyVehicle',
      'China',
      opts.enemyKindOf ?? ['VEHICLE'],
      [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ],
      {
        Geometry: 'CYLINDER',
        GeometryMajorRadius: opts.enemyGeomRadius ?? 3,
        GeometryMinorRadius: opts.enemyGeomRadius ?? 3,
      },
    );

    const registry = makeRegistry(makeBundle({
      objects: [mineDef, enemyDef],
      weapons: [
        makeWeaponDef('MineDetonationWeapon', {
          PrimaryDamage: opts.weaponDamage ?? 50,
          PrimaryDamageRadius: opts.weaponRadius ?? 10,
          DamageType: 'EXPLOSION',
        }),
      ],
    }));

    return { registry };
  }

  it('detonates mine when enemy overlaps mine geometry radius', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup();

    // Place mine at (10,10) and enemy at (12,10)  within combined radius (5+3=8).
    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 12, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0); // enemies

    // Mine should exist before update.
    const mineBefore = logic.getEntityState(1);
    expect(mineBefore).not.toBeNull();
    expect(mineBefore!.alive).toBe(true);

    // Run 1 frame  collision should detonate and destroy the 1-charge mine.
    logic.update(1 / 30);

    // Mine with 1 virtual mine is destroyed and cleaned up (returns null).
    const mineAfter = logic.getEntityState(1);
    expect(mineAfter).toBeNull();

    // Enemy should have taken detonation damage (50 damage, from 200  150).
    const enemyAfter = logic.getEntityState(2);
    expect(enemyAfter).not.toBeNull();
    expect(enemyAfter!.health).toBeLessThan(200);
  });

  it('does not detonate mine for allies (default detonatedBy = ENEMIES+NEUTRAL)', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup();

    // Place mine and an allied vehicle overlapping.
    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 12, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    // Set China as allies of America (2 = ALLIES)  mine should NOT detonate.
    logic.setTeamRelationship('America', 'China', 2);
    logic.setTeamRelationship('China', 'America', 2);

    logic.update(1 / 30);

    // Mine should still be alive  not detonated by ally.
    const mineAfter = logic.getEntityState(1);
    expect(mineAfter).not.toBeNull();
    expect(mineAfter!.alive).toBe(true);

    // Allied vehicle should be at full health.
    const allyAfter = logic.getEntityState(2);
    expect(allyAfter).not.toBeNull();
    expect(allyAfter!.health).toBe(200);
  });

  it('detonates mine for allies when DetonatedBy includes ALLIES', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup({ detonatedBy: 'ALLIES ENEMIES NEUTRAL' });

    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 12, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 2); // allies
    logic.setTeamRelationship('China', 'America', 2);

    logic.update(1 / 30);

    // Mine with 1 charge detonated for ally  destroyed and cleaned up.
    const mineAfter = logic.getEntityState(1);
    expect(mineAfter).toBeNull();
  });

  it('decrements virtual mine charges without destroying multi-charge mine', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup({ numVirtualMines: 3, mineHealth: 300 });

    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 12, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);

    logic.update(1 / 30);

    // Mine should still be alive with 2 charges remaining (health reduced proportionally).
    const mineAfter = logic.getEntityState(1);
    expect(mineAfter).not.toBeNull();
    expect(mineAfter!.alive).toBe(true);
    // Health reduced: 2/3 * 300 = 200.
    expect(mineAfter!.health).toBeLessThan(300);
  });

  it('does not detonate when entities are outside combined radius', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup();

    // Place mine at (10,10) and enemy at (30,10)  distance 20 > combined radius (5+3=8).
    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 30, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);

    logic.update(1 / 30);

    // Mine should be alive  no collision.
    const mineAfter = logic.getEntityState(1);
    expect(mineAfter).not.toBeNull();
    expect(mineAfter!.alive).toBe(true);

    // Enemy should be at full health.
    const enemyAfter = logic.getEntityState(2);
    expect(enemyAfter).not.toBeNull();
    expect(enemyAfter!.health).toBe(200);
  });

  it('does not detonate for worker units (infantry+dozer) when workersDetonate is false', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup({
      workersDetonate: false,
      enemyKindOf: ['INFANTRY', 'DOZER'],
    });

    // Place mine and infantry/dozer worker overlapping.
    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 12, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);

    logic.update(1 / 30);

    // Mine should NOT detonate for worker (infantry+dozer).
    const mineAfter = logic.getEntityState(1);
    expect(mineAfter).not.toBeNull();
    expect(mineAfter!.alive).toBe(true);
  });

  it('emits WEAPON_IMPACT visual event on mine detonation', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const { registry } = makeMineSetup();

    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('EnemyVehicle', 12, 10),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);

    logic.update(1 / 30);

    // Should have emitted visual events including a WEAPON_IMPACT for the detonation.
    const events = logic.drainVisualEvents();
    const impactEvents = events.filter(e => e.type === 'WEAPON_IMPACT');
    expect(impactEvents.length).toBeGreaterThanOrEqual(1);
  });

  it('sympathetically detonates when mine is shot by external weapon', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Mine with 3 charges and an attacker that can shoot the mine.
    const mineDef = makeObjectDef('TestMine', 'China', ['MINE', 'IMMOBILE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      makeBlock('Behavior', 'MinefieldBehavior ModuleTag_Minefield', {
        DetonationWeapon: 'MineDetonationWeapon',
        NumVirtualMines: 3,
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 5,
      GeometryMinorRadius: 5,
    });

    const attackerDef = makeObjectDef('MineShooter', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ShooterGun'] }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 3,
      GeometryMinorRadius: 3,
    });

    const registry = makeRegistry(makeBundle({
      objects: [mineDef, attackerDef],
      weapons: [
        makeWeaponDef('ShooterGun', {
          AttackRange: 200,
          PrimaryDamage: 150,
          DelayBetweenShots: 100,
        }),
        makeWeaponDef('MineDetonationWeapon', {
          PrimaryDamage: 40,
          PrimaryDamageRadius: 10,
          DamageType: 'EXPLOSION',
        }),
      ],
    }));

    // Place mine at (10,10) and attacker FAR away (50,10)  outside mine geometry.
    const map = makeMap([
      makeMapObject('TestMine', 10, 10),
      makeMapObject('MineShooter', 50, 10),
    ], 64, 64);

    logic.loadMapObjects(map, registry, makeHeightmap(64, 64));
    logic.setTeamRelationship('America', 'China', 0); // enemies
    logic.setTeamRelationship('China', 'America', 0);

    // Command attacker to shoot the mine.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Mine should exist before attack.
    const mineBefore = logic.getEntityState(1);
    expect(mineBefore).not.toBeNull();
    expect(mineBefore!.alive).toBe(true);

    // Run enough frames for the attacker to fire and deal 150 damage to a 300hp mine.
    // That should reduce health to 150/300 = 50%, expecting ceil(3*0.5) = 2 mines.
    // Since mine had 3 charges, it needs to detonate 1 charge sympathetically.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // After 150 damage to a 300hp 3-charge mine, at least 1 sympathetic detonation
    // should have occurred. Check if visual events include detonation impacts.
    const events = logic.drainVisualEvents();
    const mineDetonations = events.filter(e =>
      e.type === 'WEAPON_IMPACT' && e.sourceEntityId === 1,
    );
    // Should have at least one sympathetic detonation from the mine.
    expect(mineDetonations.length).toBeGreaterThanOrEqual(1);
  });
});

describe('tunnel network', () => {
  function makeTunnelSetup(opts: {
    maxTunnelCapacity?: number;
    timeForFullHealMs?: number;
    tunnelCount?: number;
    infantryHealth?: number;
    infantryMaxHealth?: number;
  } = {}) {
    const timeForFullHealMs = opts.timeForFullHealMs ?? 3000;
    const tunnelDef = makeObjectDef('GLATunnelNetwork', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'TunnelContain ModuleTag_Tunnel', {
        ...(timeForFullHealMs > 0 ? { TimeForFullHeal: timeForFullHealMs } : {}),
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 15,
      GeometryMinorRadius: 15,
    });

    const infantryDef = makeObjectDef('GLARebel', 'GLA', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', {
        MaxHealth: opts.infantryMaxHealth ?? 100,
        InitialHealth: opts.infantryHealth ?? (opts.infantryMaxHealth ?? 100),
      }),
    ]);

    const enemyTankDef = makeObjectDef('USATank', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankCannon'] }),
    ]);

    const tunnelCount = opts.tunnelCount ?? 1;
    const tunnelObjects: MapObjectJSON[] = [];
    for (let i = 0; i < tunnelCount; i++) {
      tunnelObjects.push(makeMapObject('GLATunnelNetwork', 50 + i * 40, 50));
    }

    const registry = makeRegistry(makeBundle({
      objects: [tunnelDef, infantryDef, enemyTankDef],
      weapons: [
        makeWeaponDef('TankCannon', { PrimaryDamage: 50, AttackRange: 100, DelayBetweenShots: 100, DamageType: 'ARMOR_PIERCING' }),
      ],
    }));

    return { registry, tunnelObjects, tunnelDef, infantryDef };
  }

  it('infantry enters tunnel and gets DISABLED_HELD + MASKED + UNSELECTABLE', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    const { registry, tunnelObjects } = makeTunnelSetup();

    const map = makeMap([
      ...tunnelObjects,
      makeMapObject('GLARebel', 50, 50),  // Adjacent to tunnel
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // Entity 1 = tunnel, entity 2 = infantry
    const infantryBefore = logic.getEntityState(2);
    expect(infantryBefore).not.toBeNull();
    expect(infantryBefore!.statusFlags).not.toContain('DISABLED_HELD');

    // Issue enter transport command to enter the tunnel.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    const infantryAfter = logic.getEntityState(2);
    expect(infantryAfter).not.toBeNull();
    expect(infantryAfter!.statusFlags).toContain('DISABLED_HELD');
    expect(infantryAfter!.statusFlags).toContain('MASKED');
    expect(infantryAfter!.statusFlags).toContain('UNSELECTABLE');
  });

  it('infantry exits tunnel and clears containment flags', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    const { registry, tunnelObjects } = makeTunnelSetup();

    const map = makeMap([
      ...tunnelObjects,
      makeMapObject('GLARebel', 50, 50),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // Enter tunnel.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    // Verify inside.
    expect(logic.getEntityState(2)!.statusFlags).toContain('DISABLED_HELD');

    // Exit container.
    logic.submitCommand({ type: 'exitContainer', entityId: 2 });
    logic.update(1 / 30);

    const infantryAfter = logic.getEntityState(2);
    expect(infantryAfter).not.toBeNull();
    expect(infantryAfter!.statusFlags).not.toContain('DISABLED_HELD');
    expect(infantryAfter!.statusFlags).not.toContain('MASKED');
    expect(infantryAfter!.statusFlags).not.toContain('UNSELECTABLE');
  });

  it('blocks aircraft from entering tunnel', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });

    const tunnelDef = makeObjectDef('GLATunnelNetwork', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'TunnelContain ModuleTag_Tunnel', {}),
    ]);
    const aircraftDef = makeObjectDef('GLAHelicopter', 'GLA', ['AIRCRAFT'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const registry = makeRegistry(makeBundle({ objects: [tunnelDef, aircraftDef] }));
    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),
      makeMapObject('GLAHelicopter', 50, 50),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    // Aircraft should NOT be inside tunnel  no DISABLED_HELD.
    const aircraft = logic.getEntityState(2);
    expect(aircraft).not.toBeNull();
    expect(aircraft!.statusFlags).not.toContain('DISABLED_HELD');
  });

  it('respects maxTunnelCapacity shared across tunnels', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 2 });
    const { registry } = makeTunnelSetup({ tunnelCount: 2 });

    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),   // Tunnel 1
      makeMapObject('GLATunnelNetwork', 90, 50),   // Tunnel 2
      makeMapObject('GLARebel', 50, 50),  // Infantry 1
      makeMapObject('GLARebel', 50, 50),  // Infantry 2
      makeMapObject('GLARebel', 90, 50),  // Infantry 3
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // Enter two infantry (fills capacity of 2).
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 4, targetTransportId: 1 });
    logic.update(1 / 30);

    expect(logic.getEntityState(3)!.statusFlags).toContain('DISABLED_HELD');
    expect(logic.getEntityState(4)!.statusFlags).toContain('DISABLED_HELD');

    // Third infantry tries to enter a DIFFERENT tunnel  should be rejected (shared capacity).
    logic.submitCommand({ type: 'enterTransport', entityId: 5, targetTransportId: 2 });
    logic.update(1 / 30);

    expect(logic.getEntityState(5)!.statusFlags).not.toContain('DISABLED_HELD');
  });

  it('cave-in kills all passengers when last tunnel destroyed', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    const { registry } = makeTunnelSetup();

    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),  // Single tunnel
      makeMapObject('GLARebel', 50, 50),
      makeMapObject('GLARebel', 50, 50),
      makeMapObject('USATank', 55, 50),  // Enemy near tunnel
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('GLA', 'America', 0); // enemies
    logic.setTeamRelationship('America', 'GLA', 0);

    // Enter both infantry.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    logic.update(1 / 30);

    expect(logic.getEntityState(2)!.statusFlags).toContain('DISABLED_HELD');
    expect(logic.getEntityState(3)!.statusFlags).toContain('DISABLED_HELD');

    // Enemy tank attacks the tunnel.
    logic.submitCommand({ type: 'attackEntity', entityId: 4, targetEntityId: 1 });
    // Run enough frames for the tank to destroy the 500hp tunnel (50 damage per shot).
    for (let i = 0; i < 120; i++) {
      logic.update(1 / 30);
    }

    // Tunnel is destroyed.
    const tunnel = logic.getEntityState(1);
    expect(tunnel).toBeNull();

    // Both passengers should be dead (cave-in).
    expect(logic.getEntityState(2)).toBeNull();
    expect(logic.getEntityState(3)).toBeNull();
  });

  it('reassigns passengers when non-last tunnel destroyed', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    const { registry } = makeTunnelSetup({ tunnelCount: 2 });

    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),  // Tunnel 1
      makeMapObject('GLATunnelNetwork', 90, 50),  // Tunnel 2
      makeMapObject('GLARebel', 50, 50),           // Infantry near tunnel 1
      makeMapObject('USATank', 55, 50),            // Enemy near tunnel 1
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);

    // Enter infantry into tunnel 1.
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    logic.update(1 / 30);

    expect(logic.getEntityState(3)!.statusFlags).toContain('DISABLED_HELD');

    // Enemy tank destroys tunnel 1 (non-last  tunnel 2 still exists).
    logic.submitCommand({ type: 'attackEntity', entityId: 4, targetEntityId: 1 });
    for (let i = 0; i < 120; i++) {
      logic.update(1 / 30);
    }

    // Tunnel 1 should be destroyed.
    expect(logic.getEntityState(1)).toBeNull();

    // Passenger should still be alive (reassigned to tunnel 2).
    const infantry = logic.getEntityState(3);
    expect(infantry).not.toBeNull();
    expect(infantry!.statusFlags).toContain('DISABLED_HELD');
  });

  it('evacuate command exits all passengers from tunnel', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    const { registry } = makeTunnelSetup();

    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),
      makeMapObject('GLARebel', 50, 50),
      makeMapObject('GLARebel', 50, 50),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // Enter both.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    logic.update(1 / 30);

    expect(logic.getEntityState(2)!.statusFlags).toContain('DISABLED_HELD');
    expect(logic.getEntityState(3)!.statusFlags).toContain('DISABLED_HELD');

    // Evacuate.
    logic.submitCommand({ type: 'evacuate', entityId: 1 });
    logic.update(1 / 30);

    expect(logic.getEntityState(2)!.statusFlags).not.toContain('DISABLED_HELD');
    expect(logic.getEntityState(3)!.statusFlags).not.toContain('DISABLED_HELD');
  });

  it('heals passengers inside tunnel over time', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    // 3000ms = 90 frames for full heal
    const { registry } = makeTunnelSetup({
      timeForFullHealMs: 3000,
      infantryHealth: 50,
      infantryMaxHealth: 100,
    });

    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),
      makeMapObject('GLARebel', 50, 50),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // Verify infantry starts at 50hp.
    expect(logic.getEntityState(2)!.health).toBe(50);

    // Enter tunnel.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    // Run 30 frames (~1 second) inside tunnel.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // Should have healed: 30 frames * (100 / 90) per frame  33 hp healed.
    // From 50  should be ~83.
    const afterPartial = logic.getEntityState(2);
    expect(afterPartial).not.toBeNull();
    expect(afterPartial!.health).toBeGreaterThan(70);
    expect(afterPartial!.health).toBeLessThan(100);

    // Run 60 more frames (total 90 = full heal time).
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    const afterFull = logic.getEntityState(2);
    expect(afterFull).not.toBeNull();
    expect(afterFull!.health).toBe(100);
  });

  it('selling last tunnel ejects passengers safely', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene, { maxTunnelCapacity: 10 });
    const { registry } = makeTunnelSetup();

    const map = makeMap([
      makeMapObject('GLATunnelNetwork', 50, 50),
      makeMapObject('GLARebel', 50, 50),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());

    // Enter tunnel.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    expect(logic.getEntityState(2)!.statusFlags).toContain('DISABLED_HELD');

    // Sell the tunnel.
    logic.submitCommand({ type: 'sell', entityId: 1 });
    logic.update(1 / 30);

    // Passenger should be ejected (not killed).
    const infantry = logic.getEntityState(2);
    expect(infantry).not.toBeNull();
    expect(infantry!.alive).toBe(true);
    expect(infantry!.statusFlags).not.toContain('DISABLED_HELD');
  });
});

//  Construction Progress System 

describe('construction progress', () => {
  function makeConstructionSetup(buildTimeSeconds = 2) {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], {
          GeometryMajorRadius: 5,
          GeometryMinorRadius: 5,
          Speed: 30,
        }),
        makeObjectDef('USAPowerPlant', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], {
          BuildCost: 500,
          BuildTime: buildTimeSeconds,
          EnergyBonus: 10,
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
      ],
      locomotors: [makeLocomotorDef('DozerLocomotor', 30)],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('USADozer', 16, 16)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 2000 });
    logic.update(1 / 30); // Process credits

    return { logic, scene };
  }

  it('building starts under construction with 0% and health=1 when dozer places it', () => {
    const { logic } = makeConstructionSetup(2);

    // Issue construct command  dozer at (16,16) builds at (20,20).
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USAPowerPlant',
      targetPosition: [20, 0, 20],
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30);

    // Building should exist with UNDER_CONSTRUCTION.
    const building = logic.getEntityState(2);
    expect(building).not.toBeNull();
    expect(building!.statusFlags).toContain('UNDER_CONSTRUCTION');
    expect(building!.constructionPercent).toBeGreaterThanOrEqual(0);
    expect(building!.constructionPercent).toBeLessThan(100);
    expect(building!.health).toBeLessThan(building!.maxHealth);

    // Credits should be deducted immediately.
    expect(logic.getSideCredits('America')).toBe(1500);
  });

  it('building completes construction after BuildTime seconds of dozer proximity', () => {
    const { logic } = makeConstructionSetup(1); // 1 second = 30 frames

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USAPowerPlant',
      targetPosition: [18, 0, 18], // Close to dozer at (16,16)
      angle: 0,
      lineEndPosition: null,
    });

    // Run for 31 frames (1 second + margin)  first frame places the building.
    for (let i = 0; i < 31; i++) {
      logic.update(1 / 30);
    }

    const building = logic.getEntityState(2);
    expect(building).not.toBeNull();
    expect(building!.statusFlags).not.toContain('UNDER_CONSTRUCTION');
    expect(building!.constructionPercent).toBe(-1); // CONSTRUCTION_COMPLETE
    expect(building!.health).toBe(building!.maxHealth);
  });

  it('building does not gain energy until construction completes', () => {
    const { logic } = makeConstructionSetup(1);

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USAPowerPlant',
      targetPosition: [18, 0, 18],
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30); // Place building

    // During construction, energy should not be contributed.
    const powerDuring = logic.getSidePowerState('America');
    expect(powerDuring.energyProduction).toBe(0);

    // Complete construction.
    for (let i = 0; i < 31; i++) {
      logic.update(1 / 30);
    }

    // After completion, energy should be registered.
    const powerAfter = logic.getSidePowerState('America');
    expect(powerAfter.energyProduction).toBe(10);
  });

  it('building under construction cannot attack', () => {
    const weaponBlock = makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'GatlingCannon'] });
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('USADefense', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          weaponBlock,
        ], { BuildCost: 300, BuildTime: 2, GeometryMajorRadius: 10, GeometryMinorRadius: 10 }),
        makeObjectDef('ChinaTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [makeWeaponDef('GatlingCannon', {
        AttackRange: 100, PrimaryDamage: 10, PrimaryDamageRadius: 0,
        DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL', DelayBetweenShots: 100,
      })],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('USADozer', 16, 16), makeMapObject('ChinaTank', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.setTeamRelationship('America', 'China', 0); // enemies
    logic.setTeamRelationship('China', 'America', 0);

    // Build the defense structure.
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USADefense',
      targetPosition: [18, 0, 18],
      angle: 0,
      lineEndPosition: null,
    });

    // Run a few frames  building is under construction.
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }

    const building = logic.getEntityState(3); // building is entity 3 (dozer=1, tank=2)
    expect(building).not.toBeNull();
    expect(building!.statusFlags).toContain('UNDER_CONSTRUCTION');

    // Tank should NOT be under attack from the building under construction.
    const tank = logic.getEntityState(2);
    expect(tank).not.toBeNull();
    expect(tank!.health).toBe(100); // Full health  not attacked.
  });

  it('dozer interrupted during construction leaves building partially built', () => {
    const { logic } = makeConstructionSetup(2); // 2 seconds = 60 frames

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USAPowerPlant',
      targetPosition: [18, 0, 18],
      angle: 0,
      lineEndPosition: null,
    });

    // Build for 15 frames (~25%).
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    const buildingMid = logic.getEntityState(2);
    expect(buildingMid).not.toBeNull();
    expect(buildingMid!.statusFlags).toContain('UNDER_CONSTRUCTION');
    const midPercent = buildingMid!.constructionPercent;
    expect(midPercent).toBeGreaterThan(0);
    expect(midPercent).toBeLessThan(100);

    // Interrupt: order dozer to move elsewhere.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 50, targetZ: 50 });
    logic.update(1 / 30);

    // Building should still be under construction at the same percent.
    const buildingAfter = logic.getEntityState(2);
    expect(buildingAfter).not.toBeNull();
    expect(buildingAfter!.statusFlags).toContain('UNDER_CONSTRUCTION');
    expect(buildingAfter!.constructionPercent).toBeCloseTo(midPercent, 0);
  });

  it('cancel construction refunds full cost and destroys building', () => {
    const { logic } = makeConstructionSetup(2);

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USAPowerPlant',
      targetPosition: [18, 0, 18],
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30);

    expect(logic.getSideCredits('America')).toBe(1500); // Deducted 500.

    // Cancel the construction.
    logic.submitCommand({ type: 'cancelDozerConstruction', entityId: 2 });
    logic.update(1 / 30);

    // Full cost refunded.
    expect(logic.getSideCredits('America')).toBe(2000);

    // Building should be destroyed.
    const building = logic.getEntityState(2);
    expect(building).toBeNull();
  });

  it('another dozer can resume partially built construction', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('USAPowerPlant', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], { BuildCost: 500, BuildTime: 2, GeometryMajorRadius: 10, GeometryMinorRadius: 10 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('USADozer', 14, 14), makeMapObject('USADozer', 30, 30)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 2000 });
    logic.update(1 / 30);

    // Dozer 1 starts building.
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'USAPowerPlant',
      targetPosition: [16, 0, 16],
      angle: 0,
      lineEndPosition: null,
    });

    // Build for 15 frames.
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    // Interrupt dozer 1.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 50, targetZ: 50 });
    logic.update(1 / 30);

    const buildingMid = logic.getEntityState(3);
    expect(buildingMid).not.toBeNull();
    expect(buildingMid!.statusFlags).toContain('UNDER_CONSTRUCTION');
    const midPercent = buildingMid!.constructionPercent;

    // Dozer 2 resumes construction (via repair command on partially built building).
    logic.submitCommand({ type: 'repairBuilding', entityId: 2, targetBuildingId: 3 });

    // Run enough frames for dozer 2 to reach the building and complete it.
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    const buildingFinal = logic.getEntityState(3);
    expect(buildingFinal).not.toBeNull();
    expect(buildingFinal!.statusFlags).not.toContain('UNDER_CONSTRUCTION');
    expect(buildingFinal!.constructionPercent).toBe(-1);
    expect(buildingFinal!.health).toBe(500);
  });
});

describe('slow death behavior', () => {
  function makeSlowDeathBundle(slowDeathFields: Record<string, unknown> = {}) {
    return makeBundle({
      objects: [
        makeObjectDef('SlowDeathUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SlowDeath', {
            DestructionDelay: 300, // 300ms = 9 frames
            SinkDelay: 100, // 100ms = 3 frames
            SinkRate: 0.5,
            ProbabilityModifier: 10,
            ...slowDeathFields,
          }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'InstantKillGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('InstantKillGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
  }

  it('delays entity destruction for the configured DestructionDelay', () => {
    const bundle = makeSlowDeathBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SlowDeathUnit', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Advance until the unit takes lethal damage and enters slow death.
    let enteredSlowDeath = false;
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
      const s = logic.getEntityState(1);
      if (s && s.health <= 0 && s.animationState === 'DIE') {
        enteredSlowDeath = true;
        break;
      }
    }
    expect(enteredSlowDeath).toBe(true);

    // Unit should be in slow death (health <= 0) but NOT destroyed yet at 5 frames.
    const midDeath = logic.getEntityState(1);
    expect(midDeath).not.toBeNull();
    expect(midDeath!.health).toBeLessThanOrEqual(0);
    expect(midDeath!.animationState).toBe('DIE');

    // Run past destructionDelay (9 frames from slow death start + margin).
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Now the entity should be fully destroyed and removed.
    const afterDestruction = logic.getEntityState(1);
    expect(afterDestruction).toBeNull();
  });

  it('sinks the entity below terrain after SinkDelay', () => {
    // SinkRate is in dist/sec  use 30 so per-frame rate = 1.0 for easy assertions.
    const bundle = makeSlowDeathBundle({ SinkRate: 30, SinkDelay: 100, DestructionDelay: 5000 });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SlowDeathUnit', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Advance until the unit enters slow death.
    let initialY = 0;
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
      const s = logic.getEntityState(1);
      if (s && s.health <= 0 && s.animationState === 'DIE') {
        initialY = s.y;
        break;
      }
    }

    // Run past sinkDelay (3 frames) + several more frames for sinking.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const afterSink = logic.getEntityState(1);
    expect(afterSink).not.toBeNull();
    expect(afterSink!.y).toBeLessThan(initialY);
  });

  it('prevents the dying entity from being targeted by other attackers', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SlowDeathUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SlowDeath', {
            DestructionDelay: 5000, // Very long death
            ProbabilityModifier: 10,
          }),
        ]),
        makeObjectDef('Attacker1', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
        ]),
        makeObjectDef('Attacker2', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('BigGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SlowDeathUnit', 50, 50),
        makeMapObject('Attacker1', 20, 50),
        makeMapObject('Attacker2', 80, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    // Attacker1 kills the unit.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    // Now attacker2 tries to target the dying entity.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    // Entity 1 should still be in slow death (alive but dying).
    const dyingState = logic.getEntityState(1);
    expect(dyingState).not.toBeNull();
    expect(dyingState!.animationState).toBe('DIE');
    // Attacker2's target should have been rejected (canTakeDamage = false).
    // The dying entity should not have taken additional damage beyond the first kill.
  });

  it('executes phase OCLs at INITIAL and FINAL phases', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SlowDeathWithOCL', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SlowDeath', {
            DestructionDelay: 200, // ~6 frames
            ProbabilityModifier: 10,
            OCL: ['INITIAL OCLDeathDebris', 'FINAL OCLFinalDebris'],
          }),
        ]),
        makeObjectDef('DeathDebris', 'America', ['INERT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
        ]),
        makeObjectDef('FinalDebris', 'America', ['INERT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'KillGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('KillGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
    // Add OCL definitions to the bundle.
    (bundle as Record<string, unknown>).objectCreationLists = [
      {
        name: 'OCLDeathDebris',
        fields: {},
        blocks: [{
          type: 'CreateObject',
          name: 'CreateObject',
          fields: { ObjectNames: 'DeathDebris', Count: '1' },
          blocks: [],
        }],
      },
      {
        name: 'OCLFinalDebris',
        fields: {},
        blocks: [{
          type: 'CreateObject',
          name: 'CreateObject',
          fields: { ObjectNames: 'FinalDebris', Count: '1' },
          blocks: [],
        }],
      },
    ];

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SlowDeathWithOCL', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill the unit  INITIAL phase should execute, spawning debris.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Check that debris was spawned by the INITIAL phase OCL.
    const initialStates = logic.getRenderableEntityStates();
    const initialDebris = initialStates.filter(s => s.templateName === 'DeathDebris');
    expect(initialDebris.length).toBeGreaterThanOrEqual(1);

    // Run past destructionDelay (~6 frames)  FINAL phase should fire OCLFinalDebris.
    for (let i = 0; i < 15; i++) logic.update(1 / 30);

    const finalStates = logic.getRenderableEntityStates();
    const finalDebris = finalStates.filter(s => s.templateName === 'FinalDebris');
    expect(finalDebris.length).toBeGreaterThanOrEqual(1);
  });

  it('selects from multiple SlowDeathBehavior modules via weighted probability', () => {
    // Entity with two SlowDeathBehavior modules of different probability.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('MultiDeathUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_Death1', {
            DestructionDelay: 100, // ~3 frames
            ProbabilityModifier: 1,
          }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_Death2', {
            DestructionDelay: 1000, // ~30 frames
            ProbabilityModifier: 1,
          }),
        ]),
        makeObjectDef('Killer', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'OHKGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('OHKGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('MultiDeathUnit', 50, 50),
        makeMapObject('Killer', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill the unit.
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    // Entity should be in slow death (one of the two profiles was selected).
    const dyingState = logic.getEntityState(1);
    expect(dyingState).not.toBeNull();
    expect(dyingState!.animationState).toBe('DIE');
    expect(dyingState!.health).toBeLessThanOrEqual(0);
  });

  it('excludes slow-death entities from victory condition counting', () => {
    const bundle = makeSlowDeathBundle({ DestructionDelay: 10000 });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SlowDeathUnit', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setPlayerSide(0, 'America');
    logic.setPlayerSide(1, 'China');
    logic.setSidePlayerType('America', 'HUMAN');
    logic.setSidePlayerType('China', 'HUMAN');
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Advance until the unit enters slow death.
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
      const s = logic.getEntityState(1);
      if (s && s.health <= 0 && s.animationState === 'DIE') break;
    }

    // Entity is in slow death but entity not yet destroyed.
    const dyingState = logic.getEntityState(1);
    expect(dyingState).not.toBeNull();
    expect(dyingState!.animationState).toBe('DIE');

    // Run a few more frames  victory should be detected even though entity hasn't
    // fully been destroyed yet, because slow-death entities are excluded from counting.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const gameEnd = logic.getGameEndState();
    expect(gameEnd).not.toBeNull();
    // China should win since America's only unit is in slow death.
    expect(gameEnd!.victorSides).toContain('china');
  });
});

describe('lifetime update', () => {
  it('destroys the entity after MinLifetime/MaxLifetime expires', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('DebrisChunk', 'America', ['INERT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'LifetimeUpdate ModuleTag_Lifetime', {
            MinLifetime: 300, // 9 frames
            MaxLifetime: 300, // 9 frames (exact for deterministic test)
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('DebrisChunk', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Entity should exist immediately.
    expect(logic.getEntityState(1)).not.toBeNull();

    // Run 5 frames  entity should still be alive.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    expect(logic.getEntityState(1)).not.toBeNull();
    expect(logic.getEntityState(1)!.health).toBe(10);

    // Run past the 9-frame lifetime + destruction.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Entity should be destroyed.
    expect(logic.getEntityState(1)).toBeNull();
  });

  it('triggers slow death when lifetime expires on an entity with SlowDeathBehavior', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TimedDeathUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'LifetimeUpdate ModuleTag_Lifetime', {
            MinLifetime: 200, // 6 frames
            MaxLifetime: 200,
          }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SlowDeath', {
            DestructionDelay: 5000, // 150 frames
            ProbabilityModifier: 10,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TimedDeathUnit', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Run past lifetime (6 frames) + a couple extra.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Entity should be in slow death (still rendered, animationState = DIE).
    const state = logic.getEntityState(1);
    expect(state).not.toBeNull();
    expect(state!.animationState).toBe('DIE');
    expect(state!.health).toBeLessThanOrEqual(0);
  });
});

describe('fire weapon when dead behavior', () => {
  it('fires the death weapon at entity position when the entity dies', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Bomber', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'FireWeaponWhenDeadBehavior ModuleTag_FWWD', {
            DeathWeapon: 'DeathExplosion',
            StartsActive: 'Yes',
          }),
        ]),
        makeObjectDef('Bystander', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'KillGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('KillGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
        makeWeaponDef('DeathExplosion', {
          AttackRange: 10,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 100, // Area damage to hit Bystander
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Bomber', 50, 50),
        makeMapObject('Bystander', 52, 50), // Close to Bomber
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });

    const bystanderBefore = logic.getEntityState(2);
    expect(bystanderBefore).not.toBeNull();
    expect(bystanderBefore!.health).toBe(200);

    // Kill the Bomber  death explosion should damage Bystander.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Bomber should be destroyed.
    expect(logic.getEntityState(1)).toBeNull();

    // Bystander should have taken damage from the death explosion.
    const bystanderAfter = logic.getEntityState(2);
    expect(bystanderAfter).not.toBeNull();
    expect(bystanderAfter!.health).toBeLessThan(200);
  });
});

describe('fire weapon when damaged behavior', () => {
  it('fires the reaction weapon when entity takes damage', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ToxicBuilding', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'FireWeaponWhenDamagedBehavior ModuleTag_FWWD', {
            ReactionWeaponPristine: 'ToxicSpray',
            ReactionWeaponDamaged: 'ToxicSprayDamaged',
            DamageAmount: 0,
          }),
        ]),
        makeObjectDef('NearbyUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('Attacker', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SmallGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('SmallGun', {
          AttackRange: 220,
          PrimaryDamage: 100,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
        makeWeaponDef('ToxicSpray', {
          AttackRange: 10,
          PrimaryDamage: 30,
          PrimaryDamageRadius: 100,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
        makeWeaponDef('ToxicSprayDamaged', {
          AttackRange: 10,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 100,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ToxicBuilding', 50, 50),
        makeMapObject('NearbyUnit', 52, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });

    const nearbyBefore = logic.getEntityState(2);
    expect(nearbyBefore).not.toBeNull();
    expect(nearbyBefore!.health).toBe(200);

    // Attack the building  reaction weapon should fire, damaging NearbyUnit.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const nearbyAfter = logic.getEntityState(2);
    expect(nearbyAfter).not.toBeNull();
    // NearbyUnit should have taken damage from the reaction weapon.
    expect(nearbyAfter!.health).toBeLessThan(200);
  });
});

describe('generate minefield behavior', () => {
  it('spawns mines around the entity on death when GenerateOnlyOnDeath is set', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('MineLayer', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'GenerateMinefieldBehavior ModuleTag_GenMine', {
            MineName: 'LandMine',
            DistanceAroundObject: 15,
            BorderOnly: true,
            GenerateOnlyOnDeath: true,
          }),
        ]),
        makeObjectDef('LandMine', 'China', ['MINE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
        makeObjectDef('Attacker', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'KillGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('KillGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('MineLayer', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // No mines should exist before death.
    const statesBefore = logic.getRenderableEntityStates();
    const minesBefore = statesBefore.filter(s => s.templateName === 'LandMine');
    expect(minesBefore.length).toBe(0);

    // Kill the MineLayer.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // MineLayer should be destroyed.
    expect(logic.getEntityState(1)).toBeNull();

    // Mines should have been spawned in a circle around the MineLayer's position.
    const statesAfter = logic.getRenderableEntityStates();
    const minesAfter = statesAfter.filter(s => s.templateName === 'LandMine');
    expect(minesAfter.length).toBeGreaterThan(0);

    // All mines should be approximately 15 units away from the original position (50,50).
    for (const mine of minesAfter) {
      const dx = mine.x - 50;
      const dz = mine.z - 50;
      const dist = Math.sqrt(dx * dx + dz * dz);
      expect(dist).toBeCloseTo(15, 0);
    }
  });
});

describe('deploy style AI update', () => {
  function makeDeploySetup(opts: { unpackTime?: number; packTime?: number } = {}) {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Artillery', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Behavior', 'DeployStyleAIUpdate ModuleTag_Deploy', {
            UnpackTime: opts.unpackTime ?? 300,
            PackTime: opts.packTime ?? 300,
          }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ArtilleryGun'] }),
          makeBlock('Locomotor', 'SET_NORMAL ArtilleryLocomotor', { Speed: 30 }),
        ]),
        makeObjectDef('Target', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SmallGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('ArtilleryGun', {
          AttackRange: 200,
          PrimaryDamage: 100,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
        makeWeaponDef('SmallGun', {
          AttackRange: 200,
          PrimaryDamage: 10,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Artillery', 50, 50),
        makeMapObject('Target', 80, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    return { logic };
  }

  it('deploys before attacking and undeploys before moving', () => {
    const { logic } = makeDeploySetup({ unpackTime: 300, packTime: 300 });
    // 300ms  ceil(300/33.33) = 9 frames

    // Artillery should start in READY_TO_MOVE state.
    let state = logic.getEntityState(1);
    expect(state).not.toBeNull();
    expect(state!.health).toBe(200);

    // Issue attack command  this should start deploying.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
    logic.update(1 / 30); // frame 1

    // Target should NOT have taken damage yet (still deploying).
    const targetAfter1 = logic.getEntityState(2);
    expect(targetAfter1).not.toBeNull();
    expect(targetAfter1!.health).toBe(500);

    // Run 8 more frames to complete deploy (9 frames total for 300ms).
    for (let i = 0; i < 8; i++) logic.update(1 / 30);

    // After 9 frames, should be READY_TO_ATTACK. Run 1 more frame to let combat fire.
    logic.update(1 / 30);

    // Target should have taken damage now.
    const targetAfterDeploy = logic.getEntityState(2);
    expect(targetAfterDeploy).not.toBeNull();
    expect(targetAfterDeploy!.health).toBeLessThan(500);
  });

  it('cannot fire during deploy animation and does not move while deployed', () => {
    const { logic } = makeDeploySetup({ unpackTime: 300, packTime: 300 });
    // 300ms  9 frames for deploy/undeploy

    // Issue attack  entity starts deploying.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    // Run 5 frames (mid-deploy). Target should not be damaged yet.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    const targetMidDeploy = logic.getEntityState(2);
    expect(targetMidDeploy).not.toBeNull();
    expect(targetMidDeploy!.health).toBe(500); // Still full health during deploy animation

    // Run to completion of deploy (4 more frames to reach 9) + 1 extra for combat.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // After deploy completes, the entity should start firing.
    // Run several more frames to ensure at least one shot lands.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    const targetAfterDeploy = logic.getEntityState(2);
    expect(targetAfterDeploy).not.toBeNull();
    expect(targetAfterDeploy!.health).toBeLessThan(500); // Took damage after full deploy

    // Verify entity hasn't moved (deployed entities can't move).
    const artilleryState = logic.getEntityState(1);
    expect(artilleryState).not.toBeNull();
    expect(artilleryState!.x).toBe(50); // Stayed at initial position
  });

  it('reverses deploy mid-transition when move command is issued', () => {
    const { logic } = makeDeploySetup({ unpackTime: 600, packTime: 600 });
    // 600ms  ceil(600/33.33) = 18 frames

    // Issue attack to start deploying.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });
    // Run 6 frames (1/3 through deploy).
    for (let i = 0; i < 6; i++) logic.update(1 / 30);

    // Target should still be at full health (not deployed yet).
    const targetMidDeploy = logic.getEntityState(2);
    expect(targetMidDeploy!.health).toBe(500);

    // Issue move command to reverse the deploy.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 10, targetZ: 50 });

    // The reversal should take 18 - (18 - 6) = 6 frames remaining  total = 6 frames to undeploy.
    // But actually the reversal formula is: totalFrames - framesLeft = 18 - 12 = 6 frames done,
    // new wait = now + (18 - 12) = 6 more frames.
    // So after 6 more frames from now, should be READY_TO_MOVE.
    for (let i = 0; i < 8; i++) logic.update(1 / 30);

    // Should have started moving by now.
    const afterReversal = logic.getEntityState(1);
    expect(afterReversal).not.toBeNull();
    // Even if not moved far, at least the entity should be alive and not stuck.
    expect(afterReversal!.health).toBe(200);
  });
});

//  Garrison firing tests 

describe('garrison firing', () => {
  function makeGarrisonSetup() {
    const buildingDef = makeObjectDef('CivBuilding', 'Neutral', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'GarrisonContain ModuleTag_Garrison', {
        ContainMax: 5,
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 15,
      GeometryMinorRadius: 15,
    });

    const infantryDef = makeObjectDef('USARanger', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'RangerRifle'] }),
      makeBlock('Locomotor', 'SET_NORMAL InfantryLocomotor', { Speed: 20 }),
    ]);

    const enemyTankDef = makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    const bundle = makeBundle({
      objects: [buildingDef, infantryDef, enemyTankDef],
      weapons: [
        makeWeaponDef('RangerRifle', {
          AttackRange: 100,
          PrimaryDamage: 25,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 500,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Building at 50,50; infantry close enough to enter immediately; enemy nearby.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CivBuilding', 50, 50),
        makeMapObject('USARanger', 51, 50),
        makeMapObject('EnemyTank', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'Neutral', 2);
    logic.setTeamRelationship('Neutral', 'America', 2);
    return { logic };
  }

  it('garrisoned infantry auto-targets and damages nearby enemy', () => {
    const { logic } = makeGarrisonSetup();

    // Enter garrison.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.update(1 / 30);

    // Verify infantry entered the garrison.
    const infantryState = logic.getEntityState(2);
    // Infantry at building position now.
    expect(infantryState).not.toBeNull();

    // Tick enough frames for auto-targeting scan and weapon firing.
    const enemyBefore = logic.getEntityState(3);
    expect(enemyBefore).not.toBeNull();
    const initialHealth = enemyBefore!.health;
    expect(initialHealth).toBe(500);

    // Run 90 frames (~3 seconds)  should be enough for auto-target + fire cycle.
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    const enemyAfter = logic.getEntityState(3);
    expect(enemyAfter).not.toBeNull();
    expect(enemyAfter!.health).toBeLessThan(initialHealth);
  });
});

//  Special power INI parameter tests 

describe('special power INI parameters', () => {
  it('area damage uses module radius and damage from INI', () => {
    const superWeaponDef = makeObjectDef('SuperWeapon', 'America', ['STRUCTURE', 'FS_SUPERWEAPON'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SP', {
        SpecialPowerTemplate: 'SuperTestPower',
        Radius: 50,
        Damage: 300,
      }),
    ]);

    const targetDef = makeObjectDef('Target', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ]);

    // Target slightly outside 50-unit radius (should NOT be hit).
    const farTargetDef = makeObjectDef('FarTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
    ]);

    const bundle = makeBundle({
      objects: [superWeaponDef, targetDef, farTargetDef],
      specialPowers: [{ name: 'SuperTestPower', fields: {}, blocks: [] } as SpecialPowerDef],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // SuperWeapon at 50,50; Target at 80,50 (30 units away, within 50 radius);
    // FarTarget at 120,50 (70 units away, outside 50 radius).
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SuperWeapon', 50, 50),
        makeMapObject('Target', 80, 50),
        makeMapObject('FarTarget', 120, 50),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(1 / 30);

    // Issue area damage special power at center (50, 50).
    // commandOption 0x20 = COMMAND_OPTION_NEED_TARGET_POS (position-targeted power).
    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'SuperTestButton',
      specialPowerName: 'SuperTestPower',
      commandOption: 0x20,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: 50,
      targetZ: 50,
    });
    logic.update(1 / 30);

    // Close target (30 units away, within 50 radius) should take 300 damage.
    const closeTarget = logic.getEntityState(2);
    expect(closeTarget).not.toBeNull();
    expect(closeTarget!.health).toBe(700);

    // Far target (70 units away, outside 50 radius) should be unharmed.
    const farTarget = logic.getEntityState(3);
    expect(farTarget).not.toBeNull();
    expect(farTarget!.health).toBe(1000);
  });
});

//  Mine regeneration via auto-heal 

describe('mine regeneration', () => {
  it('regenerating mine recovers virtual mines through auto-heal', () => {
    const mineDef = makeObjectDef('RegenMine', 'America', ['MINE', 'IMMOBILE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', {
        MaxHealth: 100,
        InitialHealth: 100,
      }),
      makeBlock('Behavior', 'MinefieldBehavior ModuleTag_Minefield', {
        DetonationWeapon: 'MineDetonationWeapon',
        NumVirtualMines: 2,
        Regenerates: true,
      }),
      makeBlock('Behavior', 'AutoHealBehavior ModuleTag_AutoHeal', {
        HealingAmount: 10,
        HealingDelay: 100,
        StartHealingDelay: 0,
        StartsActive: true,
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 5,
      GeometryMinorRadius: 5,
    });

    const enemyDef = makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 3,
      GeometryMinorRadius: 3,
    });

    const bundle = makeBundle({
      objects: [mineDef, enemyDef],
      weapons: [
        makeWeaponDef('MineDetonationWeapon', {
          PrimaryDamage: 30,
          PrimaryDamageRadius: 10,
          DamageType: 'EXPLOSION',
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Mine at 50,50; enemy close enough to detonate.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('RegenMine', 50, 50),
        makeMapObject('EnemyVehicle', 52, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Run a few frames to trigger mine detonation (enemy overlaps mine).
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // After detonation, enemy should have taken damage.
    const enemyAfterDetonation = logic.getEntityState(2);
    expect(enemyAfterDetonation).not.toBeNull();
    expect(enemyAfterDetonation!.health).toBeLessThan(500);

    // Move enemy away so it doesn't keep triggering detonations.
    logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: 120, targetZ: 50 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Mine should be MASKED (all virtual mines spent) with health floor at 0.1.
    const mineState = logic.getEntityState(1);
    expect(mineState).not.toBeNull();
    // Mine lost health from detonation and is now low or at floor.

    // Run many frames to let auto-heal restore health.
    // HealingAmount=10, delay=100ms(~3 frames), maxHealth=100.
    // After enough healing cycles, virtual mines should regenerate.
    for (let i = 0; i < 120; i++) logic.update(1 / 30);

    // Mine should have healed and recovered at least 1 virtual mine (un-masked).
    const mineAfterHeal = logic.getEntityState(1);
    expect(mineAfterHeal).not.toBeNull();
    // If health is above 50% of maxHealth, at least 1 virtual mine should be restored.
    // The mine should be alive (not destroyed).
    expect(mineAfterHeal!.health).toBeGreaterThan(0);
  });
});

describe('WEAPON_DOESNT_AFFECT_AIRBORNE', () => {
  it('skips entities significantly above terrain in radius damage', () => {
    // Source parity: Weapon.cpp:1375  NOT_AIRBORNE in RadiusDamageAffects
    // skips targets where isSignificantlyAboveTerrain() is true (height > 9.0).
    const launcherDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'GroundBomb'] }),
    ]);
    const groundTargetDef = makeObjectDef('GroundTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const airTargetDef = makeObjectDef('AirTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const bundle = makeBundle({
      objects: [launcherDef, groundTargetDef, airTargetDef],
      weapons: [
        makeWeaponDef('GroundBomb', {
          AttackRange: 120,
          PrimaryDamage: 30,
          PrimaryDamageRadius: 100,
          DamageType: 'EXPLOSION',
          DeathType: 'NORMAL',
          RadiusDamageAffects: 'ENEMIES NOT_AIRBORNE',
          DelayBetweenShots: 100,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Attacker', 10, 10),
        makeMapObject('GroundTarget', 30, 10),
        makeMapObject('AirTarget', 30, 12),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Elevate entity 3 by 20 units above its base position (>9.0 threshold).
    const entities = (logic as unknown as { spawnedEntities: Map<number, { y: number; baseHeight: number }> }).spawnedEntities;
    const airEntity = entities.get(3)!;
    airEntity.y += 20;

    // Attack ground target.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    // Run enough frames for weapon to fire (matches existing combat timeline pattern).
    for (let i = 0; i < 6; i++) logic.update(1 / 30);

    // Ground target should have taken radius damage.
    const groundState = logic.getEntityState(2);
    expect(groundState).not.toBeNull();
    expect(groundState!.health).toBeLessThan(100);

    // Air target should NOT have taken radius damage (NOT_AIRBORNE filter).
    const airState = logic.getEntityState(3);
    expect(airState).not.toBeNull();
    expect(airState!.health).toBe(100);
  });
});

//  Disabled entity restrictions 

describe('disabled entity movement restrictions', () => {
  function makeMovementSetup() {
    const tankDef = makeObjectDef('TestTank', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Locomotor', 'SET_NORMAL TankLocomotor', { Speed: 30 }),
    ]);

    const bundle = makeBundle({ objects: [tankDef], weapons: [] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestTank', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    return { logic };
  }

  it('DISABLED_EMP blocks movement', () => {
    // Source parity: Object::isMobile() returns false when isDisabled() is true.
    const { logic } = makeMovementSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { objectStatusFlags: Set<string>; x: number; z: number }> };
    const entity = priv.spawnedEntities.get(1)!;
    const startX = entity.x;
    const startZ = entity.z;

    entity.objectStatusFlags.add('DISABLED_EMP');
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 100, targetZ: 100 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Entity should not have moved.
    expect(entity.x).toBe(startX);
    expect(entity.z).toBe(startZ);
  });

  it('DISABLED_HACKED blocks movement', () => {
    const { logic } = makeMovementSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { objectStatusFlags: Set<string>; x: number; z: number }> };
    const entity = priv.spawnedEntities.get(1)!;
    const startX = entity.x;

    entity.objectStatusFlags.add('DISABLED_HACKED');
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 100, targetZ: 100 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(entity.x).toBe(startX);
  });

  it('DISABLED_SUBDUED blocks movement', () => {
    const { logic } = makeMovementSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { objectStatusFlags: Set<string>; x: number; z: number }> };
    const entity = priv.spawnedEntities.get(1)!;
    const startX = entity.x;

    entity.objectStatusFlags.add('DISABLED_SUBDUED');
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 100, targetZ: 100 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(entity.x).toBe(startX);
  });
});

describe('disabled container evacuation restrictions', () => {
  function makeGarrisonEvacSetup() {
    const buildingDef = makeObjectDef('CivBuilding', 'Neutral', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'GarrisonContain ModuleTag_Garrison', {
        ContainMax: 5,
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 15,
      GeometryMinorRadius: 15,
    });

    const infantryDef = makeObjectDef('USARanger', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Locomotor', 'SET_NORMAL InfantryLocomotor', { Speed: 20 }),
    ]);

    const bundle = makeBundle({ objects: [buildingDef, infantryDef], weapons: [] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CivBuilding', 50, 50),
        makeMapObject('USARanger', 51, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'Neutral', 2);
    logic.setTeamRelationship('Neutral', 'America', 2);
    return { logic };
  }

  it('DISABLED_SUBDUED blocks evacuation from garrisoned building', () => {
    // Source parity: AIUpdate::privateEvacuate  DISABLED_SUBDUED container blocks evacuation.
    const { logic } = makeGarrisonEvacSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { objectStatusFlags: Set<string>; garrisonContainerId: number | null }> };

    // Enter garrison.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.update(1 / 30);

    // Verify infantry is garrisoned.
    const infantry = priv.spawnedEntities.get(2)!;
    expect(infantry.garrisonContainerId).toBe(1);

    // Subdue the building (e.g., Microwave Tank).
    const building = priv.spawnedEntities.get(1)!;
    building.objectStatusFlags.add('DISABLED_SUBDUED');

    // Attempt evacuation  should be blocked.
    logic.submitCommand({ type: 'evacuate', entityId: 1 });
    logic.update(1 / 30);

    // Infantry should still be garrisoned.
    expect(infantry.garrisonContainerId).toBe(1);
  });

  it('DISABLED_SUBDUED blocks individual exit from garrisoned building', () => {
    // Source parity: AIUpdate::privateExit  DISABLED_SUBDUED container blocks passenger exit.
    const { logic } = makeGarrisonEvacSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { objectStatusFlags: Set<string>; garrisonContainerId: number | null }> };

    // Enter garrison.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.update(1 / 30);

    const infantry = priv.spawnedEntities.get(2)!;
    expect(infantry.garrisonContainerId).toBe(1);

    // Subdue the building.
    const building = priv.spawnedEntities.get(1)!;
    building.objectStatusFlags.add('DISABLED_SUBDUED');

    // Attempt individual exit  should be blocked.
    logic.submitCommand({ type: 'exitContainer', entityId: 2 });
    logic.update(1 / 30);

    // Infantry should still be garrisoned.
    expect(infantry.garrisonContainerId).toBe(1);
  });

  it('evacuation works when building is NOT subdued', () => {
    const { logic } = makeGarrisonEvacSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { garrisonContainerId: number | null }> };

    // Enter garrison.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.update(1 / 30);

    const infantry = priv.spawnedEntities.get(2)!;
    expect(infantry.garrisonContainerId).toBe(1);

    // Evacuate without subdued status  should work.
    logic.submitCommand({ type: 'evacuate', entityId: 1 });
    logic.update(1 / 30);

    // Infantry should have exited.
    expect(infantry.garrisonContainerId).toBeNull();
  });
});

//  DISABLED_UNDERPOWERED (power brown-out) tests 

describe('DISABLED_UNDERPOWERED power brown-out', () => {
  function makePowerSetup() {
    // Power plant: produces 5 energy, is POWERED itself.
    const powerPlantDef = makeObjectDef('PowerPlant', 'America', ['STRUCTURE', 'POWERED'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], { EnergyBonus: 5 });

    // Barracks: consumes 3 energy, is POWERED (will be disabled when underpowered).
    const barracksDef = makeObjectDef('Barracks', 'America', ['STRUCTURE', 'POWERED'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], { EnergyBonus: -3 });

    // Non-POWERED building: never gets DISABLED_UNDERPOWERED.
    const wallDef = makeObjectDef('Wall', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const bundle = makeBundle({ objects: [powerPlantDef, barracksDef, wallDef], weapons: [] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    return { logic, bundle };
  }

  it('sets DISABLED_UNDERPOWERED on POWERED entities when power drops below consumption', () => {
    // Source parity: Player::onPowerBrownOutChange + doPowerDisable.
    const { logic, bundle } = makePowerSetup();
    // Power plant produces 5, barracks consumes 3, barracks2 consumes 3 = 6 consumption, 5 production  brownout.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('Barracks', 80, 50),
        makeMapObject('Barracks', 80, 80),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Initial state: no brownout yet (check happens on update).
    logic.update(1 / 30);

    // Check power state: production=5, consumption=6  brownout.
    const state1 = logic.getEntityState(1)!;
    const state2 = logic.getEntityState(2)!;
    const state3 = logic.getEntityState(3)!;

    // Power plant is POWERED so it gets DISABLED_UNDERPOWERED too.
    expect(state1.statusFlags).toContain('DISABLED_UNDERPOWERED');
    expect(state2.statusFlags).toContain('DISABLED_UNDERPOWERED');
    expect(state3.statusFlags).toContain('DISABLED_UNDERPOWERED');
  });

  it('does NOT set DISABLED_UNDERPOWERED when power is sufficient', () => {
    const { logic, bundle } = makePowerSetup();
    // Power plant produces 5, barracks consumes 3 = sufficient power.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('Barracks', 80, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.update(1 / 30);

    const state1 = logic.getEntityState(1)!;
    const state2 = logic.getEntityState(2)!;
    expect(state1.statusFlags).not.toContain('DISABLED_UNDERPOWERED');
    expect(state2.statusFlags).not.toContain('DISABLED_UNDERPOWERED');
  });

  it('does NOT set DISABLED_UNDERPOWERED on non-POWERED buildings', () => {
    const { logic, bundle } = makePowerSetup();
    // Even with brownout, Wall (no POWERED kindof) should not be disabled.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Barracks', 50, 50),
        makeMapObject('Barracks', 80, 50),
        makeMapObject('Wall', 80, 80),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.update(1 / 30);

    // No power plant  0 production, 6 consumption  brownout.
    const barrState = logic.getEntityState(1)!;
    const wallState = logic.getEntityState(3)!;
    expect(barrState.statusFlags).toContain('DISABLED_UNDERPOWERED');
    expect(wallState.statusFlags).not.toContain('DISABLED_UNDERPOWERED');
  });

  it('clears DISABLED_UNDERPOWERED when power is restored via destruction of consumer', () => {
    const { logic, bundle } = makePowerSetup();
    // Power plant (5), barracks (3), barracks (3)  brownout.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('Barracks', 80, 50),
        makeMapObject('Barracks', 80, 80),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.update(1 / 30);
    expect(logic.getEntityState(1)!.statusFlags).toContain('DISABLED_UNDERPOWERED');

    // Destroy one barracks to restore power balance: 5 production, 3 consumption  sufficient.
    const priv = logic as unknown as { markEntityDestroyed: (id: number, attackerId: number) => void };
    priv.markEntityDestroyed(3, -1);
    logic.update(1 / 30);

    // Power should be restored.
    expect(logic.getEntityState(1)!.statusFlags).not.toContain('DISABLED_UNDERPOWERED');
    expect(logic.getEntityState(2)!.statusFlags).not.toContain('DISABLED_UNDERPOWERED');
  });
});

describe('radar disable during power brown-out', () => {
  function makeRadarSetup() {
    // Power plant: produces 5 energy.
    const powerPlantDef = makeObjectDef('PowerPlant', 'America', ['STRUCTURE', 'POWERED'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], { EnergyBonus: 5 });

    // Command center with radar upgrade: consumes 3 energy, has radar.
    const commandCenterDef = makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'POWERED'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'RadarUpgrade ModuleTag_Radar', {
        TriggeredBy: 'Upgrade_Radar',
        DisableProof: false,
      }),
    ], { EnergyBonus: -3 });

    // Command center with disable-proof radar.
    const hardCommandCenterDef = makeObjectDef('HardCommandCenter', 'America', ['STRUCTURE', 'POWERED'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'RadarUpgrade ModuleTag_DisableProofRadar', {
        TriggeredBy: 'Upgrade_Radar',
        DisableProof: true,
      }),
    ], { EnergyBonus: -3 });

    // Barracks: consumes 3 energy.
    const barracksDef = makeObjectDef('Barracks', 'America', ['STRUCTURE', 'POWERED'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], { EnergyBonus: -3 });

    const bundle = makeBundle({
      objects: [powerPlantDef, commandCenterDef, hardCommandCenterDef, barracksDef],
      weapons: [],
      upgrades: [makeUpgradeDef('Upgrade_Radar', { Type: 'OBJECT', BuildTime: 0.1, BuildCost: 0 })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    return { logic, bundle };
  }

  it('disables radar when power brown-out occurs', () => {
    const { logic, bundle } = makeRadarSetup();
    // Power plant (5), CommandCenter (-3), Barracks (-3)  5 < 6  brownout.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('CommandCenter', 80, 50),
        makeMapObject('Barracks', 110, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Grant the radar upgrade to the command center.
    logic.applyUpgradeToEntity(2, 'Upgrade_Radar');
    logic.update(1 / 30);

    // Should have radar disabled due to brown-out.
    expect(logic.hasRadar('America')).toBe(false);
    const radarState = logic.getSideRadarState('America');
    expect(radarState.radarCount).toBe(1);
    expect(radarState.radarDisabled).toBe(true);
  });

  it('radar works when power is sufficient', () => {
    const { logic, bundle } = makeRadarSetup();
    // Power plant (5), CommandCenter (-3)  5 >= 3  no brownout.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('CommandCenter', 80, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.applyUpgradeToEntity(2, 'Upgrade_Radar');
    logic.update(1 / 30);

    expect(logic.hasRadar('America')).toBe(true);
    const radarState = logic.getSideRadarState('America');
    expect(radarState.radarCount).toBe(1);
    expect(radarState.radarDisabled).toBe(false);
  });

  it('disable-proof radar survives brown-out', () => {
    const { logic, bundle } = makeRadarSetup();
    // Power plant (5), HardCommandCenter (-3), Barracks (-3)  brownout.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('HardCommandCenter', 80, 50),
        makeMapObject('Barracks', 110, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.applyUpgradeToEntity(2, 'Upgrade_Radar');
    logic.update(1 / 30);

    // Brown-out should be active, but disable-proof radar still works.
    const radarState = logic.getSideRadarState('America');
    expect(radarState.radarDisabled).toBe(true);
    expect(radarState.disableProofRadarCount).toBe(1);
    expect(logic.hasRadar('America')).toBe(true);
  });

  it('restores radar when power is recovered', () => {
    const { logic, bundle } = makeRadarSetup();
    // Power plant (5), CommandCenter (-3), Barracks (-3)  brownout.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 50, 50),
        makeMapObject('CommandCenter', 80, 50),
        makeMapObject('Barracks', 110, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.applyUpgradeToEntity(2, 'Upgrade_Radar');
    logic.update(1 / 30);
    expect(logic.hasRadar('America')).toBe(false);

    // Destroy barracks to restore power: 5 production, 3 consumption  sufficient.
    const priv = logic as unknown as { markEntityDestroyed: (id: number, attackerId: number) => void };
    priv.markEntityDestroyed(3, -1);
    logic.update(1 / 30);

    expect(logic.hasRadar('America')).toBe(true);
    expect(logic.getSideRadarState('America').radarDisabled).toBe(false);
  });
});

describe('3D damage distance with terrain elevation', () => {
  it('excludes entities on elevated terrain from ground-level radius damage when 3D distance exceeds weapon radius', () => {
    // Build a heightmap where columns 4+ are at raw value 160  100 world height.
    // Columns 0-3 stay at 0 (ground level).
    const hmWidth = 64;
    const hmHeight = 64;
    const rawData = new Uint8Array(hmWidth * hmHeight);
    for (let row = 0; row < hmHeight; row++) {
      for (let col = 0; col < hmWidth; col++) {
        rawData[row * hmWidth + col] = col >= 4 ? 160 : 0;
      }
    }
    const heightmap = HeightmapGrid.fromJSON({
      width: hmWidth,
      height: hmHeight,
      borderSize: 0,
      data: uint8ArrayToBase64(rawData),
    });

    // Weapon: DIRECT, large radius (25 world units), instant damage.
    const attackerDef = makeObjectDef('ElevAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ElevRadiusCannon'] }),
    ]);
    const groundTargetDef = makeObjectDef('GroundTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);
    const cliffTargetDef = makeObjectDef('CliffTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const bundle = makeBundle({
      objects: [attackerDef, groundTargetDef, cliffTargetDef],
      weapons: [
        makeWeaponDef('ElevRadiusCannon', {
          AttackRange: 200,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 25,
          SecondaryDamage: 25,
          SecondaryDamageRadius: 25,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Attacker at (10,10)  ground (col 1).
    // GroundTarget at (20,10)  ground (col 2), XZ distance 10 from impact.
    // CliffTarget at (40,10)  elevated (col 4, height ~100), XZ distance 20 from impact.
    // Impact will be at GroundTarget position.
    logic.loadMapObjects(
      {
        heightmap: {
          width: hmWidth,
          height: hmHeight,
          borderSize: 0,
          data: uint8ArrayToBase64(rawData),
        },
        objects: [
          makeMapObject('ElevAttacker', 10, 10),
          makeMapObject('GroundTarget', 20, 10),
          makeMapObject('CliffTarget', 40, 10),
        ],
        triggers: [],
      },
      makeRegistry(bundle),
      heightmap,
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Attack the ground target (entity 2). Radius damage centered on ground target.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    // Advance enough frames for DIRECT weapon to fire and deal damage.
    for (let i = 0; i < 3; i++) {
      logic.update(1 / 30);
    }

    const groundHealth = logic.getEntityState(2)?.health ?? -1;
    const cliffHealth = logic.getEntityState(3)?.health ?? -1;

    // Ground target is within radius  takes primary damage (50).
    expect(groundHealth).toBeLessThan(200);
    // Cliff target XZ distance is 20 (within radius 25 in 2D) but 3D distance
    // includes ~100 unit elevation difference  outside radius  no damage.
    expect(cliffHealth).toBe(200);
  });

  it('bounding sphere subtraction extends effective hit zone for entities with explicit geometry', () => {
    // Source parity: FROM_BOUNDINGSPHERE_3D subtracts the target entity's bounding
    // sphere radius from the 3D center-to-point distance. An entity with large geometry
    // (majorRadius=12) gets BSR=12, making it hittable at longer range than the weapon's
    // nominal damage radius.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BSRAttacker', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BSRWeapon'] }),
        ]),
        // SmallTarget: no geometry  BSR falls back to baseHeight (~1.5).
        makeObjectDef('SmallTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        // LargeTarget: explicit geometry with majorRadius=12  BSR=12 (cylinder).
        makeObjectDef('LargeTarget', 'China', ['VEHICLE', 'STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { GeometryMajorRadius: 12, GeometryMinorRadius: 12, GeometryHeight: 5 }),
      ],
      weapons: [
        makeWeaponDef('BSRWeapon', {
          AttackRange: 120,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 5,
          SecondaryDamage: 0,
          SecondaryDamageRadius: 0,
          DelayBetweenShots: 1000,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Attacker at (10,10). SmallTarget at (25,10)  XZ dist=15 from impact at SmallTarget.
    // LargeTarget at (25,50)  placed far from attack path, won't be hit.
    // We attack SmallTarget; radius damage checks entities within radius=5 of SmallTarget.
    // SmallTarget (at impact point): shrunkenDist=0  hit.
    // LargeTarget: too far  not hit.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BSRAttacker', 10, 10),
        makeMapObject('SmallTarget', 25, 10),
        makeMapObject('LargeTarget', 25, 50),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    for (let i = 0; i < 3; i++) {
      logic.update(1 / 30);
    }

    const smallHealth = logic.getEntityState(2)?.health ?? -1;
    const largeHealth = logic.getEntityState(3)?.health ?? -1;

    // SmallTarget is the primary victim  takes damage.
    expect(smallHealth).toBeLessThan(100);
    // LargeTarget is 40 units away in XZ  even with BSR=12, still outside radius 5.
    expect(largeHealth).toBe(100);
  });
});

describe('crush damage during movement', () => {
  // Shared bundle for most crush tests: tank (CrusherLevel=2) + crushable infantry.
  function makeCrushBundle(infantrySide: string = 'China') {
    return makeBundle({
      objects: [
        makeObjectDef('CrusherTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('LocomotorSet', 'SET_NORMAL TankLocomotor', {}),
        ], { CrusherLevel: 2, GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('CrushableInfantry', infantrySide, ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Collide', 'SquishCollide ModuleTag_Squish', {}),
        ], { CrushableLevel: 0 }),
      ],
      locomotors: [
        makeLocomotorDef('TankLocomotor', 180),
      ],
    });
  }

  it('tank crushes infantry when moving through them', () => {
    // Source parity: SquishCollide::onCollide  moving entity with CrusherLevel > 0
    // kills crushable enemies on bounding circle overlap + moving-toward-target check.
    // Place at cell centers (PATHFIND_CELL_SIZE=10, so centers at x%10=5) for straight-line A*.
    const bundle = makeCrushBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrusherTank', 205, 205),
        makeMapObject('CrushableInfantry', 220, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    expect(logic.getEntityState(2)?.health).toBe(100);

    // Move tank straight through infantry in +X at same Z level.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 255, targetZ: 205 });

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Infantry should be dead and removed from CRUSH damage (HUGE_DAMAGE_AMOUNT).
    const infantryAfter = logic.getEntityState(2);
    expect(infantryAfter === null || infantryAfter.health === 0).toBe(true);
  });

  it('allies are not crushed', () => {
    // Same side  canCrushOrSquish rejects allies.
    const bundle = makeCrushBundle('America');
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrusherTank', 205, 205),
        makeMapObject('CrushableInfantry', 220, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 255, targetZ: 205 });

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    const allyHealth = logic.getEntityState(2)?.health ?? -1;
    expect(allyHealth).toBe(100);
  });

  it('vehicle with higher crushableLevel resists crush from lower crusherLevel', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('LightTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('LocomotorSet', 'SET_NORMAL TankLocomotor', {}),
        ], { CrusherLevel: 1, GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('HeavyVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], { CrushableLevel: 2, GeometryMajorRadius: 4, GeometryMinorRadius: 4 }),
      ],
      locomotors: [
        makeLocomotorDef('TankLocomotor', 180),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('LightTank', 205, 205),
        makeMapObject('HeavyVehicle', 220, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 255, targetZ: 205 });

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // CrushableLevel=2 >= CrusherLevel=1  not crushed.
    const heavyHealth = logic.getEntityState(2)?.health ?? -1;
    expect(heavyHealth).toBe(300);
  });

  it('tank moving away from infantry does not crush', () => {
    // Dot product direction check: crusher moving away from victim should not crush.
    const bundle = makeCrushBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Infantry behind the tank: tank at cell center, infantry behind in -X.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrusherTank', 215, 205),
        makeMapObject('CrushableInfantry', 205, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Tank moves in +X direction, away from infantry at -X.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 255, targetZ: 205 });

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Infantry should be alive  tank moved away, dot product was <= 0.
    const infHealth = logic.getEntityState(2)?.health ?? -1;
    expect(infHealth).toBe(100);
  });

  it('applies vehicle crush only after passing the selected crush point', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CrusherTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('LocomotorSet', 'SET_NORMAL TankLocomotor', {}),
        ], { CrusherLevel: 2, GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('CrushableVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('LocomotorSet', 'SET_NORMAL TankLocomotor', {}),
        ], { CrushableLevel: 0, GeometryMajorRadius: 10, GeometryMinorRadius: 10 }),
      ],
      locomotors: [
        makeLocomotorDef('TankLocomotor', 120),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrusherTank', 225, 205),
        makeMapObject('CrushableVehicle', 220, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { moving: boolean; rotationY: number; speed: number; health: number; destroyed: boolean }>;
      updateCrushCollisions: () => void;
    };
    const crusher = privateApi.spawnedEntities.get(1)!;
    const victim = privateApi.spawnedEntities.get(2)!;
    crusher.moving = true;
    crusher.rotationY = Math.PI / 2; // facing +X, so target center is behind (dot < 0)
    crusher.speed = 1;
    victim.rotationY = 0; // align victim crush points to center-line for deterministic TOTAL target.

    privateApi.updateCrushCollisions();
    expect(victim.health <= 0 || victim.destroyed).toBe(true);
  });

  it('hijacker infantry is immune to crush by target vehicle', () => {
    // Source parity: SquishCollide::onCollide  infantry with a pending hijackVehicle
    // action targeting the crusher is immune to being crushed by that vehicle.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CrusherTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('LocomotorSet', 'SET_NORMAL TankLocomotor', {}),
        ], { CrusherLevel: 2, GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('Hijacker', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Collide', 'SquishCollide ModuleTag_Squish', {}),
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
          makeBlock('LocomotorSet', 'SET_NORMAL InfLocomotor', {}),
        ], { CrushableLevel: 0 }),
      ],
      locomotors: [
        makeLocomotorDef('TankLocomotor', 180),
        makeLocomotorDef('InfLocomotor', 60),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Place far enough apart that the hijack doesn't resolve immediately
    // (reachDistance = 5+5=10, so distance must exceed 10).
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrusherTank', 205, 205),
        makeMapObject('Hijacker', 235, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Issue hijack command  hijacker will move toward the tank.
    logic.submitCommand({
      type: 'enterObject',
      entityId: 2,
      targetObjectId: 1,
      action: 'hijackVehicle',
    });

    // Move tank toward the hijacker  they will overlap and crush would normally kill.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 265, targetZ: 205 });

    // Run enough frames for the entities to meet and the hijack to resolve.
    // Tank speed=180 (6 units/frame), hijacker speed=60 (2 units/frame).
    // They close at 8 units/frame, gap=30, so ~4 frames to overlap.
    // Without crush immunity the hijacker would die on overlap. With immunity,
    // the hijacker survives to reach interaction distance and the hijack resolves.
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    // Hijacker is consumed by the successful hijack (destroyed after entering vehicle).
    const hijackerState = logic.getEntityState(2);
    expect(hijackerState).toBeNull();

    // The tank should have been captured  side changed from China to America.
    // This proves crush immunity worked: if the hijacker had been crushed,
    // the hijack would never have resolved and the tank would remain Chinese.
    const tankState = logic.getEntityState(1);
    expect(tankState).not.toBeNull();
    expect(tankState!.side.toLowerCase()).toBe('america');
  });
});

describe('INI-driven stealth and detection', () => {
  /**
   * Shared bundle: stealthUnit with StealthUpdate module (InnateStealth=Yes, delay=1000ms)
   * and detectorUnit with KINDOF_DETECTOR + StealthDetectorUpdate module.
   */
  function makeStealthBundle(options: {
    stealthDelay?: number;
    innateStealth?: boolean;
    forbiddenConditions?: string;
    moveThresholdSpeed?: number;
    detectionRange?: number;
    detectionRate?: number;
    extraRequiredKindOf?: string;
    extraForbiddenKindOf?: string;
    detectorSide?: string;
  } = {}) {
    const stealthDelay = options.stealthDelay ?? 1000;
    const innateStealth = options.innateStealth !== false;
    const forbiddenConditions = options.forbiddenConditions ?? '';
    const moveThresholdSpeed = options.moveThresholdSpeed ?? 0;
    const detectionRange = options.detectionRange ?? 0;
    const detectionRate = options.detectionRate ?? 33;
    const detectorSide = options.detectorSide ?? 'China';
    const extraRequiredKindOf = options.extraRequiredKindOf ?? '';
    const extraForbiddenKindOf = options.extraForbiddenKindOf ?? '';

    return makeBundle({
      objects: [
        makeObjectDef('StealthUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', {
            StealthDelay: stealthDelay,
            InnateStealth: innateStealth ? 'Yes' : 'No',
            StealthForbiddenConditions: forbiddenConditions,
            MoveThresholdSpeed: moveThresholdSpeed,
          }),
        ]),
        makeObjectDef('DetectorUnit', detectorSide, ['INFANTRY', 'DETECTOR'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthDetectorUpdate ModuleTag_Detector', {
            DetectionRange: detectionRange,
            DetectionRate: detectionRate,
            ExtraRequiredKindOf: extraRequiredKindOf,
            ExtraForbiddenKindOf: extraForbiddenKindOf,
          }),
        ], { VisionRange: 200 }),
      ],
    });
  }

  function setupRelationships(logic: GameLogicSubsystem): void {
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
  }

  it('innate stealth sets CAN_STEALTH on creation and enters stealth after delay', () => {
    const bundle = makeStealthBundle({ stealthDelay: 300 }); // 300ms = ~9 frames at 30fps
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('StealthUnit', 105, 105)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    // Immediately after creation, entity should have CAN_STEALTH but NOT STEALTHED.
    const initialFlags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(initialFlags).toContain('CAN_STEALTH');
    expect(initialFlags).not.toContain('STEALTHED');

    // Run for enough frames to exceed stealth delay (300ms = 9 frames at 30fps).
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    const afterFlags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(afterFlags).toContain('STEALTHED');
  });

  it('stealth breaks on damage when TAKING_DAMAGE forbidden condition is set', () => {
    const bundle = makeStealthBundle({
      stealthDelay: 100,
      forbiddenConditions: 'TAKING_DAMAGE',
    });

    // Add an enemy attacker with weapon and DETECTOR so it can see through stealth.
    const bundleWithAttacker = makeBundle({
      objects: [
        ...bundle.objects,
        makeObjectDef('Attacker', 'China', ['INFANTRY', 'DETECTOR'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'StealthBreakGun'] }),
        ], { VisionRange: 200 }),
      ],
      weapons: [
        makeWeaponDef('StealthBreakGun', {
          PrimaryDamage: 10,
          PrimaryDamageRadius: 0,
          AttackRange: 200,
          DelayBetweenShots: 100,
          DamageType: 'SMALL_ARMS',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('Attacker', 115, 105),
      ], 128, 128),
      makeRegistry(bundleWithAttacker),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    // Wait for stealth to activate (100ms = 3 frames).
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).toContain('STEALTHED');

    // Issue attack command  attacker can see the stealthed unit via DETECTOR.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Run enough frames for the attacker to fire and damage to register.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Stealth should be broken because damage was taken.
    const stealthFlags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(stealthFlags).not.toContain('STEALTHED');
  });

  it('detector reveals stealthed enemy within range', () => {
    const bundle = makeStealthBundle({ stealthDelay: 100 });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('DetectorUnit', 115, 105), // 10 units away, well within detection range
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    // Wait for stealth to activate.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).toContain('STEALTHED');
    expect(flags).toContain('DETECTED');
  });

  it('detector does not reveal stealthed ally', () => {
    // Detector is same side as stealth unit.
    const bundle = makeStealthBundle({ stealthDelay: 100, detectorSide: 'America' });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('DetectorUnit', 115, 105),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).toContain('STEALTHED');
    expect(flags).not.toContain('DETECTED');
  });

  it('detector does not reveal stealthed enemy out of range', () => {
    // Use small explicit detection range.
    const bundle = makeStealthBundle({ stealthDelay: 100, detectionRange: 5 });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('DetectorUnit', 205, 205), // Far away (100+ units)
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).toContain('STEALTHED');
    expect(flags).not.toContain('DETECTED');
  });

  it('detection expires after detector is destroyed', () => {
    // Use a weapon to kill the detector so detection expires.
    const bundle = makeStealthBundle({ stealthDelay: 100, detectionRange: 200 });
    const bundleWithKiller = makeBundle({
      objects: [
        ...bundle.objects,
        makeObjectDef('Killer', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'InstantKillGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('InstantKillGun', {
          PrimaryDamage: 9999,
          PrimaryDamageRadius: 0,
          AttackRange: 200,
          DelayBetweenShots: 100,
          DamageType: 'EXPLOSION',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('DetectorUnit', 115, 105),
        makeMapObject('Killer', 125, 105),
      ], 128, 128),
      makeRegistry(bundleWithKiller),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    // Activate stealth and get detected.
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).toContain('DETECTED');

    // Kill the detector with an ally unit (Killer is America, DetectorUnit is China = enemy).
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Detector should be dead, but detection may still linger briefly.
    // Run enough frames for the detection timer to expire.
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // Detection should have expired since detector no longer scans.
    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).toContain('STEALTHED');
    expect(flags).not.toContain('DETECTED');
  });

  it('non-innate stealth unit does NOT get CAN_STEALTH on creation', () => {
    const bundle = makeStealthBundle({ innateStealth: false });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('StealthUnit', 105, 105)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).not.toContain('CAN_STEALTH');
    expect(flags).not.toContain('STEALTHED');

    // After many frames, still not stealthed (no CAN_STEALTH).
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).not.toContain('STEALTHED');
  });

  it('extraRequiredKindOf filters detection targets', () => {
    // Detector only detects VEHICLE, but stealth unit is INFANTRY.
    const bundle = makeStealthBundle({
      stealthDelay: 100,
      extraRequiredKindOf: 'VEHICLE',
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('DetectorUnit', 115, 105),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Stealth unit is INFANTRY, detector only detects VEHICLE  should NOT detect.
    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).toContain('STEALTHED');
    expect(flags).not.toContain('DETECTED');
  });

  it('stealth breaks on movement when MOVING forbidden condition is set', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('MoverStealth', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', {
            StealthDelay: 100,
            InnateStealth: 'Yes',
            StealthForbiddenConditions: 'MOVING',
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL FastLoco', {}),
        ]),
      ],
      locomotors: [makeLocomotorDef('FastLoco', 120)],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('MoverStealth', 105, 105)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Wait for stealth activation.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).toContain('STEALTHED');

    // Issue move command  stealth should break.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 505, targetZ: 105 });
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).not.toContain('STEALTHED');
  });

  it('stealth re-enters after forbidden condition clears and delay elapses', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ResteathUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', {
            StealthDelay: 300, // 300ms = ~9 frames at 30fps
            InnateStealth: 'Yes',
            StealthForbiddenConditions: 'MOVING',
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL FastLoco', {}),
        ]),
      ],
      locomotors: [makeLocomotorDef('FastLoco', 120)],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('ResteathUnit', 105, 105)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Wait for initial stealth.
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).toContain('STEALTHED');

    // Move to break stealth.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 115, targetZ: 105 });
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).not.toContain('STEALTHED');

    // Stop moving (arrive). Wait for re-stealth delay (~9 frames).
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }
    // Unit should have re-entered stealth after the delay.
    expect(logic.getEntityState(1)?.statusFlags ?? []).toContain('STEALTHED');
  });

  it('extraForbiddenKindOf filters detection targets', () => {
    // Detector refuses to detect INFANTRY.
    const bundle = makeStealthBundle({
      stealthDelay: 100,
      extraForbiddenKindOf: 'INFANTRY',
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 105, 105),
        makeMapObject('DetectorUnit', 115, 105),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Stealth unit is INFANTRY with forbidden filter  should NOT detect.
    const flags = logic.getEntityState(1)?.statusFlags ?? [];
    expect(flags).toContain('STEALTHED');
    expect(flags).not.toContain('DETECTED');
  });

  it('short-form forbidden condition tokens are parsed correctly', () => {
    // Use C++ short-form token names instead of long form.
    const bundle = makeStealthBundle({
      stealthDelay: 100,
      forbiddenConditions: 'ATTACKING MOVING TAKING_DAMAGE',
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('StealthUnit', 105, 105)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    setupRelationships(logic);

    // Should enter stealth after delay (forbidden conditions don't prevent entry when inactive).
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getEntityState(1)?.statusFlags ?? []).toContain('STEALTHED');
  });
});

// 
// Salvage Crate System
// 
describe('salvage crate system', () => {
  /** Destroyed entities are cleaned up from spawnedEntities, so getEntityState returns null. */
  function isEntityDead(logic: GameLogicSubsystem, entityId: number): boolean {
    const state = logic.getEntityState(entityId);
    return state === null || state.alive === false;
  }
  function makeSalvageBundle(opts: {
    salvagerKindOf?: string[];
    crateWeaponChance?: string;
    crateLevelChance?: string;
    crateMinMoney?: number;
    crateMaxMoney?: number;
    salvagerExpRequired?: string;
    salvagerExpValue?: string;
    victimHealth?: number;
    attackDamage?: number;
  } = {}) {
    // Victim spawns a crate on death.
    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', {
        MaxHealth: opts.victimHealth ?? 10,
        InitialHealth: opts.victimHealth ?? 10,
      }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', {
        CrateData: 'SalvageCrate',
      }),
    ]);

    // Crate object with SalvageCrateCollide behavior.
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', {
        MaxHealth: 100,
        InitialHealth: 100,
      }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SalvageCrate', {
        ...(opts.crateWeaponChance !== undefined ? { WeaponChance: opts.crateWeaponChance } : {}),
        ...(opts.crateLevelChance !== undefined ? { LevelChance: opts.crateLevelChance } : {}),
        ...(opts.crateMinMoney !== undefined ? { MinMoney: opts.crateMinMoney } : {}),
        ...(opts.crateMaxMoney !== undefined ? { MaxMoney: opts.crateMaxMoney } : {}),
      }),
    ], {
      Geometry: 'CYLINDER',
      GeometryMajorRadius: 5,
      GeometryMinorRadius: 5,
    });

    // Salvager unit with weapon.
    const salvagerDef = makeObjectDef(
      'Salvager',
      'America',
      opts.salvagerKindOf ?? ['VEHICLE', 'SALVAGER', 'WEAPON_SALVAGER'],
      [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', {
          MaxHealth: 200,
          InitialHealth: 200,
        }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SalvagerGun'] }),
        makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
      ],
      {
        ...(opts.salvagerExpRequired ? { ExperienceRequired: opts.salvagerExpRequired } : {}),
        ...(opts.salvagerExpValue ? { ExperienceValue: opts.salvagerExpValue } : {}),
      },
    );

    const bundle = makeBundle({
      objects: [victimDef, crateDef, salvagerDef],
      weapons: [
        makeWeaponDef('SalvagerGun', {
          AttackRange: 120,
          PrimaryDamage: opts.attackDamage ?? 50,
          DamageType: 'ARMOR_PIERCING',
          DelayBetweenShots: 100,
          DeliveryType: 'DIRECT',
        }),
      ],
      locomotors: [makeLocomotorDef('LocomotorFast', 180)],
    });

    return bundle;
  }

  it('spawns crate on enemy death and salvager collects for weapon upgrade', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const bundle = makeSalvageBundle();
    const registry = makeRegistry(bundle);

    // Place victim at (55,55), salvager at (55,65)  within attack range.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('Salvager', 55, 65),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0); // enemies

    // Attack and kill the victim.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Victim should be dead.
    expect(isEntityDead(logic, 1)).toBe(true);

    // A crate entity should have spawned (entity 3).
    const crateState = logic.getEntityState(3);
    expect(crateState).not.toBeNull();
    expect(crateState!.alive).toBe(true);

    // Move salvager to collect the crate.
    logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: crateState!.x, targetZ: crateState!.z });
    for (let i = 0; i < 60; i++) logic.update(1 / 30);

    // Crate should be consumed (destroyed).
    expect(isEntityDead(logic, 3)).toBe(true);
  });

  it('grants CRATEUPGRADE_ONE on first crate, CRATEUPGRADE_TWO on second', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Two victims at same position as salvager for auto-collection.
    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // Target with high health to verify upgraded weapon damage.
    const targetDef = makeObjectDef('DamageTarget', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50000, InitialHealth: 50000 }),
    ]);

    // Salvager with three weapon sets: base, CRATEUPGRADE_ONE, CRATEUPGRADE_TWO.
    // Explicit geometry radius 3 ensures overlap with crate (combined 3+5=8 > max offset ~7.07).
    const salvagerDef = makeObjectDef('Salvager', 'America', ['VEHICLE', 'SALVAGER', 'WEAPON_SALVAGER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'Gun'] }),
      makeBlock('WeaponSet', 'WeaponSet', {
        Conditions: 'CRATEUPGRADE_ONE',
        Weapon: ['PRIMARY', 'GunUpgraded1'],
      }),
      makeBlock('WeaponSet', 'WeaponSet', {
        Conditions: 'CRATEUPGRADE_TWO',
        Weapon: ['PRIMARY', 'GunUpgraded2'],
      }),
      makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 3, GeometryMinorRadius: 3 });

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, salvagerDef, targetDef],
      weapons: [
        makeWeaponDef('Gun', { AttackRange: 120, PrimaryDamage: 50, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
        makeWeaponDef('GunUpgraded1', { AttackRange: 120, PrimaryDamage: 80, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
        makeWeaponDef('GunUpgraded2', { AttackRange: 120, PrimaryDamage: 120, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
      ],
      locomotors: [makeLocomotorDef('LocomotorFast', 180)],
    }));

    // Place: victim1@(55,55), victim2@(55,55), salvager@(55,55), target@(55,115)
    // Overlapping positions ensure crate auto-collection on spawn.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('Salvager', 55, 55),
        makeMapObject('DamageTarget', 55, 115),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    // Kill victim1  crate spawns nearby and auto-collects  CRATEUPGRADE_ONE.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 1)).toBe(true);

    // Attack target for 30 frames  damage should come from GunUpgraded1 (80/shot).
    const health1 = logic.getEntityState(4)!.health;
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 4 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    const damage1 = health1 - logic.getEntityState(4)!.health;
    // GunUpgraded1 does 80/shot. Multiple shots fired  verify damage is a multiple of 80.
    expect(damage1).toBeGreaterThan(0);
    expect(damage1 % 80).toBe(0);

    // Kill victim2  crate spawns nearby and auto-collects  CRATEUPGRADE_TWO.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 2)).toBe(true);

    // Attack target for 30 frames  damage should come from GunUpgraded2 (120/shot).
    const health2 = logic.getEntityState(4)!.health;
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 4 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    const damage2 = health2 - logic.getEntityState(4)!.health;
    expect(damage2).toBeGreaterThan(0);
    expect(damage2 % 120).toBe(0);
  });

  it('non-SALVAGER units cannot collect crates', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // Non-salvager  no SALVAGER kindOf.
    const normalUnit = makeObjectDef('NormalUnit', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'Gun'] }),
      makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, normalUnit],
      weapons: [
        makeWeaponDef('Gun', { AttackRange: 120, PrimaryDamage: 50, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
      ],
      locomotors: [makeLocomotorDef('LocomotorFast', 180)],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('NormalUnit', 55, 55),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    // Kill victim  crate spawns.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 1)).toBe(true);

    // Move non-salvager to crate.
    const crate = logic.getEntityState(3);
    expect(crate).not.toBeNull();
    logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: crate!.x, targetZ: crate!.z });
    for (let i = 0; i < 60; i++) logic.update(1 / 30);

    // Crate should still be alive  non-salvager cannot collect.
    expect(logic.getEntityState(3)?.alive).toBe(true);
  });

  it('no crate spawns when killed by ally via area damage', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    // Victim (America) gets hit by friendly area damage  crate should NOT spawn.
    const victimDef = makeObjectDef('CrateVictim', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // Enemy target that the attacker is actually aiming at.
    const enemyDef = makeObjectDef('Enemy', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);

    // Attacker has area-damage weapon that will splash the ally victim.
    const attackerDef = makeObjectDef('AreaAttacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AreaGun'] }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, enemyDef, attackerDef],
      weapons: [
        makeWeaponDef('AreaGun', {
          AttackRange: 120,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 20,
          DamageType: 'EXPLOSION',
          DelayBetweenShots: 100,
          DeliveryType: 'DIRECT',
        }),
      ],
    }));

    // Place: victim@(55,55), enemy@(55,57)  within splash, attacker@(55,75).
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('Enemy', 55, 57),
        makeMapObject('AreaAttacker', 55, 75),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    // Attack enemy  splash hits both enemy and ally victim.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Victim (10HP) should be dead from splash.
    expect(isEntityDead(logic, 1)).toBe(true);

    // No crate should have spawned  ally killed it.
    // Entity 4 would be the crate if spawned (entities 1=victim, 2=enemy, 3=attacker).
    expect(logic.getEntityState(4)).toBeNull();
  });

  it('grants veterancy level when weapon upgrade not eligible', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {
        WeaponChance: '100%',
        LevelChance: '100%',
      }),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // SALVAGER but NOT WEAPON_SALVAGER  weapon upgrade ineligible, falls through to level.
    const salvagerDef = makeObjectDef('Salvager', 'America', ['VEHICLE', 'SALVAGER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'Gun'] }),
    ], {
      ExperienceRequired: '0 50 200 500',
      ExperienceValue: '10 20 40 80',
    });

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, salvagerDef],
      weapons: [
        makeWeaponDef('Gun', { AttackRange: 120, PrimaryDamage: 50, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
      ],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('Salvager', 55, 55),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    // Check initial veterancy.
    expect(logic.getEntityState(2)?.veterancyLevel).toBe(0); // REGULAR

    // Kill victim  crate spawns nearby and salvager auto-collects (overlapping positions).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 1)).toBe(true);

    // Crate was auto-collected: should have leveled up to VETERAN.
    expect(logic.getEntityState(2)?.veterancyLevel).toBe(1); // VETERAN
  });

  it('grants money when both weapon and level are ineligible', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {
        MinMoney: 50,
        MaxMoney: 50,
      }),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // No WEAPON_SALVAGER and no experience profile  money fallback.
    const salvagerDef = makeObjectDef('Salvager', 'America', ['VEHICLE', 'SALVAGER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'Gun'] }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, salvagerDef],
      weapons: [
        makeWeaponDef('Gun', { AttackRange: 120, PrimaryDamage: 50, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
      ],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('Salvager', 55, 55),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    const initialCredits = logic.getSideCredits('America');

    // Kill victim  crate spawns nearby and salvager auto-collects (overlapping positions).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 1)).toBe(true);

    // Credits should have increased by exactly 50 (money fallback from auto-collected crate).
    const finalCredits = logic.getSideCredits('America');
    expect(finalCredits - initialCredits).toBe(50);
  });

  it('fully upgraded WEAPON_SALVAGER falls through to level then money', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {
        MinMoney: 100,
        MaxMoney: 100,
      }),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // Three victims at same position as salvager for auto-collection.
    // Explicit geometry radius 3 ensures overlap with crate (combined 3+5=8 > max offset ~7.07).
    const salvagerDef = makeObjectDef('Salvager', 'America', ['VEHICLE', 'SALVAGER', 'WEAPON_SALVAGER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'Gun'] }),
      makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 3, GeometryMinorRadius: 3 });

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, salvagerDef],
      weapons: [
        makeWeaponDef('Gun', { AttackRange: 120, PrimaryDamage: 50, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
      ],
      locomotors: [makeLocomotorDef('LocomotorFast', 180)],
    }));

    // All victims at (55,55) overlapping salvager for auto-collection.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('Salvager', 55, 55),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    // Kill first victim  crate auto-collects  CRATEUPGRADE_ONE.
    logic.submitCommand({ type: 'attackEntity', entityId: 4, targetEntityId: 1 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 1)).toBe(true);

    // Kill second victim  crate auto-collects  CRATEUPGRADE_TWO.
    logic.submitCommand({ type: 'attackEntity', entityId: 4, targetEntityId: 2 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 2)).toBe(true);

    // Now fully upgraded. Kill third victim  crate should fall through to money.
    const creditsBefore = logic.getSideCredits('America');
    logic.submitCommand({ type: 'attackEntity', entityId: 4, targetEntityId: 3 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 3)).toBe(true);

    // Credits should have increased by 100 (money fallback from auto-collected crate).
    const creditsAfter = logic.getSideCredits('America');
    expect(creditsAfter - creditsBefore).toBe(100);
  });

  it('ARMOR_SALVAGER gets armor crate upgrade with model conditions', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const victimDef = makeObjectDef('CrateVictim', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      makeBlock('Behavior', 'CreateCrateDie ModuleTag_CrateDie', { CrateData: 'SalvageCrate' }),
    ]);
    const crateDef = makeObjectDef('SalvageCrate', '', ['CRATE', 'UNATTACKABLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'SalvageCrateCollide ModuleTag_SC', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5, GeometryMinorRadius: 5 });

    // Salvager with ARMOR_SALVAGER kindOf.
    const salvagerDef = makeObjectDef('ArmorSalvager', 'America', ['VEHICLE', 'SALVAGER', 'ARMOR_SALVAGER'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'Gun'] }),
      makeBlock('LocomotorSet', 'SET_NORMAL LocomotorFast', {}),
    ], { Geometry: 'CYLINDER', GeometryMajorRadius: 3, GeometryMinorRadius: 3 });

    const registry = makeRegistry(makeBundle({
      objects: [victimDef, crateDef, salvagerDef],
      weapons: [
        makeWeaponDef('Gun', { AttackRange: 120, PrimaryDamage: 50, DamageType: 'ARMOR_PIERCING', DelayBetweenShots: 100, DeliveryType: 'DIRECT' }),
      ],
      locomotors: [makeLocomotorDef('LocomotorFast', 180)],
    }));

    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('CrateVictim', 55, 55),
        makeMapObject('ArmorSalvager', 55, 55),
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        armorSetFlagsMask: number;
        modelConditionFlags: Set<string>;
      }>;
    };
    const salvager = priv.spawnedEntities.get(3)!;

    // Kill first victim  armor upgrade ONE.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(isEntityDead(logic, 1)).toBe(true);

    // Auto-collect: should have CRATE_UPGRADE_ONE armor flag and model condition.
    // Wait for crate collision.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    expect(salvager.armorSetFlagsMask & (1 << 6)).not.toBe(0); // ARMOR_SET_FLAG_CRATE_UPGRADE_ONE
    expect(salvager.modelConditionFlags.has('ARMORSET_CRATEUPGRADE_ONE')).toBe(true);

    // Kill second victim  armor upgrade TWO.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    expect(salvager.armorSetFlagsMask & (1 << 6)).toBe(0); // CRATE_UPGRADE_ONE cleared
    expect(salvager.armorSetFlagsMask & (1 << 7)).not.toBe(0); // CRATE_UPGRADE_TWO set
    expect(salvager.modelConditionFlags.has('ARMORSET_CRATEUPGRADE_ONE')).toBe(false);
    expect(salvager.modelConditionFlags.has('ARMORSET_CRATEUPGRADE_TWO')).toBe(true);
  });
});

//  BattlePlanUpdate system 

describe('BattlePlanUpdate', () => {
  // C++ source parity: each battle plan has its own SpecialPower template.
  const PLAN_POWERS = {
    BOMBARDMENT: 'SpecialPowerChangeBombardmentBattlePlan',
    HOLDTHELINE: 'SpecialPowerChangeHoldTheLineBattlePlan',
    SEARCHANDDESTROY: 'SpecialPowerChangeSearchAndDestroyBattlePlan',
  } as const;

  // Helper: issue battle plan special power command.
  function issueBattlePlan(
    logic: GameLogicSubsystem,
    sourceEntityId: number,
    plan: 'BOMBARDMENT' | 'HOLDTHELINE' | 'SEARCHANDDESTROY',
  ): void {
    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: `CMD_${plan}`,
      specialPowerName: PLAN_POWERS[plan],
      commandOption: 0,
      issuingEntityIds: [sourceEntityId],
      sourceEntityId,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
  }

  // Helper: build a Strategy Center with BattlePlanUpdate + infantry on the same side.
  function makeBattlePlanSetup(opts?: {
    animationMs?: number;
    paralyzeMs?: number;
    transitionIdleMs?: number;
    armorDamageScalar?: number;
    sightRangeScalar?: number;
    validMemberKindOf?: string;
    invalidMemberKindOf?: string;
    strategyCenterSightRangeScalar?: number;
    strategyCenterDetectsStealth?: boolean;
    strategyCenterHealthScalar?: number;
  }) {
    const animMs = opts?.animationMs ?? 300;
    const paraMs = opts?.paralyzeMs ?? 300;
    const idleMs = opts?.transitionIdleMs ?? 300;
    const armorScalar = opts?.armorDamageScalar ?? 0.5;
    const sightScalar = opts?.sightRangeScalar ?? 1.5;

    // C++ source parity: BattlePlanUpdate module registers separate SpecialPowerTemplate
    // for each plan type. We register via three SpecialPowerModule behavior blocks.
    const strategyCenterDef = makeObjectDef('StrategyCenter', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'BattlePlanUpdate ModuleTag_BattlePlan', {
        BombardmentPlanAnimationTime: animMs,
        HoldTheLinePlanAnimationTime: animMs,
        SearchAndDestroyPlanAnimationTime: animMs,
        TransitionIdleTime: idleMs,
        BattlePlanChangeParalyzeTime: paraMs,
        HoldTheLinePlanArmorDamageScalar: armorScalar,
        SearchAndDestroyPlanSightRangeScalar: sightScalar,
        StrategyCenterSearchAndDestroySightRangeScalar: opts?.strategyCenterSightRangeScalar ?? 2.0,
        StrategyCenterSearchAndDestroyDetectsStealth: opts?.strategyCenterDetectsStealth ?? false,
        StrategyCenterHoldTheLineMaxHealthScalar: opts?.strategyCenterHealthScalar ?? 1.0,
        ValidMemberKindOf: opts?.validMemberKindOf ?? '',
        InvalidMemberKindOf: opts?.invalidMemberKindOf ?? '',
      }),
      makeBlock('Behavior', 'SpecialPowerModule BattlePlanBombardment', {
        SpecialPowerTemplate: PLAN_POWERS.BOMBARDMENT,
      }),
      makeBlock('Behavior', 'SpecialPowerModule BattlePlanHoldTheLine', {
        SpecialPowerTemplate: PLAN_POWERS.HOLDTHELINE,
      }),
      makeBlock('Behavior', 'SpecialPowerModule BattlePlanSearchAndDestroy', {
        SpecialPowerTemplate: PLAN_POWERS.SEARCHANDDESTROY,
      }),
    ]);

    const infantryDef = makeObjectDef('Ranger', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'RangerGun'] }),
    ], { VisionRange: 150 });

    const enemyDef = makeObjectDef('Enemy', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'EnemyGun'] }),
    ]);

    const registry = makeRegistry(makeBundle({
      objects: [strategyCenterDef, infantryDef, enemyDef],
      specialPowers: [
        makeSpecialPowerDef(PLAN_POWERS.BOMBARDMENT, { ReloadTime: 0 }),
        makeSpecialPowerDef(PLAN_POWERS.HOLDTHELINE, { ReloadTime: 0 }),
        makeSpecialPowerDef(PLAN_POWERS.SEARCHANDDESTROY, { ReloadTime: 0 }),
      ],
      weapons: [
        makeWeaponDef('RangerGun', {
          AttackRange: 120,
          PrimaryDamage: 50,
          DamageType: 'ARMOR_PIERCING',
          DelayBetweenShots: 100,
          DeliveryType: 'DIRECT',
        }),
        makeWeaponDef('EnemyGun', {
          AttackRange: 120,
          PrimaryDamage: 100,
          DamageType: 'ARMOR_PIERCING',
          DelayBetweenShots: 100,
          DeliveryType: 'DIRECT',
        }),
      ],
    }));

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Entity 1: StrategyCenter at (55,55).  Entity 2: Ranger at (505,55) (far from enemy).
    // Entity 3: Enemy at (75,55).
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StrategyCenter', 55, 55),
        makeMapObject('Ranger', 505, 55),
        makeMapObject('Enemy', 75, 55),
      ], 1024, 1024),
      registry,
      makeHeightmap(1024, 1024),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    return { logic, scene };
  }

  // At 30 FPS, 300ms  ceil(300/33.33) = 9 frames.
  const ANIM_FRAMES = 9;
  const PARALYZE_FRAMES = 9;
  const IDLE_FRAMES = 9;

  it('activates Bombardment plan and sets WEAPON_BONUS_BOMBARDMENT on allied troops', () => {
    const { logic } = makeBattlePlanSetup();

    // Before: no weapon bonus flags.
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 12)).toBe(0);

    // Issue Bombardment.
    issueBattlePlan(logic, 1, 'BOMBARDMENT');
    logic.update(0);

    // Still UNPACKING  no bonus yet.
    for (let i = 0; i < ANIM_FRAMES - 1; i++) logic.update(1 / 30);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 12)).toBe(0);

    // One more frame  becomes ACTIVE.
    logic.update(1 / 30);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 12)).toBe(1 << 12);

    // Enemy should NOT have the flag.
    expect(logic.getEntityState(3)!.weaponBonusConditionFlags & (1 << 12)).toBe(0);
  });

  it('activates Hold the Line plan and reduces damage taken via armor scalar', () => {
    const { logic } = makeBattlePlanSetup({ armorDamageScalar: 0.5 });

    // Activate Hold the Line.
    issueBattlePlan(logic, 1, 'HOLDTHELINE');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);

    // Check damage scalar on ranger.
    const rangerState = logic.getEntityState(2)!;
    expect(rangerState.weaponBonusConditionFlags & (1 << 13)).toBe(1 << 13);
    expect(rangerState.battlePlanDamageScalar).toBeCloseTo(0.5, 5);
  });

  it('activates Search and Destroy plan and increases vision range', () => {
    const { logic } = makeBattlePlanSetup({ sightRangeScalar: 1.5 });

    // Before: base vision range.
    expect(logic.getEntityState(2)!.visionRange).toBe(150);

    // Activate Search and Destroy.
    issueBattlePlan(logic, 1, 'SEARCHANDDESTROY');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);

    // After: vision range scaled.
    const rangerState = logic.getEntityState(2)!;
    expect(rangerState.weaponBonusConditionFlags & (1 << 14)).toBe(1 << 14);
    expect(rangerState.visionRange).toBeCloseTo(225, 0); // 150 * 1.5
  });

  it('paralyzes troops when switching between active plans', () => {
    const { logic } = makeBattlePlanSetup();

    // Activate Bombardment.
    issueBattlePlan(logic, 1, 'BOMBARDMENT');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 12)).toBe(1 << 12);

    // Switch to Hold the Line  C++ parity: bonuses removed and troops paralyzed
    // immediately at packing start (not at end of packing animation).
    issueBattlePlan(logic, 1, 'HOLDTHELINE');
    logic.update(0);

    // Ranger should be paralyzed immediately (DISABLED_SUBDUED).
    expect(logic.getEntityState(2)!.statusFlags).toContain('DISABLED_SUBDUED');

    // Bombardment bonus should be removed immediately.
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 12)).toBe(0);

    // Wait for paralysis to wear off.
    for (let i = 0; i < PARALYZE_FRAMES; i++) logic.update(1 / 30);
    expect(logic.getEntityState(2)!.statusFlags).not.toContain('DISABLED_SUBDUED');

    // Wait for idle cooldown then UNPACKING  eventually Hold the Line becomes ACTIVE.
    for (let i = 0; i < IDLE_FRAMES + ANIM_FRAMES; i++) logic.update(1 / 30);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 13)).toBe(1 << 13);
  });

  it('removes bonuses when Strategy Center is destroyed', () => {
    const { logic } = makeBattlePlanSetup();

    // Activate Search and Destroy.
    issueBattlePlan(logic, 1, 'SEARCHANDDESTROY');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 14)).toBe(1 << 14);
    expect(logic.getEntityState(2)!.visionRange).toBeCloseTo(225, 0);

    // Destroy Strategy Center: have enemy attack it.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 200; i++) logic.update(1 / 30);

    // Strategy Center should be dead.
    expect(logic.getEntityState(1)).toBeNull();

    // Bonuses should be removed from ranger (which is far from enemy, still alive).
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 14)).toBe(0);
    expect(logic.getEntityState(2)!.visionRange).toBe(150);
  });

  it('does not apply bonuses to entities matching InvalidMemberKindOf', () => {
    const { logic } = makeBattlePlanSetup({ invalidMemberKindOf: 'INFANTRY' });

    // Activate Bombardment.
    issueBattlePlan(logic, 1, 'BOMBARDMENT');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);

    // Ranger (INFANTRY) should be excluded by InvalidMemberKindOf.
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & (1 << 12)).toBe(0);
  });

  it('does not paralyze the Strategy Center building itself', () => {
    const { logic } = makeBattlePlanSetup();

    // Activate Bombardment, then switch to Hold the Line.
    issueBattlePlan(logic, 1, 'BOMBARDMENT');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);

    issueBattlePlan(logic, 1, 'HOLDTHELINE');
    logic.update(0);
    for (let i = 0; i < ANIM_FRAMES; i++) logic.update(1 / 30);

    // Strategy Center itself should NOT be paralyzed.
    expect(logic.getEntityState(1)!.statusFlags).not.toContain('DISABLED_SUBDUED');
  });
});

//  PointDefenseLaserUpdate tests 
describe('PointDefenseLaserUpdate', () => {
  /**
   * Setup: Enemy missile launcher fires PROJECTILE at a target.
   * A PDL defender is positioned on the flight path to intercept.
   *
   * Map layout (128128, MAP_XY_FACTOR=10  world = cell*10+5):
   *   Entity 1: PDL defender (America) at cell (5,4)  world (55,45)
   *   Entity 2: Target building (America) at cell (5,7)  world (55,75)
   *   Entity 3: Enemy missile launcher (China) at cell (5,2)  world (55,25)
   *
   * Flight path: (55,25)  (55,75), distance = 50 world units.
   * PDL at (55,45) is right on the flight path, 20 units from launcher.
   */
  function makePdlSetup(opts?: {
    pdlScanRange?: number;
    pdlWeaponRange?: number;
    pdlScanRate?: number;
    missileSpeed?: number;
    primaryTargetTypes?: string;
    secondaryTargetTypes?: string;
  }) {
    const pdlScanRange = opts?.pdlScanRange ?? 60;
    const pdlWeaponRange = opts?.pdlWeaponRange ?? 40;
    const pdlScanRate = opts?.pdlScanRate ?? 33; // 33ms  1 frame
    const missileSpeed = opts?.missileSpeed ?? 5; // 50 units / 5 = ~10 frame flight
    const primaryTargetTypes = opts?.primaryTargetTypes ?? 'SMALL_MISSILE';
    const secondaryTargetTypes = opts?.secondaryTargetTypes ?? '';

    const bundle = makeBundle({
      objects: [
        makeObjectDef('PDLDefender', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'PointDefenseLaserUpdate ModuleTag_PDL', {
            WeaponTemplate: 'PDLLaser',
            PrimaryTargetTypes: primaryTargetTypes,
            SecondaryTargetTypes: secondaryTargetTypes,
            ScanRate: pdlScanRate,
            ScanRange: pdlScanRange,
            PredictTargetVelocityFactor: 0,
          }),
        ]),
        makeObjectDef('TargetBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
        makeObjectDef('MissileLauncher', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'EnemyMissile'] }),
        ]),
        makeObjectDef('MissileProjectile', 'China', ['PROJECTILE', 'SMALL_MISSILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('PDLLaser', {
          AttackRange: pdlWeaponRange,
          PrimaryDamage: 100,
          WeaponSpeed: 999999,
          DelayBetweenShots: 33,
        }),
        makeWeaponDef('EnemyMissile', {
          AttackRange: 120,
          PrimaryDamage: 200,
          WeaponSpeed: missileSpeed,
          DelayBetweenShots: 5000,
          ProjectileObject: 'MissileProjectile',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PDLDefender', 5, 4),
        makeMapObject('TargetBuilding', 5, 7),
        makeMapObject('MissileLauncher', 5, 2),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    return { logic };
  }

  it('intercepts an in-flight enemy missile within range', () => {
    const { logic } = makePdlSetup();

    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    logic.update(0);

    // Missile flies 50 units at speed 5  ~10 frames. PDL should intercept within that time.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(logic.getEntityState(2)!.health).toBe(1000);
  });

  it('does not intercept ally projectiles', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('PDLDefender', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'PointDefenseLaserUpdate ModuleTag_PDL', {
            WeaponTemplate: 'PDLLaser',
            PrimaryTargetTypes: 'SMALL_MISSILE',
            ScanRate: 33,
            ScanRange: 60,
          }),
        ]),
        makeObjectDef('AllyLauncher', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AllyMissile'] }),
        ]),
        makeObjectDef('EnemyTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
        makeObjectDef('MissileProjectile', 'America', ['PROJECTILE', 'SMALL_MISSILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('PDLLaser', { AttackRange: 40, PrimaryDamage: 100, WeaponSpeed: 999999, DelayBetweenShots: 33 }),
        makeWeaponDef('AllyMissile', { AttackRange: 120, PrimaryDamage: 200, WeaponSpeed: 5, DelayBetweenShots: 5000, ProjectileObject: 'MissileProjectile' }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('PDLDefender', 5, 4), makeMapObject('AllyLauncher', 5, 2), makeMapObject('EnemyTarget', 5, 7)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 3 });
    logic.update(0);
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Ally missile should hit  PDL does not intercept ally projectiles.
    expect(logic.getEntityState(3)!.health).toBeLessThan(1000);
  });

  it('ignores projectiles that do not match target kindOf', () => {
    // PDL only targets BALLISTIC_MISSILE, but enemy fires SMALL_MISSILE.
    const { logic } = makePdlSetup({ primaryTargetTypes: 'BALLISTIC_MISSILE' });

    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    logic.update(0);
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Missile should hit  PDL doesn't target SMALL_MISSILE.
    expect(logic.getEntityState(2)!.health).toBeLessThan(1000);
  });

  it('respects scan range  does not intercept projectiles beyond range', () => {
    // PDL positioned far from flight path with tiny scan range.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('PDLDefender', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'PointDefenseLaserUpdate ModuleTag_PDL', {
            WeaponTemplate: 'PDLLaser',
            PrimaryTargetTypes: 'SMALL_MISSILE',
            ScanRate: 33,
            ScanRange: 5, // very short scan range
          }),
        ]),
        makeObjectDef('TargetBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
        makeObjectDef('MissileLauncher', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'EnemyMissile'] }),
        ]),
        makeObjectDef('MissileProjectile', 'China', ['PROJECTILE', 'SMALL_MISSILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('PDLLaser', { AttackRange: 3, PrimaryDamage: 100, WeaponSpeed: 999999, DelayBetweenShots: 33 }),
        makeWeaponDef('EnemyMissile', { AttackRange: 120, PrimaryDamage: 200, WeaponSpeed: 5, DelayBetweenShots: 5000, ProjectileObject: 'MissileProjectile' }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // PDL at cell (9,4)  world (95,45), 40 units away from flight path at x=55.
    logic.loadMapObjects(
      makeMap([makeMapObject('PDLDefender', 9, 4), makeMapObject('TargetBuilding', 5, 7), makeMapObject('MissileLauncher', 5, 2)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    logic.update(0);
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Missile should hit  PDL is too far away.
    expect(logic.getEntityState(2)!.health).toBeLessThan(1000);
  });

  it('intercepts using secondary target types as fallback', () => {
    // Primary targets BALLISTIC_MISSILE (no match), secondary targets SMALL_MISSILE (match).
    const { logic } = makePdlSetup({
      primaryTargetTypes: 'BALLISTIC_MISSILE',
      secondaryTargetTypes: 'SMALL_MISSILE',
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    logic.update(0);
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Missile intercepted via secondary target type.
    expect(logic.getEntityState(2)!.health).toBe(1000);
  });
});

//  HordeUpdate tests 

describe('HordeUpdate', () => {
  const WEAPON_BONUS_HORDE = 1 << 1;
  const WEAPON_BONUS_NATIONALISM = 1 << 4;
  const WEAPON_BONUS_FANATICISM = 1 << 23;

  function makeHordeBlock(overrides: Record<string, unknown> = {}): IniBlock {
    return {
      type: 'Behavior',
      name: 'HordeUpdate ModuleTag_Horde',
      fields: {
        KindOf: 'INFANTRY',
        Count: 3,
        Radius: 80,
        UpdateRate: 100,
        RubOffRadius: 20,
        AlliesOnly: 'Yes',
        ExactMatch: 'No',
        AllowedNationalism: 'Yes',
        ...overrides,
      } as Record<string, string | number | boolean | string[] | number[]>,
      blocks: [],
    };
  }

  function makeHordeSetup(opts?: {
    unitCount?: number;
    hordeOverrides?: Record<string, unknown>;
    mapWidth?: number;
  }) {
    const unitCount = opts?.unitCount ?? 3;
    const hordeOverrides = opts?.hordeOverrides ?? {};
    const mapWidth = opts?.mapWidth ?? 20;

    const objects = [
      makeObjectDef('HordeInfantry', 'China', ['INFANTRY'], [
        makeHordeBlock(hordeOverrides),
      ], { MaxHealth: 100 }),
    ];

    // Place units close together (cell 5,5 / 5,6 / 5,7  within 20 world units of each other).
    const mapObjects: MapObjectJSON[] = [];
    for (let i = 0; i < unitCount; i++) {
      mapObjects.push(makeMapObject('HordeInfantry', 5, 5 + i));
    }

    const scene = new THREE.Scene();
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, mapWidth, mapWidth), registry, makeHeightmap(mapWidth, mapWidth));

    return { logic, registry };
  }

  it('grants HORDE weapon bonus when enough units are grouped', () => {
    // 3 infantry within radius  all get HORDE bonus (minCount=3).
    const { logic } = makeHordeSetup({ unitCount: 3 });

    // Run enough frames for the staggered scan to trigger.
    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // All 3 entities should have HORDE bonus.
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
    expect(logic.getEntityState(3)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
  });

  it('does not grant HORDE bonus with too few units', () => {
    // Only 2 infantry when minCount=3  no HORDE bonus.
    const { logic } = makeHordeSetup({ unitCount: 2 });

    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
  });

  it('removes HORDE bonus when unit is destroyed', () => {
    const { logic } = makeHordeSetup({ unitCount: 3 });

    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Verify horde is active.
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);

    // Kill entity 3 to drop below threshold.
    const priv = logic as unknown as { markEntityDestroyed: (id: number, attackerId: number) => void };
    priv.markEntityDestroyed(3, 0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Entity 1 and 2 should lose HORDE bonus (only 2 alive, need 3).
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
  });

  it('does not count enemy units toward horde when AlliesOnly is true', () => {
    // 2 China infantry + 1 America "enemy" infantry  only 2 allies, not enough.
    const objects = [
      makeObjectDef('HordeInfantry', 'China', ['INFANTRY'], [makeHordeBlock()], { MaxHealth: 100 }),
      makeObjectDef('EnemyInfantry', 'America', ['INFANTRY'], [makeHordeBlock()], { MaxHealth: 100 }),
    ];
    const mapObjects = [
      makeMapObject('HordeInfantry', 5, 5),
      makeMapObject('HordeInfantry', 5, 6),
      makeMapObject('EnemyInfantry', 5, 7),
    ];

    const scene = new THREE.Scene();
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, 20, 20), registry, makeHeightmap(20, 20));
    logic.setTeamRelationship('China', 'America', 0);

    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Only 2 allied infantry  not enough for horde.
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
  });

  it('does not count units outside scan range', () => {
    // 3 infantry but one is far away (outside 80 radius).
    // Positions are world coordinates: (5,5), (5,6), (5,100).
    // Distance from (5,5) to (5,100) = 95 > 80 scan radius.
    const objects = [
      makeObjectDef('HordeInfantry', 'China', ['INFANTRY'], [makeHordeBlock()], { MaxHealth: 100 }),
    ];
    const mapObjects = [
      makeMapObject('HordeInfantry', 5, 5),
      makeMapObject('HordeInfantry', 5, 6),
      makeMapObject('HordeInfantry', 5, 100), // Far away (95 units > 80 scan radius).
    ];

    const scene = new THREE.Scene();
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, 120, 120), registry, makeHeightmap(120, 120));

    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Units 1 and 2 only have 1 neighbor each (each other)  not enough (need 2 neighbors).
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
    expect(logic.getEntityState(2)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
    // Unit 3 is isolated (both other units are > 80 away).
    expect(logic.getEntityState(3)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
  });

  it('grants NATIONALISM bonus when horde is active and player has science', () => {
    const { logic } = makeHordeSetup({ unitCount: 3 });

    // Directly add nationalism science for China via private method.
    // normalizeSide('China') = 'china' (lowercase), so use lowercase key.
    const priv = logic as unknown as { addScienceToSide: (side: string, science: string) => boolean };
    priv.addScienceToSide('china', 'SCIENCE_NATIONALISM');
    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // All entities should have HORDE + NATIONALISM.
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_NATIONALISM).toBe(WEAPON_BONUS_NATIONALISM);
    // No fanaticism without the upgrade.
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_FANATICISM).toBe(0);
  });

  it('grants FANATICISM bonus when both nationalism and fanaticism sciences are active', () => {
    const { logic } = makeHordeSetup({ unitCount: 3 });

    const priv = logic as unknown as { addScienceToSide: (side: string, science: string) => boolean };
    priv.addScienceToSide('china', 'SCIENCE_NATIONALISM');
    priv.addScienceToSide('china', 'SCIENCE_FANATICISM');
    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_NATIONALISM).toBe(WEAPON_BONUS_NATIONALISM);
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_FANATICISM).toBe(WEAPON_BONUS_FANATICISM);
  });

  it('rub-off inheritance grants horde to nearby non-qualifying units', () => {
    // 3 units qualify as true horde members. 4th unit placed close to them
    // but it only has 2 neighbors within count range (needs 3). However,
    // it's within rubOffRadius of a true horde member  inherits.
    const objects = [
      makeObjectDef('HordeInfantry', 'China', ['INFANTRY'], [
        makeHordeBlock({ RubOffRadius: 30 }),
      ], { MaxHealth: 100 }),
    ];
    // Place 3 close together (cell 5,5 / 5,6 / 5,7)  true horde members.
    // Place 4th at cell 5,8  within rubOffRadius of entity at cell 5,7 (10 units away).
    // But 4th only has 2 neighbors in scan range (5,6 and 5,7)  not enough for minCount=3,
    // but entity at 5,7 IS a true horde member and within rubOffRadius.
    const mapObjects = [
      makeMapObject('HordeInfantry', 5, 5),
      makeMapObject('HordeInfantry', 5, 6),
      makeMapObject('HordeInfantry', 5, 7),
      makeMapObject('HordeInfantry', 5, 8),
    ];

    const scene = new THREE.Scene();
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, 20, 20), registry, makeHeightmap(20, 20));

    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // All 4 should have HORDE bonus (3 true + 1 via rub-off).
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
    expect(logic.getEntityState(4)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(WEAPON_BONUS_HORDE);
  });

  it('kindOf filter rejects non-matching units', () => {
    // HordeUpdate requires INFANTRY kindOf, but we place VEHICLE units nearby.
    const objects = [
      makeObjectDef('HordeInfantry', 'China', ['INFANTRY'], [
        makeHordeBlock({ KindOf: 'INFANTRY' }),
      ], { MaxHealth: 100 }),
      makeObjectDef('Vehicle', 'China', ['VEHICLE'], [
        makeHordeBlock({ KindOf: 'INFANTRY' }),
      ], { MaxHealth: 100 }),
    ];
    const mapObjects = [
      makeMapObject('HordeInfantry', 5, 5),
      makeMapObject('Vehicle', 5, 6),
      makeMapObject('Vehicle', 5, 7),
    ];

    const scene = new THREE.Scene();
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, 20, 20), registry, makeHeightmap(20, 20));

    logic.update(0);
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // HordeInfantry only counts INFANTRY neighbors  vehicles don't count.
    // Only 1 infantry (itself)  not enough for horde.
    expect(logic.getEntityState(1)!.weaponBonusConditionFlags & WEAPON_BONUS_HORDE).toBe(0);
  });
});

describe('ProneUpdate', () => {
  function makeProneSetup(opts?: {
    damageToFramesRatio?: number;
    attackDamage?: number;
    infantryHealth?: number;
    mapSize?: number;
  }) {
    const ratio = opts?.damageToFramesRatio ?? 2.0;
    const atkDmg = opts?.attackDamage ?? 10;
    const hp = opts?.infantryHealth ?? 200;
    const sz = opts?.mapSize ?? 64;

    const bundle = makeBundle({
      objects: [
        makeObjectDef('ProneInfantry', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: hp, InitialHealth: hp }),
          makeBlock('Behavior', 'ProneUpdate ModuleTag_Prone', {
            DamageToFramesRatio: ratio,
          }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SmallArm'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('SmallArm', {
          AttackRange: 220,
          PrimaryDamage: atkDmg,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ProneInfantry', 30, 30),
        makeMapObject('Attacker', 20, 30),
      ], sz, sz),
      registry,
      makeHeightmap(sz, sz),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    return { logic, scene, registry };
  }

  it('sets PRONE animation and NO_ATTACK when infantry takes damage', () => {
    const { logic } = makeProneSetup({ damageToFramesRatio: 2.0, attackDamage: 10 });

    // Before combat: entity should start IDLE.
    logic.update(0);
    expect(logic.getEntityState(1)!.animationState).toBe('IDLE');

    // Command attacker (entity 2) to attack infantry (entity 1).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Run frames until the attacker fires.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const after = logic.getEntityState(1)!;
    // Infantry took damage  should be PRONE and have lost HP.
    expect(after.health).toBeLessThan(200);
    expect(after.animationState).toBe('PRONE');
  });

  it('recovers from prone after countdown expires', () => {
    // 10 damage * 2.0 ratio = 20 frames of prone.
    const { logic } = makeProneSetup({ damageToFramesRatio: 2.0, attackDamage: 10, infantryHealth: 500 });
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Fire first shot.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Should be prone now.
    expect(logic.getEntityState(1)!.animationState).toBe('PRONE');

    // Stop the attacker so no more damage is dealt.
    logic.submitCommand({ type: 'stop', entityId: 2 });

    // Tick enough frames for prone to expire (20 frames at 30fps = ~0.67s).
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Should have recovered from prone.
    const recovered = logic.getEntityState(1)!;
    expect(recovered.animationState).not.toBe('PRONE');
  });

  it('stacks prone duration when hit multiple times', () => {
    // Use a fast-firing weapon so we get two hits quickly.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ProneInfantry', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50000, InitialHealth: 50000 }),
          makeBlock('Behavior', 'ProneUpdate ModuleTag_Prone', {
            DamageToFramesRatio: 5.0,
          }),
        ]),
        makeObjectDef('FastAttacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'FastGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('FastGun', {
          AttackRange: 220,
          PrimaryDamage: 10,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 200,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ProneInfantry', 30, 30),
        makeMapObject('FastAttacker', 20, 30),
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Run enough frames for at least two shots (200ms delay = ~6 frames at 30fps).
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Destroy attacker to prevent auto-targeting re-acquisition and further damage.
    const priv = logic as unknown as { markEntityDestroyed: (id: number, attackerId: number) => void };
    priv.markEntityDestroyed(2, 0);
    logic.update(1 / 30);

    const midState = logic.getEntityState(1)!;
    expect(midState.animationState).toBe('PRONE');
    expect(midState.health).toBeLessThan(50000);

    // Each hit: floor(10 * 5.0) = 50 prone frames. With ~200ms between shots,
    // multiple hits accumulate (3-4 in 20 frames). Total ~150-200 prone frames,
    // minus ~21 already decayed. Run 50 more  should still be prone (stacking confirmed).
    for (let i = 0; i < 50; i++) logic.update(1 / 30);
    expect(logic.getEntityState(1)!.animationState).toBe('PRONE');

    // Run enough frames to fully expire even a worst-case accumulation.
    for (let i = 0; i < 300; i++) logic.update(1 / 30);
    expect(logic.getEntityState(1)!.animationState).not.toBe('PRONE');
  });

  it('does not trigger prone on entities without ProneUpdate profile', () => {
    // The attacker has no ProneUpdate  taking damage should not cause prone.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NormalUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SmallGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('SmallGun', {
          AttackRange: 220,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NormalUnit', 30, 30),
        makeMapObject('Attacker', 20, 30),
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const state = logic.getEntityState(1)!;
    // Should have taken damage but NOT be prone.
    expect(state.health).toBeLessThan(200);
    expect(state.animationState).not.toBe('PRONE');
  });
});

describe('DemoTrapUpdate', () => {
  function makeDemoTrapBlock(overrides: Record<string, unknown> = {}): IniBlock {
    return {
      type: 'Behavior',
      name: 'DemoTrapUpdate ModuleTag_DemoTrap',
      fields: {
        DefaultProximityMode: 'Yes',
        TriggerDetonationRange: 30,
        ScanRate: 100,
        AutoDetonationWithFriendsInvolved: 'No',
        DetonationWeapon: 'TrapExplosion',
        DetonateWhenKilled: 'Yes',
        ...overrides,
      } as Record<string, string | number | boolean | string[] | number[]>,
      blocks: [],
    };
  }

  function makeDemoTrapSetup(opts?: {
    trapOverrides?: Record<string, unknown>;
    enemyDistance?: number;
    includeAlly?: boolean;
    mapSize?: number;
  }) {
    const overrides = opts?.trapOverrides ?? {};
    const enemyDist = opts?.enemyDistance ?? 1;
    const sz = opts?.mapSize ?? 64;

    const objects = [
      makeObjectDef('DemoTrap', 'GLA', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeDemoTrapBlock(overrides),
      ]),
      makeObjectDef('EnemyTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      ]),
    ];

    if (opts?.includeAlly) {
      objects.push(
        makeObjectDef('AllyUnit', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      );
    }

    const mapObjects: MapObjectJSON[] = [
      makeMapObject('DemoTrap', 30, 30),
      makeMapObject('EnemyTank', 30, 30 + enemyDist),
    ];
    if (opts?.includeAlly) {
      mapObjects.push(makeMapObject('AllyUnit', 30, 31));
    }

    const bundle = makeBundle({
      objects,
      weapons: [
        makeWeaponDef('TrapExplosion', {
          AttackRange: 10,
          PrimaryDamage: 200,
          PrimaryDamageRadius: 40,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);

    return { logic };
  }

  it('detonates when enemy enters proximity range', () => {
    // Enemy 1 unit away, range=30  should detonate.
    const { logic } = makeDemoTrapSetup({ enemyDistance: 1 });

    logic.update(0);
    // Run enough frames for scan to trigger.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Trap should be destroyed.
    const trapState = logic.getEntityState(1);
    expect(trapState === null || !trapState.alive).toBe(true);

    // Enemy should have taken damage from the explosion.
    const enemyState = logic.getEntityState(2)!;
    expect(enemyState.health).toBeLessThan(500);
  });

  it('does not detonate when enemy is outside range', () => {
    // Enemy 50 units away, range=30  no detonation.
    const { logic } = makeDemoTrapSetup({ enemyDistance: 50 });

    logic.update(0);
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Trap should still be alive.
    const trapState = logic.getEntityState(1)!;
    expect(trapState.alive).toBe(true);

    // Enemy should be untouched.
    const enemyState = logic.getEntityState(2)!;
    expect(enemyState.health).toBe(500);
  });

  it('blocks detonation when friendly is nearby and AutoDetonationWithFriendsInvolved=No', () => {
    // Ally unit at (30,31) within range, enemy also in range  no detonation.
    const { logic } = makeDemoTrapSetup({
      includeAlly: true,
      enemyDistance: 2,
      trapOverrides: { AutoDetonationWithFriendsInvolved: 'No' },
    });

    logic.update(0);
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Trap should still be alive (ally blocked detonation).
    const trapState = logic.getEntityState(1)!;
    expect(trapState.alive).toBe(true);
  });

  it('detonates with friendly nearby when AutoDetonationWithFriendsInvolved=Yes', () => {
    const { logic } = makeDemoTrapSetup({
      includeAlly: true,
      enemyDistance: 2,
      trapOverrides: { AutoDetonationWithFriendsInvolved: 'Yes' },
    });

    logic.update(0);
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Trap should have detonated despite ally being nearby.
    const trapState = logic.getEntityState(1);
    expect(trapState === null || !trapState.alive).toBe(true);
  });

  it('detonates on manual command', () => {
    // Start in manual mode (not proximity).
    const { logic } = makeDemoTrapSetup({
      enemyDistance: 50,
      trapOverrides: { DefaultProximityMode: 'No' },
    });

    logic.update(0);
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Trap should still be alive (manual mode, no proximity scan).
    expect(logic.getEntityState(1)!.alive).toBe(true);

    // Issue manual detonate command.
    logic.submitCommand({ type: 'detonateDemoTrap', entityId: 1 });
    logic.update(1 / 30);

    // Trap should be destroyed.
    const trapState = logic.getEntityState(1);
    expect(trapState === null || !trapState.alive).toBe(true);
  });

  it('detonates when killed if DetonateWhenKilled=Yes', () => {
    const { logic } = makeDemoTrapSetup({
      enemyDistance: 5,
      trapOverrides: { DefaultProximityMode: 'No', DetonateWhenKilled: 'Yes' },
    });

    // Add an attacker to kill the trap.
    const objects2 = [
      makeObjectDef('DemoTrap', 'GLA', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeDemoTrapBlock({ DefaultProximityMode: 'No', DetonateWhenKilled: 'Yes' }),
      ]),
      makeObjectDef('EnemyTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
      ]),
    ];
    const bundle2 = makeBundle({
      objects: objects2,
      weapons: [
        makeWeaponDef('BigGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
        makeWeaponDef('TrapExplosion', {
          AttackRange: 10,
          PrimaryDamage: 200,
          PrimaryDamageRadius: 40,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
      ],
    });
    const scene2 = new THREE.Scene();
    const registry2 = makeRegistry(bundle2);
    const logic2 = new GameLogicSubsystem(scene2);
    logic2.loadMapObjects(
      makeMap([
        makeMapObject('DemoTrap', 30, 30),
        makeMapObject('EnemyTank', 28, 30),
      ], 64, 64),
      registry2,
      makeHeightmap(64, 64),
    );
    logic2.setTeamRelationship('GLA', 'America', 0);
    logic2.setTeamRelationship('America', 'GLA', 0);

    // Order the tank to attack the trap.
    logic2.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    const enemyBefore = logic2.getEntityState(2)!.health;

    // Run until the trap is killed by the tank.
    for (let i = 0; i < 15; i++) logic2.update(1 / 30);

    // Trap should be dead, and its detonation weapon should have damaged the tank.
    const trapState = logic2.getEntityState(1);
    expect(trapState === null || !trapState.alive).toBe(true);

    const enemyAfter = logic2.getEntityState(2)!;
    expect(enemyAfter.health).toBeLessThan(enemyBefore);
  });

  it('does not scan in manual mode', () => {
    // Start in manual mode  enemy in range should NOT trigger detonation.
    const { logic } = makeDemoTrapSetup({
      enemyDistance: 1,
      trapOverrides: { DefaultProximityMode: 'No' },
    });

    logic.update(0);
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Trap should still be alive (manual mode, no scanning).
    expect(logic.getEntityState(1)!.alive).toBe(true);

    // Toggle to proximity mode.
    logic.submitCommand({ type: 'toggleDemoTrapMode', entityId: 1 });
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Now it should have detonated.
    const trapState = logic.getEntityState(1);
    expect(trapState === null || !trapState.alive).toBe(true);
  });
});

//  RebuildHoleBehavior tests 

describe('RebuildHoleBehavior', () => {
  /** Build the GLA building + hole + worker INI templates and a test scenario. */
  function makeRebuildHoleSetup(opts?: {
    workerRespawnDelay?: number;
    holeHealthRegenPercent?: number;
    holeMaxHealth?: number;
    buildingBuildTime?: number;
    transferAttackers?: boolean;
  }) {
    const respawnDelayMs = opts?.workerRespawnDelay ?? 100; // ~3 frames at 30fps
    const regenPercent = opts?.holeHealthRegenPercent ?? 10; // INI value: 10 = 10%/sec
    const holeMaxHp = opts?.holeMaxHealth ?? 50;
    const buildTime = opts?.buildingBuildTime ?? 5; // 5 seconds = 150 frames
    const transfer = opts?.transferAttackers ?? true;
    const sz = 64;

    const objects = [
      // 1: GLA building with RebuildHoleExposeDie die module.
      makeObjectDef('GLABarracks', 'GLA', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('Die', 'RebuildHoleExposeDie ModuleTag_RebuildDie', {
          HoleName: 'GLAHole',
          HoleMaxHealth: holeMaxHp,
          TransferAttackers: transfer ? 'Yes' : 'No',
        }),
      ], { BuildTime: buildTime }),
      // 2: The hole object with RebuildHoleBehavior.
      makeObjectDef('GLAHole', 'GLA', ['REBUILD_HOLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: holeMaxHp, InitialHealth: holeMaxHp }),
        makeBlock('Behavior', 'RebuildHoleBehavior ModuleTag_RebuildHole', {
          WorkerObjectName: 'GLAWorker',
          WorkerRespawnDelay: respawnDelayMs,
          'HoleHealthRegen%PerSecond': regenPercent,
        }),
      ]),
      // 3: The worker unit.
      makeObjectDef('GLAWorker', 'GLA', ['INFANTRY', 'DOZER'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
      // 4: Enemy attacker.
      makeObjectDef('EnemyTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankGun'] }),
      ]),
    ];

    const mapObjects: MapObjectJSON[] = [
      makeMapObject('GLABarracks', 30, 30),
      makeMapObject('EnemyTank', 30, 32),
    ];

    const bundle = makeBundle({
      objects,
      weapons: [
        makeWeaponDef('TankGun', {
          AttackRange: 100,
          PrimaryDamage: 50,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 100,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('gla', 'HUMAN');
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('america', 'COMPUTER');

    return { logic, sz };
  }

  it('creates a rebuild hole when building is destroyed', () => {
    const { logic } = makeRebuildHoleSetup();
    logic.update(0);

    // Building is entity 1, enemy is entity 2.
    const buildingBefore = logic.getEntityState(1)!;
    expect(buildingBefore.alive).toBe(true);

    // Kill the building by dealing massive damage.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    // Building should be destroyed.
    const buildingAfter = logic.getEntityState(1);
    expect(buildingAfter === null || !buildingAfter.alive).toBe(true);

    // A hole entity should have been spawned (entity 3).
    logic.update(1 / 30);
    const holeState = logic.getEntityState(3);
    expect(holeState).not.toBeNull();
    expect(holeState!.alive).toBe(true);
    expect(holeState!.templateName).toBe('GLAHole');
  });

  it('spawns worker after respawn delay and begins reconstruction', () => {
    const { logic } = makeRebuildHoleSetup({ workerRespawnDelay: 100 }); // ~3 frames
    logic.update(0);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    // Run for a few frames to let the worker spawn timer tick down.
    // WorkerRespawnDelay=100ms  ~3 frames at 30fps.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Worker should exist (entity 4  after hole=3).
    const workerState = logic.getEntityState(4);
    expect(workerState).not.toBeNull();
    expect(workerState!.alive).toBe(true);
    expect(workerState!.templateName).toBe('GLAWorker');

    // A reconstruction building should exist (entity 5).
    const reconState = logic.getEntityState(5);
    expect(reconState).not.toBeNull();
    expect(reconState!.alive).toBe(true);
    expect(reconState!.templateName).toBe('GLABarracks');
    // Should be under construction.
    expect(reconState!.constructionPercent).toBeGreaterThanOrEqual(0);
  });

  it('completes reconstruction and destroys hole and worker', () => {
    const { logic } = makeRebuildHoleSetup({
      workerRespawnDelay: 100,
      buildingBuildTime: 1, // 1 second  30 frames
    });
    logic.update(0);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    // Run enough frames for worker spawn (~3 frames) + full construction (30 frames).
    for (let i = 0; i < 50; i++) logic.update(1 / 30);

    // Hole should be destroyed (reconstruction complete).
    const holeState = logic.getEntityState(3);
    expect(holeState === null || !holeState.alive).toBe(true);

    // Worker should be destroyed.
    const workerState = logic.getEntityState(4);
    expect(workerState === null || !workerState.alive).toBe(true);

    // Reconstructed building should be alive and complete.
    const reconState = logic.getEntityState(5);
    expect(reconState).not.toBeNull();
    expect(reconState!.alive).toBe(true);
    expect(reconState!.constructionPercent).toBe(-1); // CONSTRUCTION_COMPLETE
    expect(reconState!.health).toBe(500);
  });

  it('respawns worker if worker dies during reconstruction', () => {
    const { logic } = makeRebuildHoleSetup({
      workerRespawnDelay: 100,
      buildingBuildTime: 100, // 100 seconds  long enough to kill worker mid-build
    });
    logic.update(0);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
      markEntityDestroyed: (id: number, attackerId: number) => void;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    // Let worker spawn.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    const firstWorkerState = logic.getEntityState(4);
    expect(firstWorkerState).not.toBeNull();
    expect(firstWorkerState!.alive).toBe(true);

    // Kill the worker.
    privateApi.markEntityDestroyed(4, -1);
    const deadWorker = logic.getEntityState(4);
    expect(deadWorker === null || !deadWorker.alive).toBe(true);

    // Run more frames to let replacement worker spawn.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // New worker should be spawned (entity 6  after recon=5).
    const newWorkerState = logic.getEntityState(6);
    expect(newWorkerState).not.toBeNull();
    expect(newWorkerState!.alive).toBe(true);
    expect(newWorkerState!.templateName).toBe('GLAWorker');
  });

  it('restarts construction if reconstructing building is destroyed', () => {
    const { logic } = makeRebuildHoleSetup({
      workerRespawnDelay: 100,
      buildingBuildTime: 10000,
    });
    logic.update(0);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
      markEntityDestroyed: (id: number, attackerId: number) => void;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    // Let worker spawn and reconstruction start.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    expect(logic.getEntityState(5)).not.toBeNull(); // Reconstruction exists.

    // Kill the reconstruction building.
    privateApi.markEntityDestroyed(5, -1);

    // Run more frames  should restart the cycle.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Hole should still be alive.
    const holeState = logic.getEntityState(3);
    expect(holeState).not.toBeNull();
    expect(holeState!.alive).toBe(true);

    // A new worker and reconstruction should exist.
    // Worker 4 was killed when recon died, new worker is 6, new recon is 7.
    const newRecon = logic.getEntityState(7);
    expect(newRecon).not.toBeNull();
    expect(newRecon!.alive).toBe(true);
    expect(newRecon!.templateName).toBe('GLABarracks');
  });

  it('destroys worker when hole is killed', () => {
    const { logic } = makeRebuildHoleSetup({
      workerRespawnDelay: 100,
      buildingBuildTime: 10000,
    });
    logic.update(0);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
      markEntityDestroyed: (id: number, attackerId: number) => void;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    // Let worker spawn.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    expect(logic.getEntityState(4)!.alive).toBe(true); // Worker alive.

    // Kill the hole.
    privateApi.markEntityDestroyed(3, -1);

    // Worker should also be destroyed.
    const workerState = logic.getEntityState(4);
    expect(workerState === null || !workerState.alive).toBe(true);
  });

  it('does not create hole for buildings under construction', () => {
    const { logic } = makeRebuildHoleSetup();
    logic.update(0);

    // Mark building as under construction.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    building.objectStatusFlags.add('UNDER_CONSTRUCTION');

    // Kill the building.
    privateApi.applyWeaponDamageAmount(2, building as unknown as never, 9999, 'EXPLOSION');

    logic.update(1 / 30);

    // No hole should exist  entity 3 should not be a hole.
    const entity3 = logic.getEntityState(3);
    expect(entity3).toBeNull();
  });

  it('heals hole passively over time', () => {
    const { logic } = makeRebuildHoleSetup({
      workerRespawnDelay: 30000, // Long delay so worker doesn't spawn.
      holeHealthRegenPercent: 50, // INI value: 50 = 50%/sec  heals fast.
      holeMaxHealth: 100,
    });
    logic.update(0);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building, 9999, 'EXPLOSION');

    logic.update(1 / 30);

    // Damage the hole.
    const hole = privateApi.spawnedEntities.get(3) as { health: number; maxHealth: number };
    expect(hole).toBeTruthy();
    hole.health = 50; // Half health.

    // Run 30 frames (1 second) at 50% regen/sec  should heal ~50 HP.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const holeState = logic.getEntityState(3)!;
    expect(holeState.health).toBeGreaterThan(90); // Should be near max.
  });

  it('transfers attackers from dead building to hole', () => {
    const { logic } = makeRebuildHoleSetup({ transferAttackers: true });
    logic.update(0);

    // Make enemy attack the building.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    logic.update(1 / 30);

    // Kill the building.
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { attackTargetEntityId: number | null }>;
    };
    const building = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, building as unknown as never, 9999, 'EXPLOSION');

    // After building death, enemy's target should be redirected to hole (entity 3).
    const enemy = privateApi.spawnedEntities.get(2)!;
    expect(enemy.attackTargetEntityId).toBe(3);
  });
});

describe('AutoDepositUpdate', () => {
  /** Build a scenario with an auto-deposit building (e.g., oil derrick). */
  function makeAutoDepositSetup(opts?: {
    depositTimingMs?: number;
    depositAmount?: number;
    initialCaptureBonus?: number;
    startCredits?: number;
  }) {
    const timingMs = opts?.depositTimingMs ?? 1000; // 1s = 30 frames
    const amount = opts?.depositAmount ?? 100;
    const captureBonus = opts?.initialCaptureBonus ?? 0;
    const startCredits = opts?.startCredits ?? 500;
    const sz = 64;

    const objects = [
      makeObjectDef('OilDerrick', 'GLA', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('Behavior', 'AutoDepositUpdate ModuleTag_AutoDeposit', {
          DepositTiming: timingMs,
          DepositAmount: amount,
          InitialCaptureBonus: captureBonus,
        }),
      ]),
    ];

    const mapObjects: MapObjectJSON[] = [
      makeMapObject('OilDerrick', 30, 30),
    ];

    const bundle = makeBundle({ objects });
    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('gla', 'HUMAN');
    logic.submitCommand({ type: 'setSideCredits', side: 'gla', amount: startCredits });

    return { logic, startCredits };
  }

  it('deposits money at fixed intervals', () => {
    const { logic, startCredits } = makeAutoDepositSetup({
      depositTimingMs: 1000, // 30 frames
      depositAmount: 50,
    });

    // Source parity: C++ constructor sets m_depositOnFrame = currentFrame + depositFrame.
    // Entity created at frame 0, so first deposit at frame 30.
    // Advance 29 frames (frameCounter 1-29)  no deposit yet.
    for (let i = 0; i < 29; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getSideCredits('gla')).toBe(startCredits);

    // Frame 30 triggers the first deposit.
    logic.update(1 / 30);
    expect(logic.getSideCredits('gla')).toBe(startCredits + 50);
  });

  it('deposits repeatedly at each interval', () => {
    const { logic, startCredits } = makeAutoDepositSetup({
      depositTimingMs: 500, // 15 frames
      depositAmount: 25,
    });
    logic.update(0);

    // Advance 45 frames = 3 deposit intervals.
    for (let i = 0; i < 45; i++) {
      logic.update(1 / 30);
    }
    expect(logic.getSideCredits('gla')).toBe(startCredits + 75);
  });

  it('awards initial capture bonus on ownership change', () => {
    // Source parity: C++ awardInitialCaptureBonus is called from Player.cpp line 1038
    // when a building with AutoDeposit changes ownership to a non-neutral player.
    const sz = 64;
    const objects = [
      makeObjectDef('OilDerrick', 'Neutral', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('Behavior', 'AutoDepositUpdate ModuleTag_AutoDeposit', {
          DepositTiming: 10000, // Long interval  no periodic deposits during test.
          DepositAmount: 10,
          InitialCaptureBonus: 200,
        }),
      ]),
    ];

    const mapObjects: MapObjectJSON[] = [makeMapObject('OilDerrick', 30, 30)];
    const bundle = makeBundle({ objects });
    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('gla', 'HUMAN');
    logic.submitCommand({ type: 'setSideCredits', side: 'gla', amount: 500 });

    // Let the deposit timer elapse so m_initialized becomes true and capture bonus is pending.
    // DepositTiming = 10000ms  300 frames. Advance 301 frames to let the timer fire.
    for (let i = 0; i < 301; i++) {
      logic.update(1 / 30);
    }
    // Still neutral  no deposit and no capture bonus yet.
    expect(logic.getSideCredits('gla')).toBe(500);

    // Capture: change ownership to GLA.
    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'gla' });
    logic.update(1 / 30);

    // Capture bonus of 200 should be awarded.
    expect(logic.getSideCredits('gla')).toBe(700);

    // Capture again  bonus should NOT be awarded again.
    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'gla' });
    logic.update(1 / 30);
    expect(logic.getSideCredits('gla')).toBe(700);
  });

  it('does not deposit for entities under construction', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('OilDerrick', 'GLA', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('Behavior', 'AutoDepositUpdate ModuleTag_AutoDeposit', {
          DepositTiming: 100, // Very short
          DepositAmount: 999,
          InitialCaptureBonus: 0,
        }),
      ], { BuildTime: 100 }), // 100 seconds
      makeObjectDef('Dozer', 'GLA', ['VEHICLE', 'DOZER'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ];

    const mapObjects: MapObjectJSON[] = [
      makeMapObject('Dozer', 25, 30),
    ];

    const bundle = makeBundle({ objects });
    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('gla', 'HUMAN');
    logic.submitCommand({ type: 'setSideCredits', side: 'gla', amount: 1000 });
    logic.update(0);

    // Command dozer to construct the building.
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'OilDerrick',
      targetPosition: [30, 0, 30],
      angle: 0,
      lineEndPosition: null,
    });

    // Advance frames  building is under construction.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // Credits should not have increased from auto-deposit (only building cost deducted).
    const credits = logic.getSideCredits('gla');
    // Building cost is deducted but no auto-deposit income should have been added.
    expect(credits).toBeLessThanOrEqual(1000);
  });

  it('does not deposit for entities without a player type', () => {
    const { logic, startCredits } = makeAutoDepositSetup({
      depositTimingMs: 100,
      depositAmount: 999,
    });
    // Remove player type mapping.
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.delete('gla');
    logic.update(0);

    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // No deposits should have been made.
    expect(logic.getSideCredits('gla')).toBe(startCredits);
  });

  it('skips deposit when depositAmount is zero', () => {
    const { logic, startCredits } = makeAutoDepositSetup({
      depositTimingMs: 100, // 3 frames
      depositAmount: 0,
    });

    // Advance 60 frames  deposit timer fires many times but amount is zero.
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // No deposits should have occurred.
    expect(logic.getSideCredits('gla')).toBe(startCredits);
  });
});

describe('DynamicShroudClearingRangeUpdate', () => {
  function makeDynamicShroudSetup(opts?: {
    growDelayMs?: number;
    growTimeMs?: number;
    shrinkDelayMs?: number;
    shrinkTimeMs?: number;
    finalVision?: number;
    changeIntervalMs?: number;
    growIntervalMs?: number;
    visionRange?: number;
  }) {
    const sz = 64;
    const growDelayMs = opts?.growDelayMs ?? 100;   // 3 frames
    const growTimeMs = opts?.growTimeMs ?? 200;      // 6 frames
    const shrinkDelayMs = opts?.shrinkDelayMs ?? 333; // 10 frames (must be >= growDelay + growTime per C++ invariant)
    const shrinkTimeMs = opts?.shrinkTimeMs ?? 200;   // 6 frames
    const finalVision = opts?.finalVision ?? 5;
    const changeIntervalMs = opts?.changeIntervalMs ?? 33; // ~1 frame
    const growIntervalMs = opts?.growIntervalMs ?? 33;     // ~1 frame
    const visionRange = opts?.visionRange ?? 100;

    const objects = [
      makeObjectDef('SpySat', 'USA', ['STRUCTURE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'DynamicShroudClearingRangeUpdate ModuleTag_Shroud', {
          GrowDelay: growDelayMs,
          GrowTime: growTimeMs,
          ShrinkDelay: shrinkDelayMs,
          ShrinkTime: shrinkTimeMs,
          FinalVision: finalVision,
          ChangeInterval: changeIntervalMs,
          GrowInterval: growIntervalMs,
        }),
      ], { VisionRange: visionRange }),
    ];

    const mapObjects: MapObjectJSON[] = [makeMapObject('SpySat', 30, 30)];
    const bundle = makeBundle({ objects });
    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('usa', 'HUMAN');

    return { logic };
  }

  function getEntityVisionRange(logic: GameLogicSubsystem): number {
    const entities = (logic as unknown as { spawnedEntities: Map<number, { visionRange: number }> }).spawnedEntities;
    for (const entity of entities.values()) {
      return entity.visionRange;
    }
    return 0;
  }

  it('grows vision range from 0 to native during growing phase', () => {
    // growDelay=3 frames, growTime=6 frames, shrinkDelay=10 frames, shrinkTime=6 frames
    // stateCountDown = shrinkDelay + shrinkTime = 10 + 6 = 16
    // shrinkStartDeadline = 16 - 10 = 6
    // growStartDeadline = 16 - 3 = 13
    // sustainDeadline = 13 - 6 = 7 (>= shrinkStartDeadline )
    const { logic } = makeDynamicShroudSetup({
      growDelayMs: 100,   // 3 frames
      growTimeMs: 200,    // 6 frames
      shrinkDelayMs: 333, // 10 frames
      shrinkTimeMs: 200,  // 6 frames
      finalVision: 5,
      visionRange: 100,
    });

    // Initial vision range should be entity's native range (set at creation before DynamicShroud modifies it).
    // After first update, DynamicShroud starts modifying the vision range.
    logic.update(1 / 30); // frame 1

    // After enough frames, the vision range should start growing.
    // The grow phase grows by nativeClearingRange/growTime per frame.
    // Native = 100*MAP_XY_FACTOR = 1000, growTime = 6 frames, so +166.67 per frame.
    // After 6 grow frames, vision should reach native.
    for (let i = 0; i < 20; i++) {
      logic.update(1 / 30);
    }

    // After all phases complete, vision should reach finalVision = 5 (raw INI value).
    // Keep advancing until DONE/SLEEPING.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    const finalRange = getEntityVisionRange(logic);
    // Should be at or near finalVision = 5.
    expect(finalRange).toBeCloseTo(5, 0);
  });

  it('settles to final vision after full lifecycle', () => {
    const { logic } = makeDynamicShroudSetup({
      growDelayMs: 33,    // 1 frame
      growTimeMs: 100,    // 3 frames
      shrinkDelayMs: 133, // 4 frames (>= growDelay + growTime per C++ invariant)
      shrinkTimeMs: 100,  // 3 frames
      finalVision: 10,
      changeIntervalMs: 33, // 1 frame
      growIntervalMs: 33,   // 1 frame
      visionRange: 50,
    });

    // Run enough frames for the full lifecycle: grow  sustain  shrink  done  sleeping.
    // stateCountDown = shrinkDelay + shrinkTime = 4 + 3 = 7 frames total.
    // Run 30 frames to be safe.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    const finalRange = getEntityVisionRange(logic);
    // finalVision = 10 (raw INI value).
    expect(finalRange).toBeCloseTo(10, 0);
  });

  it('does not modify vision range for entities without the module', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('Tank', 'USA', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ], { VisionRange: 150 }),
    ];
    const mapObjects: MapObjectJSON[] = [makeMapObject('Tank', 30, 30)];
    const bundle = makeBundle({ objects });
    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));

    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    const range = getEntityVisionRange(logic);
    // VisionRange = 150 (raw INI value, not scaled), should be unchanged.
    expect(range).toBe(150);
  });
});

describe('VeterancyGainCreate', () => {
  it('sets starting veterancy level when player has required science', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('EliteTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('Behavior', 'VeterancyGainCreate ModuleTag_VetCreate', {
          StartingLevel: 'VETERAN',
          ScienceRequired: 'SCIENCE_TANK_VETERAN',
        }),
      ], { ExperienceRequired: [0, 50, 200, 500], ExperienceValue: [10, 20, 30, 40] }),
    ];
    const sciences = [makeScienceDef('SCIENCE_TANK_VETERAN', { IsGrantable: 'Yes' })];
    const bundle = makeBundle({ objects, sciences });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());

    // Pre-populate the side's science set directly (bypasses registry lookup in grantSideScience).
    const priv = logic as unknown as { sideSciences: Map<string, Set<string>> };
    priv.sideSciences.set('america', new Set(['SCIENCE_TANK_VETERAN']));

    logic.loadMapObjects(makeMap([makeMapObject('EliteTank', 30, 30)], sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('america', 'HUMAN');

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, { experienceState: { currentLevel: number } }>;
    }).spawnedEntities;
    const tank = entities.get(1)!;
    // Should start at VETERAN (level 1) due to VeterancyGainCreate.
    expect(tank.experienceState.currentLevel).toBe(1);
  });

  it('does not set veterancy when player lacks required science', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('EliteTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('Behavior', 'VeterancyGainCreate ModuleTag_VetCreate', {
          StartingLevel: 'ELITE',
          ScienceRequired: 'SCIENCE_TANK_ELITE',
        }),
      ], { ExperienceRequired: [0, 50, 200, 500], ExperienceValue: [10, 20, 30, 40] }),
    ];
    const sciences = [makeScienceDef('SCIENCE_TANK_ELITE', { IsGrantable: 'Yes' })];
    const bundle = makeBundle({ objects, sciences });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());

    // Do NOT grant the science  sideSciences is empty.
    logic.loadMapObjects(makeMap([makeMapObject('EliteTank', 30, 30)], sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('america', 'HUMAN');

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, { experienceState: { currentLevel: number } }>;
    }).spawnedEntities;
    const tank = entities.get(1)!;
    // Should stay at REGULAR (level 0) since the science is not owned.
    expect(tank.experienceState.currentLevel).toBe(0);
  });

  it('sets veterancy without science requirement when ScienceRequired is omitted', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('HeroUnit', 'GLA', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        makeBlock('Behavior', 'VeterancyGainCreate ModuleTag_VetCreate', {
          StartingLevel: 'HEROIC',
        }),
      ], { ExperienceRequired: [0, 100, 300, 800], ExperienceValue: [50, 100, 150, 200] }),
    ];
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(makeMap([makeMapObject('HeroUnit', 30, 30)], sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('gla', 'HUMAN');

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, { experienceState: { currentLevel: number } }>;
    }).spawnedEntities;
    const unit = entities.get(1)!;
    // Should start at HEROIC (level 3) since no science is required.
    expect(unit.experienceState.currentLevel).toBe(3);
  });

  it('never lowers veterancy level (setMinVeterancyLevel)', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('MixedVet', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        // First module grants ELITE unconditionally.
        makeBlock('Behavior', 'VeterancyGainCreate ModuleTag_VetCreate1', {
          StartingLevel: 'ELITE',
        }),
        // Second module would grant VETERAN  should be ignored (never lowers).
        makeBlock('Behavior', 'VeterancyGainCreate ModuleTag_VetCreate2', {
          StartingLevel: 'VETERAN',
        }),
      ], { ExperienceRequired: [0, 50, 200, 500], ExperienceValue: [10, 20, 30, 40] }),
    ];
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(makeMap([makeMapObject('MixedVet', 30, 30)], sz, sz), registry, makeHeightmap(sz, sz));
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('america', 'HUMAN');

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, { experienceState: { currentLevel: number } }>;
    }).spawnedEntities;
    const tank = entities.get(1)!;
    // Should be ELITE (level 2), not lowered to VETERAN.
    expect(tank.experienceState.currentLevel).toBe(2);
  });
});

describe('FXListDie', () => {
  it('parses FXListDie profiles from INI with DieMuxData fields', () => {
    const objects = [
      makeObjectDef('FXUnit', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'FXListDie ModuleTag_FXDie1', {
          DeathFX: 'FX_InfantryDeath',
          OrientToObject: 'Yes',
        }),
        makeBlock('Behavior', 'FXListDie ModuleTag_FXDie2', {
          DeathFX: 'FX_CrushDeath',
          DeathTypes: 'CRUSHED EXPLODED',
          OrientToObject: 'No',
        }),
      ]),
    ];
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(makeMap([makeMapObject('FXUnit', 10, 10)]), registry, makeHeightmap());

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        fxListDieProfiles: Array<{
          deathFXName: string;
          orientToObject: boolean;
          deathTypes: Set<string>;
        }>;
      }>;
    };
    const unit = priv.spawnedEntities.get(1)!;
    expect(unit.fxListDieProfiles.length).toBe(2);
    // First profile: no DeathTypes filter, orientToObject = true.
    expect(unit.fxListDieProfiles[0]!.deathFXName).toBe('FX_INFANTRYDEATH');
    expect(unit.fxListDieProfiles[0]!.orientToObject).toBe(true);
    expect(unit.fxListDieProfiles[0]!.deathTypes.size).toBe(0);
    // Second profile: CRUSHED + EXPLODED death types, orientToObject = false.
    expect(unit.fxListDieProfiles[1]!.deathFXName).toBe('FX_CRUSHDEATH');
    expect(unit.fxListDieProfiles[1]!.orientToObject).toBe(false);
    expect(unit.fxListDieProfiles[1]!.deathTypes.has('CRUSHED')).toBe(true);
    expect(unit.fxListDieProfiles[1]!.deathTypes.has('EXPLODED')).toBe(true);
  });

  it('emits death FX visual events when FXListDie profile matches', () => {
    const objects = [
      makeObjectDef('FXUnit', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'FXListDie ModuleTag_FXDie', {
          DeathFX: 'FX_InfantryDeath',
        }),
      ]),
      makeObjectDef('Attacker', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestCannon'] }),
      ]),
    ];
    const weapons = [
      makeWeaponDef('TestCannon', {
        AttackRange: 120, PrimaryDamage: 999, DelayBetweenShots: 100,
      }),
    ];
    const bundle = makeBundle({ objects, weapons });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('FXUnit', 10, 10), makeMapObject('Attacker', 30, 10)]),
      registry, makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    for (let i = 0; i < 12; i++) {
      logic.update(1 / 30);
    }

    // After the kill: 1 ENTITY_DESTROYED from standard death + 1 from FXListDie = at least 2.
    const events = logic.drainVisualEvents();
    const destroyEvents = events.filter(e => e.type === 'ENTITY_DESTROYED');
    expect(destroyEvents.length).toBeGreaterThanOrEqual(2);
  });
});

describe('CrushDie', () => {
  it('extracts CrushDie profiles from INI with DieMuxData fields', () => {
    const objects = [
      makeObjectDef('CrushVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'CrushDie ModuleTag_CrushDie1', {}),
        makeBlock('Behavior', 'CrushDie ModuleTag_CrushDie2', {
          DeathTypes: 'CRUSHED',
          ExemptStatus: 'SOLD',
        }),
      ], { CrushableLevel: 2 }),
    ];
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(makeMap([makeMapObject('CrushVictim', 10, 10)]), registry, makeHeightmap());

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        crushDieProfiles: Array<{ deathTypes: Set<string>; exemptStatus: Set<string> }>;
      }>;
    };
    const unit = priv.spawnedEntities.get(1)!;
    expect(unit.crushDieProfiles.length).toBe(2);
    // First profile: no filtering (empty sets).
    expect(unit.crushDieProfiles[0]!.deathTypes.size).toBe(0);
    // Second profile: CRUSHED death type, SOLD exempt status.
    expect(unit.crushDieProfiles[1]!.deathTypes.has('CRUSHED')).toBe(true);
    expect(unit.crushDieProfiles[1]!.exemptStatus.has('SOLD')).toBe(true);
  });

  it('sets crush model conditions when entity dies from crush damage', () => {
    // Use the same pattern as 'crush damage during movement' tests  cell-aligned positions on large map.
    const objects = [
      makeObjectDef('CrushVictim', 'China', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'CrushDie ModuleTag_CrushDie', {}),
        makeBlock('Collide', 'SquishCollide ModuleTag_Squish', {}),
      ], { CrushableLevel: 0 }),
      makeObjectDef('CrusherTank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('LocomotorSet', 'SET_NORMAL TankLoco', {}),
      ], { CrusherLevel: 2, GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
    ];
    const locomotors = [makeLocomotorDef('TankLoco', 180)];
    const bundle = makeBundle({ objects, locomotors });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    // Place victim and crusher on the same Z row, crusher to the left.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrushVictim', 225, 205),
        makeMapObject('CrusherTank', 205, 205),
      ], 128, 128),
      registry, makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Access internal state to check crush flags after death pipeline but before finalize.
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        destroyed: boolean;
        frontCrushed: boolean;
        backCrushed: boolean;
        modelConditionFlags: Set<string>;
        pendingDeathType: string;
      }>;
    };
    const victim = priv.spawnedEntities.get(1)!;

    // Move tank through victim.
    logic.submitCommand({ type: 'moveTo', entityId: 2, targetX: 255, targetZ: 205 });

    let foundCrush = false;
    for (let i = 0; i < 20; i++) {
      logic.update(1 / 30);
      // Keep a direct reference: finalizeDestroyedEntities removes dead entities from
      // spawnedEntities in the same update tick.
      if (victim.destroyed && !foundCrush) {
        foundCrush = true;
        // Crush die should have set the model condition flags.
        expect(victim.frontCrushed || victim.backCrushed).toBe(true);
        expect(
          victim.modelConditionFlags.has('FRONTCRUSHED')
          || victim.modelConditionFlags.has('BACKCRUSHED'),
        ).toBe(true);
        expect(victim.pendingDeathType).toBe('CRUSHED');
        break;
      }
    }
    expect(foundCrush).toBe(true);
    expect(priv.spawnedEntities.has(1)).toBe(false);
  });

  it('does not set crush flags when entity dies from non-crush damage', () => {
    const objects = [
      makeObjectDef('CrushVictim', 'China', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'CrushDie ModuleTag_CrushDie', {}),
      ]),
      makeObjectDef('Shooter', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
      ]),
    ];
    const weapons = [
      makeWeaponDef('TestGun', {
        AttackRange: 120, PrimaryDamage: 999, DelayBetweenShots: 100,
      }),
    ];
    const bundle = makeBundle({ objects, weapons });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CrushVictim', 10, 10), makeMapObject('Shooter', 30, 10)]),
      registry, makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        destroyed: boolean;
        frontCrushed: boolean;
        backCrushed: boolean;
      }>;
    };

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
      const victim = priv.spawnedEntities.get(1);
      if (victim?.destroyed) {
        // Died from gun damage, not crush  no crush flags should be set.
        expect(victim.frontCrushed).toBe(false);
        expect(victim.backCrushed).toBe(false);
        return;
      }
    }
    // Entity should be dead.
    expect(logic.getEntityState(1)).toBeNull();
  });
});

describe('WanderAIUpdate', () => {
  function makeWanderSetup() {
    const objects = [
      makeObjectDef('Wanderer', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL WanderLoco', {}),
        makeBlock('Behavior', 'WanderAIUpdate ModuleTag_Wander', {}),
      ]),
      makeObjectDef('Stationary', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('LocomotorSet', 'SET_NORMAL WanderLoco', {}),
      ]),
    ];
    const bundle = makeBundle({ objects, locomotors: [makeLocomotorDef('WanderLoco', 30)] });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Wanderer', 50, 50), makeMapObject('Stationary', 200, 200)], 128, 128),
      registry, makeHeightmap(128, 128),
    );
    return logic;
  }

  it('moves idle entity with WanderAIUpdate to a random position', () => {
    const logic = makeWanderSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { x: number; z: number; hasWanderAI: boolean; canMove: boolean }> };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.hasWanderAI).toBe(true);
    expect(entity.canMove).toBe(true);
    const startX = entity.x;
    const startZ = entity.z;

    // Run enough frames for wander movement to occur
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    const hasMoved = entity.x !== startX || entity.z !== startZ;
    expect(hasMoved).toBe(true);
  });

  it('does not move entity without WanderAIUpdate', () => {
    const logic = makeWanderSetup();
    const priv = logic as unknown as { spawnedEntities: Map<number, { x: number; z: number }> };
    const entity = priv.spawnedEntities.get(2)!;
    const startX = entity.x;
    const startZ = entity.z;

    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    expect(entity.x).toBe(startX);
    expect(entity.z).toBe(startZ);
  });
});

describe('FloatUpdate', () => {
  function makeFloatSetup(opts?: { enabled?: boolean; waterHeight?: number }) {
    const sz = 64;
    const waterH = opts?.waterHeight ?? 20;
    const enabled = opts?.enabled ?? true;
    const objects = [
      makeObjectDef('Boat', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('Behavior', 'FloatUpdate ModuleTag_Float', {
          Enabled: enabled ? 'Yes' : 'No',
        }),
      ]),
      makeObjectDef('Tank', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
    ];
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());

    // Create map with a water polygon trigger covering the area 0..500, 0..500.
    // MapPoint uses original engine coordinates: x=horizontal X, y=horizontal Z, z=height.
    const mapData: MapDataJSON = {
      heightmap: {
        width: sz,
        height: sz,
        borderSize: 0,
        data: uint8ArrayToBase64(new Uint8Array(sz * sz).fill(0)),
      },
      objects: [
        makeMapObject('Boat', 50, 50),
        makeMapObject('Tank', 200, 200),
      ],
      triggers: [{
        name: 'WaterArea1',
        id: 1,
        isWaterArea: true,
        isRiver: false,
        points: [
          { x: 0, y: 0, z: waterH },
          { x: 500, y: 0, z: waterH },
          { x: 500, y: 500, z: waterH },
          { x: 0, y: 500, z: waterH },
        ],
      }],
      textureClasses: [],
      blendTileCount: 0,
    };

    logic.loadMapObjects(mapData, registry, makeHeightmap(sz, sz));
    return logic;
  }

  it('snaps entity with FloatUpdate to water surface height', () => {
    const waterHeight = 25;
    const logic = makeFloatSetup({ waterHeight });
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { y: number; baseHeight: number; floatUpdateProfile: { enabled: boolean } | null }>;
    };
    const boat = priv.spawnedEntities.get(1)!;
    expect(boat.floatUpdateProfile?.enabled).toBe(true);

    // Before update, entity is on terrain (height = 0 + baseHeight).
    const baseH = boat.baseHeight;
    expect(boat.y).toBeCloseTo(baseH, 1);

    // After one frame, entity should snap to water surface.
    logic.update(1 / 30);
    expect(boat.y).toBeCloseTo(waterHeight + baseH, 1);
  });

  it('does not modify entity without FloatUpdate', () => {
    const logic = makeFloatSetup({ waterHeight: 25 });
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { y: number; floatUpdateProfile: { enabled: boolean } | null }>;
    };
    const tank = priv.spawnedEntities.get(2)!;
    expect(tank.floatUpdateProfile).toBeNull();

    const startY = tank.y;
    logic.update(1 / 30);
    expect(tank.y).toBe(startY);
  });

  it('does not modify entity with FloatUpdate when not over water', () => {
    const sz = 64;
    const objects = [
      makeObjectDef('Boat', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        makeBlock('Behavior', 'FloatUpdate ModuleTag_Float', { Enabled: 'Yes' }),
      ]),
    ];
    const bundle = makeBundle({ objects });
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(new THREE.Scene());

    // Map with NO water triggers.
    logic.loadMapObjects(
      makeMap([makeMapObject('Boat', 50, 50)], sz, sz),
      registry,
      makeHeightmap(sz, sz),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { y: number; floatUpdateProfile: { enabled: boolean } | null }>;
    };
    const boat = priv.spawnedEntities.get(1)!;
    expect(boat.floatUpdateProfile?.enabled).toBe(true);

    const startY = boat.y;
    logic.update(1 / 30);
    // Not over water, so height should not change.
    expect(boat.y).toBe(startY);
  });
});

describe('SlavedUpdate', () => {
  function makeSlavedSetup(opts?: {
    spawnNumber?: number;
    guardMaxRange?: number;
    attackRange?: number;
    scoutRange?: number;
    repairRatePerSecond?: number;
    repairBelowHealthPercent?: number;
    spawnedRequireSpawner?: boolean;
    oneShot?: boolean;
    distToTargetToGrantRangeBonus?: number;
  }) {
    const guardRange = opts?.guardMaxRange ?? 50;
    const attackRange = opts?.attackRange ?? 0;
    const scoutRange = opts?.scoutRange ?? 0;
    const repairRate = opts?.repairRatePerSecond ?? 0;
    const repairBelow = opts?.repairBelowHealthPercent ?? 0;
    const requireSpawner = opts?.spawnedRequireSpawner ?? true;
    const isOneShot = opts?.oneShot ?? false;
    const spawnCount = opts?.spawnNumber ?? 1;
    const droneSpottingDist = opts?.distToTargetToGrantRangeBonus ?? 0;
    const sz = 128;

    const objects = [
      // 1: Master vehicle with SpawnBehavior
      makeObjectDef('MasterVehicle', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('Behavior', 'SpawnBehavior ModuleTag_Spawn', {
          SpawnNumber: spawnCount,
          SpawnReplaceDelay: 3000, // 3 sec = 90 frames
          SpawnTemplateName: 'DroneUnit',
          SpawnedRequireSpawner: requireSpawner ? 'Yes' : 'No',
          OneShot: isOneShot ? 'Yes' : 'No',
          InitialBurst: spawnCount,
        }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'MasterGun'] }),
      ]),
      // 2: Drone slave with SlavedUpdate
      makeObjectDef('DroneUnit', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'SlavedUpdate ModuleTag_Slaved', {
          GuardMaxRange: guardRange,
          GuardWanderRange: 10,
          AttackRange: attackRange,
          AttackWanderRange: 5,
          ScoutRange: scoutRange,
          ScoutWanderRange: 5,
          DistToTargetToGrantRangeBonus: droneSpottingDist,
          RepairRatePerSecond: repairRate,
          'RepairWhenBelowHealth%': repairBelow,
        }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'DroneGun'] }),
      ]),
      // Enemy target
      makeObjectDef('EnemyTank', 'GLA', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankGun'] }),
      ]),
    ];

    const mapObjects: MapObjectJSON[] = [
      makeMapObject('MasterVehicle', 60, 60),
      makeMapObject('EnemyTank', 60, 90),
    ];

    const bundle = makeBundle({
      objects,
      weapons: [
        makeWeaponDef('MasterGun', {
          AttackRange: 100,
          PrimaryDamage: 20,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 500,
        }),
        makeWeaponDef('DroneGun', {
          AttackRange: 50,
          PrimaryDamage: 10,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 300,
        }),
        makeWeaponDef('TankGun', {
          AttackRange: 100,
          PrimaryDamage: 30,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 500,
        }),
      ],
    });

    const scene = new THREE.Scene();
    const registry = makeRegistry(bundle);
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects, sz, sz), registry, makeHeightmap(sz, sz));
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('america', 'HUMAN');
    (logic as unknown as { sidePlayerTypes: Map<string, string> }).sidePlayerTypes.set('gla', 'COMPUTER');

    return { logic, sz };
  }

  function getEntity(logic: GameLogicSubsystem, id: number) {
    return (logic as unknown as { spawnedEntities: Map<number, {
      slaverEntityId: number | null;
      statusFlags: Set<string>;
      destroyed: boolean;
      health: number;
      maxHealth: number;
      moveTarget: { x: number; z: number } | null;
      attackTargetEntityId: number | null;
      x: number; z: number;
      weaponBonusConditionFlags: number;
    }> }).spawnedEntities.get(id);
  }

  it('spawns slaves on master creation and marks them UNSELECTABLE', () => {
    const { logic } = makeSlavedSetup({ spawnNumber: 2 });
    logic.update(0);

    // Master is entity 1, enemy is entity 2. Slaves should be 3 and 4.
    const slave1 = getEntity(logic, 3);
    const slave2 = getEntity(logic, 4);
    expect(slave1).toBeDefined();
    expect(slave2).toBeDefined();
    expect(slave1!.slaverEntityId).toBe(1);
    expect(slave2!.slaverEntityId).toBe(1);
    expect(slave1!.objectStatusFlags.has('UNSELECTABLE')).toBe(true);
    expect(slave2!.objectStatusFlags.has('UNSELECTABLE')).toBe(true);
  });

  it('kills slaves when master dies with spawnedRequireSpawner', () => {
    const { logic } = makeSlavedSetup({ spawnedRequireSpawner: true });
    logic.update(0);

    const slave = getEntity(logic, 3);
    expect(slave).toBeDefined();
    expect(slave!.destroyed).toBe(false);

    // Kill the master.
    const api = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const master = api.spawnedEntities.get(1)!;
    api.applyWeaponDamageAmount(2, master as never, 9999, 'EXPLOSION');

    // Slave should also be destroyed.
    expect(slave!.destroyed).toBe(true);
  });

  it('disables slaves with DISABLED_UNMANNED when master dies without spawnedRequireSpawner', () => {
    const { logic } = makeSlavedSetup({ spawnedRequireSpawner: false });
    logic.update(0);

    const slave = getEntity(logic, 3);
    expect(slave).toBeDefined();

    // Kill the master.
    const api = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const master = api.spawnedEntities.get(1)!;
    api.applyWeaponDamageAmount(2, master as never, 9999, 'EXPLOSION');

    // Slave should be orphaned (slaverEntityId = null) but not immediately destroyed.
    expect(slave!.slaverEntityId).toBe(null);
    expect(slave!.objectStatusFlags.has('UNSELECTABLE')).toBe(false);
  });

  it('replaces dead slaves after replace delay', () => {
    const { logic } = makeSlavedSetup({ spawnNumber: 1 });
    logic.update(0);

    const slave = getEntity(logic, 3);
    expect(slave).toBeDefined();

    // Kill the slave.
    const api = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    api.applyWeaponDamageAmount(null, slave as never, 9999, 'EXPLOSION');

    // Advance frames but not enough for replacement (90 frames = 3s).
    for (let i = 0; i < 50; i++) {
      logic.update(1 / 30);
    }
    // No replacement yet.
    const potentialReplacement = getEntity(logic, 4);
    // Entity 4 might not exist or could be the replacement  check slave count.
    const master = getEntity(logic, 1);
    const state = (master as unknown as { spawnBehaviorState: { slaveIds: number[] } })?.spawnBehaviorState;
    const liveSlaves1 = state?.slaveIds.filter((id: number) => {
      const e = getEntity(logic, id);
      return e && !e.destroyed;
    });
    // At 50 frames, replacement shouldn't have happened yet.
    expect(liveSlaves1?.length ?? 0).toBe(0);

    // Advance past the 90-frame threshold.
    for (let i = 0; i < 50; i++) {
      logic.update(1 / 30);
    }
    const liveSlaves2 = state?.slaveIds.filter((id: number) => {
      const e = getEntity(logic, id);
      return e && !e.destroyed;
    });
    expect(liveSlaves2?.length ?? 0).toBe(1);
  });

  it('does not replace slaves when oneShot is true', () => {
    const { logic } = makeSlavedSetup({ spawnNumber: 1, oneShot: true });
    logic.update(0);

    const slave = getEntity(logic, 3);
    expect(slave).toBeDefined();

    // Kill the slave.
    const api = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
    };
    api.applyWeaponDamageAmount(null, slave as never, 9999, 'EXPLOSION');

    // Advance well past replacement delay.
    for (let i = 0; i < 200; i++) {
      logic.update(1 / 30);
    }

    // No replacement should have occurred.
    const master = getEntity(logic, 1);
    const state = (master as unknown as { spawnBehaviorState: { slaveIds: number[] } })?.spawnBehaviorState;
    const liveSlaves = state?.slaveIds.filter((id: number) => {
      const e = getEntity(logic, id);
      return e && !e.destroyed;
    });
    expect(liveSlaves?.length ?? 0).toBe(0);
  });

  it('slave follows master via guard logic', () => {
    const { logic } = makeSlavedSetup({ guardMaxRange: 30 });
    logic.update(0);

    // Move the master far away.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 100, targetZ: 100 });

    // Advance enough frames for the master to move and slave to update.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    const slave = getEntity(logic, 3);
    expect(slave).toBeDefined();
    // Slave should have a move target (following the master).
    expect(slave!.moveTarget).not.toBeNull();
  });

  it('slave heals master when repair rate is set and master is damaged', () => {
    const { logic } = makeSlavedSetup({
      repairRatePerSecond: 30, // 1 HP per frame
      repairBelowHealthPercent: 100, // Always emergency repair
    });
    logic.update(0);

    // Damage the master.
    const master = getEntity(logic, 1);
    expect(master).toBeDefined();
    master!.health = 400;

    // Advance frames for repair to take effect.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // Master should have healed somewhat.
    expect(master!.health).toBeGreaterThan(400);
  });
});

describe('CountermeasuresBehavior', () => {
  /**
   * Setup: Aircraft with countermeasures, enemy missile launcher targets it.
   *
   * Map layout (128128, MAP_XY_FACTOR=10  world = cell*10+5):
   *   Entity 1: Aircraft (America) at cell (5,5)  world (55,55)
   *   Entity 2: Missile launcher (GLA) at cell (5,2)  world (55,25)
   */
  function makeCountermeasureSetup(opts?: {
    evasionRate?: number;
    volleySize?: number;
    numberOfVolleys?: number;
    missileDecoyDelayMs?: number;
    reactionLatencyMs?: number;
    reloadTimeMs?: number;
    delayBetweenVolleysMs?: number;
    missileSpeed?: number;
    missileDamage?: number;
  }) {
    const evasionRate = opts?.evasionRate ?? 100; // percent
    const volleySize = opts?.volleySize ?? 2;
    const numberOfVolleys = opts?.numberOfVolleys ?? 3;
    const missileDecoyDelayMs = opts?.missileDecoyDelayMs ?? 333; // ~10 frames
    const reactionLatencyMs = opts?.reactionLatencyMs ?? 100; // ~3 frames
    const reloadTimeMs = opts?.reloadTimeMs ?? 0; // no auto-reload by default
    const delayBetweenVolleysMs = opts?.delayBetweenVolleysMs ?? 333; // ~10 frames
    const missileSpeed = opts?.missileSpeed ?? 3; // slow missile for longer flight
    const missileDamage = opts?.missileDamage ?? 200;

    const bundle = makeBundle({
      objects: [
        makeObjectDef('CountermeasureAircraft', 'America', ['VEHICLE', 'AIRCRAFT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'CountermeasuresBehavior ModuleTag_CM', {
            FlareTemplateName: '',
            VolleySize: volleySize,
            VolleyArcAngle: 30,
            VolleyVelocityFactor: 1.0,
            DelayBetweenVolleys: delayBetweenVolleysMs,
            NumberOfVolleys: numberOfVolleys,
            ReloadTime: reloadTimeMs,
            EvasionRate: evasionRate,
            MissileDecoyDelay: missileDecoyDelayMs,
            ReactionLaunchLatency: reactionLatencyMs,
          }),
        ], { IsAirborneTarget: 'Yes' }),
        makeObjectDef('EnemyLauncher', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'EnemyMissileWeapon'] }),
        ]),
        makeObjectDef('TestMissile', 'GLA', ['PROJECTILE', 'SMALL_MISSILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('EnemyMissileWeapon', {
          AttackRange: 120,
          PrimaryDamage: missileDamage,
          WeaponSpeed: missileSpeed,
          DelayBetweenShots: 10000,
          ProjectileObject: 'TestMissile',
          AntiAirborneVehicle: 'Yes',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CountermeasureAircraft', 5, 5),
        makeMapObject('EnemyLauncher', 5, 2),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Set America and GLA as enemies.
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const entities = (logic as unknown as { spawnedEntities: Map<number, { templateName: string; health: number; maxHealth: number; countermeasuresState: unknown; category: string }> }).spawnedEntities;
    let aircraft: (typeof entities extends Map<number, infer V> ? V : never) | undefined;
    let launcher: (typeof entities extends Map<number, infer V> ? V : never) | undefined;
    for (const [, e] of entities) {
      if (e.templateName === 'CountermeasureAircraft') aircraft = e;
      if (e.templateName === 'EnemyLauncher') launcher = e;
    }

    return { logic, entities, aircraft: aircraft!, launcher: launcher! };
  }

  it('initializes countermeasures state on entity creation', () => {
    const { aircraft } = makeCountermeasureSetup({ volleySize: 2, numberOfVolleys: 3 });
    const state = aircraft.countermeasuresState as {
      availableCountermeasures: number;
      activeCountermeasures: number;
      flareIds: number[];
    };
    expect(state).toBeTruthy();
    expect(state.availableCountermeasures).toBe(6); // 2 * 3
    expect(state.activeCountermeasures).toBe(0);
    expect(state.flareIds.length).toBe(0);
  });

  it('diverts missile and suppresses damage when evasion succeeds', () => {
    const { logic, aircraft } = makeCountermeasureSetup({
      evasionRate: 100, // 100% evasion  always diverts
      missileDamage: 200,
      missileSpeed: 3,
      missileDecoyDelayMs: 33, // ~1 frame  divert before missile arrives
      reactionLatencyMs: 33,  // ~1 frame  launch flares immediately
    });

    // Command enemy (entity 2) to attack aircraft (entity 1).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    const initialHealth = aircraft.health;
    // Check pending events after weapon fires.
    const pendingEvents = (logic as unknown as { pendingWeaponDamageEvents: { countermeasureDivertFrame: number; countermeasureNoDamage: boolean }[] }).pendingWeaponDamageEvents;

    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // Verify that any missile events were marked for diversion.
    // With 100% evasion, the aircraft should take no damage from missiles.
    // It may still take damage from subsequent attacks if the weapon reloads.
    expect(aircraft.health).toBe(initialHealth);
  });

  it('does not divert missile when evasion rate is 0%', () => {
    const { logic, aircraft, launcher } = makeCountermeasureSetup({
      evasionRate: 0, // 0% evasion  never diverts
      missileDamage: 100,
      missileSpeed: 5,
    });

    // Use entity IDs directly (1=aircraft, 2=launcher by creation order).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    const initialHealth = aircraft.health;
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // With 0% evasion, the missile should hit  aircraft takes damage.
    expect(aircraft.health).toBeLessThan(initialHealth);
  });

  it('consumes countermeasures and launches volleys', () => {
    const { logic, aircraft, launcher } = makeCountermeasureSetup({
      evasionRate: 100,
      volleySize: 2,
      numberOfVolleys: 2,
      reactionLatencyMs: 100, // ~3 frames
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Advance past reaction time + first volley launch.
    for (let i = 0; i < 20; i++) {
      logic.update(1 / 30);
    }

    const state = aircraft.countermeasuresState as {
      availableCountermeasures: number;
      activeCountermeasures: number;
    };

    // Should have consumed at least one volley worth of countermeasures.
    expect(state.availableCountermeasures).toBeLessThan(4); // started with 2*2=4
  });

  it('auto-reloads countermeasures after reload timer expires', () => {
    const { logic, aircraft } = makeCountermeasureSetup({
      evasionRate: 100,
      volleySize: 1,
      numberOfVolleys: 1,
      reloadTimeMs: 333, // ~10 frames to reload
      reactionLatencyMs: 33,
      missileDecoyDelayMs: 33,
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    const state = aircraft.countermeasuresState as {
      availableCountermeasures: number;
      reloadFrame: number;
    };

    // Initial: 1 countermeasure available.
    expect(state.availableCountermeasures).toBe(1);

    // Advance a few frames  missile fires, countermeasures activate and are consumed.
    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    // After the volley, countermeasures should be depleted (0 available).
    // The reload timer should have started.
    const afterVolleyAvailable = state.availableCountermeasures;

    // Advance well past reload time (another 30 frames).
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // After reload, if volley was consumed, countermeasures should be restored.
    if (afterVolleyAvailable === 0) {
      expect(state.availableCountermeasures).toBe(1);
    } else {
      // Volley wasn't consumed  just verify the state is valid.
      expect(state.availableCountermeasures).toBeGreaterThanOrEqual(0);
    }
  });

  it('only diverts MISSILE projectiles, not BULLET delivery', () => {
    // Setup with a direct (non-missile) weapon  countermeasures should not activate.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CMTarget', 'America', ['VEHICLE', 'AIRCRAFT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'CountermeasuresBehavior ModuleTag_CM', {
            FlareTemplateName: '',
            VolleySize: 2,
            NumberOfVolleys: 3,
            EvasionRate: 100,
            MissileDecoyDelay: 333,
            ReactionLaunchLatency: 100,
          }),
        ]),
        makeObjectDef('GunEnemy', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'GunWeapon'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('GunWeapon', {
          AttackRange: 120,
          PrimaryDamage: 50,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
          AntiAirborneVehicle: 'Yes',
          // No ProjectileObject  this is a direct/bullet weapon.
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CMTarget', 5, 5),
        makeMapObject('GunEnemy', 5, 2),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const entities = (logic as unknown as { spawnedEntities: Map<number, { templateName: string; health: number; id: number; category: string }> }).spawnedEntities;
    let target: { templateName: string; health: number; id: number; category: string } | undefined;
    let enemy: { templateName: string; health: number; id: number; category: string } | undefined;
    for (const [, e] of entities) {
      if (e.templateName === 'CMTarget') target = e;
      if (e.templateName === 'GunEnemy') enemy = e;
    }

    logic.submitCommand({ type: 'attackEntity', entityId: enemy!.id, targetEntityId: target!.id });

    const initialHealth = target!.health;
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // Bullet damage should go through  countermeasures don't affect direct weapons.
    expect(target!.health).toBeLessThan(initialHealth);
  });
});

//  PilotFindVehicleUpdate 

describe('PilotFindVehicleUpdate', () => {
  function makePilotSetup(opts: {
    pilotSide?: string;
    vehicleSide?: string;
    playerType?: 'HUMAN' | 'COMPUTER';
    vehicleHealth?: number;
    vehicleMaxHealth?: number;
    scanRange?: number;
    minHealth?: number;
    vehicleOccupied?: boolean;
  } = {}) {
    const pilotSide = opts.pilotSide ?? 'America';
    const vehicleSide = opts.vehicleSide ?? 'America';
    const playerType = opts.playerType ?? 'COMPUTER';
    const vehicleHealth = opts.vehicleHealth ?? 200;
    const vehicleMaxHealth = opts.vehicleMaxHealth ?? 200;
    const scanRange = opts.scanRange ?? 300;
    const minHealth = opts.minHealth ?? 0.5;

    const objects: ObjectDef[] = [
      makeObjectDef('Pilot', pilotSide, ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        makeBlock('Behavior', 'VeterancyCrateCollide ModuleTag_PilotCollide', {
          IsPilot: 'Yes',
        }),
        makeBlock('Behavior', 'PilotFindVehicleUpdate ModuleTag_PFV', {
          ScanRate: 100,
          ScanRange: scanRange,
          MinHealth: minHealth,
        }),
      ]),
      makeObjectDef('EmptyTank', vehicleSide, ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: vehicleMaxHealth, InitialHealth: vehicleHealth }),
      ], { ExperienceRequired: [1, 50, 100, 200] }),
    ];

    if (opts.vehicleOccupied) {
      objects.push(
        makeObjectDef('Occupant', vehicleSide, ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
      );
    }

    const bundle = makeBundle({ objects });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);

    const mapObjects = [
      makeMapObject('Pilot', 5, 5),
      makeMapObject('EmptyTank', 5, 8),
    ];
    if (opts.vehicleOccupied) {
      mapObjects.push(makeMapObject('Occupant', 5, 8));
    }

    logic.loadMapObjects(
      makeMap(mapObjects, 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    if (playerType === 'COMPUTER') {
      logic.submitCommand({ type: 'setSidePlayerType', side: pilotSide, playerType: 'COMPUTER' });
    }

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        templateName: string;
        x: number;
        z: number;
        y: number;
        moving: boolean;
        destroyed: boolean;
        moveTarget: { x: number; z: number } | null;
        pilotFindVehicleProfile: unknown;
        pilotFindVehicleDidMoveToBase: boolean;
        pilotFindVehicleTargetId: number | null;
        transportContainerId: number | null;
        experienceState: { currentLevel: number };
        category: string;
      }>;
    }).spawnedEntities;

    let pilot: (typeof entities extends Map<number, infer V> ? V : never) | undefined;
    let vehicle: (typeof entities extends Map<number, infer V> ? V : never) | undefined;
    let occupant: (typeof entities extends Map<number, infer V> ? V : never) | undefined;
    for (const [, e] of entities) {
      if (e.templateName === 'Pilot') pilot = e;
      if (e.templateName === 'EmptyTank') vehicle = e;
      if (e.templateName === 'Occupant') occupant = e;
    }

    if (opts.vehicleOccupied && occupant && vehicle) {
      occupant.transportContainerId = vehicle.id;
    }

    return { logic, pilot: pilot!, vehicle: vehicle!, entities };
  }

  it('initializes PilotFindVehicleProfile from INI', () => {
    const { pilot } = makePilotSetup();
    expect(pilot.pilotFindVehicleProfile).not.toBeNull();
  });

  it('AI pilot moves toward empty same-side vehicle', () => {
    const { logic, pilot, vehicle } = makePilotSetup();

    // Run enough frames for the scan to trigger and pilot to reach vehicle.
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // Pilot should either still be moving/targeting, or be consumed after veterancy transfer.
    const hasTarget = pilot.pilotFindVehicleTargetId === vehicle.id;
    const isMoving = pilot.moveTarget !== null || pilot.moving;
    expect(hasTarget || isMoving || pilot.destroyed).toBe(true);
    if (pilot.destroyed) {
      expect(vehicle.experienceState.currentLevel).toBeGreaterThan(0);
    }
  });

  it('does not activate for human-controlled pilots', () => {
    const { logic, pilot } = makePilotSetup({ playerType: 'HUMAN' });

    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    // Human-controlled pilots should not auto-seek vehicles.
    expect(pilot.pilotFindVehicleTargetId).toBeNull();
  });

  it('rejects vehicles below minHealth threshold', () => {
    // Vehicle at 40% health (80/200), minHealth=0.5  below 50%, should be rejected.
    const { logic, pilot } = makePilotSetup({
      vehicleHealth: 80,
      vehicleMaxHealth: 200,
      minHealth: 0.5,
    });

    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    // Pilot should NOT target the damaged vehicle.
    expect(pilot.pilotFindVehicleTargetId).toBeNull();
  });

  it('does not target vehicles of different side', () => {
    const { logic, pilot } = makePilotSetup({ vehicleSide: 'GLA' });

    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    expect(pilot.pilotFindVehicleTargetId).toBeNull();
  });

  it('allows targeting occupied same-side vehicles when pilot collide path is valid', () => {
    const { logic, pilot, vehicle } = makePilotSetup({ vehicleOccupied: true });

    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
    }

    // Source parity: occupied same-side vehicles are still valid for pilot collide behavior.
    expect(pilot.destroyed).toBe(true);
    expect(vehicle.experienceState.currentLevel).toBeGreaterThan(0);
  });

  it('moves to base when no vehicle found', () => {
    // Create setup with a building for base center + vehicle out of scan range.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Pilot', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'PilotFindVehicleUpdate ModuleTag_PFV', {
            ScanRate: 100,
            ScanRange: 1,
            MinHealth: 0.5,
          }),
        ]),
        makeObjectDef('EmptyTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('BaseBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Pilot', 5, 5),
        makeMapObject('EmptyTank', 60, 60),  // Far away, out of scan range (1)
        makeMapObject('BaseBuilding', 10, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'COMPUTER' });

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, {
        templateName: string;
        pilotFindVehicleDidMoveToBase: boolean;
      }>;
    }).spawnedEntities;

    let pilot: { templateName: string; pilotFindVehicleDidMoveToBase: boolean } | undefined;
    for (const [, e] of entities) {
      if (e.templateName === 'Pilot') pilot = e;
    }

    for (let i = 0; i < 15; i++) {
      logic.update(1 / 30);
    }

    // After scan finds no vehicle, pilot should move to base once.
    expect(pilot!.pilotFindVehicleDidMoveToBase).toBe(true);
  });
});

//  ToppleUpdate 

describe('ToppleUpdate', () => {
  function makeToppleBundle(opts: {
    killWhenFinished?: boolean;
    killWhenStart?: boolean;
    initialVelocityPercent?: number;
    initialAccelPercent?: number | null;
    bounceVelocityPercent?: number;
  } = {}) {
    return makeBundle({
      objects: [
        makeObjectDef('Tree', 'Neutral', ['SHRUBBERY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'ToppleUpdate ModuleTag_Topple', {
            InitialVelocityPercent: opts.initialVelocityPercent ?? 20,
            ...(opts.initialAccelPercent !== null ? { InitialAccelPercent: opts.initialAccelPercent ?? 1 } : {}),
            BounceVelocityPercent: opts.bounceVelocityPercent ?? 30,
            KillWhenFinishedToppling: opts.killWhenFinished ?? true,
            KillWhenStartToppling: opts.killWhenStart ?? false,
          }),
        ]),
      ],
    });
  }

  function makeToppleSetup(opts: Parameters<typeof makeToppleBundle>[0] = {}) {
    const bundle = makeToppleBundle(opts);
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Tree', 5, 5)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        templateName: string;
        destroyed: boolean;
        toppleProfile: unknown;
        toppleState: string;
        toppleDirX: number;
        toppleDirZ: number;
        toppleAngularVelocity: number;
        toppleAngularAccumulation: number;
        toppleSpeed: number;
        blocksPath: boolean;
      }>;
      applyTopplingForce(entity: unknown, dirX: number, dirZ: number, speed: number): void;
    }).spawnedEntities;

    let tree: (typeof entities extends Map<number, infer V> ? V : never) | undefined;
    for (const [, e] of entities) {
      if (e.templateName === 'Tree') tree = e;
    }

    const applyTopple = (logic as unknown as {
      applyTopplingForce(entity: unknown, dirX: number, dirZ: number, speed: number): void;
    }).applyTopplingForce.bind(logic);

    return { logic, tree: tree!, entities, applyTopple };
  }

  it('initializes ToppleProfile from INI', () => {
    const { tree } = makeToppleSetup();
    expect(tree.toppleProfile).not.toBeNull();
    expect(tree.toppleState).toBe('NONE');
  });

  it('applies toppling force and transitions to TOPPLING state', () => {
    const { logic, tree, applyTopple } = makeToppleSetup();
    applyTopple(tree, 1, 0, 5.0);

    expect(tree.toppleState).toBe('TOPPLING');
    expect(tree.toppleDirX).toBeCloseTo(1.0);
    expect(tree.toppleDirZ).toBeCloseTo(0.0);
    expect(tree.toppleAngularVelocity).toBeGreaterThan(0);
    // Source parity: blocksPath cleared on topple start.
    expect(tree.blocksPath).toBe(false);
  });

  it('ignores second topple force while already toppling', () => {
    const { tree, applyTopple } = makeToppleSetup();
    applyTopple(tree, 1, 0, 5.0);
    const firstVelocity = tree.toppleAngularVelocity;

    // Second topple should be ignored.
    applyTopple(tree, 0, 1, 10.0);
    expect(tree.toppleAngularVelocity).toBe(firstVelocity);
    expect(tree.toppleDirX).toBeCloseTo(1.0);
  });

  it('progresses angular accumulation toward PI/2 over frames', () => {
    const { logic, tree, applyTopple } = makeToppleSetup();
    applyTopple(tree, 1, 0, 5.0);

    // Run a few frames  angular accumulation should increase.
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }

    expect(tree.toppleAngularAccumulation).toBeGreaterThan(0);
  });

  it('kills entity when finished toppling with KillWhenFinishedToppling=true', () => {
    const { logic, tree, applyTopple } = makeToppleSetup({ killWhenFinished: true });
    // Source parity: typical crusher speed is ~1.0 units/frame (tank at 30 units/sec, 30fps).
    applyTopple(tree, 1, 0, 1.0);

    // Run many frames until topple completes.
    for (let i = 0; i < 300; i++) {
      logic.update(1 / 30);
      if (tree.destroyed) break;
    }

    expect(tree.destroyed).toBe(true);
  });

  it('kills entity immediately when KillWhenStartToppling=true', () => {
    const { tree, applyTopple } = makeToppleSetup({ killWhenStart: true });
    applyTopple(tree, 0, 1, 5.0);

    expect(tree.destroyed).toBe(true);
  });

  it('bounces at angular limit and eventually stops', () => {
    // High initial velocity ensures at least one visible bounce. Non-zero acceleration
    // provides the gravity-like force needed to converge (C++ default is 0.01).
    const { logic, tree, applyTopple } = makeToppleSetup({
      killWhenFinished: false,
      bounceVelocityPercent: 50,
      initialVelocityPercent: 80,
    });
    applyTopple(tree, 1, 0, 1.0);

    let sawBouncing = false;
    for (let i = 0; i < 300; i++) {
      logic.update(1 / 30);
      if (tree.toppleState === 'BOUNCING') sawBouncing = true;
      if (tree.toppleState === 'DONE') break;
    }

    expect(sawBouncing).toBe(true);
    expect(tree.toppleState).toBe('DONE');
  });

  it('exposes topple angle on RenderableEntityState', () => {
    const { logic, tree, applyTopple } = makeToppleSetup();
    applyTopple(tree, 1, 0, 5.0);

    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }

    // Source parity: topple data exposed via makeRenderableEntityState for renderer.
    const states = logic.getRenderableEntityStates();
    const treeState = states.find((s) => s.id === tree.id);
    expect(treeState).toBeDefined();
    expect(treeState!.toppleAngle).toBeGreaterThan(0);
    expect(treeState!.toppleDirX).toBeCloseTo(1.0);
    expect(treeState!.toppleDirZ).toBeCloseTo(0.0);
  });

  it('crush collision topples tree instead of instantly killing it', () => {
    // Source parity: In C++, ToppleUpdate::onCollide handles crush for trees.
    // Trees are NOT squish-killed; they topple and die on completion.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CrusherTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('LocomotorSet', 'SET_NORMAL TankLocomotor', {}),
        ], { CrusherLevel: 2, GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('ToppleTree', 'Neutral', ['SHRUBBERY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'ToppleUpdate ModuleTag_Topple', {
            InitialVelocityPercent: 20,
            BounceVelocityPercent: 30,
            KillWhenFinishedToppling: true,
          }),
        ], { CrushableLevel: 0 }),
      ],
      locomotors: [
        makeLocomotorDef('TankLocomotor', 180),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CrusherTank', 205, 205),
        makeMapObject('ToppleTree', 215, 205),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'Neutral', 0);
    logic.setTeamRelationship('Neutral', 'America', 0);

    const entities = (logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        templateName: string;
        destroyed: boolean;
        toppleState: string;
        health: number;
      }>;
    }).spawnedEntities;

    let tree: { destroyed: boolean; toppleState: string; health: number } | undefined;
    for (const [, e] of entities) {
      if (e.templateName === 'ToppleTree') tree = e;
    }

    // Move tank through the tree.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 255, targetZ: 205 });

    // Run frames until tree starts toppling or gets destroyed.
    for (let i = 0; i < 60; i++) {
      logic.update(1 / 30);
      if (tree!.toppleState !== 'NONE' || tree!.destroyed) break;
    }

    // Tree should be toppling, NOT instantly destroyed by crush damage.
    // The tree should still be alive at this point (death comes when topple finishes).
    if (tree!.toppleState !== 'NONE') {
      expect(tree!.toppleState).not.toBe('NONE');
      // Tree should still have full health (no crush damage applied).
      expect(tree!.health).toBe(50);
    }
  });
});

// 
// SpecialAbilityUpdate  unit special ability state machine
// 

function makeSpecialAbilityBundle(params: {
  abilityFields?: Record<string, unknown>;
  specialPowerName?: string;
  targetObjectDef?: ObjectDef;
  moveSpeed?: number;
}) {
  const specialPowerName = params.specialPowerName ?? 'TestAbilityPower';
  const moveSpeed = params.moveSpeed ?? 30;
  return makeBundle({
    objects: [
      makeObjectDef('AbilityUser', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody Body', { MaxHealth: 100, InitialHealth: 100 }),
        makeBlock('Behavior', 'SpecialAbilityUpdate AbilityModule', {
          SpecialPowerTemplate: specialPowerName,
          UpdateModuleStartsAttack: true,
          ...params.abilityFields,
        }),
        makeBlock('LocomotorSet', 'LocomotorSet', { Locomotor: ['SET_NORMAL', 'TestLoco'] }),
      ], { CommandSet: 'AbilityUserCS', BuildCost: 500 }),
      ...(params.targetObjectDef ? [params.targetObjectDef] : [
        makeObjectDef('AbilityTarget', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ]),
    ],
    specialPowers: [
      makeSpecialPowerDef(specialPowerName, { ReloadTime: 0 }),
    ],
    locomotors: [
      makeLocomotorDef('TestLoco', moveSpeed),
    ],
  });
}

function makeSpecialAbilitySetup(
  abilityFields: Record<string, unknown> = {},
  targetPosition?: { x: number; y: number },
) {
  const bundle = makeSpecialAbilityBundle({ abilityFields });
  const scene = new THREE.Scene();
  const logic = new GameLogicSubsystem(scene);

  const mapObjects = [
    makeMapObject('AbilityUser', 10, 10),
    ...(targetPosition ? [makeMapObject('AbilityTarget', targetPosition.x, targetPosition.y)] : []),
  ];

  logic.loadMapObjects(
    makeMap(mapObjects),
    makeRegistry(bundle),
    makeHeightmap(),
  );

  return { logic, scene };
}

describe('SpecialAbilityUpdate', () => {
  it('extracts SpecialAbilityProfile from INI', () => {
    const { logic } = makeSpecialAbilitySetup({
      StartAbilityRange: 50,
      AbilityAbortRange: 100,
      PreparationTime: 1000,
      PackTime: 500,
      UnpackTime: 750,
      SkipPackingWithNoTarget: true,
      FleeRangeAfterCompletion: 40,
      FlipOwnerAfterUnpacking: true,
    });

    const entity = logic.getEntityState(1);
    expect(entity).not.toBeNull();
    // Entity should have been created successfully with a special ability profile.
    // Verify via the specialAbilityState being initialized.
    expect(entity!.statusFlags).toBeDefined();
  });

  it('initiates ability and sets IS_USING_ABILITY status flag', () => {
    const { logic } = makeSpecialAbilitySetup(
      { UnpackTime: 0, PreparationTime: 500, SkipPackingWithNoTarget: true },
    );

    // Issue special ability command (no target).
    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    logic.update(1 / 30);

    const state = logic.getEntityState(1);
    expect(state).not.toBeNull();
    expect(state!.statusFlags).toContain('IS_USING_ABILITY');
  });

  it('runs unpack  preparation  pack lifecycle with no target', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        UnpackTime: 100,  // ~3 frames
        PreparationTime: 100, // ~3 frames
        PackTime: 100, // ~3 frames
        SkipPackingWithNoTarget: false,
      },
    );

    // Issue no-target ability.
    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    // Tick through unpack + prep + pack: ~9 frames + overhead.
    let abilityCleared = false;
    for (let frame = 0; frame < 30; frame++) {
      logic.update(1 / 30);
      const s = logic.getEntityState(1);
      if (s && !s.statusFlags.includes('IS_USING_ABILITY') && frame > 2) {
        abilityCleared = true;
        break;
      }
    }

    expect(abilityCleared).toBe(true);
  });

  it('skips packing with SkipPackingWithNoTarget and no-target command', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        UnpackTime: 0,
        PreparationTime: 100, // ~3 frames
        PackTime: 500, // would be ~15 frames if not skipped
        SkipPackingWithNoTarget: true,
      },
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    // With SkipPackingWithNoTarget and prep ~3 frames, should finish quickly
    // (no unpack, prep only, then skip pack  finish).
    let abilityCleared = false;
    for (let frame = 0; frame < 10; frame++) {
      logic.update(1 / 30);
      const s = logic.getEntityState(1);
      if (s && !s.statusFlags.includes('IS_USING_ABILITY') && frame > 0) {
        abilityCleared = true;
        break;
      }
    }

    // Should finish in well under 10 frames (no 15-frame pack).
    expect(abilityCleared).toBe(true);
  });

  it('approaches target position when not within StartAbilityRange', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        StartAbilityRange: 15,
        UnpackTime: 0,
        PreparationTime: 100,
        PackTime: 0,
      },
    );

    // commandOption 0x20 = COMMAND_OPTION_NEED_TARGET_POS  position-targeted ability.
    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0x20,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: 50,
      targetZ: 50,
    });
    logic.update(1 / 30);

    // Entity should have the special ability active with target position stored.
    const entity = (logic as any).spawnedEntities.get(1);
    expect(entity).toBeDefined();
    // Verify ability was initiated.
    expect(entity.specialAbilityState).not.toBeNull();
    expect(entity.specialAbilityState.active).toBe(true);
    expect(entity.specialAbilityState.targetX).toBe(50);
    expect(entity.specialAbilityState.targetZ).toBe(50);
    // Verify entity is not yet within range.
    expect(entity.specialAbilityState.withinStartAbilityRange).toBe(false);
  });

  it('aborts ability when target entity dies during preparation', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        StartAbilityRange: 10000,
        UnpackTime: 0,
        PreparationTime: 5000, // long prep time (~150 frames)
        PackTime: 0,
      },
      { x: 10, y: 11 }, // Target placed very close.
    );

    // Directly initiate the special ability with target entity via internal state,
    // bypassing the routing layer which requires enemy relationship.
    const entity = (logic as any).spawnedEntities.get(1);
    const state = entity.specialAbilityState;
    state.active = true;
    state.targetEntityId = 2;
    state.withinStartAbilityRange = true;
    state.packingState = 'UNPACKED';
    entity.objectStatusFlags.add('IS_USING_ABILITY');

    // Tick a few frames to get into preparation.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)!.statusFlags).toContain('IS_USING_ABILITY');

    // Force-kill target by directly manipulating internal state.
    const target = (logic as any).spawnedEntities.get(2);
    if (target) {
      target.health = 0;
      target.destroyed = true;
    }

    logic.update(1 / 30);

    // Ability should be aborted  IS_USING_ABILITY cleared.
    const afterState = logic.getEntityState(1);
    expect(afterState!.statusFlags).not.toContain('IS_USING_ABILITY');
  });

  it('cancels ability when entity receives stop command', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        StartAbilityRange: 10000,
        UnpackTime: 0,
        PreparationTime: 5000,
        PackTime: 0,
        SkipPackingWithNoTarget: true,
      },
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    // Tick a few frames  IS_USING_ABILITY set at preparation start (first frame).
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)!.statusFlags).toContain('IS_USING_ABILITY');

    // Stop command should cancel the ability.
    logic.submitCommand({ type: 'stop', entityId: 1 });
    logic.update(1 / 30);

    expect(logic.getEntityState(1)!.statusFlags).not.toContain('IS_USING_ABILITY');
  });

  it('persistent ability triggers multiple times before packing', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        StartAbilityRange: 10000,
        UnpackTime: 0,
        PreparationTime: 100, // ~3 frames to first trigger
        PersistentPrepTime: 100, // ~3 frames between subsequent triggers
        PackTime: 0,
        SkipPackingWithNoTarget: true,
      },
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    // Run for 20 frames  should trigger multiple times and stay active.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Persistent ability should STILL be active (never packs until stopped).
    const state = logic.getEntityState(1);
    expect(state!.statusFlags).toContain('IS_USING_ABILITY');
  });

  it('flips entity rotation after unpacking when FlipOwnerAfterUnpacking is set', () => {
    const { logic } = makeSpecialAbilitySetup(
      {
        StartAbilityRange: 10000,
        UnpackTime: 100, // ~3 frames
        PreparationTime: 10000,
        PackTime: 0,
        FlipOwnerAfterUnpacking: true,
        SkipPackingWithNoTarget: false,
      },
    );

    const entity = (logic as any).spawnedEntities.get(1);
    const rotBefore = entity.rotationY;

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_ABILITY',
      specialPowerName: 'TestAbilityPower',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    // Run through unpack animation (~3 frames) + a few extra.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Rotation should have changed by PI (180 degrees).
    const rotDiff = Math.abs(entity.rotationY - rotBefore);
    expect(rotDiff).toBeCloseTo(Math.PI, 1);
  });
});

//  FireWeaponUpdate Tests 

describe('FireWeaponUpdate', () => {
  function makeFireWeaponSetup(opts: {
    weaponName?: string;
    initialDelayMs?: number;
    exclusiveWeaponDelayMs?: number;
    weaponDamage?: number;
    weaponRadius?: number;
    delayBetweenShotsMs?: number;
    targetHealth?: number;
  } = {}) {
    const weaponName = opts.weaponName ?? 'AutoFireWeapon';
    const autofireWeapon = makeWeaponDef(weaponName, {
      PrimaryDamage: opts.weaponDamage ?? 10,
      PrimaryDamageRadius: opts.weaponRadius ?? 50,
      DamageType: 'EXPLOSION',
      DelayBetweenShots: opts.delayBetweenShotsMs ?? 200, // ~6 frames
    });

    const emitterDef = makeObjectDef('PoisonEmitter', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FireWeaponUpdate ModuleTag_AutoFire', {
        Weapon: weaponName,
        InitialDelay: opts.initialDelayMs ?? 0,
        ExclusiveWeaponDelay: opts.exclusiveWeaponDelayMs ?? 0,
      }),
    ]);

    const targetDef = makeObjectDef('Victim', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', {
        MaxHealth: opts.targetHealth ?? 200,
        InitialHealth: opts.targetHealth ?? 200,
      }),
    ]);

    const bundle = makeBundle({
      objects: [emitterDef, targetDef],
      weapons: [autofireWeapon],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Place emitter and target at same map cell so they overlap within damage radius.
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PoisonEmitter', 5, 5),
        makeMapObject('Victim', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);
    return { logic };
  }

  it('extracts FireWeaponUpdateProfile from INI', () => {
    const { logic } = makeFireWeaponSetup();
    const state = logic.getEntityState(1);
    expect(state).not.toBeNull();
    // Entity should exist and be alive.
    expect(state!.health).toBe(500);
  });

  it('fires weapon at own position every frame when ready', () => {
    const { logic } = makeFireWeaponSetup({ delayBetweenShotsMs: 100, targetHealth: 500 });

    // Record health after initial frame (first shot may fire on frame 0).
    const initial = logic.getEntityState(2);
    expect(initial).not.toBeNull();
    const healthAfterInit = initial!.health;

    // Run several more frames  weapon should keep firing and deal cumulative damage.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const after = logic.getEntityState(2);
    expect(after).not.toBeNull();
    expect(after!.health).toBeLessThan(healthAfterInit);
  });

  it('respects initial delay before first fire', () => {
    const { logic } = makeFireWeaponSetup({
      initialDelayMs: 500, // ~15 frames
      delayBetweenShotsMs: 100,
      targetHealth: 200,
    });

    // Run 5 frames  should still be in initial delay.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    const mid = logic.getEntityState(2);
    expect(mid).not.toBeNull();
    expect(mid!.health).toBe(200); // No damage yet.

    // Run past initial delay  should start firing.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);
    const after = logic.getEntityState(2);
    expect(after).not.toBeNull();
    expect(after!.health).toBeLessThan(200);
  });

  it('does not fire while UNDER_CONSTRUCTION', () => {
    const { logic } = makeFireWeaponSetup({
      delayBetweenShotsMs: 100,
      targetHealth: 500,
    });

    // Mark emitter as under construction AFTER the initial update(0).
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const emitter = priv.spawnedEntities.get(1)!;
    emitter.objectStatusFlags.add('UNDER_CONSTRUCTION');

    // Record target health after UNDER_CONSTRUCTION is set.
    const healthBefore = logic.getEntityState(2)!.health;

    // Run several frames  emitter should NOT fire while under construction.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Target health should not have changed.
    const after = logic.getEntityState(2);
    expect(after).not.toBeNull();
    expect(after!.health).toBe(healthBefore);
  });

  it('respects weapon delay between shots', () => {
    const { logic } = makeFireWeaponSetup({
      delayBetweenShotsMs: 1000, // ~30 frames  fires once per second
      weaponDamage: 50,
      weaponRadius: 100,
      targetHealth: 500,
    });

    // Run exactly 10 frames  should fire at most once (delay = 30 frames).
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    const after10 = logic.getEntityState(2);
    expect(after10).not.toBeNull();
    // At most one shot of 50 damage.
    expect(after10!.health).toBeGreaterThanOrEqual(450);
  });
});

//  OCLUpdate Tests 

describe('OCLUpdate', () => {
  function makeOCLUpdateSetup(opts: {
    minDelayMs?: number;
    maxDelayMs?: number;
  } = {}) {
    const spawnerDef = makeObjectDef('Spawner', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'OCLUpdate ModuleTag_OCLSpawn', {
        OCL: 'OCLSpawnUnit',
        MinDelay: opts.minDelayMs ?? 1000,
        MaxDelay: opts.maxDelayMs ?? 1000,
      }),
    ]);

    const spawnedUnitDef = makeObjectDef('SpawnedUnit', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const bundle = makeBundle({
      objects: [spawnerDef, spawnedUnitDef],
    });
    // Add OCL definitions to the bundle.
    (bundle as Record<string, unknown>).objectCreationLists = [
      {
        name: 'OCLSpawnUnit',
        fields: {},
        blocks: [{
          type: 'CreateObject',
          name: 'CreateObject',
          fields: { ObjectNames: 'SpawnedUnit', Count: '1' },
          blocks: [],
        }],
      },
    ];

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Spawner', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);
    return { logic };
  }

  it('extracts OCLUpdateProfile from INI', () => {
    const { logic } = makeOCLUpdateSetup();
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { oclUpdateProfiles: { oclName: string; minDelayFrames: number; maxDelayFrames: number }[] }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.oclUpdateProfiles.length).toBe(1);
    expect(entity.oclUpdateProfiles[0]!.oclName).toBe('OCLSpawnUnit');
    // 1000ms at 30fps = 30 frames
    expect(entity.oclUpdateProfiles[0]!.minDelayFrames).toBe(30);
  });

  it('spawns object after delay elapses', () => {
    const { logic } = makeOCLUpdateSetup({ minDelayMs: 1000, maxDelayMs: 1000 });

    // After initial frame, only the spawner should exist.
    const initialStates = logic.getRenderableEntityStates();
    expect(initialStates.filter(s => s.templateName === 'SpawnedUnit').length).toBe(0);

    // Run 15 frames  first shouldCreate sets the timer, so no spawn yet.
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    const midStates = logic.getRenderableEntityStates();
    expect(midStates.filter(s => s.templateName === 'SpawnedUnit').length).toBe(0);

    // Run past the 30-frame delay  OCL should fire and spawn unit.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);
    const afterStates = logic.getRenderableEntityStates();
    expect(afterStates.filter(s => s.templateName === 'SpawnedUnit').length).toBeGreaterThanOrEqual(1);
  });

  it('does not spawn while UNDER_CONSTRUCTION', () => {
    const { logic } = makeOCLUpdateSetup({ minDelayMs: 100, maxDelayMs: 100 });

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const spawner = priv.spawnedEntities.get(1)!;
    spawner.objectStatusFlags.add('UNDER_CONSTRUCTION');

    // Run well past the delay  should NOT spawn.
    for (let i = 0; i < 60; i++) logic.update(1 / 30);
    const states = logic.getRenderableEntityStates();
    expect(states.filter(s => s.templateName === 'SpawnedUnit').length).toBe(0);
  });

  it('pauses timer while disabled (EMP)', () => {
    const { logic } = makeOCLUpdateSetup({ minDelayMs: 500, maxDelayMs: 500 });

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const spawner = priv.spawnedEntities.get(1)!;

    // Run 5 frames to initialize the timer.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Disable with EMP.
    spawner.objectStatusFlags.add('DISABLED_EMP');

    // Run 30 frames while disabled  timer should be paused.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    const midStates = logic.getRenderableEntityStates();
    expect(midStates.filter(s => s.templateName === 'SpawnedUnit').length).toBe(0);

    // Re-enable and run past the remaining delay.
    spawner.objectStatusFlags.delete('DISABLED_EMP');
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const afterStates = logic.getRenderableEntityStates();
    expect(afterStates.filter(s => s.templateName === 'SpawnedUnit').length).toBeGreaterThanOrEqual(1);
  });

  it('spawns repeatedly on timer cycle', () => {
    // Short delay so we get multiple spawns.
    const { logic } = makeOCLUpdateSetup({ minDelayMs: 200, maxDelayMs: 200 });

    // Run 90 frames (3 seconds)  with 200ms (~6 frame) delay, should get multiple spawns.
    // First shouldCreate sets timer at frame ~0, first spawn at frame ~6, next at ~12, etc.
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    const states = logic.getRenderableEntityStates();
    const spawned = states.filter(s => s.templateName === 'SpawnedUnit');
    // Should have spawned multiple units.
    expect(spawned.length).toBeGreaterThanOrEqual(3);
  });
});

it('transfers script name when OCL inherits veterancy', () => {
  const bundle = makeBundle({
    objects: [
      makeObjectDef('NamedSource', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      ]),
      makeObjectDef('SpawnedUnit', 'America', ['INFANTRY'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      ]),
    ],
  });

  (bundle as Record<string, unknown>).objectCreationLists = [
    {
      name: 'OCLTransferNamed',
      fields: {},
      blocks: [{
        type: 'CreateObject',
        name: 'CreateObject',
        fields: { ObjectNames: 'SpawnedUnit', Count: '1', InheritsVeterancy: 'Yes' },
        blocks: [],
      }],
    },
  ];

  const logic = new GameLogicSubsystem(new THREE.Scene());
  logic.loadMapObjects(
    makeMap([makeMapObject('NamedSource', 10, 10, { objectName: 'NamedSource' })], 128, 128),
    makeRegistry(bundle),
    makeHeightmap(128, 128),
  );

  const privateApi = logic as unknown as {
    executeOCL: (oclName: string, sourceEntity: unknown) => void;
    spawnedEntities: Map<number, { scriptName: string | null }>;
    scriptNamedEntitiesByName: Map<string, number>;
  };
  const source = privateApi.spawnedEntities.get(1);
  expect(source).toBeDefined();
  privateApi.executeOCL('OCLTransferNamed', source!);

  const mappedId = privateApi.scriptNamedEntitiesByName.get('NamedSource');
  expect(mappedId).toBe(2);
  expect(privateApi.spawnedEntities.get(2)?.scriptName).toBe('NamedSource');
});

//  WeaponBonusUpdate Tests 

describe('WeaponBonusUpdate', () => {
  function makeWeaponBonusSetup(opts: {
    bonusCondition?: string;
    bonusDurationMs?: number;
    bonusDelayMs?: number;
    bonusRange?: number;
    requiredKindOf?: string;
    forbiddenKindOf?: string;
  } = {}) {
    const towerDef = makeObjectDef('PropagandaTower', 'China', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'WeaponBonusUpdate ModuleTag_Propaganda', {
        BonusConditionType: opts.bonusCondition ?? 'ENTHUSIASTIC',
        BonusDuration: opts.bonusDurationMs ?? 2000,
        BonusDelay: opts.bonusDelayMs ?? 500,
        BonusRange: opts.bonusRange ?? 200,
        ...(opts.requiredKindOf ? { RequiredAffectKindOf: opts.requiredKindOf } : {}),
        ...(opts.forbiddenKindOf ? { ForbiddenAffectKindOf: opts.forbiddenKindOf } : {}),
      }),
    ]);

    const allyUnitDef = makeObjectDef('AllyUnit', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const enemyUnitDef = makeObjectDef('EnemyUnit', 'GLA', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const bundle = makeBundle({
      objects: [towerDef, allyUnitDef, enemyUnitDef],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PropagandaTower', 5, 5),
        makeMapObject('AllyUnit', 5, 5),
        makeMapObject('EnemyUnit', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);
    logic.update(0);
    return { logic };
  }

  it('extracts WeaponBonusUpdateProfile from INI', () => {
    const { logic } = makeWeaponBonusSetup();
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { weaponBonusUpdateProfiles: { bonusConditionFlag: number; bonusRange: number }[] }>;
    };
    const tower = priv.spawnedEntities.get(1)!;
    expect(tower.weaponBonusUpdateProfiles.length).toBe(1);
    expect(tower.weaponBonusUpdateProfiles[0]!.bonusRange).toBe(200);
  });

  it('applies temp weapon bonus to allied units in range', () => {
    const { logic } = makeWeaponBonusSetup({ bonusDelayMs: 100 });

    // Run enough frames for the first pulse.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { weaponBonusConditionFlags: number; tempWeaponBonusFlag: number }>;
    };
    const ally = priv.spawnedEntities.get(2)!;
    // ENTHUSIASTIC = bit 8 = 256
    expect(ally.weaponBonusConditionFlags & 256).toBe(256);
    expect(ally.tempWeaponBonusFlag).toBe(256);
  });

  it('does not apply bonus to enemy units', () => {
    const { logic } = makeWeaponBonusSetup({ bonusDelayMs: 100 });

    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { weaponBonusConditionFlags: number; tempWeaponBonusFlag: number }>;
    };
    const enemy = priv.spawnedEntities.get(3)!;
    // Enemy should NOT have the bonus.
    expect(enemy.weaponBonusConditionFlags & 256).toBe(0);
    expect(enemy.tempWeaponBonusFlag).toBe(0);
  });

  it('clears temp bonus after duration expires', () => {
    const { logic } = makeWeaponBonusSetup({
      bonusDelayMs: 100,
      bonusDurationMs: 500, // ~15 frames
    });

    // Pulse fires around frame 3, bonus lasts 15 frames (until frame ~18).
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { weaponBonusConditionFlags: number; tempWeaponBonusFlag: number }>;
    };
    const ally = priv.spawnedEntities.get(2)!;
    expect(ally.tempWeaponBonusFlag).toBe(256);

    // Run past the duration without a re-pulse (delay = 100ms = 3 frames, duration = 15 frames).
    // Since delay < duration, the bonus should be continuously refreshed.
    // To test expiry, we need delay > duration. Let's use a different setup.
  });

  it('expires bonus when not refreshed', () => {
    const { logic } = makeWeaponBonusSetup({
      bonusDelayMs: 2000, // ~60 frames between pulses
      bonusDurationMs: 300, // ~9 frames duration
    });

    // Run 5 frames  first pulse fires.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { weaponBonusConditionFlags: number; tempWeaponBonusFlag: number }>;
    };
    const ally = priv.spawnedEntities.get(2)!;
    expect(ally.tempWeaponBonusFlag).toBe(256);

    // Run 15 more frames  bonus should expire (duration was ~9 frames).
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    expect(ally.tempWeaponBonusFlag).toBe(0);
    expect(ally.weaponBonusConditionFlags & 256).toBe(0);
  });

  it('respects RequiredAffectKindOf filter', () => {
    // Only affect VEHICLE, not INFANTRY.
    const towerDef = makeObjectDef('BonusTower', 'China', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'WeaponBonusUpdate ModuleTag_Propaganda', {
        BonusConditionType: 'ENTHUSIASTIC',
        BonusDuration: 2000,
        BonusDelay: 100,
        BonusRange: 200,
        RequiredAffectKindOf: 'VEHICLE',
      }),
    ]);

    const infantryDef = makeObjectDef('Soldier', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const vehicleDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
    ]);

    const bundle = makeBundle({ objects: [towerDef, infantryDef, vehicleDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BonusTower', 5, 5),
        makeMapObject('Soldier', 5, 5),
        makeMapObject('Tank', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { weaponBonusConditionFlags: number; tempWeaponBonusFlag: number }>;
    };
    const infantry = priv.spawnedEntities.get(2)!;
    const vehicle = priv.spawnedEntities.get(3)!;

    // Infantry should NOT have the bonus (not a VEHICLE).
    expect(infantry.tempWeaponBonusFlag).toBe(0);
    // Vehicle should have the bonus.
    expect(vehicle.tempWeaponBonusFlag).toBe(256);
  });
});

//  FlammableUpdate Tests 

describe('FlammableUpdate', () => {
  function makeFlammableSetup(opts: {
    flameDamageLimit?: number;
    aflameDurationMs?: number;
    aflameDamageDelayMs?: number;
    aflameDamageAmount?: number;
    burnedDelayMs?: number;
    attackDamage?: number;
  } = {}) {
    const flammableDef = makeObjectDef('FlammableUnit', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FlammableUpdate ModuleTag_Flammable', {
        FlameDamageLimit: opts.flameDamageLimit ?? 10,
        AflameDuration: opts.aflameDurationMs ?? 2000,
        AflameDamageDelay: opts.aflameDamageDelayMs ?? 500,
        AflameDamageAmount: opts.aflameDamageAmount ?? 5,
        BurnedDelay: opts.burnedDelayMs ?? 0,
      }),
    ]);

    const attackerDef = makeObjectDef('Flamer', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'FlameGun'] }),
    ]);
    const flameWeapon = makeWeaponDef('FlameGun', {
      AttackRange: 200,
      PrimaryDamage: opts.attackDamage ?? 20,
      PrimaryDamageRadius: 0,
      DamageType: 'FLAME',
      DelayBetweenShots: 500,
      WeaponSpeed: 999999,
    });

    const bundle = makeBundle({
      objects: [flammableDef, attackerDef],
      weapons: [flameWeapon],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('FlammableUnit', 5, 5),
        makeMapObject('Flamer', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(0);
    return { logic };
  }

  it('extracts FlammableProfile from INI', () => {
    const { logic } = makeFlammableSetup();
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { flammableProfile: { flameDamageLimit: number; aflameDurationFrames: number; burnedDelayFrames: number } | null }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.flammableProfile).not.toBeNull();
    expect(entity.flammableProfile!.flameDamageLimit).toBe(10);
    // 2000ms at 30fps = 60 frames
    expect(entity.flammableProfile!.aflameDurationFrames).toBe(60);
    expect(entity.flammableProfile!.burnedDelayFrames).toBe(0);
  });

  it('ignites entity after exceeding fire damage threshold', () => {
    const { logic } = makeFlammableSetup({ flameDamageLimit: 10, attackDamage: 20 });

    // Attack with flame weapon to trigger ignition.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { flameStatus: string; objectStatusFlags: Set<string> }>;
    };
    const target = priv.spawnedEntities.get(1)!;
    expect(target.flameStatus).toBe('AFLAME');
    expect(target.objectStatusFlags.has('AFLAME')).toBe(true);
  });

  it('applies periodic fire damage while AFLAME', () => {
    const { logic } = makeFlammableSetup({
      flameDamageLimit: 1, // Low threshold for instant ignition
      aflameDurationMs: 5000,
      aflameDamageDelayMs: 200, // ~6 frames between damage ticks
      aflameDamageAmount: 10,
      attackDamage: 5,
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    // Initial attack + ignition.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const healthAfterIgnition = logic.getEntityState(1)!.health;

    // Run more frames for fire DoT to tick.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const healthAfterBurning = logic.getEntityState(1)!.health;
    expect(healthAfterBurning).toBeLessThan(healthAfterIgnition);
  });

  it('transitions to NORMAL (not BURNED) when burnedDelay is 0', () => {
    const { logic } = makeFlammableSetup({
      flameDamageLimit: 1,
      aflameDurationMs: 500, // ~15 frames
      burnedDelayMs: 0, // No burned state
      attackDamage: 5,
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { flameStatus: string; objectStatusFlags: Set<string> }>;
    };
    const target = priv.spawnedEntities.get(1)!;
    expect(target.flameStatus).toBe('AFLAME');

    // Run past aflameDuration (~15 frames).
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Should transition to NORMAL (can burn again), NOT BURNED.
    expect(target.flameStatus).toBe('NORMAL');
    expect(target.objectStatusFlags.has('AFLAME')).toBe(false);
    expect(target.objectStatusFlags.has('BURNED')).toBe(false);
  });

  it('transitions to BURNED when burnedDelay < aflameDuration', () => {
    const { logic } = makeFlammableSetup({
      flameDamageLimit: 1,
      aflameDurationMs: 2000, // ~60 frames
      burnedDelayMs: 500, // ~15 frames  BURNED set before flame ends
      attackDamage: 5,
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { flameStatus: string; objectStatusFlags: Set<string> }>;
    };
    const target = priv.spawnedEntities.get(1)!;
    expect(target.flameStatus).toBe('AFLAME');

    // Run 20 frames  past burnedDelay but before aflameDuration.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);
    expect(target.objectStatusFlags.has('BURNED')).toBe(true);
    expect(target.flameStatus).toBe('AFLAME'); // Still burning.

    // Run past aflameDuration.
    for (let i = 0; i < 60; i++) logic.update(1 / 30);
    expect(target.flameStatus).toBe('BURNED');
    expect(target.objectStatusFlags.has('AFLAME')).toBe(false);
  });

  it('transitions to NORMAL when burnedDelay > aflameDuration (burned timer never fires)', () => {
    const { logic } = makeFlammableSetup({
      flameDamageLimit: 1,
      aflameDurationMs: 1000, // ~30 frames
      burnedDelayMs: 5000, // ~150 frames  burned timer fires AFTER flame ends
      attackDamage: 5,
    });

    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { flameStatus: string; objectStatusFlags: Set<string> }>;
    };
    const target = priv.spawnedEntities.get(1)!;
    expect(target.flameStatus).toBe('AFLAME');

    // Run past aflameDuration (~30 frames) but well before burnedDelay (~150 frames).
    for (let i = 0; i < 40; i++) logic.update(1 / 30);
    // BURNED status flag was never set because burnedDelay hasn't elapsed.
    expect(target.objectStatusFlags.has('BURNED')).toBe(false);
    // So entity transitions to NORMAL, not BURNED.
    expect(target.flameStatus).toBe('NORMAL');
  });
});

//  FireSpreadUpdate Tests 

describe('FireSpreadUpdate', () => {
  function makeFireSpreadSetup(opts: {
    spreadTryRange?: number;
    minSpreadDelayMs?: number;
    maxSpreadDelayMs?: number;
  } = {}) {
    // Entity that can catch fire AND spread fire to others.
    const spreaderDef = makeObjectDef('Spreader', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FlammableUpdate ModuleTag_Flammable', {
        FlameDamageLimit: 1,
        AflameDuration: 10000,
        AflameDamageDelay: 500,
        AflameDamageAmount: 5,
      }),
      makeBlock('Behavior', 'FireSpreadUpdate ModuleTag_FireSpread', {
        MinSpreadDelay: opts.minSpreadDelayMs ?? 100,
        MaxSpreadDelay: opts.maxSpreadDelayMs ?? 100,
        SpreadTryRange: opts.spreadTryRange ?? 50,
      }),
    ]);

    // Nearby target that can catch fire but does NOT spread it.
    const targetDef = makeObjectDef('Target', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FlammableUpdate ModuleTag_Flammable', {
        FlameDamageLimit: 1,
        AflameDuration: 10000,
        AflameDamageDelay: 500,
        AflameDamageAmount: 5,
      }),
    ]);

    // Attacker with flame weapon  co-located with spreader for instant attack.
    const attackerDef = makeObjectDef('Flamer', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'FlameGun'] }),
    ]);
    const flameWeapon = makeWeaponDef('FlameGun', {
      AttackRange: 200,
      PrimaryDamage: 20,
      PrimaryDamageRadius: 0,
      DamageType: 'FLAME',
      DeliveryType: 'DIRECT',
    });

    const mapObjects = [
      makeMapObject('Spreader', 5, 5),   // Entity that will burn and spread fire
      makeMapObject('Target', 7, 7),      // Nearby entity that should catch fire
      makeMapObject('Flamer', 5, 5),      // Enemy attacker co-located with spreader
    ];

    const bundle = makeBundle({
      objects: [spreaderDef, targetDef, attackerDef],
      weapons: [flameWeapon],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap(mapObjects), makeRegistry(bundle), makeHeightmap());
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, MapEntity>;
      frameCounter: number;
    };

    return { logic, priv };
  }

  it('spreads fire from burning entity to nearby flammable entity', () => {
    const { logic, priv } = makeFireSpreadSetup();

    const spreader = priv.spawnedEntities.get(1)!;
    const target = priv.spawnedEntities.get(2)!;

    expect(spreader.flameStatus).toBe('NORMAL');
    expect(target.flameStatus).toBe('NORMAL');

    // Command attacker to fire at the spreader.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });

    // Run enough frames for the attack to fire and ignite the spreader.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    expect(spreader.flameStatus).toBe('AFLAME');

    // After enough frames, fire should spread to nearby target.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(target.flameStatus).toBe('AFLAME');
  });

  it('does not spread fire to entities outside range', () => {
    // Place target far from spreader. Use custom setup with far-away target.
    const spreaderDef = makeObjectDef('Spreader', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FlammableUpdate ModuleTag_Flammable', {
        FlameDamageLimit: 1,
        AflameDuration: 10000,
        AflameDamageDelay: 500,
        AflameDamageAmount: 5,
      }),
      makeBlock('Behavior', 'FireSpreadUpdate ModuleTag_FireSpread', {
        MinSpreadDelay: 100,
        MaxSpreadDelay: 100,
        SpreadTryRange: 1, // Very short range (10 world units).
      }),
    ]);
    const targetDef = makeObjectDef('Target', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FlammableUpdate ModuleTag_Flammable', {
        FlameDamageLimit: 1,
        AflameDuration: 10000,
        AflameDamageDelay: 500,
        AflameDamageAmount: 5,
      }),
    ]);
    const attackerDef = makeObjectDef('Flamer', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'FlameGun'] }),
    ]);
    const flameWeapon = makeWeaponDef('FlameGun', {
      AttackRange: 200,
      PrimaryDamage: 20,
      PrimaryDamageRadius: 0,
      DamageType: 'FLAME',
      DeliveryType: 'DIRECT',
    });

    const bundle = makeBundle({
      objects: [spreaderDef, targetDef, attackerDef],
      weapons: [flameWeapon],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Spreader', 5, 5),
        makeMapObject('Target', 60, 60), // Far away from spreader.
        makeMapObject('Flamer', 5, 5),   // Co-located with spreader.
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    // GLA neutral to China  attacker won't auto-target the far target.
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('GLA', 'China', 1);
    logic.setTeamRelationship('China', 'GLA', 1);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const spreader = priv.spawnedEntities.get(1)!;
    const target = priv.spawnedEntities.get(2)!;

    // Ignite the spreader.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });

    for (let i = 0; i < 60; i++) logic.update(1 / 30);
    expect(spreader.flameStatus).toBe('AFLAME');
    // Target should NOT have caught fire  out of fire spread range.
    expect(target.flameStatus).toBe('NORMAL');
  });

  it('does not spread fire to already burning or burned entities', () => {
    const { logic, priv } = makeFireSpreadSetup();

    const spreader = priv.spawnedEntities.get(1)!;
    const target = priv.spawnedEntities.get(2)!;

    // Manually set target to BURNED so it can't ignite.
    target.flameStatus = 'BURNED';
    target.objectStatusFlags.add('BURNED');

    // Ignite the spreader.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });

    for (let i = 0; i < 60; i++) logic.update(1 / 30);
    expect(spreader.flameStatus).toBe('AFLAME');
    // Target remains BURNED  not re-ignited.
    expect(target.flameStatus).toBe('BURNED');
  });
});

//  HeightDieUpdate Tests 

describe('HeightDieUpdate', () => {
  it('kills entity when it falls below target height above terrain', () => {
    const objectDef = makeObjectDef('FallingAircraft', 'America', ['AIRCRAFT'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('Behavior', 'HeightDieUpdate ModuleTag_HeightDie', {
        TargetHeight: 5,
        SnapToGroundOnDeath: 'Yes',
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('FallingAircraft', 50, 50)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // Grab entity reference before update  finalizeDestroyedEntities removes dead entities.
    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const aircraft = priv.spawnedEntities.get(1)!;
    expect(aircraft).toBeDefined();

    // Entity spawns at ground level. Height above terrain = 0, which is < 5.
    // After the HeightDieUpdate runs, entity should die.
    logic.update(0);
    expect(aircraft.destroyed || aircraft.slowDeathState !== null || aircraft.health <= 0).toBe(true);
  });

  it('does not kill entity when above target height', () => {
    const objectDef = makeObjectDef('FlyingAircraft', 'America', ['AIRCRAFT'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('Behavior', 'HeightDieUpdate ModuleTag_HeightDie', {
        TargetHeight: 5,
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('FlyingAircraft', 50, 50)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // Grab entity and elevate before first update  otherwise HeightDie kills it at ground level.
    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const aircraft = priv.spawnedEntities.get(1)!;
    aircraft.y += 50;

    logic.update(0);

    // Run frames  entity should survive above target height.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    expect(aircraft.destroyed).toBe(false);
    expect(aircraft.health).toBe(200);
  });

  it('respects InitialDelay before checking height', () => {
    const objectDef = makeObjectDef('DelayedAircraft', 'America', ['AIRCRAFT'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      makeBlock('Behavior', 'HeightDieUpdate ModuleTag_HeightDie', {
        TargetHeight: 5,
        InitialDelay: 1000, // ~30 frames delay
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('DelayedAircraft', 50, 50)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const aircraft = priv.spawnedEntities.get(1)!;

    // Entity is at ground level (below target height) but delay hasn't expired.
    // Run a few frames  should survive because of InitialDelay.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    expect(aircraft.destroyed).toBe(false);
    expect(aircraft.health).toBe(200);

    // Run past the delay (30 frames total).
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    // Now the height check should fire and kill the entity.
    expect(aircraft.destroyed || aircraft.slowDeathState !== null || aircraft.health <= 0).toBe(true);
  });
});

//  HiveStructureBody Tests 

describe('HiveStructureBody', () => {
  it('redirects matching damage types to closest spawn slave', () => {
    const hiveDef = makeObjectDef('GlaTunnel', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'HiveStructureBody ModuleTag_Body', {
        MaxHealth: 500,
        InitialHealth: 500,
        PropagateDamageTypesToSlavesWhenExisting: 'EXPLOSION ARMOR_PIERCING',
      }),
      makeBlock('Behavior', 'SpawnBehavior ModuleTag_Spawn', {
        SpawnNumber: 2,
        SpawnReplaceDelay: 100,
        SpawnTemplateName: 'TunnelDefender',
        InitialBurst: 2,
      }),
    ]);
    const defenderDef = makeObjectDef('TunnelDefender', 'GLA', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const attackerDef = makeObjectDef('Tank', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankGun'] }),
    ]);
    const tankGun = makeWeaponDef('TankGun', {
      PrimaryDamage: 30,
      PrimaryDamageRadius: 0,
      DamageType: 'EXPLOSION',
      AttackRange: 150,
      DelayBetweenShots: 500,
    });

    const bundle = makeBundle({ objects: [hiveDef, defenderDef, attackerDef], weapons: [tankGun] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GlaTunnel', 5, 5),
        makeMapObject('Tank', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const tunnel = priv.spawnedEntities.get(1)!;
    expect(tunnel).toBeDefined();
    expect(tunnel.hiveStructureProfile).not.toBeNull();

    // Spawn behavior should have created 2 defenders.
    const state = tunnel.spawnBehaviorState!;
    expect(state.slaveIds.length).toBe(2);

    const slave1 = priv.spawnedEntities.get(state.slaveIds[0]!)!;
    const tunnelHealthBefore = tunnel.health;

    // Attack the tunnel with EXPLOSION damage (should redirect to slave).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    // Tunnel should not have taken damage  slave should have.
    expect(tunnel.health).toBe(tunnelHealthBefore);
    expect(slave1.health).toBeLessThan(100);
  });

  it('swallows damage when all slaves dead and damage type matches swallow list', () => {
    // Source parity: HiveStructureBody.cpp:88  swallow only fires when SpawnBehavior exists
    // but getClosestSlave returns null (all slaves dead). No SpawnBehavior = DEBUG_CRASH + fallthrough.
    const hiveDef = makeObjectDef('GlaTunnel2', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'HiveStructureBody ModuleTag_Body', {
        MaxHealth: 500,
        InitialHealth: 500,
        PropagateDamageTypesToSlavesWhenExisting: 'EXPLOSION',
        SwallowDamageTypesIfSlavesNotExisting: 'EXPLOSION',
      }),
      makeBlock('Behavior', 'SpawnBehavior ModuleTag_Spawn', {
        SpawnNumber: 1,
        SpawnReplaceDelay: 99999,
        SpawnTemplateName: 'TunnelDefender2',
        InitialBurst: 1,
      }),
    ]);
    const defenderDef = makeObjectDef('TunnelDefender2', 'GLA', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
    ]);
    const attackerDef = makeObjectDef('Tank2', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankGun2'] }),
    ]);
    const tankGun = makeWeaponDef('TankGun2', {
      PrimaryDamage: 50,
      PrimaryDamageRadius: 0,
      DamageType: 'EXPLOSION',
      AttackRange: 150,
      DelayBetweenShots: 500,
    });

    const bundle = makeBundle({ objects: [hiveDef, defenderDef, attackerDef], weapons: [tankGun] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GlaTunnel2', 5, 5),
        makeMapObject('Tank2', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const tunnel = priv.spawnedEntities.get(1)!;
    const state = tunnel.spawnBehaviorState!;
    expect(state.slaveIds.length).toBe(1);

    // Kill the slave so no living slaves remain.
    const slave = priv.spawnedEntities.get(state.slaveIds[0]!)!;
    (logic as any).applyWeaponDamageAmount(null, slave, 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    expect(slave.destroyed).toBe(true);

    const healthBefore = tunnel.health;

    // Attack the tunnel with EXPLOSION  should be swallowed since no alive slaves.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    // Tunnel health should be unchanged  EXPLOSION damage swallowed.
    expect(tunnel.health).toBe(healthBefore);
  });

  it('applies non-propagated damage types directly to hive structure', () => {
    const hiveDef = makeObjectDef('GlaTunnel3', 'GLA', ['STRUCTURE'], [
      makeBlock('Body', 'HiveStructureBody ModuleTag_Body', {
        MaxHealth: 500,
        InitialHealth: 500,
        PropagateDamageTypesToSlavesWhenExisting: 'EXPLOSION',
      }),
      makeBlock('Behavior', 'SpawnBehavior ModuleTag_Spawn', {
        SpawnNumber: 1,
        SpawnReplaceDelay: 100,
        SpawnTemplateName: 'TunnelDefender3',
        InitialBurst: 1,
      }),
    ]);
    const defenderDef = makeObjectDef('TunnelDefender3', 'GLA', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const attackerDef = makeObjectDef('Sniper', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'SniperRifle'] }),
    ]);
    const sniperRifle = makeWeaponDef('SniperRifle', {
      PrimaryDamage: 40,
      PrimaryDamageRadius: 0,
      DamageType: 'SMALL_ARMS',
      AttackRange: 150,
      DelayBetweenShots: 1000,
    });

    const bundle = makeBundle({ objects: [hiveDef, defenderDef, attackerDef], weapons: [sniperRifle] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GlaTunnel3', 5, 5),
        makeMapObject('Sniper', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const tunnel = priv.spawnedEntities.get(1)!;
    const slave = priv.spawnedEntities.get(tunnel.spawnBehaviorState!.slaveIds[0]!)!;

    // Attack tunnel with SMALL_ARMS (not in propagate list)  should hit tunnel directly.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    // Tunnel should have taken damage, slave should be untouched.
    expect(tunnel.health).toBeLessThan(500);
    expect(slave.health).toBe(100);
  });
});

//  KeepObjectDie Tests 

describe('KeepObjectDie', () => {
  it('keeps destroyed entity in world as rubble instead of removing it', () => {
    const buildingDef = makeObjectDef('CivBuilding', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'KeepObjectDie ModuleTag_Keep', {}),
    ]);
    const attackerDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
    ]);
    const bigGun = makeWeaponDef('BigGun', {
      PrimaryDamage: 200,
      PrimaryDamageRadius: 0,
      DamageType: 'EXPLOSION',
      AttackRange: 150,
      DelayBetweenShots: 500,
    });

    const bundle = makeBundle({ objects: [buildingDef, attackerDef], weapons: [bigGun] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CivBuilding', 5, 5),
        makeMapObject('Attacker', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('Civilian', 'America', 0);
    logic.setTeamRelationship('America', 'Civilian', 0);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const building = priv.spawnedEntities.get(1)!;
    expect(building.keepObjectOnDeath).toBe(true);

    // Kill the building.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    // Building should be destroyed but still in spawnedEntities (kept as rubble).
    expect(building.destroyed).toBe(true);
    expect(priv.spawnedEntities.has(1)).toBe(true);
  });

  it('removes destroyed entity normally when KeepObjectDie is absent', () => {
    const buildingDef = makeObjectDef('NormalBuilding', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const attackerDef = makeObjectDef('Attacker2', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun2'] }),
    ]);
    const bigGun = makeWeaponDef('BigGun2', {
      PrimaryDamage: 200,
      PrimaryDamageRadius: 0,
      DamageType: 'EXPLOSION',
      AttackRange: 150,
      DelayBetweenShots: 500,
    });

    const bundle = makeBundle({ objects: [buildingDef, attackerDef], weapons: [bigGun] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NormalBuilding', 5, 5),
        makeMapObject('Attacker2', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('Civilian', 'America', 0);
    logic.setTeamRelationship('America', 'Civilian', 0);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const building = priv.spawnedEntities.get(1)!;
    expect(building.keepObjectOnDeath).toBe(false);

    // Kill the building.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 90; i++) logic.update(1 / 30);

    // Building should be removed from spawnedEntities (no KeepObjectDie).
    expect(priv.spawnedEntities.has(1)).toBe(false);
  });
});

describe('DestroyDie', () => {
  it('extracts DestroyDie profiles from INI with DieMuxData fields', () => {
    const objectDef = makeObjectDef('FilteredDestroy', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'DestroyDie ModuleTag_Destroy', {
        DeathTypes: 'CRUSHED',
        ExemptStatus: 'SOLD',
      }),
    ]);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(makeMap([makeMapObject('FilteredDestroy', 10, 10)]), makeRegistry(makeBundle({ objects: [objectDef] })), makeHeightmap());

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { destroyDieProfiles: Array<{ deathTypes: Set<string>; exemptStatus: Set<string> }> }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.destroyDieProfiles.length).toBe(1);
    expect(entity.destroyDieProfiles[0]!.deathTypes.has('CRUSHED')).toBe(true);
    expect(entity.destroyDieProfiles[0]!.exemptStatus.has('SOLD')).toBe(true);
  });

  it('overrides KeepObjectDie removal only when DestroyDie DeathTypes match', () => {
    const objectDef = makeObjectDef('ConditionalWreck', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'KeepObjectDie ModuleTag_Keep', {}),
      makeBlock('Behavior', 'DestroyDie ModuleTag_Destroy', {
        DeathTypes: 'CRUSHED',
      }),
    ]);
    const bundle = makeBundle({ objects: [objectDef] });

    const logicNormal = new GameLogicSubsystem(new THREE.Scene());
    logicNormal.loadMapObjects(makeMap([makeMapObject('ConditionalWreck', 10, 10)]), makeRegistry(bundle), makeHeightmap());
    const normalPriv = logicNormal as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string, deathType?: string) => void;
      spawnedEntities: Map<number, { destroyed: boolean }>;
    };
    const normalTarget = normalPriv.spawnedEntities.get(1)!;
    normalPriv.applyWeaponDamageAmount(null, normalTarget, 200, 'EXPLOSION', 'NORMAL');
    logicNormal.update(1 / 30);
    // KeepObjectDie applies; DestroyDie(DeathTypes=CRUSHED) does not.
    expect(normalPriv.spawnedEntities.has(1)).toBe(true);

    const logicCrushed = new GameLogicSubsystem(new THREE.Scene());
    logicCrushed.loadMapObjects(makeMap([makeMapObject('ConditionalWreck', 10, 10)]), makeRegistry(bundle), makeHeightmap());
    const crushedPriv = logicCrushed as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string, deathType?: string) => void;
      spawnedEntities: Map<number, { destroyed: boolean }>;
    };
    const crushedTarget = crushedPriv.spawnedEntities.get(1)!;
    crushedPriv.applyWeaponDamageAmount(null, crushedTarget, 200, 'EXPLOSION', 'CRUSHED');
    logicCrushed.update(1 / 30);
    // Matching DestroyDie profile overrides KeepObjectDie and removes the wreck.
    expect(crushedPriv.spawnedEntities.has(1)).toBe(false);
  });
});

describe('DamDie', () => {
  it('extracts DamDie profiles from INI with DieMuxData fields', () => {
    const damDef = makeObjectDef('Dam', 'Civilian', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('Behavior', 'DamDie ModuleTag_Dam', {
        DeathTypes: 'CRUSHED',
        RequiredStatus: 'UNDER_CONSTRUCTION',
      }),
    ]);
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(makeMap([makeMapObject('Dam', 10, 10)]), makeRegistry(makeBundle({ objects: [damDef] })), makeHeightmap());

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { damDieProfiles: Array<{ deathTypes: Set<string>; requiredStatus: Set<string> }> }>;
    };
    const dam = priv.spawnedEntities.get(1)!;
    expect(dam.damDieProfiles.length).toBe(1);
    expect(dam.damDieProfiles[0]!.deathTypes.has('CRUSHED')).toBe(true);
    expect(dam.damDieProfiles[0]!.requiredStatus.has('UNDER_CONSTRUCTION')).toBe(true);
  });

  it('enables WAVEGUIDE objects when DamDie death filter matches', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dam', 'Civilian', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'DamDie ModuleTag_Dam', {
            DeathTypes: 'CRUSHED',
          }),
        ]),
        makeObjectDef('WaveGuideObject', 'Civilian', ['WAVEGUIDE', 'STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Dam', 20, 20),
        makeMapObject('WaveGuideObject', 30, 20),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    const priv = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string, deathType?: string) => void;
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const dam = priv.spawnedEntities.get(1)!;
    const waveGuide = priv.spawnedEntities.get(2)!;
    waveGuide.objectStatusFlags.add('DISABLED_DEFAULT');

    // Non-matching death type should not enable wave guides.
    priv.applyWeaponDamageAmount(null, dam, 1000, 'EXPLOSION', 'NORMAL');
    logic.update(1 / 30);
    expect(waveGuide.objectStatusFlags.has('DISABLED_DEFAULT')).toBe(true);

    // Reload and kill with matching death type.
    const logic2 = new GameLogicSubsystem(new THREE.Scene());
    logic2.loadMapObjects(
      makeMap([
        makeMapObject('Dam', 20, 20),
        makeMapObject('WaveGuideObject', 30, 20),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    const priv2 = logic2 as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string, deathType?: string) => void;
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    const dam2 = priv2.spawnedEntities.get(1)!;
    const waveGuide2 = priv2.spawnedEntities.get(2)!;
    waveGuide2.objectStatusFlags.add('DISABLED_DEFAULT');
    priv2.applyWeaponDamageAmount(null, dam2, 1000, 'EXPLOSION', 'CRUSHED');
    logic2.update(1 / 30);
    expect(waveGuide2.objectStatusFlags.has('DISABLED_DEFAULT')).toBe(false);
  });
});

// 
// DeletionUpdate  silent timed removal (no death pipeline)
// 
describe('DeletionUpdate', () => {
  it('extracts DeletionUpdate from INI and resolves die frame', () => {
    const objectDef = makeObjectDef('Debris', 'America', ['PROJECTILE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
      makeBlock('Behavior', 'DeletionUpdate ModuleTag_Deletion', {
        MinLifetime: 1000, // ~30 frames
        MaxLifetime: 1000,
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Debris', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { deletionDieFrame: number | null }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.deletionDieFrame).not.toBeNull();
    expect(entity.deletionDieFrame).toBeGreaterThan(0);
  });

  it('silently removes entity when deletion timer expires', () => {
    const objectDef = makeObjectDef('Debris', 'America', ['PROJECTILE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'DeletionUpdate ModuleTag_Deletion', {
        MinLifetime: 500, // ~15 frames
        MaxLifetime: 500,
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Debris', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    // Run 10 frames  should still be alive.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    const state1 = logic.getEntityState(1);
    expect(state1).not.toBeNull();

    // Run 20 more frames  past 15 frame deletion time.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);
    const state2 = logic.getEntityState(1);
    expect(state2).toBeNull(); // Entity silently removed.
  });

  it('does not trigger death pipeline (no visual events, no SlowDeath)', () => {
    const objectDef = makeObjectDef('Debris', 'America', ['PROJECTILE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'DeletionUpdate ModuleTag_Deletion', {
        MinLifetime: 300, // ~9 frames
        MaxLifetime: 300,
      }),
      makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SlowDeath', {
        DestructionDelay: 5000, // 5 seconds  would keep entity alive if death pipeline ran
        SinkRate: 0,
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Debris', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    // Drain any initial visual events.
    logic.drainVisualEvents();

    // Run 15 frames  past deletion time.
    for (let i = 0; i < 15; i++) logic.update(1 / 30);
    // Entity should be immediately gone (not in SlowDeath).
    const state = logic.getEntityState(1);
    expect(state).toBeNull();

    // No ENTITY_DESTROYED visual event should have been emitted (silent removal).
    const events = logic.drainVisualEvents();
    const destroyedEvents = events.filter(e => e.type === 'ENTITY_DESTROYED');
    expect(destroyedEvents).toHaveLength(0);
  });
});

// 
// RadarUpdate  radar dish extension animation + player radar state
// 
describe('RadarUpdate', () => {
  it('extracts RadarUpdateProfile from INI', () => {
    const objectDef = makeObjectDef('Radar', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'RadarUpdate ModuleTag_Radar', {
        RadarExtendTime: 2000, // ~60 frames
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Radar', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { radarUpdateProfile: { radarExtendTimeFrames: number } | null }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.radarUpdateProfile).not.toBeNull();
    expect(entity.radarUpdateProfile!.radarExtendTimeFrames).toBe(60);
  });
});

// 
// FloatUpdate  water surface snapping profile extraction
// 
describe('FloatUpdate', () => {
  it('extracts FloatUpdateProfile from INI', () => {
    const objectDef = makeObjectDef('Boat', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'FloatUpdate ModuleTag_Float', {
        Enabled: 'Yes',
      }),
    ]);

    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Boat', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { floatUpdateProfile: { enabled: boolean } | null }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.floatUpdateProfile).not.toBeNull();
    expect(entity.floatUpdateProfile!.enabled).toBe(true);
  });
});

// 
// Spy Vision Duration  temporary fog reveals expire after duration
// 
describe('Spy Vision Duration', () => {
  it('temporary vision reveals expire after default duration', () => {
    const objectDef = makeObjectDef('Unit', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const bundle = makeBundle({ objects: [objectDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Unit', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      temporaryVisionReveals: { expiryFrame: number }[];
      fogOfWarGrid: unknown;
    };

    // If fogOfWarGrid is null, revealFogOfWar is a no-op and nothing is tracked.
    // The test verifies the tracking array behavior.
    if (!priv.fogOfWarGrid) {
      // No fog grid = no vision tracking, test is vacuously OK.
      expect(priv.temporaryVisionReveals).toHaveLength(0);
      return;
    }

    // With fog grid, reveals would be tracked and expired.
    // Run 950 frames (past default 900-frame duration).
    for (let i = 0; i < 950; i++) logic.update(1 / 30);
    expect(priv.temporaryVisionReveals).toHaveLength(0);
  });
});

//  PoisonedBehavior Tests 

describe('PoisonedBehavior', () => {
  function makePoisonSetup(opts: {
    poisonDamageIntervalMs?: number;
    poisonDurationMs?: number;
    attackDamage?: number;
    includeAutoHeal?: boolean;
  } = {}) {
    const targetBlocks = [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'PoisonedBehavior ModuleTag_Poison', {
        PoisonDamageInterval: opts.poisonDamageIntervalMs ?? 333,
        PoisonDuration: opts.poisonDurationMs ?? 3000,
      }),
    ];
    if (opts.includeAutoHeal) {
      targetBlocks.push(
        makeBlock('Behavior', 'AutoHealBehavior ModuleTag_AutoHeal', {
          HealingAmount: 50,
          HealingDelay: 0,
          StartHealingDelay: 0,
          StartsActive: 'Yes',
        }),
      );
    }
    const targetDef = makeObjectDef('PoisonTarget', 'America', ['INFANTRY'], targetBlocks);

    const attackerDef = makeObjectDef('PoisonAttacker', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ToxinGun'] }),
    ]);
    const toxinWeapon = makeWeaponDef('ToxinGun', {
      AttackRange: 200,
      PrimaryDamage: opts.attackDamage ?? 10,
      PrimaryDamageRadius: 0,
      DamageType: 'POISON',
      DelayBetweenShots: 500,
      WeaponSpeed: 999999,
    });

    const bundle = makeBundle({
      objects: [targetDef, attackerDef],
      weapons: [toxinWeapon],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PoisonTarget', 5, 5),
        makeMapObject('PoisonAttacker', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(0);
    return { logic };
  }

  it('extracts PoisonedBehaviorProfile from INI', () => {
    const { logic } = makePoisonSetup({ poisonDamageIntervalMs: 500, poisonDurationMs: 5000 });
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { poisonedBehaviorProfile: { poisonDamageIntervalFrames: number; poisonDurationFrames: number } | null }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.poisonedBehaviorProfile).not.toBeNull();
    // 500ms at 30fps = 15 frames
    expect(entity.poisonedBehaviorProfile!.poisonDamageIntervalFrames).toBe(15);
    // 5000ms at 30fps = 150 frames
    expect(entity.poisonedBehaviorProfile!.poisonDurationFrames).toBe(150);
  });

  it('applies poison DoT after POISON damage and clears on expiry', () => {
    const { logic } = makePoisonSetup({ poisonDamageIntervalMs: 333, poisonDurationMs: 1000, attackDamage: 10 });
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number; poisonDamageAmount: number; objectStatusFlags: Set<string> }>;
    };

    // Attack with poison weapon to trigger poison.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const target = priv.spawnedEntities.get(1)!;
    expect(target.objectStatusFlags.has('POISONED')).toBe(true);
    expect(target.poisonDamageAmount).toBeGreaterThan(0);
    const healthAfterPoison = target.health;
    expect(healthAfterPoison).toBeLessThan(500); // took initial + some tick damage

    // Stop the attacker so it doesn't keep re-poisoning.
    logic.submitCommand({ type: 'stop', entityId: 2 });

    // Run past poison duration (1000ms = 30 frames). Run extra to be safe.
    for (let i = 0; i < 60; i++) logic.update(1 / 30);

    // Poison should have expired.
    expect(target.objectStatusFlags.has('POISONED')).toBe(false);
    expect(target.poisonDamageAmount).toBe(0);
  });

  it('healing clears poison state', () => {
    // C++ parity: PoisonedBehavior::onHealing clears poison when entity receives healing.
    // Directly set poison state on entity, then reduce health and run a frame so
    // the ambulance healer triggers clearPoisonFromEntity.
    const targetDef = makeObjectDef('PoisonHealTarget', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'PoisonedBehavior ModuleTag_Poison', {
        PoisonDamageInterval: 333,
        PoisonDuration: 10000,
      }),
    ]);
    // External healer with radius-mode AutoHeal.
    const healerDef = makeObjectDef('Ambulance', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'AutoHealBehavior ModuleTag_AutoHeal', {
        HealingAmount: 100,
        HealingDelay: 1,
        StartHealingDelay: 0,
        Radius: 200,
        StartsActive: 'Yes',
      }),
    ]);
    const bundle = makeBundle({ objects: [targetDef, healerDef], weapons: [] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PoisonHealTarget', 5, 5),
        makeMapObject('Ambulance', 5, 5),
      ]),
      makeRegistry(bundle), makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number; maxHealth: number; poisonDamageAmount: number;
        poisonNextDamageFrame: number; poisonExpireFrame: number;
        objectStatusFlags: Set<string>;
      }>;
    };
    const target = priv.spawnedEntities.get(1)!;

    // Manually inject poison state (simulating a POISON damage hit).
    target.poisonDamageAmount = 10;
    target.poisonNextDamageFrame = 9999; // Far future  no tick during test
    target.poisonExpireFrame = 9999;
    target.objectStatusFlags.add('POISONED');
    target.health = 400; // Below max so the ambulance will heal
    expect(target.objectStatusFlags.has('POISONED')).toBe(true);

    // Run a few frames. The ambulance should heal and clear poison.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    expect(target.objectStatusFlags.has('POISONED')).toBe(false);
    expect(target.poisonDamageAmount).toBe(0);
    expect(target.health).toBe(500); // Healed back to full
  });

  it('entities without PoisonedBehavior module cannot be poisoned', () => {
    // Create a target WITHOUT PoisonedBehavior module.
    const targetDef = makeObjectDef('NoPoisonTarget', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const attackerDef = makeObjectDef('PoisonAttacker2', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'ToxinGun2'] }),
    ]);
    const toxinWeapon = makeWeaponDef('ToxinGun2', {
      AttackRange: 200,
      PrimaryDamage: 10,
      PrimaryDamageRadius: 0,
      DamageType: 'POISON',
      DelayBetweenShots: 500,
      WeaponSpeed: 999999,
    });

    const bundle = makeBundle({
      objects: [targetDef, attackerDef],
      weapons: [toxinWeapon],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NoPoisonTarget', 5, 5),
        makeMapObject('PoisonAttacker2', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(0);

    // Attack with poison weapon.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { poisonDamageAmount: number; objectStatusFlags: Set<string> }>;
    };
    const target = priv.spawnedEntities.get(1)!;
    // Entity takes POISON damage but should NOT become poisoned (no PoisonedBehavior module).
    expect(target.objectStatusFlags.has('POISONED')).toBe(false);
    expect(target.poisonDamageAmount).toBe(0);
  });
});

// 
// StickyBombUpdate  bomb attachment, tracking, and detonation
// 

describe('StickyBombUpdate', () => {
  it('extracts StickyBombUpdateProfile from INI', () => {
    const bombDef = makeObjectDef('StickyBomb', 'America', ['VEHICLE', 'BOOBY_TRAP'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      {
        type: 'Behavior',
        name: 'StickyBombUpdate ModuleTag_StickyBomb',
        fields: {
          GeometryBasedDamageWeapon: 'StickyBombDetonation',
          OffsetZ: 15.0,
        },
        blocks: [],
      },
    ]);
    const bundle = makeBundle({ objects: [bombDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('StickyBomb', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        stickyBombProfile: { offsetZ: number; geometryBasedDamageWeaponName: string | null } | null;
      }>;
    };
    const bomb = priv.spawnedEntities.get(1)!;
    expect(bomb.stickyBombProfile).not.toBeNull();
    expect(bomb.stickyBombProfile!.offsetZ).toBe(15.0);
    expect(bomb.stickyBombProfile!.geometryBasedDamageWeaponName).toBe('StickyBombDetonation');
  });

  it('tracks mobile target position each frame', () => {
    // Create a bomb and a mobile target.
    const targetDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const bombDef = makeObjectDef('StickyBomb', 'America', ['VEHICLE', 'BOOBY_TRAP'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      {
        type: 'Behavior',
        name: 'StickyBombUpdate ModuleTag_SB',
        fields: { OffsetZ: 10 },
        blocks: [],
      },
    ]);
    const bundle = makeBundle({ objects: [targetDef, bombDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),
        makeMapObject('StickyBomb', 10, 10),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        x: number; z: number;
        stickyBombTargetId: number;
        objectStatusFlags: Set<string>;
      }>;
    };
    const bomb = priv.spawnedEntities.get(2)!;
    const target = priv.spawnedEntities.get(1)!;

    // Manually attach bomb to target (simulates OCL onCreatePost).
    bomb.stickyBombTargetId = 1;
    target.objectStatusFlags.add('BOOBY_TRAPPED');

    // Move target.
    target.x = 50;
    target.z = 60;
    logic.update(1 / 30);

    // Bomb should follow target position.
    expect(bomb.x).toBe(50);
    expect(bomb.z).toBe(60);
  });

  it('detonates bomb with geometry-scaled damage when LifetimeUpdate timer expires', () => {
    // Bomb with LifetimeUpdate (30 frames = 1 second).
    const targetDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ], {
      GeometryMajorRadius: 20,
    });
    const bombDef = makeObjectDef('StickyBomb', 'America', ['VEHICLE', 'BOOBY_TRAP'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      {
        type: 'Behavior',
        name: 'StickyBombUpdate ModuleTag_SB',
        fields: {
          GeometryBasedDamageWeapon: 'StickyBombWeapon',
          OffsetZ: 10,
        },
        blocks: [],
      },
      {
        type: 'Behavior',
        name: 'LifetimeUpdate ModuleTag_Lifetime',
        fields: {
          MinLifetime: 1000, // 30 frames
          MaxLifetime: 1000,
        },
        blocks: [],
      },
    ]);
    // Nearby enemy unit to take splash damage (500 HP so it survives the 200 damage detonation).
    const bystander = makeObjectDef('Infantry', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const detonationWeapon = makeWeaponDef('StickyBombWeapon', {
      PrimaryDamage: 200,
      PrimaryDamageRadius: 30,
      DamageType: 'EXPLOSION',
    });
    const bundle = makeBundle({
      objects: [targetDef, bombDef, bystander],
      weapons: [detonationWeapon],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),        // id 1
        makeMapObject('StickyBomb', 10, 10),   // id 2
        makeMapObject('Infantry', 10, 10),     // id 3 (within blast radius)
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        x: number; z: number;
        health: number;
        destroyed: boolean;
        stickyBombTargetId: number;
        objectStatusFlags: Set<string>;
      }>;
    };
    const bomb = priv.spawnedEntities.get(2)!;
    const target = priv.spawnedEntities.get(1)!;

    // Attach bomb to target.
    bomb.stickyBombTargetId = 1;
    target.objectStatusFlags.add('BOOBY_TRAPPED');

    const targetInitialHealth = target.health;
    const bystanderInitialHealth = priv.spawnedEntities.get(3)!.health;

    // Advance past LifetimeUpdate timer (30 frames).
    for (let i = 0; i < 35; i++) logic.update(1 / 30);

    // Bomb should be destroyed.
    expect(bomb.destroyed).toBe(true);

    // Target should have taken geometry-scaled damage (radius = 30 + 20 majorRadius = 50).
    expect(target.health).toBeLessThan(targetInitialHealth);

    // Bystander at same position should also have taken damage.
    const bystander3 = priv.spawnedEntities.get(3)!;
    expect(bystander3.health).toBeLessThan(bystanderInitialHealth);

    // BOOBY_TRAPPED status should be cleared.
    expect(target.objectStatusFlags.has('BOOBY_TRAPPED')).toBe(false);
  });

  it('detonates bomb via checkAndDetonateBoobyTrap when target dies', () => {
    const targetDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ], {
      GeometryMajorRadius: 10,
    });
    const bombDef = makeObjectDef('StickyBomb', 'America', ['VEHICLE', 'BOOBY_TRAP'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      {
        type: 'Behavior',
        name: 'StickyBombUpdate ModuleTag_SB',
        fields: {
          GeometryBasedDamageWeapon: 'StickyBombWeapon2',
          OffsetZ: 10,
        },
        blocks: [],
      },
    ]);
    // Attacker to kill the target.
    const attackerDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
    ]);
    const attackerWeapon = makeWeaponDef('BigGun', {
      AttackRange: 200,
      PrimaryDamage: 200,
      PrimaryDamageRadius: 0,
      DamageType: 'ARMOR_PIERCING',
      DelayBetweenShots: 100,
      WeaponSpeed: 999999,
    });
    const detonationWeapon = makeWeaponDef('StickyBombWeapon2', {
      PrimaryDamage: 150,
      PrimaryDamageRadius: 25,
      DamageType: 'EXPLOSION',
    });
    // Nearby enemy bystander to verify splash damage from detonation.
    const bystanderDef = makeObjectDef('Bystander', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const bundle = makeBundle({
      objects: [targetDef, bombDef, attackerDef, bystanderDef],
      weapons: [attackerWeapon, detonationWeapon],
      commandSets: [makeCommandSetDef('AttackerCS', { '1': 'AttackButton' })],
      commandButtons: [makeCommandButtonDef('AttackButton', {
        Command: 'ATTACK_MOVE',
        Options: 'NEED_TARGET_ENEMY_OBJECT',
      })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),       // id 1  target
        makeMapObject('StickyBomb', 10, 10),  // id 2  bomb
        makeMapObject('Attacker', 10, 10),    // id 3  attacker
        makeMapObject('Bystander', 10, 10),   // id 4  splash damage recipient
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        destroyed: boolean;
        stickyBombTargetId: number;
        objectStatusFlags: Set<string>;
      }>;
    };
    const bomb = priv.spawnedEntities.get(2)!;
    const target = priv.spawnedEntities.get(1)!;

    // Attach bomb to target.
    bomb.stickyBombTargetId = 1;
    target.objectStatusFlags.add('BOOBY_TRAPPED');

    const bystanderInitialHealth = priv.spawnedEntities.get(4)!.health;

    // Order attacker to kill the target.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Target should be destroyed (200 damage > 100 HP).
    expect(target.destroyed).toBe(true);

    // Bomb should also be destroyed (via checkAndDetonateBoobyTrap  detonateStickyBomb  markEntityDestroyed,
    // or via updateStickyBombs  silentDestroyEntity when target is dead).
    expect(bomb.destroyed).toBe(true);

    // Bystander should have taken splash damage from the bomb detonation.
    const bystander4 = priv.spawnedEntities.get(4)!;
    expect(bystander4.health).toBeLessThan(bystanderInitialHealth);
  });

  it('silently destroys bomb when target is already dead and bomb has no lifetime', () => {
    const targetDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const bombDef = makeObjectDef('StickyBomb', 'America', ['VEHICLE', 'BOOBY_TRAP'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
      {
        type: 'Behavior',
        name: 'StickyBombUpdate ModuleTag_SB',
        fields: { OffsetZ: 10 },
        blocks: [],
      },
    ]);
    const bundle = makeBundle({ objects: [targetDef, bombDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),
        makeMapObject('StickyBomb', 10, 10),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        destroyed: boolean;
        stickyBombTargetId: number;
        objectStatusFlags: Set<string>;
      }>;
    };
    const bomb = priv.spawnedEntities.get(2)!;
    const target = priv.spawnedEntities.get(1)!;

    // Attach bomb.
    bomb.stickyBombTargetId = 1;
    target.objectStatusFlags.add('BOOBY_TRAPPED');

    // Destroy target directly (simulate external death without booby trap check).
    (target as unknown as { destroyed: boolean }).destroyed = true;

    // Next update: bomb's updateStickyBombs sees target is dead, silently destroys bomb.
    logic.update(1 / 30);

    expect(bomb.destroyed).toBe(true);
  });
});

// 
// InstantDeathBehavior  die module with filtering and weapon/OCL effects
// 

describe('InstantDeathBehavior', () => {
  it('extracts InstantDeathBehavior profiles from INI', () => {
    const tankDef = makeObjectDef('Tank', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
      {
        type: 'Die',
        name: 'InstantDeathBehavior ModuleTag_Die1',
        fields: {
          DeathTypes: 'BURNED EXPLODED',
          ExemptStatus: 'SOLD',
          Weapon: 'TankDeathExplosion',
        },
        blocks: [],
      },
      {
        type: 'Die',
        name: 'InstantDeathBehavior ModuleTag_Die2',
        fields: {
          DeathTypes: 'CRUSHED',
          RequiredStatus: 'DAMAGED',
          OCL: 'OCLCrushedDebris',
        },
        blocks: [],
      },
    ]);
    const bundle = makeBundle({ objects: [tankDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Tank', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        instantDeathProfiles: Array<{
          deathTypes: Set<string>;
          exemptStatus: Set<string>;
          requiredStatus: Set<string>;
          weaponNames: string[];
          oclNames: string[];
        }>;
      }>;
    };
    const tank = priv.spawnedEntities.get(1)!;
    expect(tank.instantDeathProfiles).toHaveLength(2);

    const p0 = tank.instantDeathProfiles[0]!;
    expect(p0.deathTypes.has('BURNED')).toBe(true);
    expect(p0.deathTypes.has('EXPLODED')).toBe(true);
    expect(p0.exemptStatus.has('SOLD')).toBe(true);
    expect(p0.weaponNames).toEqual(['TankDeathExplosion']);

    const p1 = tank.instantDeathProfiles[1]!;
    expect(p1.deathTypes.has('CRUSHED')).toBe(true);
    expect(p1.requiredStatus.has('DAMAGED')).toBe(true);
    expect(p1.oclNames).toEqual(['OCLCrushedDebris']);
  });

  it('fires death weapon on entity destruction', () => {
    const tankDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      {
        type: 'Die',
        name: 'InstantDeathBehavior ModuleTag_Die',
        fields: {
          Weapon: 'DeathBlast',
        },
        blocks: [],
      },
    ]);
    const nearbyDef = makeObjectDef('Bystander', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const attackerDef = makeObjectDef('Attacker', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigCannon'] }),
    ]);
    const bigCannon = makeWeaponDef('BigCannon', {
      AttackRange: 200,
      PrimaryDamage: 300,
      PrimaryDamageRadius: 0,
      DamageType: 'ARMOR_PIERCING',
      DelayBetweenShots: 100,
      WeaponSpeed: 999999,
    });
    const deathBlast = makeWeaponDef('DeathBlast', {
      PrimaryDamage: 75,
      PrimaryDamageRadius: 50,
      DamageType: 'EXPLOSION',
    });
    const bundle = makeBundle({
      objects: [tankDef, nearbyDef, attackerDef],
      weapons: [bigCannon, deathBlast],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),       // id 1  dies and fires DeathBlast
        makeMapObject('Bystander', 10, 10),   // id 2  nearby, should take death weapon damage
        makeMapObject('Attacker', 10, 10),    // id 3  kills the tank
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number; destroyed: boolean }>;
    };
    const tank = priv.spawnedEntities.get(1)!;
    const bystander = priv.spawnedEntities.get(2)!;
    const bystanderBefore = bystander.health;

    // Kill the tank.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);

    // Tank should be destroyed.
    expect(tank.destroyed).toBe(true);

    // Bystander should have taken death weapon damage (75 EXPLOSION, radius 50).
    expect(bystander.health).toBeLessThan(bystanderBefore);
  });

  it('skips die module when ExemptStatus matches', () => {
    const tankDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      {
        type: 'Die',
        name: 'InstantDeathBehavior ModuleTag_Die',
        fields: {
          ExemptStatus: 'SOLD',
          Weapon: 'DeathBlast2',
        },
        blocks: [],
      },
    ]);
    const nearbyDef = makeObjectDef('Bystander', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const deathBlast = makeWeaponDef('DeathBlast2', {
      PrimaryDamage: 100,
      PrimaryDamageRadius: 50,
      DamageType: 'EXPLOSION',
    });
    const bundle = makeBundle({
      objects: [tankDef, nearbyDef],
      weapons: [deathBlast],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),
        makeMapObject('Bystander', 10, 10),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        destroyed: boolean;
        objectStatusFlags: Set<string>;
      }>;
    };
    const tank = priv.spawnedEntities.get(1)!;
    const bystanderBefore = priv.spawnedEntities.get(2)!.health;

    // Mark tank as SOLD  this should exempt the die module.
    tank.objectStatusFlags.add('SOLD');

    // Kill the tank directly via UNRESISTABLE damage.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, tank, 500, 'UNRESISTABLE');

    // Advance one frame to process.
    logic.update(1 / 30);

    // Tank should be destroyed.
    expect(tank.destroyed).toBe(true);

    // Bystander should NOT have taken damage (die module was exempt).
    expect(priv.spawnedEntities.get(2)!.health).toBe(bystanderBefore);
  });

  it('skips die module when RequiredStatus is missing', () => {
    const tankDef = makeObjectDef('Tank', 'China', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      {
        type: 'Die',
        name: 'InstantDeathBehavior ModuleTag_Die',
        fields: {
          RequiredStatus: 'BOOBY_TRAPPED',
          Weapon: 'DeathBlast3',
        },
        blocks: [],
      },
    ]);
    const nearbyDef = makeObjectDef('Bystander', 'China', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
    ]);
    const deathBlast = makeWeaponDef('DeathBlast3', {
      PrimaryDamage: 100,
      PrimaryDamageRadius: 50,
      DamageType: 'EXPLOSION',
    });
    const bundle = makeBundle({
      objects: [tankDef, nearbyDef],
      weapons: [deathBlast],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),
        makeMapObject('Bystander', 10, 10),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        destroyed: boolean;
        objectStatusFlags: Set<string>;
      }>;
    };
    const tank = priv.spawnedEntities.get(1)!;
    const bystanderBefore = priv.spawnedEntities.get(2)!.health;

    // Tank does NOT have BOOBY_TRAPPED status  RequiredStatus check should block die module.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, tank, 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(tank.destroyed).toBe(true);
    // Bystander should NOT have taken damage (RequiredStatus not met).
    expect(priv.spawnedEntities.get(2)!.health).toBe(bystanderBefore);
  });
});

//  Body Type Polymorphism Tests 
describe('BodyModuleType', () => {
  it('resolves body type from INI block name (ActiveBody default)', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Tank', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as { spawnedEntities: Map<number, { bodyType: string; health: number; maxHealth: number; canTakeDamage: boolean }> };
    const tank = priv.spawnedEntities.get(1)!;
    expect(tank.bodyType).toBe('ACTIVE');
    expect(tank.health).toBe(200);
    expect(tank.canTakeDamage).toBe(true);
  });

  it('resolves HighlanderBody type from INI', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Boss', 'America', ['VEHICLE'], [
          makeBlock('Body', 'HighlanderBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Boss', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as { spawnedEntities: Map<number, { bodyType: string; health: number }> };
    expect(priv.spawnedEntities.get(1)!.bodyType).toBe('HIGHLANDER');
  });

  it('HighlanderBody caps damage at health-1 for non-UNRESISTABLE', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Boss', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'HighlanderBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Boss', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number; destroyed: boolean }>;
    };
    const boss = priv.spawnedEntities.get(1)!;

    // Apply massive EXPLOSION damage  should be capped at health-1.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, boss, 9999, 'EXPLOSION');

    expect(boss.health).toBe(1);
    expect(boss.destroyed).toBe(false);

    // Now apply UNRESISTABLE  should kill.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, boss, 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(boss.health).toBe(0);
    expect(boss.destroyed).toBe(true);
  });

  it('ImmortalBody never lets health drop below 1', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Immortal', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ImmortalBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Immortal', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number; destroyed: boolean }>;
    };
    const unit = priv.spawnedEntities.get(1)!;

    // Apply massive EXPLOSION damage  should not drop below 1.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, unit, 9999, 'EXPLOSION');

    expect(unit.health).toBe(1);
    expect(unit.destroyed).toBe(false);

    // UNRESISTABLE should ALSO be capped at 1 for ImmortalBody (unlike HighlanderBody).
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, unit, 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(unit.health).toBe(1);
    expect(unit.destroyed).toBe(false);
  });

  it('InactiveBody ignores all damage except UNRESISTABLE', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Scenery', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'InactiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('Scenery', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number; destroyed: boolean; canTakeDamage: boolean; bodyType: string }>;
    };
    const scenery = priv.spawnedEntities.get(1)!;

    // InactiveBody has no health and cannot take damage.
    expect(scenery.bodyType).toBe('INACTIVE');
    expect(scenery.canTakeDamage).toBe(false);
    expect(scenery.health).toBe(0);

    // Normal damage is ignored (canTakeDamage is false so applyWeaponDamageAmount is a no-op).
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, scenery, 9999, 'EXPLOSION');
    logic.update(1 / 30);
    expect(scenery.destroyed).toBe(false);
  });
});

//  Crate Collection System Tests 
describe('CrateCollideSystem', () => {
  it('HealCrateCollide heals all units of collector side', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('HealCrate', 'Neutral', ['CRATE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'HealCrateCollide ModuleTag_Collide', {}),
        ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5 }),
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 100 }),
        ], { Geometry: 'BOX', GeometryMajorRadius: 5 }),
        makeObjectDef('Soldier', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 25 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('HealCrate', 100, 100),
        makeMapObject('Tank', 102, 100),
        makeMapObject('Soldier', 500, 500),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number; maxHealth: number; destroyed: boolean }>;
    };

    logic.update(1 / 30);
    logic.update(1 / 30);

    // Crate should be destroyed (collected).
    const crate = priv.spawnedEntities.get(1);
    expect(crate === undefined || crate.destroyed).toBe(true);
    // Tank should be at max health.
    const tank = priv.spawnedEntities.get(2)!;
    expect(tank.health).toBe(tank.maxHealth);
    // Soldier (same side) should also be at max health.
    const soldier = priv.spawnedEntities.get(3)!;
    expect(soldier.health).toBe(soldier.maxHealth);
  });

  it('MoneyCrateCollide deposits credits to collector side', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('MoneyCrate', 'Neutral', ['CRATE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'MoneyCrateCollide ModuleTag_Collide', {
            MoneyProvided: 2000,
          }),
        ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5 }),
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { Geometry: 'BOX', GeometryMajorRadius: 5 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('MoneyCrate', 100, 100),
        makeMapObject('Tank', 102, 100),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // Get initial credits via private field.
    const priv = logic as unknown as {
      sideCredits: Map<string, number>;
      normalizeSide(s: string): string;
    };
    const creditsBefore = priv.sideCredits.get(priv.normalizeSide('America')) ?? 0;

    logic.update(1 / 30);
    logic.update(1 / 30);

    const creditsAfter = priv.sideCredits.get(priv.normalizeSide('America')) ?? 0;

    // Should have gained 2000 credits.
    expect(creditsAfter - creditsBefore).toBe(2000);
  });

  it('VeterancyCrateCollide grants veterancy level to collector', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('VetCrate', 'Neutral', ['CRATE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'VeterancyCrateCollide ModuleTag_Collide', {}),
        ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5 }),
        // ExperienceRequired is a top-level ObjectDef field, not a Behavior block field.
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { Geometry: 'BOX', GeometryMajorRadius: 5, ExperienceRequired: [1, 50, 100, 200] }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('VetCrate', 100, 100),
        makeMapObject('Tank', 102, 100),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        experienceState: { currentLevel: number };
      }>;
    };
    const tank = priv.spawnedEntities.get(2)!;
    const levelBefore = tank.experienceState.currentLevel;

    logic.update(1 / 30);
    logic.update(1 / 30);

    // Should have gained at least 1 veterancy level.
    expect(tank.experienceState.currentLevel).toBeGreaterThan(levelBefore);
  });

  it('UnitCrateCollide spawns units near crate', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitCrate', 'Neutral', ['CRATE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'UnitCrateCollide ModuleTag_Collide', {
            UnitName: 'SpawnedSoldier',
            UnitCount: 3,
          }),
        ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5 }),
        makeObjectDef('SpawnedSoldier', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { Geometry: 'BOX', GeometryMajorRadius: 5 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('UnitCrate', 100, 100),
        makeMapObject('Tank', 102, 100),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { templateName: string }>;
    };

    logic.update(1 / 30);
    logic.update(1 / 30);

    // Should have 3 new SpawnedSoldier entities.
    let spawnedCount = 0;
    for (const e of priv.spawnedEntities.values()) {
      if (e.templateName === 'SpawnedSoldier') spawnedCount++;
    }
    expect(spawnedCount).toBe(3);
  });

  it('crate ForbidOwnerPlayer prevents same-side unit from collecting', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('MoneyCrate', 'America', ['CRATE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'MoneyCrateCollide ModuleTag_Collide', {
            MoneyProvided: 1000,
            ForbidOwnerPlayer: true,
          }),
        ], { Geometry: 'CYLINDER', GeometryMajorRadius: 5 }),
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { Geometry: 'BOX', GeometryMajorRadius: 5 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('MoneyCrate', 100, 100),
        makeMapObject('Tank', 102, 100),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    const priv = logic as unknown as {
      sideCredits: Map<string, number>;
      normalizeSide(s: string): string;
    };
    const creditsBefore = priv.sideCredits.get(priv.normalizeSide('America')) ?? 0;

    logic.update(1 / 30);
    logic.update(1 / 30);

    const creditsAfter = priv.sideCredits.get(priv.normalizeSide('America')) ?? 0;

    // ForbidOwnerPlayer = true: America crate should NOT be collectable by America tank.
    expect(creditsAfter - creditsBefore).toBe(0);
  });
});

//  Victory Conditions C++ Parity 

describe('victory conditions C++ parity', () => {
  it('any non-excluded entity prevents defeat (C++ hasAnyObjects parity)', () => {
    // Source parity: C++ hasAnyObjects() counts ALL non-excluded entities regardless of
    // MP_COUNT_FOR_VICTORY. A structure without MP_COUNT_FOR_VICTORY still prevents defeat.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USAMine', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('GLATank', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        // America has only a STRUCTURE without MP_COUNT_FOR_VICTORY  NOT defeated per C++.
        makeMapObject('USAMine', 50, 50),
        makeMapObject('GLATank', 100, 100),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setPlayerSide(0, 'America');
    logic.setPlayerSide(1, 'GLA');
    logic.setSidePlayerType('America', 'HUMAN');
    logic.setSidePlayerType('GLA', 'HUMAN');

    // Run frames  America has a STRUCTURE (no MP_COUNT_FOR_VICTORY). C++ hasAnyObjects
    // counts all non-excluded entities, so America should NOT be defeated.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const gameEnd = logic.getGameEndState();
    // Game should NOT end  both sides still have entities.
    expect(gameEnd).toBeNull();
  });

  it('detects alliance-based victory (allied sides survive together)', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USATank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
        ]),
        makeObjectDef('ChinaTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('USATank', 30, 30),
        makeMapObject('ChinaTank', 70, 70),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    // America and China are mutual allies.
    logic.setTeamRelationship('America', 'China', 2);
    logic.setTeamRelationship('China', 'America', 2);
    // GLA is an enemy but has no entities  already defeated.
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);
    logic.setPlayerSide(0, 'America');
    logic.setPlayerSide(1, 'China');
    logic.setPlayerSide(2, 'GLA');
    logic.setSidePlayerType('America', 'HUMAN');
    logic.setSidePlayerType('China', 'HUMAN');
    logic.setSidePlayerType('GLA', 'HUMAN');

    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const gameEnd = logic.getGameEndState();
    expect(gameEnd).not.toBeNull();
    // GLA is defeated, and America+China are allied  game should end with both as victors.
    expect(gameEnd!.defeatedSides).toContain('gla');
    expect(gameEnd!.victorSides).toContain('america');
    expect(gameEnd!.victorSides).toContain('china');
  });

  it('kills remaining entities on defeat and reveals map', () => {
    // Source parity: Player::killPlayer  all entities destroyed on defeat.
    // Set up a side with ONE entity. GLA side has a tank that kills it.
    // After defeat, killRemainingEntitiesForSide destroys stragglers.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USAPowerPlant', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('GLATank', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0,
          DamageType: 'ARMOR_PIERCING', AttackRange: 200,
          DelayBetweenShots: 100, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('USAPowerPlant', 50, 50),
        makeMapObject('GLATank', 55, 55),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setPlayerSide(0, 'America');
    logic.setPlayerSide(1, 'GLA');
    logic.setSidePlayerType('America', 'HUMAN');
    logic.setSidePlayerType('GLA', 'HUMAN');

    // Attack the power plant to destroy it.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Run enough frames for the tank to fire and destroy the power plant.
    for (let i = 0; i < 120; i++) logic.update(1 / 30);

    // Power plant destroyed  USA has zero non-excluded entities  defeated.
    const gameEnd = logic.getGameEndState();
    expect(gameEnd).not.toBeNull();
    expect(gameEnd!.defeatedSides).toContain('america');
    expect(gameEnd!.victorSides).toContain('gla');

    // The power plant should be destroyed (health 0 or null entity state).
    const plant = logic.getEntityState(1);
    expect(plant === null || plant.health <= 0).toBe(true);
  });
});

//  Death OCL DieMuxData Filtering 

describe('death OCL DieMuxData filtering', () => {
  it('filters death OCLs by veterancy level', () => {
    // Create a unit with a death OCL that only fires at VETERAN+ level.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EliteUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
          makeBlock('Die', 'CreateObjectDie ModuleTag_Die', {
            CreationList: 'OCL_VetDeath',
            VeterancyLevels: 'VETERAN ELITE HEROIC',
          }),
        ], { ExperienceRequired: [1, 50, 100, 200], ExperienceValue: 10 }),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
        ]),
        makeObjectDef('DebrisChunk', 'America', ['INERT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0,
          DamageType: 'ARMOR_PIERCING', AttackRange: 200,
          DelayBetweenShots: 100, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
      ],
      ocls: [
        {
          name: 'OCL_VetDeath',
          blocks: [
            makeBlock('CreateObject', '', { ObjectNames: 'DebrisChunk', Count: '1' }),
          ],
        },
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EliteUnit', 50, 50),
        makeMapObject('Attacker', 100, 100),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    // Attack and kill the unit (at REGULAR level, not VETERAN).
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Unit should be dead. Check if any debris was spawned  at REGULAR level, the
    // VeterancyLevels filter should block the death OCL.
    const allEntities: number[] = [];
    for (let id = 1; id <= 10; id++) {
      const state = logic.getEntityState(id);
      if (state && state.templateName?.toUpperCase().includes('DEBRIS')) {
        allEntities.push(id);
      }
    }
    // No debris should have spawned because the unit was REGULAR, not VETERAN+.
    expect(allEntities.length).toBe(0);
  });
});

//  HealContain System 

describe('HealContain system', () => {
  it('heals passengers and auto-ejects when fully healed', () => {
    // Source parity: HealContain::update  heal passengers per frame, auto-eject at full health.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ambulance', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
          makeBlock('Behavior', 'HealContain ModuleTag_Contain', {
            ContainMax: 3,
            TimeForFullHeal: 1000, // 1000ms = 30 frames at 30fps
          }),
        ]),
        makeObjectDef('Infantry', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 5 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ambulance', 50, 50),
        makeMapObject('Infantry', 52, 52), // Close enough to enter immediately.
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // Damage the infantry to 50% health.
    const infantry = (logic as any).spawnedEntities.get(2);
    infantry.health = 50;

    // Enter the ambulance.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    // One frame to process the enter command.
    logic.update(1 / 30);

    // Infantry should be inside (MASKED/UNSELECTABLE).
    let infantryState = logic.getEntityState(2);
    expect(infantryState).not.toBeNull();
    // Entity is inside ambulance  check it's not visible (health not yet full).
    expect(infantryState!.health).toBeLessThan(100);

    // Run 30 frames (1000ms at 30fps)  should be fully healed and ejected.
    for (let i = 0; i < 35; i++) logic.update(1 / 30);

    // Infantry should be fully healed and ejected (visible again).
    infantryState = logic.getEntityState(2);
    expect(infantryState).not.toBeNull();
    expect(infantryState!.health).toBe(100);
  });

  it('respects container capacity limit', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ambulance', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
          makeBlock('Behavior', 'HealContain ModuleTag_Contain', {
            ContainMax: 1, // Only 1 passenger.
            TimeForFullHeal: 1000,
          }),
        ]),
        makeObjectDef('Infantry', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 5 }),
          makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ambulance', 50, 50),
        makeMapObject('Infantry', 52, 52),
        makeMapObject('Infantry', 53, 53),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // Damage both infantry.
    const priv = logic as any;
    priv.spawnedEntities.get(2).health = 50;
    priv.spawnedEntities.get(3).health = 50;

    // Try to enter both.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    logic.update(1 / 30);

    // Only one should be inside (capacity = 1).
    const infantry2 = priv.spawnedEntities.get(2);
    const infantry3 = priv.spawnedEntities.get(3);
    const inside2 = infantry2.transportContainerId === 1;
    const inside3 = infantry3.transportContainerId === 1;
    // Exactly one should be inside.
    expect(inside2 !== inside3 || (!inside2 && !inside3)).toBe(true);
  });
});

//  AutoFindHealingUpdate Tests 

describe('AutoFindHealingUpdate', () => {
  function makeAutoHealSetup(opts: {
    healthPercent?: number;
    scanRange?: number;
    neverHeal?: number;
    alwaysHeal?: number;
    isHuman?: boolean;
  } = {}) {
    const healPadDef = makeObjectDef('HealPad', 'America', ['STRUCTURE', 'HEAL_PAD'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'HealContain ModuleTag_Contain', {
        ContainMax: 3,
        TimeForFullHeal: 1000,
      }),
    ]);

    const infantryDef = makeObjectDef('Infantry', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Locomotor', 'BasicLocomotor LocoTag', { Speed: 10 }),
      makeBlock('Behavior', 'AIUpdateInterface ModuleTag_AI', {}),
      makeBlock('Behavior', 'AutoFindHealing ModuleTag_AutoHeal', {
        ScanRate: 200,  // ~6 frames
        ScanRange: opts.scanRange ?? 200,
        NeverHeal: opts.neverHeal ?? 0.95,
        AlwaysHeal: opts.alwaysHeal ?? 0.25,
      }),
    ]);

    const bundle = makeBundle({ objects: [healPadDef, infantryDef] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('HealPad', 50, 50),
        makeMapObject('Infantry', 52, 52),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setSidePlayerType('America', opts.isHuman ? 'HUMAN' : 'COMPUTER');
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const infantry = priv.spawnedEntities.get(2)!;

    const healthPercent = opts.healthPercent ?? 50;
    infantry.health = (healthPercent / 100) * infantry.maxHealth;

    return { logic, priv, infantry };
  }

  it('AI unit auto-enters nearby heal pad when damaged and idle', () => {
    const { logic, infantry } = makeAutoHealSetup({ healthPercent: 50 });

    expect(infantry.health).toBe(50);

    // Run enough frames for the auto-heal scan and entry.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // Infantry should now be inside the heal pad.
    expect(infantry.transportContainerId).not.toBeNull();

    // Run more frames for healing + auto-eject.
    for (let i = 0; i < 40; i++) logic.update(1 / 30);
    expect(infantry.health).toBe(100);
    expect(infantry.transportContainerId).toBeNull();
  });

  it('does not auto-heal for human-controlled units', () => {
    const { logic, infantry } = makeAutoHealSetup({ healthPercent: 50, isHuman: true });

    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(infantry.transportContainerId).toBeNull();
    expect(infantry.health).toBe(50);
  });

  it('does not seek healing when health above NeverHeal threshold', () => {
    const { logic, infantry } = makeAutoHealSetup({ healthPercent: 96, neverHeal: 0.95 });

    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(infantry.transportContainerId).toBeNull();
  });
});

// 
// EnemyNearUpdate  proximity detection for model condition
// 
describe('EnemyNearUpdate', () => {
  it('detects enemy within vision range and sets enemyNearDetected', () => {
    const guard = makeObjectDef('Guard', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'EnemyNearUpdate ModuleTag_EN', { ScanDelayTime: 500 }),
    ], { VisionRange: 150 });
    const tank = makeObjectDef('Tank', 'GLA', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const bundle = makeBundle({ objects: [guard, tank] });
    const registry = makeRegistry(bundle);
    const map = makeMap([makeMapObject('Guard', 5, 5), makeMapObject('Tank', 5, 5)]);
    const heightmap = makeHeightmap();
    const scene = { add: () => {}, remove: () => {} } as any;
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(map, registry, heightmap);
    logic.setTeamRelationship('America', 'GLA', 0); // enemies
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as any;
    const guardEntity = priv.spawnedEntities.get(1)!;
    expect(guardEntity.enemyNearScanDelayFrames).toBeGreaterThan(0);
    expect(guardEntity.enemyNearDetected).toBe(false);

    // Run enough frames for the initial random delay to expire + a scan.
    for (let i = 0; i < 60; i++) logic.update(1 / 30);

    expect(guardEntity.enemyNearDetected).toBe(true);
  });

  it('clears enemyNearDetected when enemy moves out of range', () => {
    const guard = makeObjectDef('Guard', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'EnemyNearUpdate ModuleTag_EN', { ScanDelayTime: 100 }),
    ], { VisionRange: 50 });
    const tank = makeObjectDef('Tank', 'GLA', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const bundle = makeBundle({ objects: [guard, tank] });
    const registry = makeRegistry(bundle);
    const map = makeMap([makeMapObject('Guard', 5, 5), makeMapObject('Tank', 5, 5)]);
    const heightmap = makeHeightmap();
    const scene = { add: () => {}, remove: () => {} } as any;
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(map, registry, heightmap);
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as any;
    const guardEntity = priv.spawnedEntities.get(1)!;
    const tankEntity = priv.spawnedEntities.get(2)!;

    // Run to detect enemy.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(guardEntity.enemyNearDetected).toBe(true);

    // Move enemy far away  beyond vision range.
    tankEntity.x = 9999;
    tankEntity.z = 9999;

    // Run again to clear detection.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(guardEntity.enemyNearDetected).toBe(false);
  });

  it('does not detect allies as enemies', () => {
    const guard = makeObjectDef('Guard', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'EnemyNearUpdate ModuleTag_EN', { ScanDelayTime: 100 }),
    ], { VisionRange: 150 });
    const friendly = makeObjectDef('Friendly', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const bundle = makeBundle({ objects: [guard, friendly] });
    const registry = makeRegistry(bundle);
    const map = makeMap([makeMapObject('Guard', 5, 5), makeMapObject('Friendly', 5, 5)]);
    const heightmap = makeHeightmap();
    const scene = { add: () => {}, remove: () => {} } as any;
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(map, registry, heightmap);

    const priv = logic as any;
    const guardEntity = priv.spawnedEntities.get(1)!;

    for (let i = 0; i < 60; i++) logic.update(1 / 30);

    // Allied unit nearby should not trigger enemy near.
    expect(guardEntity.enemyNearDetected).toBe(false);
  });
});

// 
// HeightDieUpdate  OnlyWhenMovingDown parity
// 
describe('HeightDieUpdate OnlyWhenMovingDown', () => {
  it('survives when below target height but moving upward', () => {
    const aircraft = makeObjectDef('Jet', 'America', ['AIRCRAFT'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
      makeBlock('Behavior', 'HeightDieUpdate ModuleTag_HD', {
        TargetHeight: 5,
        OnlyWhenMovingDown: 'Yes',
        SnapToGroundOnDeath: 'Yes',
      }),
    ], { VisionRange: 100 });
    const bundle = makeBundle({ objects: [aircraft] });
    const registry = makeRegistry(bundle);
    const map = makeMap([makeMapObject('Jet', 3, 3)]);
    const heightmap = makeHeightmap();
    const scene = { add: () => {}, remove: () => {} } as any;
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(map, registry, heightmap);

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;

    // Start at height 2 (below target 5)  first update initializes lastY.
    jet.y = 2 + jet.baseHeight;
    logic.update(1 / 30);
    expect(jet.destroyed).toBe(false); // First frame initializes lastY

    // Now move upward  below target but ascending. Should survive.
    jet.y = 3 + jet.baseHeight;
    logic.update(1 / 30);
    expect(jet.destroyed).toBe(false);

    // Move downward  now the check fires and it's below target  die.
    jet.y = 2 + jet.baseHeight;
    logic.update(1 / 30);
    expect(jet.destroyed).toBe(true);
  });
});

describe('GrantUpgradeCreate', () => {
  it('grants object upgrade on creation when not under construction', () => {
    const building = makeObjectDef('AmericaPowerPlant', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'GrantUpgradeCreate ModuleTag_GUC', {
        UpgradeToGrant: 'Upgrade_AmericaPower',
        ExemptStatus: 'UNDER_CONSTRUCTION',
      }),
    ]);

    const bundle = makeBundle({ objects: [building] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('AmericaPowerPlant', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const entity = priv.spawnedEntities.get(1)!;

    // Map-placed entities are not under construction, so upgrade should be granted immediately.
    expect(entity.completedUpgrades.has('UPGRADE_AMERICAPOWER')).toBe(true);
  });

  it('does not grant upgrade during construction, grants on build complete', () => {
    // Place a building directly but mark it under construction, then complete it.
    const building = makeObjectDef('AmericaPowerPlant2', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'GrantUpgradeCreate ModuleTag_GUC', {
        UpgradeToGrant: 'Upgrade_Power2',
        ExemptStatus: 'UNDER_CONSTRUCTION',
      }),
    ]);

    const bundle = makeBundle({ objects: [building] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('AmericaPowerPlant2', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const entity = priv.spawnedEntities.get(1)!;

    // When placed from map, it's not under construction  upgrade already granted on creation.
    expect(entity.completedUpgrades.has('UPGRADE_POWER2')).toBe(true);

    // Now simulate a building that starts under construction:
    // Clear the upgrade and set UNDER_CONSTRUCTION, then call completeConstruction.
    entity.completedUpgrades.delete('UPGRADE_POWER2');
    entity.objectStatusFlags.add('UNDER_CONSTRUCTION');
    // The upgrade should NOT be present.
    expect(entity.completedUpgrades.has('UPGRADE_POWER2')).toBe(false);

    // Trigger completeConstruction via the private method.
    (logic as any).completeConstruction(entity);
    // Now the upgrade should be re-granted.
    expect(entity.completedUpgrades.has('UPGRADE_POWER2')).toBe(true);
  });
});

describe('UpgradeDie', () => {
  it('removes upgrade from producer when entity dies', () => {
    const factory = makeObjectDef('AmericaAirfield', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
      makeBlock('ProductionUpdate', 'ProductionUpdate ModuleTag_PU', {
        MaxQueueEntries: 5,
      }),
    ]);
    const drone = makeObjectDef('ScoutDrone', 'America', ['VEHICLE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
      makeBlock('Behavior', 'UpgradeDie ModuleTag_UD', {
        UpgradeToRemove: 'Upgrade_ScoutDrone',
      }),
    ]);

    const bundle = makeBundle({ objects: [factory, drone] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('AmericaAirfield', 5, 5)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const factoryEntity = priv.spawnedEntities.get(1)!;

    // Manually give the factory the upgrade.
    factoryEntity.completedUpgrades.add('UPGRADE_SCOUTDRONE');

    // Create a drone entity as if produced by the factory.
    const droneDef = bundle.objects.find(o => o.name.toUpperCase() === 'SCOUTDRONE')!;
    const droneMapObj: MapObjectJSON = {
      templateName: 'ScoutDrone',
      angle: 0,
      flags: 0,
      position: { x: 55, y: 55, z: 0 },
      properties: {},
    };
    const droneEntity = (logic as any).createMapEntity(droneMapObj, droneDef, makeRegistry(bundle), makeHeightmap());
    droneEntity.side = 'America';
    droneEntity.controllingPlayerToken = factoryEntity.controllingPlayerToken;
    droneEntity.producerEntityId = factoryEntity.id;
    priv.spawnedEntities.set(droneEntity.id, droneEntity);
    logic.update(1 / 30);

    expect(factoryEntity.completedUpgrades.has('UPGRADE_SCOUTDRONE')).toBe(true);

    // Kill the drone.
    (logic as any).applyWeaponDamageAmount(null, droneEntity, 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(droneEntity.destroyed).toBe(true);
    // Factory should have the upgrade removed.
    expect(factoryEntity.completedUpgrades.has('UPGRADE_SCOUTDRONE')).toBe(false);
  });
});

describe('CheckpointUpdate', () => {
  it('opens gate when ally is near and no enemies nearby', () => {
    const gate = makeObjectDef('Checkpoint', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'CheckpointUpdate ModuleTag_CU', { EnemyScanDelayTime: 500 }),
    ], { VisionRange: 100, Geometry: 'BOX', GeometryMajorRadius: 10, GeometryMinorRadius: 5, GeometryHeight: 10 });
    const ally = makeObjectDef('AllyUnit', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const bundle = makeBundle({ objects: [gate, ally] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Checkpoint', 5, 5),
        makeMapObject('AllyUnit', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    // Same team = allies (2 = RELATIONSHIP_ALLIES).
    logic.setTeamRelationship('America', 'America', 2);
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const gateEntity = priv.spawnedEntities.get(1)!;
    const initialMinorRadius = gateEntity.checkpointMaxMinorRadius;
    expect(initialMinorRadius).toBeGreaterThan(0);

    // Run several frames  gate should shrink (opening).
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const geom = gateEntity.obstacleGeometry!;
    expect(geom.minorRadius).toBeLessThan(initialMinorRadius);
  });

  it('closes gate when enemy is near', () => {
    const gate = makeObjectDef('Checkpoint2', 'America', ['STRUCTURE'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
      makeBlock('Behavior', 'CheckpointUpdate ModuleTag_CU', { EnemyScanDelayTime: 500 }),
    ], { VisionRange: 100, Geometry: 'BOX', GeometryMajorRadius: 10, GeometryMinorRadius: 5, GeometryHeight: 10 });
    const enemy = makeObjectDef('EnemyUnit', 'GLA', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);
    const ally = makeObjectDef('AllyUnit2', 'America', ['INFANTRY'], [
      makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
    ]);

    const bundle = makeBundle({ objects: [gate, enemy, ally] });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Checkpoint2', 5, 5),
        makeMapObject('EnemyUnit', 5, 5),
        makeMapObject('AllyUnit2', 5, 5),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setTeamRelationship('America', 'GLA', 0); // enemies
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'America', 2); // allies
    logic.update(0);

    const priv = logic as unknown as { spawnedEntities: Map<number, MapEntity> };
    const gateEntity = priv.spawnedEntities.get(1)!;
    const maxMinor = gateEntity.checkpointMaxMinorRadius;

    // Run several frames  gate should stay closed (enemy nearby).
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const geom = gateEntity.obstacleGeometry!;
    // Radius should remain at max (closed).
    expect(geom.minorRadius).toBe(maxMinor);
  });
});

//  StructureCollapseUpdate Tests 

describe('StructureCollapseUpdate', () => {
  function makeCollapseBundle(collapseFields: Record<string, unknown> = {}) {
    return makeBundle({
      objects: [
        makeObjectDef('CollapseBuilding', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StructureCollapseUpdate ModuleTag_Collapse', {
            MinCollapseDelay: 100, // ~3 frames
            MaxCollapseDelay: 100, // ~3 frames (deterministic)
            MinBurstDelay: 200,    // ~6 frames
            MaxBurstDelay: 200,    // ~6 frames
            CollapseDamping: 0.5,
            BigBurstFrequency: 2,
            ...collapseFields,
          }),
        ], { Geometry: 'BOX', GeometryMajorRadius: '10', GeometryMinorRadius: '10', GeometryHeight: '20' }),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BuildingKiller'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('BuildingKiller', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
  }

  it('building persists during collapse and is eventually destroyed', () => {
    const bundle = makeCollapseBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseBuilding', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Advance until lethal damage  building enters collapse.
    let enteredCollapse = false;
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
      const s = logic.getEntityState(1);
      if (s && s.health <= 0 && s.animationState === 'DIE') {
        enteredCollapse = true;
        break;
      }
    }
    expect(enteredCollapse).toBe(true);

    // Building should still be in entity state (not destroyed yet) during collapse.
    const midCollapse = logic.getEntityState(1);
    expect(midCollapse).not.toBeNull();
    expect(midCollapse!.animationState).toBe('DIE');

    // Access internal state to verify collapse state.
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { structureCollapseState: { state: string } | null; destroyed: boolean }>;
    };
    const buildingEntity = priv.spawnedEntities.get(1)!;
    expect(buildingEntity.structureCollapseState).not.toBeNull();

    // Run enough frames for the building to fully collapse and be destroyed.
    // With height=20, gravity=-1.0, damping=0.5: velocity grows at 0.5/frame.
    // After N frames of COLLAPSING, currentHeight reaches -20 and building is destroyed.
    for (let i = 0; i < 100; i++) logic.update(1 / 30);

    // Building should now be fully destroyed.
    const afterCollapse = logic.getEntityState(1);
    expect(afterCollapse).toBeNull();
  });

  it('transitions through WAITING  COLLAPSING  DONE states', () => {
    const bundle = makeCollapseBundle({
      MinCollapseDelay: 200,  // ~6 frames
      MaxCollapseDelay: 200,
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseBuilding', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill the building.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        structureCollapseState: { state: string; currentHeight: number } | null;
        destroyed: boolean;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.structureCollapseState).not.toBeNull();
    expect(entity.structureCollapseState!.state).toBe('WAITING');

    // Advance past collapse delay (6 frames).
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Should be COLLAPSING now with height decreasing.
    if (entity.structureCollapseState) {
      expect(entity.structureCollapseState.state).toBe('COLLAPSING');
      expect(entity.structureCollapseState.currentHeight).toBeLessThan(0);
    }
  });

  it('does not take further damage during collapse', () => {
    const bundle = makeCollapseBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseBuilding', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill building to enter collapse.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { canTakeDamage: boolean; structureCollapseState: object | null }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.structureCollapseState).not.toBeNull();
    expect(entity.canTakeDamage).toBe(false);
  });

  it('executes INITIAL phase OCL on collapse start', () => {
    const bundle = makeCollapseBundle({
      OCL: 'INITIAL CollapseDebrisOCL',
    });
    // Add the debris OCL and debris object def.
    (bundle as Record<string, unknown>).objectCreationLists = [
      {
        name: 'CollapseDebrisOCL',
        fields: {},
        blocks: [{
          type: 'CreateObject',
          name: 'CreateObject',
          fields: { ObjectNames: 'CollapseDebris', Count: '1' },
          blocks: [],
        }],
      },
    ];
    // Add the debris object definition to the bundle.
    (bundle.objects as ObjectDef[]).push(
      makeObjectDef('CollapseDebris', 'America', ['VEHICLE'], [
        makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
      ]),
    );

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseBuilding', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill building  INITIAL phase should fire and spawn debris.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Check that a CollapseDebris entity was spawned.
    const allStates = logic.getRenderableEntityStates();
    const debrisEntities = allStates.filter(s => s.templateName === 'CollapseDebris');
    expect(debrisEntities.length).toBeGreaterThanOrEqual(1);
  });

  it('respects DieMuxData death type filtering', () => {
    const bundle = makeCollapseBundle({
      DeathTypes: 'LASERED', // Only fire on laser death.
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseBuilding', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill with normal weapon (not LASERED)  collapse should NOT trigger.
    // Building should be immediately destroyed (no collapse animation).
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Entity should be fully destroyed and no longer visible.
    const afterDeath = logic.getEntityState(1);
    expect(afterDeath).toBeNull();
  });

  it('gravity-damped sinking causes height to decrease each frame during collapse', () => {
    const bundle = makeCollapseBundle({
      MinCollapseDelay: 0,
      MaxCollapseDelay: 0,
      CollapseDamping: 0.0, // Full gravity, no damping.
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseBuilding', 50, 50),
        makeMapObject('Attacker', 20, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });

    // Kill and enter collapse.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        structureCollapseState: { state: string; currentHeight: number; collapseVelocity: number } | null;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    // With 0 collapse delay, should immediately be COLLAPSING after one update.
    // Run a few more frames to let physics take effect.
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    if (entity.structureCollapseState) {
      // With full gravity (damping=0), velocity = (1.0)^N cumulative.
      // Height should be negative and decreasing.
      expect(entity.structureCollapseState.currentHeight).toBeLessThan(0);
      expect(entity.structureCollapseState.collapseVelocity).toBeGreaterThan(0);
    }
  });
});

describe('EMPUpdate', () => {
  it('disables nearby vehicles after fade frame and self-destructs at lifetime end', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EMPPulse', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'EMPUpdate ModuleTag_EMP', {
            Lifetime: 300,          // 9 frames
            StartFadeTime: 100,     // 3 frames  disable attack fires here
            DisabledDuration: 3000, // 90 frames
            EffectRadius: 200,
          }),
        ]),
        makeObjectDef('Tank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EMPPulse', 50, 50),
        makeMapObject('Tank', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Frame 0-2: before fade frame  tank should not be disabled.
    for (let i = 0; i < 2; i++) logic.update(1 / 30);
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);

    // Frame 3+: after fade frame  tank should become disabled.
    for (let i = 0; i < 3; i++) logic.update(1 / 30);
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);

    // After lifetime (9 frames total), EMP pulse entity should be destroyed.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);
    expect(logic.getEntityState(1)).toBeNull();

    // Tank should still exist (was disabled, not killed).
    expect(logic.getEntityState(2)).not.toBeNull();
    expect(logic.getEntityState(2)!.health).toBe(500);
  });

  it('skips infantry targets (unless SPAWNS_ARE_THE_WEAPONS)', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EMPPulse', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'EMPUpdate ModuleTag_EMP', {
            Lifetime: 300,
            StartFadeTime: 0,
            DisabledDuration: 3000,
            EffectRadius: 200,
          }),
        ]),
        makeObjectDef('Soldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('SpawnMaster', 'China', ['VEHICLE', 'SPAWNS_ARE_THE_WEAPONS'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EMPPulse', 50, 50),
        makeMapObject('Soldier', 55, 50),
        makeMapObject('SpawnMaster', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Run past StartFadeTime (0 = immediate).
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    // Infantry should NOT be disabled.
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);
    // SPAWNS_ARE_THE_WEAPONS vehicle should be disabled (it's a vehicle, not filtered).
    expect(priv.spawnedEntities.get(3)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);
  });

  it('kills airborne aircraft instead of disabling them', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EMPPulse', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'EMPUpdate ModuleTag_EMP', {
            Lifetime: 300,
            StartFadeTime: 0,
            DisabledDuration: 3000,
            EffectRadius: 200,
          }),
        ]),
        makeObjectDef('Jet', 'China', ['AIRCRAFT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EMPPulse', 50, 50),
        makeMapObject('Jet', 55, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Set the jet as airborne.
    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    priv.spawnedEntities.get(2)!.objectStatusFlags.add('AIRBORNE_TARGET');

    // Run past StartFadeTime.
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    // Airborne aircraft should be killed, not just disabled.
    expect(logic.getEntityState(2)).toBeNull();
  });

  it('EMP_HARDENED ground vehicles are still disabled but airborne EMP_HARDENED aircraft survive', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EMPPulse', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'EMPUpdate ModuleTag_EMP', {
            Lifetime: 300,
            StartFadeTime: 0,
            DisabledDuration: 3000,
            EffectRadius: 200,
          }),
        ]),
        makeObjectDef('HardenedTank', 'China', ['VEHICLE', 'EMP_HARDENED'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
        makeObjectDef('HardenedJet', 'China', ['VEHICLE', 'AIRCRAFT', 'EMP_HARDENED'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EMPPulse', 50, 50),
        makeMapObject('HardenedTank', 55, 50),
        makeMapObject('HardenedJet', 52, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string>; health: number }>;
    };
    // Make the jet airborne.
    priv.spawnedEntities.get(3)!.objectStatusFlags.add('AIRBORNE_TARGET');

    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    // Ground EMP_HARDENED vehicle SHOULD still be disabled (C++ parity: EMP_HARDENED only protects airborne aircraft).
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);
    // Airborne EMP_HARDENED aircraft should NOT be killed.
    expect(priv.spawnedEntities.get(3)!.health).toBe(300);
  });

  it('doesNotAffectMyOwnBuildings skips friendly structures', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EMPPulse', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'EMPUpdate ModuleTag_EMP', {
            Lifetime: 300,
            StartFadeTime: 0,
            DisabledDuration: 3000,
            EffectRadius: 200,
            DoesNotAffectMyOwnBuildings: 'Yes',
          }),
        ]),
        makeObjectDef('FriendlyPower', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
        makeObjectDef('EnemyPower', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EMPPulse', 50, 50),
        makeMapObject('FriendlyPower', 55, 50),
        makeMapObject('EnemyPower', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    // Friendly structure should NOT be disabled (DoesNotAffectMyOwnBuildings).
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);
    // Enemy structure should be disabled.
    expect(priv.spawnedEntities.get(3)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);
  });

  it('DISABLED_EMP expires after configured duration', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('EMPPulse', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'EMPUpdate ModuleTag_EMP', {
            Lifetime: 300,
            StartFadeTime: 0,
            DisabledDuration: 500,  // 15 frames
            EffectRadius: 200,
          }),
        ]),
        makeObjectDef('Tank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('EMPPulse', 50, 50),
        makeMapObject('Tank', 55, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Trigger the EMP (StartFadeTime = 0  immediate).
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);

    // Run past the 15-frame disable duration + some buffer.
    for (let i = 0; i < 20; i++) logic.update(1 / 30);

    // DISABLED_EMP should have expired.
    const tank = priv.spawnedEntities.get(2);
    if (tank) {
      expect(tank.objectStatusFlags.has('DISABLED_EMP')).toBe(false);
    }
  });
});

describe('HijackerUpdate', () => {
  it('hides hijacker in vehicle and ejects when vehicle is destroyed', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hijacker', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
          makeBlock('Behavior', 'HijackerUpdate ModuleTag_HijackerUpdate', {
            ParachuteName: 'GLA_Parachute',
          }),
        ]),
        makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'HijackTestGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('HijackTestGun', {
          AttackRange: 220,
          PrimaryDamage: 500,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Hijacker', 8, 8),
        makeMapObject('EnemyVehicle', 10, 8),
        makeMapObject('Attacker', 30, 8),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Issue hijack command.
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'hijackVehicle',
    });
    logic.update(1 / 30);

    // Hijacker should still exist (hidden inside vehicle), not destroyed.
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        objectStatusFlags: Set<string>;
        hijackerState: { isInVehicle: boolean; targetId: number } | null;
        x: number; z: number;
      }>;
    };
    const hijacker = priv.spawnedEntities.get(1);
    expect(hijacker).toBeDefined();
    expect(hijacker!.objectStatusFlags.has('MASKED')).toBe(true);
    expect(hijacker!.objectStatusFlags.has('UNSELECTABLE')).toBe(true);
    expect(hijacker!.objectStatusFlags.has('NO_COLLISIONS')).toBe(true);
    expect(hijacker!.hijackerState).not.toBeNull();
    expect(hijacker!.hijackerState!.isInVehicle).toBe(true);
    expect(hijacker!.hijackerState!.targetId).toBe(2);

    // Vehicle should be captured (now America's).
    expect(logic.getEntityIdsByTemplateAndSide('EnemyVehicle', 'America')).toEqual([2]);

    // Now have the attacker destroy the vehicle.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 2 });
    for (let i = 0; i < 15; i++) logic.update(1 / 30);

    // Vehicle should be destroyed.
    expect(logic.getEntityState(2)).toBeNull();

    // Hijacker should be ejected and active again.
    const ejectedHijacker = priv.spawnedEntities.get(1);
    if (ejectedHijacker) {
      expect(ejectedHijacker.objectStatusFlags.has('MASKED')).toBe(false);
      expect(ejectedHijacker.objectStatusFlags.has('UNSELECTABLE')).toBe(false);
      expect(ejectedHijacker.objectStatusFlags.has('NO_COLLISIONS')).toBe(false);
      expect(ejectedHijacker.hijackerState).toBeNull();
    }
  });

  it('syncs veterancy between hijacker and vehicle', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hijacker', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
          makeBlock('Behavior', 'HijackerUpdate ModuleTag_HijackerUpdate', {}),
        ]),
        makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Hijacker', 8, 8),
        makeMapObject('EnemyVehicle', 10, 8),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Give the vehicle veteran status before hijack.
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        experienceState: { currentLevel: number };
        hijackerState: { isInVehicle: boolean } | null;
      }>;
    };
    priv.spawnedEntities.get(2)!.experienceState.currentLevel = 2;

    // Issue hijack command.
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'hijackVehicle',
    });
    logic.update(1 / 30);

    // Both should now have veterancy level 2 (the higher of the two).
    expect(priv.spawnedEntities.get(1)!.experienceState.currentLevel).toBe(2);
    expect(priv.spawnedEntities.get(2)!.experienceState.currentLevel).toBe(2);

    // Run a few more frames to ensure sync continues.
    for (let i = 0; i < 3; i++) logic.update(1 / 30);
    expect(priv.spawnedEntities.get(1)!.experienceState.currentLevel).toBe(2);
  });

  it('positions hijacker at vehicle location each frame', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hijacker', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
          makeBlock('Behavior', 'HijackerUpdate ModuleTag_HijackerUpdate', {}),
        ]),
        makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Hijacker', 8, 8),
        makeMapObject('EnemyVehicle', 10, 8),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Issue hijack (entities are close enough for immediate resolution).
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'hijackVehicle',
    });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number; hijackerState: { isInVehicle: boolean } | null }>;
    };

    // Verify hijacker is inside vehicle.
    expect(priv.spawnedEntities.get(1)!.hijackerState?.isInVehicle).toBe(true);

    // After another frame, hijacker position should match vehicle position.
    logic.update(1 / 30);
    const hijacker = priv.spawnedEntities.get(1)!;
    const vehicle = priv.spawnedEntities.get(2)!;
    expect(hijacker.x).toBe(vehicle.x);
    expect(hijacker.z).toBe(vehicle.z);
  });

  it('without HijackerUpdate, hijacker is destroyed on hijack (legacy behavior)', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OldHijacker', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'ConvertToHijackedVehicleCrateCollide ModuleTag_Hijack', {}),
          // No HijackerUpdate module!
        ]),
        makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('OldHijacker', 8, 8),
        makeMapObject('EnemyVehicle', 10, 8),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'hijackVehicle',
    });
    logic.update(1 / 30);

    // Hijacker should be destroyed (no HijackerUpdate profile).
    expect(logic.getEntityState(1)).toBeNull();
    // Vehicle should be captured.
    expect(logic.getEntityIdsByTemplateAndSide('EnemyVehicle', 'America')).toEqual([2]);
  });
});

describe('LeafletDropBehavior', () => {
  it('disables enemy infantry and vehicles after delay, but not structures', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('LeafletBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'LeafletDropBehavior ModuleTag_Leaflet', {
            Delay: 200,           // 6 frames
            DisabledDuration: 3000, // 90 frames
            AffectRadius: 200,
          }),
        ]),
        makeObjectDef('EnemySoldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('EnemyBase', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('LeafletBomb', 50, 50),
        makeMapObject('EnemySoldier', 55, 50),
        makeMapObject('EnemyTank', 60, 50),
        makeMapObject('EnemyBase', 45, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };

    // Before delay (6 frames), nothing should be disabled.
    for (let i = 0; i < 4; i++) logic.update(1 / 30);
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);
    expect(priv.spawnedEntities.get(3)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);

    // After delay, infantry and vehicle should be disabled.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);
    expect(priv.spawnedEntities.get(3)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);

    // Structure should NOT be disabled (leaflet only affects infantry+vehicle).
    expect(priv.spawnedEntities.get(4)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);
  });

  it('only affects enemies, not allies', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('LeafletBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'LeafletDropBehavior ModuleTag_Leaflet', {
            Delay: 0,
            DisabledDuration: 3000,
            AffectRadius: 200,
          }),
        ]),
        makeObjectDef('FriendlyTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('LeafletBomb', 50, 50),
        makeMapObject('FriendlyTank', 55, 50),
        makeMapObject('EnemyTank', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Trigger (Delay = 0  fires after first frame check).
    for (let i = 0; i < 3; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    // Friendly vehicle should NOT be disabled.
    expect(priv.spawnedEntities.get(2)!.objectStatusFlags.has('DISABLED_EMP')).toBe(false);
    // Enemy vehicle should be disabled.
    expect(priv.spawnedEntities.get(3)!.objectStatusFlags.has('DISABLED_EMP')).toBe(true);
  });
});

//  SmartBombTargetHomingUpdate 
describe('SmartBombTargetHomingUpdate', () => {
  it('interpolates position toward target while above terrain', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SmartBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'SmartBombTargetHomingUpdate ModuleTag_Smart', {
            CourseCorrectionScalar: 0.5,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SmartBomb', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { x: number; y: number; z: number; baseHeight: number }>;
      resolveGroundHeight(x: number, z: number): number;
    };
    const bomb = priv.spawnedEntities.get(1)!;
    // Entity spawns at world position (50, 50).
    // Raise the bomb significantly above terrain to pass isSignificantlyAboveTerrain.
    const terrainY = priv.resolveGroundHeight(50, 50);
    bomb.y = terrainY + bomb.baseHeight + 50; // 50 units above terrain

    // Set the smart bomb target at world coords (100, 120).
    logic.setSmartBombTarget(1, 100, 120);

    logic.update(1 / 30);

    // With scalar=0.5: new pos = target * 0.5 + current * 0.5
    // x: 100 * 0.5 + 50 * 0.5 = 75
    // z: 120 * 0.5 + 50 * 0.5 = 85
    expect(bomb.x).toBeCloseTo(75, 0);
    expect(bomb.z).toBeCloseTo(85, 0);
  });

  it('does not course-correct when near ground', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SmartBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'SmartBombTargetHomingUpdate ModuleTag_Smart', {
            CourseCorrectionScalar: 0.5,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SmartBomb', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { x: number; y: number; z: number }>;
    };
    const bomb = priv.spawnedEntities.get(1)!;
    const startX = bomb.x;
    const startZ = bomb.z;

    // Set the target but leave the bomb near the ground (default spawn height).
    logic.setSmartBombTarget(1, 100, 120);

    logic.update(1 / 30);

    // Position should be unchanged  not significantly above terrain.
    expect(bomb.x).toBe(startX);
    expect(bomb.z).toBe(startZ);
  });
});

//  DynamicGeometryInfoUpdate 
describe('DynamicGeometryInfoUpdate', () => {
  it('morphs geometry from initial to final over transition time', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Morpher', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'DynamicGeometryInfoUpdate ModuleTag_DynGeom', {
            InitialDelay: 0,
            InitialHeight: 10,
            InitialMajorRadius: 5,
            InitialMinorRadius: 5,
            FinalHeight: 20,
            FinalMajorRadius: 15,
            FinalMinorRadius: 15,
            TransitionTime: 300, // 300ms = 9 frames at 30fps
            ReverseAtTransitionTime: 'No',
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Morpher', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        obstacleGeometry: { height: number; majorRadius: number; minorRadius: number } | null;
        dynamicGeometryState: { finished: boolean; timeActive: number } | null;
      }>;
    };

    // Run enough frames for the transition to complete (delay=1 frame min + 9 transition frames).
    for (let i = 0; i < 15; i++) logic.update(1 / 30);

    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.dynamicGeometryState!.finished).toBe(true);
    // Final geometry should be close to final values.
    expect(entity.obstacleGeometry!.height).toBeCloseTo(20, 0);
    expect(entity.obstacleGeometry!.majorRadius).toBeCloseTo(15, 0);
  });

  it('reverses direction when reverseAtTransitionTime is enabled', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Morpher', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'DynamicGeometryInfoUpdate ModuleTag_DynGeom', {
            InitialDelay: 0,
            InitialHeight: 10,
            InitialMajorRadius: 5,
            InitialMinorRadius: 5,
            FinalHeight: 30,
            FinalMajorRadius: 20,
            FinalMinorRadius: 20,
            TransitionTime: 300, // 9 frames
            ReverseAtTransitionTime: 'Yes',
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Morpher', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        obstacleGeometry: { height: number; majorRadius: number; minorRadius: number } | null;
        dynamicGeometryState: { finished: boolean; timeActive: number; reverseAtTransitionTime: boolean } | null;
      }>;
    };

    // Run past first transition  should reverse.
    for (let i = 0; i < 15; i++) logic.update(1 / 30);

    const entity = priv.spawnedEntities.get(1)!;
    // After first transition completes, it should have reversed (not finished).
    // After the reverse pass completes, it should be finished.
    // Run more frames for the reverse pass.
    for (let i = 0; i < 15; i++) logic.update(1 / 30);

    expect(entity.dynamicGeometryState!.finished).toBe(true);
    // Geometry should be back near initial values.
    expect(entity.obstacleGeometry!.height).toBeCloseTo(10, 0);
    expect(entity.obstacleGeometry!.majorRadius).toBeCloseTo(5, 0);
  });
});

//  FireOCLAfterWeaponCooldownUpdate 
describe('FireOCLAfterWeaponCooldownUpdate', () => {
  it('fires OCL when entity stops attacking after enough shots', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Attacker', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
          makeBlock('Behavior', 'FireOCLAfterWeaponCooldownUpdate ModuleTag_OCL', {
            WeaponSlot: 'PRIMARY',
            OCL: 'OCL_TestEffect',
            MinShotsToCreateOCL: 2,
            OCLLifetimePerSecond: 1000,
            OCLLifetimeMaxCap: 10000,
          }),
        ]),
        makeObjectDef('Target', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 5000, InitialHealth: 5000 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          AttackRange: 220,
          PrimaryDamage: 10,
          PrimaryDamageRadius: 0,
          DelayBetweenShots: 100,
          DamageType: 'ARMOR_PIERCING',
          DeathType: 'NORMAL',
          WeaponSpeed: 999,
          ProjectileNudge: '0 0 0',
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Attacker', 8, 8),
        makeMapObject('Target', 10, 8),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Command attacker to attack target.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2 });

    // Run enough frames for weapon to fire multiple shots.
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        fireOCLAfterCooldownStates: { valid: boolean; consecutiveShots: number }[];
      }>;
    };

    // Verify the tracking state has been initialized and is counting.
    const attacker = priv.spawnedEntities.get(1)!;
    expect(attacker.fireOCLAfterCooldownStates.length).toBe(1);
  });
});

describe('NeutronBlastBehavior', () => {
  it('kills infantry and makes vehicles unmanned on death', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NeutronShell', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'NeutronBlastBehavior ModuleTag_NB', {
            BlastRadius: 200,
            AffectAirborne: 'Yes',
            AffectAllies: 'Yes',
          }),
        ]),
        makeObjectDef('Infantry1', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('Vehicle1', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronShell', 50, 50),
        makeMapObject('Infantry1', 51, 50),
        makeMapObject('Vehicle1', 52, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Run one frame to initialize.
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        destroyed: boolean;
        health: number;
        side: string;
        objectStatusFlags: Set<string>;
      }>;
    };

    const shell = priv.spawnedEntities.get(1)!;
    const infantry = priv.spawnedEntities.get(2)!;
    const vehicle = priv.spawnedEntities.get(3)!;

    // Verify all alive before blast.
    expect(infantry.destroyed).toBe(false);
    expect(vehicle.destroyed).toBe(false);

    // Kill the neutron shell to trigger the blast.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 1 });
    // Apply direct damage to kill the shell.
    const privLogic = logic as unknown as {
      applyWeaponDamageAmount(attackerId: number | null, target: { id: number }, amount: number, damageType: string): void;
      spawnedEntities: Map<number, unknown>;
    };
    // Use a direct kill via unresistable damage.
    const shellEntity = privLogic.spawnedEntities.get(1) as { maxHealth: number; id: number };
    (logic as unknown as { applyWeaponDamageAmount(a: null, t: unknown, amount: number, dt: string): void })
      .applyWeaponDamageAmount(null, shellEntity, 1000, 'UNRESISTABLE');

    // Run a frame to process death.
    logic.update(1 / 30);

    // Infantry should be dead (killed by neutron blast).
    expect(infantry.destroyed).toBe(true);
    // Vehicle should be alive but unmanned.
    expect(vehicle.destroyed).toBe(false);
    expect(vehicle.objectStatusFlags.has('DISABLED_UNMANNED')).toBe(true);
    // Vehicle should be transferred to neutral (empty side).
    expect(vehicle.side).toBe('');
  });

  it('respects AffectAllies=No by sparing allied units', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NeutronShell', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'NeutronBlastBehavior ModuleTag_NB', {
            BlastRadius: 200,
            AffectAllies: 'No',
          }),
        ]),
        makeObjectDef('FriendlyInf', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('EnemyInf', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronShell', 50, 50),
        makeMapObject('FriendlyInf', 51, 50),
        makeMapObject('EnemyInf', 52, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { destroyed: boolean; health: number }>;
    };

    // Capture references BEFORE the kill (finalizeDestroyedEntities removes dead entities from the map).
    const friendly = priv.spawnedEntities.get(2)!;
    const enemy = priv.spawnedEntities.get(3)!;

    // Kill the shell to trigger the blast.
    const shellEntity = priv.spawnedEntities.get(1) as { id: number; maxHealth: number };
    (logic as unknown as { applyWeaponDamageAmount(a: null, t: unknown, amount: number, dt: string): void })
      .applyWeaponDamageAmount(null, shellEntity, 1000, 'UNRESISTABLE');

    logic.update(1 / 30);

    // Allied infantry should be spared.
    expect(friendly.destroyed).toBe(false);

    // Enemy infantry should be killed.
    expect(enemy.destroyed).toBe(true);
  });

  it('kills CLIFF_JUMPER vehicles outright instead of making them unmanned', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NeutronShell', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'NeutronBlastBehavior ModuleTag_NB', {
            BlastRadius: 200,
          }),
        ]),
        makeObjectDef('CombatBike', 'China', ['VEHICLE', 'CLIFF_JUMPER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('NormalVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronShell', 50, 50),
        makeMapObject('CombatBike', 51, 50),
        makeMapObject('NormalVehicle', 52, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        destroyed: boolean;
        objectStatusFlags: Set<string>;
      }>;
    };

    // Capture references BEFORE the kill (entities are removed from map on finalize).
    const bike = priv.spawnedEntities.get(2)!;
    const normal = priv.spawnedEntities.get(3)!;

    // Kill the shell.
    const shellEntity = priv.spawnedEntities.get(1) as { id: number; maxHealth: number };
    (logic as unknown as { applyWeaponDamageAmount(a: null, t: unknown, amount: number, dt: string): void })
      .applyWeaponDamageAmount(null, shellEntity, 1000, 'UNRESISTABLE');

    logic.update(1 / 30);

    // CLIFF_JUMPER should be killed outright.
    expect(bike.destroyed).toBe(true);

    // Normal vehicle should be alive but unmanned.
    expect(normal.destroyed).toBe(false);
    expect(normal.objectStatusFlags.has('DISABLED_UNMANNED')).toBe(true);
  });

  it('kills contained passengers inside vehicles', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NeutronShell', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'NeutronBlastBehavior ModuleTag_NB', {
            BlastRadius: 200,
          }),
        ]),
        makeObjectDef('GarrisonHouse', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_GC', {
            MaxOccupants: 10,
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
        makeObjectDef('Soldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronShell', 50, 50),
        makeMapObject('GarrisonHouse', 51, 50),
        makeMapObject('Soldier', 51, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Put the soldier inside the garrison.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 3, targetBuildingId: 2 });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { destroyed: boolean; garrisonContainerId: number | null }>;
    };

    // Capture references BEFORE the kill.
    const soldier = priv.spawnedEntities.get(3)!;
    const building = priv.spawnedEntities.get(2)!;

    // Verify soldier is garrisoned.
    expect(soldier.garrisonContainerId).toBe(2);

    // Kill the shell.
    const shellEntity = priv.spawnedEntities.get(1) as { id: number; maxHealth: number };
    (logic as unknown as { applyWeaponDamageAmount(a: null, t: unknown, amount: number, dt: string): void })
      .applyWeaponDamageAmount(null, shellEntity, 1000, 'UNRESISTABLE');

    logic.update(1 / 30);

    // Garrisoned soldier should be killed by neutron blast.
    expect(soldier.destroyed).toBe(true);

    // Building itself should survive (not infantry or vehicle).
    expect(building.destroyed).toBe(false);
  });
});

//  processDamageToContained 
describe('processDamageToContained', () => {
  it('applies percentage damage to contained units when container dies', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('DamageTransport', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_TC', {
            ContainMax: 5,
            DamagePercentToUnits: 50, // 50%  0.5 fraction
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 5 }),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('DamageTransport', 50, 50),
        makeMapObject('Passenger', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; maxHealth: number;
        transportContainerId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    // Put passenger inside transport.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    const passenger = priv.spawnedEntities.get(2)!;
    expect(passenger.transportContainerId).toBe(1);

    // Kill the transport.
    const transport = priv.spawnedEntities.get(1)!;
    priv.applyWeaponDamageAmount(null, transport, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Passenger should have taken 50% of maxHealth (200 * 0.5 = 100) as UNRESISTABLE damage.
    // Passenger started at 200 health  should now be at 100.
    expect(transport.destroyed).toBe(true);
    expect(passenger.destroyed).toBe(false);
    expect(passenger.health).toBe(100);
  });

  it('force-kills fireproof units when damagePercent is 100%', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('DeathTransport', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_TC', {
            ContainMax: 5,
            DamagePercentToUnits: 100, // 100%  1.0 fraction
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 5 }),
        makeObjectDef('ToughPassenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('DeathTransport', 50, 50),
        makeMapObject('ToughPassenger', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; maxHealth: number;
        transportContainerId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    // Put passenger inside transport.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    const passenger = priv.spawnedEntities.get(2)!;
    expect(passenger.transportContainerId).toBe(1);

    // Kill the transport.
    const transport = priv.spawnedEntities.get(1)!;
    priv.applyWeaponDamageAmount(null, transport, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // With 100% damage, passenger gets full maxHealth as damage.
    // Even if first damage doesn't kill (due to armor), the force-kill should ensure death.
    expect(transport.destroyed).toBe(true);
    expect(passenger.destroyed).toBe(true);
  });

  it('does not damage contained units when damagePercentToUnits is 0', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SafeTransport', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_TC', {
            ContainMax: 5,
            // No DamagePercentToUnits  defaults to 0
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 5 }),
        makeObjectDef('SafePassenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SafeTransport', 50, 50),
        makeMapObject('SafePassenger', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; maxHealth: number;
        transportContainerId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    // Put passenger inside transport.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    const passenger = priv.spawnedEntities.get(2)!;
    expect(passenger.transportContainerId).toBe(1);

    // Kill the transport.
    const transport = priv.spawnedEntities.get(1)!;
    priv.applyWeaponDamageAmount(null, transport, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // No damage to passenger  default 0%.
    expect(transport.destroyed).toBe(true);
    expect(passenger.destroyed).toBe(false);
    expect(passenger.health).toBe(200);
  });
});

//  BunkerBusterBehavior 
describe('BunkerBusterBehavior', () => {
  it('kills garrisoned units on bomb death with occupant damage weapon', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BunkerBusterBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'BunkerBusterBehavior ModuleTag_BB', {
            OccupantDamageWeaponTemplate: 'BunkerBusterOccupantWeapon',
          }),
        ]),
        makeObjectDef('CivilianBuilding', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_GC', {
            MaxOccupants: 10,
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
        makeObjectDef('Soldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('BunkerBusterOccupantWeapon', {
          DamageType: 'EXPLOSION',
          DeathType: 'EXPLODED',
          PrimaryDamage: 0,
          PrimaryDamageRadius: 0,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BunkerBusterBomb', 50, 50),
        makeMapObject('CivilianBuilding', 60, 50),
        makeMapObject('Soldier', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Garrison the soldier inside the building.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 3, targetBuildingId: 2 });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        destroyed: boolean;
        health: number;
        garrisonContainerId: number | null;
        attackTargetEntityId: number | null;
        bunkerBusterVictimId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    const bomb = priv.spawnedEntities.get(1)!;
    const soldier = priv.spawnedEntities.get(3)!;

    // Verify soldier is garrisoned.
    expect(soldier.garrisonContainerId).toBe(2);

    // Simulate the bomb targeting the building (this is what the AI sets during flight).
    bomb.attackTargetEntityId = 2;
    logic.update(1 / 30);

    // Verify bunker buster captured the victim.
    expect(bomb.bunkerBusterVictimId).toBe(2);

    // Kill the bomb to trigger bunker buster.
    priv.applyWeaponDamageAmount(null, bomb, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Soldier should be dead  occupant damage weapon applied 100 damage (50 HP soldier).
    expect(soldier.destroyed).toBe(true);
  });

  it('kills garrisoned units outright when no occupant weapon is specified', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BunkerBusterBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'BunkerBusterBehavior ModuleTag_BB', {}),
        ]),
        makeObjectDef('CivilianBuilding', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_GC', {
            MaxOccupants: 10,
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
        makeObjectDef('Soldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BunkerBusterBomb', 50, 50),
        makeMapObject('CivilianBuilding', 60, 50),
        makeMapObject('Soldier', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'garrisonBuilding', entityId: 3, targetBuildingId: 2 });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        destroyed: boolean;
        health: number;
        garrisonContainerId: number | null;
        attackTargetEntityId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    const bomb = priv.spawnedEntities.get(1)!;
    const soldier = priv.spawnedEntities.get(3)!;
    expect(soldier.garrisonContainerId).toBe(2);

    // Set attack target and tick to capture victim.
    bomb.attackTargetEntityId = 2;
    logic.update(1 / 30);

    // Kill the bomb.
    priv.applyWeaponDamageAmount(null, bomb, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Soldier should be killed outright (UNRESISTABLE damage = maxHealth).
    expect(soldier.destroyed).toBe(true);
  });

  it('respects upgrade gate  does not bust bunker without required upgrade', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BunkerBusterBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'BunkerBusterBehavior ModuleTag_BB', {
            UpgradeRequired: 'Upgrade_BunkerBuster',
          }),
        ]),
        makeObjectDef('CivilianBuilding', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_GC', {
            MaxOccupants: 10,
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
        makeObjectDef('Soldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      upgrades: [{ name: 'Upgrade_BunkerBuster', fields: {} }],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BunkerBusterBomb', 50, 50),
        makeMapObject('CivilianBuilding', 60, 50),
        makeMapObject('Soldier', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.submitCommand({ type: 'garrisonBuilding', entityId: 3, targetBuildingId: 2 });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        destroyed: boolean;
        health: number;
        garrisonContainerId: number | null;
        attackTargetEntityId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    const bomb = priv.spawnedEntities.get(1)!;
    const soldier = priv.spawnedEntities.get(3)!;
    expect(soldier.garrisonContainerId).toBe(2);

    // Set attack target and tick.
    bomb.attackTargetEntityId = 2;
    logic.update(1 / 30);

    // Kill the bomb WITHOUT having the upgrade.
    priv.applyWeaponDamageAmount(null, bomb, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Soldier should survive  upgrade not present.
    expect(soldier.destroyed).toBe(false);
    expect(soldier.health).toBe(100);
  });

  it('does not affect transport passengers (not bustable)', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BunkerBusterBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'BunkerBusterBehavior ModuleTag_BB', {}),
        ]),
        makeObjectDef('Humvee', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_TC', {
            MaxOccupants: 5,
            PassengersAllowedToFire: 'Yes',
          }),
        ]),
        makeObjectDef('Soldier', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BunkerBusterBomb', 50, 50),
        makeMapObject('Humvee', 60, 50),
        makeMapObject('Soldier', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    // Board the transport.
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 2 });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        destroyed: boolean;
        health: number;
        transportContainerId: number | null;
        attackTargetEntityId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    const bomb = priv.spawnedEntities.get(1)!;
    const soldier = priv.spawnedEntities.get(3)!;
    expect(soldier.transportContainerId).toBe(2);

    // Set attack target and tick.
    bomb.attackTargetEntityId = 2;
    logic.update(1 / 30);

    // Kill the bomb.
    priv.applyWeaponDamageAmount(null, bomb, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Soldier should survive  TransportContain is not bustable.
    expect(soldier.destroyed).toBe(false);
    expect(soldier.health).toBe(100);
  });

  it('fires shockwave weapon at victim position on death', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BunkerBusterBomb', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 10, InitialHealth: 10 }),
          makeBlock('Behavior', 'BunkerBusterBehavior ModuleTag_BB', {
            ShockwaveWeaponTemplate: 'BunkerBusterShockwave',
          }),
        ]),
        makeObjectDef('CivilianBuilding', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_GC', {
            MaxOccupants: 10,
          }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10, GeometryHeight: 10 }),
        makeObjectDef('NearbyTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('BunkerBusterShockwave', {
          PrimaryDamage: 200,
          PrimaryDamageRadius: 50,
          DamageType: 'EXPLOSION',
          DeathType: 'EXPLODED',
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BunkerBusterBomb', 50, 50),
        makeMapObject('CivilianBuilding', 60, 50),
        makeMapObject('NearbyTank', 62, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        destroyed: boolean;
        health: number;
        attackTargetEntityId: number | null;
      }>;
      applyWeaponDamageAmount(a: number | null, t: unknown, amount: number, dt: string): void;
    };

    const bomb = priv.spawnedEntities.get(1)!;
    const tank = priv.spawnedEntities.get(3)!;
    const initialTankHealth = tank.health;

    // Set attack target and tick.
    bomb.attackTargetEntityId = 2;
    logic.update(1 / 30);

    // Kill the bomb.
    priv.applyWeaponDamageAmount(null, bomb, 1000, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Nearby tank should have taken shockwave damage.
    expect(tank.health).toBeLessThan(initialTankHealth);
  });
});

//  GrantStealthBehavior 
describe('GrantStealthBehavior', () => {
  it('grants stealth to allied units within expanding radius and self-destructs', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GPSScrambler', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'GrantStealthBehavior ModuleTag_GS', {
            StartRadius: 0,
            FinalRadius: 30,
            RadiusGrowRate: 15,
          }),
        ]),
        makeObjectDef('FriendlyTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', { InnateStealth: 'No' }),
        ]),
        makeObjectDef('EnemyTank', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', { InnateStealth: 'No' }),
        ]),
      ],
    });
    // Map: place scrambler at (50,50), friend at (70,50) = dist 20, enemy at (60,50) = dist 10.
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GPSScrambler', 50, 50),
        makeMapObject('FriendlyTank', 70, 50),
        makeMapObject('EnemyTank', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; objectStatusFlags: Set<string>;
        grantStealthCurrentRadius: number;
      }>;
    };

    // Init frame.
    logic.update(1 / 30);

    const friend = priv.spawnedEntities.get(2)!;
    const enemy = priv.spawnedEntities.get(3)!;

    // Before second update: friend should NOT yet have stealth (radius was 15 after first frame, friend at dist 20).
    expect(friend.objectStatusFlags.has('CAN_STEALTH')).toBe(false);

    // Frame 2: radius grows from 15 to 30 (final). Friend at 20 is within range.
    logic.update(1 / 30);
    expect(friend.objectStatusFlags.has('CAN_STEALTH')).toBe(true);
    expect(friend.objectStatusFlags.has('STEALTHED')).toBe(true);

    // Enemy should NOT get stealth (not allied).
    expect(enemy.objectStatusFlags.has('CAN_STEALTH')).toBe(false);

    // Scrambler should self-destruct after reaching final radius.
    const scrambler = priv.spawnedEntities.get(1);
    expect(scrambler === undefined || scrambler.destroyed === true).toBe(true);
  });

  it('filters by KindOf when specified', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GPSScrambler', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'GrantStealthBehavior ModuleTag_GS', {
            StartRadius: 100,
            FinalRadius: 100,
            RadiusGrowRate: 100,
            KindOf: 'INFANTRY',
          }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', { InnateStealth: 'No' }),
        ]),
        makeObjectDef('Crusader', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', { InnateStealth: 'No' }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GPSScrambler', 50, 50),
        makeMapObject('Ranger', 55, 50),
        makeMapObject('Crusader', 55, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; objectStatusFlags: Set<string>;
      }>;
    };

    logic.update(1 / 30);

    const ranger = priv.spawnedEntities.get(2)!;
    const crusader = priv.spawnedEntities.get(3)!;

    // Infantry matches KindOf filter  should get stealth.
    expect(ranger.objectStatusFlags.has('CAN_STEALTH')).toBe(true);
    // Vehicle does not match  should NOT get stealth.
    expect(crusader.objectStatusFlags.has('CAN_STEALTH')).toBe(false);
  });

  it('grants stealth incrementally as radius grows', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GPSScrambler', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'GrantStealthBehavior ModuleTag_GS', {
            StartRadius: 0,
            FinalRadius: 100,
            RadiusGrowRate: 10,
          }),
        ]),
        makeObjectDef('CloseUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', { InnateStealth: 'No' }),
        ]),
        makeObjectDef('FarUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', { InnateStealth: 'No' }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GPSScrambler', 50, 50),
        makeMapObject('CloseUnit', 55, 50),   // Distance 5  within radius early.
        makeMapObject('FarUnit', 100, 50),     // Distance 50  within radius later.
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; objectStatusFlags: Set<string>;
      }>;
    };

    // After 1 frame: radius = 10, close unit at 5 is in range, far at 50 is not.
    logic.update(1 / 30);
    const close = priv.spawnedEntities.get(2)!;
    const far = priv.spawnedEntities.get(3)!;
    expect(close.objectStatusFlags.has('CAN_STEALTH')).toBe(true);
    expect(far.objectStatusFlags.has('CAN_STEALTH')).toBe(false);

    // After 5 more frames (radius = 60), far unit at 50 is now in range.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    expect(far.objectStatusFlags.has('CAN_STEALTH')).toBe(true);
  });
});

// 
// NeutronMissileSlowDeathUpdate
// 
describe('NeutronMissileSlowDeathUpdate', () => {
  function makeNeutronMissileBundle(blastFields: Record<string, unknown> = {}) {
    return makeBundle({
      objects: [
        makeObjectDef('NeutronMissile', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'NeutronMissileSlowDeathBehavior ModuleTag_NM', {
            DestructionDelay: 3000, // 90 frames  missile persists this long
            SinkRate: 0,
            ProbabilityModifier: 10,
            Blast1Enabled: 'Yes',
            Blast1Delay: 0, // 0ms = fires immediately on activation
            Blast1ScorchDelay: 0,
            Blast1InnerRadius: 20,
            Blast1OuterRadius: 100,
            Blast1MaxDamage: 200,
            Blast1MinDamage: 50,
            Blast1ToppleSpeed: 0.3,
            Blast2Enabled: 'Yes',
            Blast2Delay: 300, // 300ms = 9 frames after activation
            Blast2ScorchDelay: 300,
            Blast2InnerRadius: 50,
            Blast2OuterRadius: 200,
            Blast2MaxDamage: 150,
            Blast2MinDamage: 30,
            Blast2ToppleSpeed: 0,
            ...blastFields,
          }),
        ]),
        makeObjectDef('Target', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
        makeObjectDef('FarTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
        makeObjectDef('Tree', 'Neutral', ['SHRUBBERY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
        makeObjectDef('Killer', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'NukeKill'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('NukeKill', {
          AttackRange: 300,
          PrimaryDamage: 9999,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
        }),
      ],
    });
  }

  it('fires sequential blast waves with radius damage after slow death activation', () => {
    const bundle = makeNeutronMissileBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronMissile', 50, 50),
        makeMapObject('Target', 65, 50), // 15 units away  inside inner radius of blast 1
        makeMapObject('Killer', 100, 100),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; maxHealth: number;
        slowDeathState: unknown; neutronMissileSlowDeathState: unknown;
        slowDeathProfiles: unknown[];
      }>;
    };

    // Kill the missile to trigger slow death.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });

    // Advance enough frames for the attacker to fire and kill the missile.
    let enteredSlowDeath = false;
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      const missile = priv.spawnedEntities.get(1);
      if (missile && missile.slowDeathState) {
        enteredSlowDeath = true;
        break;
      }
    }
    expect(enteredSlowDeath).toBe(true);

    const missile = priv.spawnedEntities.get(1)!;
    expect(missile.neutronMissileSlowDeathState).not.toBeNull();

    // Capture target reference and health.
    const target = priv.spawnedEntities.get(2)!;
    const healthBefore = target.health;

    // Advance frames until blast 1 fires.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    const healthAfterBlast1 = target.health;
    expect(healthAfterBlast1).toBeLessThan(healthBefore);
    // Target at 15 units is inside innerRadius=20, so takes full maxDamage=200.
    expect(healthBefore - healthAfterBlast1).toBe(200);
  });

  it('applies damage falloff based on inner/outer radius', () => {
    const bundle = makeNeutronMissileBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronMissile', 50, 50),
        makeMapObject('Target', 110, 50), // 60 units away  between inner (20) and outer (100)
        makeMapObject('Killer', 200, 200),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
        slowDeathState: unknown;
      }>;
    };

    // Kill missile  loop until slow death activates.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (priv.spawnedEntities.get(1)?.slowDeathState) break;
    }
    expect(priv.spawnedEntities.get(1)!.slowDeathState).not.toBeNull();

    const target = priv.spawnedEntities.get(2)!;
    const healthBefore = target.health;
    // Advance until blast 1 fires.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    const damage = healthBefore - target.health;
    // Distance 60, innerRadius=20, outerRadius=100: percent = 1 - (40/80.01)  0.5
    // damage = 200 * 0.5 = 100, clamped above minDamage=50.
    expect(damage).toBeGreaterThan(50);
    expect(damage).toBeLessThan(200);
  });

  it('fires second blast wave after configured delay', () => {
    const bundle = makeNeutronMissileBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronMissile', 50, 50),
        makeMapObject('Target', 80, 50), // 30 units away  inside blast2 innerRadius=50
        makeMapObject('Killer', 200, 200),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
        slowDeathState: unknown; neutronMissileSlowDeathState: { activationFrame: number } | null;
      }>;
    };

    // Kill missile  loop until slow death activates.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    let activationFrameCount = 0;
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      activationFrameCount++;
      if (priv.spawnedEntities.get(1)?.slowDeathState) break;
    }
    expect(priv.spawnedEntities.get(1)!.slowDeathState).not.toBeNull();

    const target = priv.spawnedEntities.get(2)!;
    // Wait for blast 1 to fire (needs 2 frames after activation: set frame + elapsed > 0).
    for (let i = 0; i < 3; i++) logic.update(1 / 30);
    const healthAfterBlast1 = target.health;
    expect(healthAfterBlast1).toBeLessThan(500); // Blast 1 should have fired.

    // Now wait for blast 2 delay = 300ms = 9 frames from activation.
    // We need the elapsed count from activationFrame to exceed 9.
    // Advance frames carefully: we already ran 3 frames after slow death.
    // Blast 2 fires when elapsed > 9.
    // Run 7 more frames to reach elapsed ~10 or so.
    for (let i = 0; i < 7; i++) logic.update(1 / 30);
    const healthBeforeLastFrame = target.health;

    // By now blast 2 should have fired (elapsed = 10+ > 9).
    // Check that blast 2 dealt additional damage.
    expect(target.health).toBeLessThan(healthAfterBlast1);
  });

  it('scorch blast sets BURNED status on entities in range', () => {
    // Use a high-HP target so blast damage doesn't kill it before we can check scorch.
    const bundle = makeNeutronMissileBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutronMissile', 50, 50),
        makeMapObject('Target', 70, 50), // 20 units away  inside outerRadius, has 500 HP
        makeMapObject('Killer', 200, 200),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('GLA', 'America', 0);
    logic.setTeamRelationship('America', 'GLA', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; objectStatusFlags: Set<string>;
        slowDeathState: unknown;
      }>;
    };

    // Kill missile  loop until slow death activates.
    logic.submitCommand({ type: 'attackEntity', entityId: 3, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (priv.spawnedEntities.get(1)?.slowDeathState) break;
    }
    expect(priv.spawnedEntities.get(1)!.slowDeathState).not.toBeNull();

    const target = priv.spawnedEntities.get(2)!;
    // Advance until scorch blast fires (scorchDelay=0, fires after activation frame).
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    expect(target.objectStatusFlags.has('BURNED')).toBe(true);
  });
});

// 
// TechBuildingBehavior  neutral buildings that revert on death
// 
describe('TechBuildingBehavior', () => {
  it('reverts to civilian side on death instead of being destroyed', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OilDerrick', 'civilian', ['STRUCTURE', 'TECH_BUILDING'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Behavior', 'TechBuildingBehavior ModuleTag_TB', {
            PulseFXRate: 0,
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0, AttackRange: 50,
          DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL',
          DelayBetweenShots: 500, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('OilDerrick', 50, 50),
        makeMapObject('Attacker', 80, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    // Capture the oil derrick for America first.
    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'America' });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; side: string; health: number; maxHealth: number;
        techBuildingProfile: unknown;
      }>;
    };

    const derrick = priv.spawnedEntities.get(1)!;
    expect(derrick.side).toBe('america');
    expect(derrick.techBuildingProfile).not.toBeNull();

    // Kill the derrick with GLA attacker.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Derrick should NOT be destroyed  it should have reverted to civilian.
    expect(derrick.destroyed).toBe(false);
    expect(derrick.side).toBe('civilian');
    expect(derrick.health).toBe(derrick.maxHealth);
  });

  it('can be recaptured after death revert', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hospital', 'civilian', ['STRUCTURE', 'TECH_BUILDING'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
          makeBlock('Behavior', 'TechBuildingBehavior ModuleTag_TB', {
            PulseFXRate: 0,
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0, AttackRange: 50,
          DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL',
          DelayBetweenShots: 500, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Hospital', 50, 50),
        makeMapObject('Attacker', 80, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; side: string; health: number; maxHealth: number;
      }>;
    };

    // Capture for China.
    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'China' });
    logic.update(1 / 30);
    expect(priv.spawnedEntities.get(1)!.side).toBe('china');

    // Kill it with GLA attacker.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);
    expect(priv.spawnedEntities.get(1)!.side).toBe('civilian');
    expect(priv.spawnedEntities.get(1)!.destroyed).toBe(false);

    // Recapture for China again.
    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'China' });
    logic.update(1 / 30);
    expect(priv.spawnedEntities.get(1)!.side).toBe('china');
    expect(priv.spawnedEntities.get(1)!.destroyed).toBe(false);
    expect(priv.spawnedEntities.get(1)!.health).toBe(priv.spawnedEntities.get(1)!.maxHealth);
  });

  it('starts as civilian and is capturable from initial state', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OilRefinery', 'civilian', ['STRUCTURE', 'TECH_BUILDING'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Behavior', 'TechBuildingBehavior ModuleTag_TB', {
            PulseFXRate: 0,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('OilRefinery', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; side: string; health: number; destroyed: boolean;
        techBuildingProfile: unknown;
      }>;
    };

    logic.update(1 / 30);
    const building = priv.spawnedEntities.get(1)!;
    expect(building.side).toBe('civilian');
    expect(building.techBuildingProfile).not.toBeNull();

    // Capture for America.
    logic.submitCommand({ type: 'captureEntity', entityId: 1, newSide: 'America' });
    logic.update(1 / 30);
    expect(building.side).toBe('america');
    expect(building.health).toBe(300);
  });
});

// 
// FireWeaponWhenDeadBehavior  fire weapon on death with upgrade control
// 
describe('FireWeaponWhenDeadBehavior', () => {
  it('fires death weapon on entity destruction (StartsActive=Yes)', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Bomber', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'FireWeaponWhenDeadBehavior ModuleTag_FWWD', {
            StartsActive: 'Yes',
            DeathWeapon: 'DeathBlast',
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
        makeObjectDef('Bystander', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0, AttackRange: 50,
          DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL',
          DelayBetweenShots: 500, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
        makeWeaponDef('DeathBlast', {
          PrimaryDamage: 40, PrimaryDamageRadius: 30, AttackRange: 30,
          DamageType: 'EXPLOSION', DeathType: 'NORMAL',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Bomber', 50, 50),
        makeMapObject('Attacker', 80, 50),
        makeMapObject('Bystander', 60, 50),  // Within DeathBlast radius (30) of Bomber.
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; maxHealth: number;
      }>;
    };

    const bystander = priv.spawnedEntities.get(3)!;
    expect(bystander.health).toBe(100);

    // Kill the Bomber  should fire DeathBlast hitting the Bystander.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // Bomber should be destroyed (removed from entities).
    expect(logic.getEntityState(1)).toBeNull();
    // Bystander should have taken damage from the death blast.
    expect(bystander.health).toBeLessThan(100);
  });

  it('does not fire when StartsActive=No and no upgrade applied', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'FireWeaponWhenDeadBehavior ModuleTag_FWWD', {
            StartsActive: 'No',
            TriggeredBy: 'Upgrade_SelfDestruct',
            DeathWeapon: 'DeathBlast',
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
        makeObjectDef('Bystander', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0, AttackRange: 50,
          DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL',
          DelayBetweenShots: 500, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
        makeWeaponDef('DeathBlast', {
          PrimaryDamage: 40, PrimaryDamageRadius: 30, AttackRange: 30,
          DamageType: 'EXPLOSION', DeathType: 'NORMAL',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 50, 50),
        makeMapObject('Attacker', 80, 50),
        makeMapObject('Bystander', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
      }>;
    };

    const bystander = priv.spawnedEntities.get(3)!;

    // Kill Tank without upgrade  no death weapon should fire.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)).toBeNull();
    // Bystander should be unharmed (no death blast).
    expect(bystander.health).toBe(100);
  });

  it('fires when StartsActive=No but upgrade has been applied', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'FireWeaponWhenDeadBehavior ModuleTag_FWWD', {
            StartsActive: 'No',
            TriggeredBy: 'Upgrade_SelfDestruct',
            DeathWeapon: 'DeathBlast',
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
        makeObjectDef('Bystander', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0, AttackRange: 50,
          DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL',
          DelayBetweenShots: 500, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
        makeWeaponDef('DeathBlast', {
          PrimaryDamage: 40, PrimaryDamageRadius: 30, AttackRange: 30,
          DamageType: 'EXPLOSION', DeathType: 'NORMAL',
        }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_SelfDestruct', {}),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 50, 50),
        makeMapObject('Attacker', 80, 50),
        makeMapObject('Bystander', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    // Apply the upgrade to activate the behavior.
    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_SelfDestruct' });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
      }>;
    };

    const bystander = priv.spawnedEntities.get(3)!;

    // Kill Tank with upgrade  death weapon should fire.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)).toBeNull();
    // Bystander should be damaged by death blast.
    expect(bystander.health).toBeLessThan(100);
  });

  it('respects DieMuxData DeathTypes filter', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Truck', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
          makeBlock('Behavior', 'FireWeaponWhenDeadBehavior ModuleTag_FWWD', {
            StartsActive: 'Yes',
            DeathWeapon: 'DeathBlast',
            DeathTypes: 'LASERED',  // Only fires on LASERED death, not NORMAL.
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TestGun'] }),
        ]),
        makeObjectDef('Bystander', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TestGun', {
          PrimaryDamage: 500, PrimaryDamageRadius: 0, AttackRange: 50,
          DamageType: 'ARMOR_PIERCING', DeathType: 'NORMAL',
          DelayBetweenShots: 500, ClipSize: 1, AutoReloadsClip: 'Yes',
        }),
        makeWeaponDef('DeathBlast', {
          PrimaryDamage: 40, PrimaryDamageRadius: 30, AttackRange: 30,
          DamageType: 'EXPLOSION', DeathType: 'NORMAL',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Truck', 50, 50),
        makeMapObject('Attacker', 80, 50),
        makeMapObject('Bystander', 60, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
      }>;
    };

    const bystander = priv.spawnedEntities.get(3)!;

    // Kill with NORMAL death type  DeathTypes filter is LASERED, so no blast.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    expect(logic.getEntityState(1)).toBeNull();
    // Bystander should be unharmed (death type mismatch).
    expect(bystander.health).toBe(100);
  });
});

//  JetAIUpdate  aircraft flight state machine tests 

describe('JetAIUpdate flight state machine', () => {
  function makeJetBundle(jetAIFields: Record<string, unknown> = {}) {
    return makeBundle({
      objects: [
        makeObjectDef('TestJet', 'America', ['AIRCRAFT', 'VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'JetGun'] }),
          makeBlock('LocomotorSet', 'SET_NORMAL JetLoco', {}),
          makeBlock('Behavior', 'JetAIUpdate ModuleTag_JetAI', {
            SneakyOffsetWhenAttacking: 0,
            AttackersMissPersistTime: 0,
            MinHeight: 80,
            OutOfAmmoDamagePerSecond: 10,
            ReturnToBaseIdleTime: 5000,
            NeedsRunway: true,
            TakeoffPause: 0,
            TakeoffDistForMaxLift: 0,
            ...jetAIFields,
          }),
        ]),
        makeObjectDef('TestAirfield', 'America', ['STRUCTURE', 'FS_AIRFIELD'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Prod', {}),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_QExit', {}),
        ]),
        makeObjectDef('EnemyTank', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('JetGun', {
          AttackRange: 300,
          PrimaryDamage: 20,
          PrimaryDamageRadius: 0,
          SecondaryDamage: 0,
          SecondaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 500,
          ClipSize: 4,
          ClipReloadTime: 3000,
        }),
      ],
      locomotors: [
        makeLocomotorDef('JetLoco', 300),
      ],
    });
  }

  it('parses all JetAIProfile fields from INI', () => {
    const bundle = makeJetBundle({
      MinHeight: 120,
      OutOfAmmoDamagePerSecond: 25,
      ReturnToBaseIdleTime: 8000,
      NeedsRunway: false,
      KeepsParkingSpaceWhenAirborne: false,
      ParkingOffset: 15,
      TakeoffPause: 500,
      TakeoffDistForMaxLift: 0.5,
      AttackLocomotorType: 'SET_NORMAL',
      AttackLocomotorPersistTime: 2000,
      ReturnForAmmoLocomotorType: 'SET_NORMAL',
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestJet', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    expect(jet.jetAIProfile).not.toBeNull();
    expect(jet.jetAIProfile.minHeight).toBe(120);
    expect(jet.jetAIProfile.outOfAmmoDamagePerSecond).toBeCloseTo(0.25);
    expect(jet.jetAIProfile.needsRunway).toBe(false);
    expect(jet.jetAIProfile.keepsParkingSpaceWhenAirborne).toBe(false);
    expect(jet.jetAIProfile.parkingOffset).toBe(15);
    expect(jet.jetAIProfile.attackLocomotorSet).toBe('SET_NORMAL');
    expect(jet.jetAIProfile.returnLocomotorSet).toBe('SET_NORMAL');
    expect(jet.jetAIState).not.toBeNull();
    expect(jet.jetAIState.cruiseHeight).toBe(120);
  });

  it('map-placed aircraft start AIRBORNE with AIRBORNE_TARGET status', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestJet', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    expect(jet.jetAIState.state).toBe('AIRBORNE');
    expect(jet.jetAIState.allowAirLoco).toBe(true);
    expect(jet.objectStatusFlags.has('AIRBORNE_TARGET')).toBe(true);
  });

  it('transitions PARKED  TAKING_OFF  AIRBORNE on move command', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 50, 50),
        makeMapObject('TestAirfield', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    const airfield = priv.spawnedEntities.get(2)!;

    // Manually set to PARKED (simulating a produced aircraft).
    jet.jetAIState.state = 'PARKED';
    jet.jetAIState.allowAirLoco = false;
    jet.jetAIState.producerX = airfield.x;
    jet.jetAIState.producerZ = airfield.z;
    jet.producerEntityId = airfield.id;
    jet.objectStatusFlags.delete('AIRBORNE_TARGET');

    // Issue move command  should store as pending and trigger takeoff.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 100, targetZ: 100 });
    logic.update(1 / 30);

    expect(jet.jetAIState.state).toBe('TAKING_OFF');
    expect(jet.objectStatusFlags.has('AIRBORNE_TARGET')).toBe(true);
    // Pending command is kept until AIRBORNE entry clears it.
    expect(jet.jetAIState.pendingCommand).toEqual({ type: 'moveTo', x: 100, z: 100 });

    // Run through takeoff (30 frames).
    for (let i = 0; i < 35; i++) logic.update(1 / 30);

    expect(jet.jetAIState.state).toBe('AIRBORNE');
    expect(jet.jetAIState.allowAirLoco).toBe(true);
    expect(jet.jetAIState.pendingCommand).toBeNull(); // cleared on AIRBORNE entry
    expect(jet.moving).toBe(true);
  });

  it('returns to base when out of ammo', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 30, 30),
        makeMapObject('TestAirfield', 90, 90),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    const airfield = priv.spawnedEntities.get(2)!;

    // Start airborne with producer set.
    jet.jetAIState.producerX = airfield.x;
    jet.jetAIState.producerZ = airfield.z;
    jet.producerEntityId = airfield.id;

    // Deplete ammo.
    jet.attackAmmoInClip = 0;

    logic.update(1 / 30);

    expect(jet.jetAIState.state).toBe('RETURNING_FOR_LANDING');
    expect(jet.moving).toBe(true);
  });

  it('lands, reloads ammo, then parks after returning to airfield', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 50, 50),
        makeMapObject('TestAirfield', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    const airfield = priv.spawnedEntities.get(2)!;

    jet.jetAIState.producerX = airfield.x;
    jet.jetAIState.producerZ = airfield.z;
    jet.producerEntityId = airfield.id;

    // Set to RETURNING close to the airfield.
    jet.jetAIState.state = 'RETURNING_FOR_LANDING';
    jet.jetAIState.stateEnteredFrame = priv.frameCounter;
    jet.x = airfield.x + 5; // within NEAR_AIRFIELD_DIST_SQ (400 = 20^2)
    jet.z = airfield.z + 5;
    jet.attackAmmoInClip = 0;

    logic.update(1 / 30);

    // Should transition to LANDING since within 20 units.
    expect(jet.jetAIState.state).toBe('LANDING');

    // Run through landing (30 frames).
    for (let i = 0; i < 35; i++) logic.update(1 / 30);

    // Should be reloading now.
    expect(jet.jetAIState.state).toBe('RELOAD_AMMO');
    expect(jet.objectStatusFlags.has('AIRBORNE_TARGET')).toBe(false);

    // Run reload frames (clipReloadTime = 3000ms = 90 frames, proportional for full clip).
    for (let i = 0; i < 100; i++) logic.update(1 / 30);

    // Should be PARKED with full ammo.
    expect(jet.jetAIState.state).toBe('PARKED');
    expect(jet.attackAmmoInClip).toBe(4); // clipSize
  });

  it('enters CIRCLING_DEAD_AIRFIELD when producer destroyed while returning', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 50, 50),
        makeMapObject('TestAirfield', 80, 80),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    const airfield = priv.spawnedEntities.get(2)!;

    jet.jetAIState.producerX = airfield.x;
    jet.jetAIState.producerZ = airfield.z;
    jet.producerEntityId = airfield.id;

    // Set to RETURNING.
    jet.jetAIState.state = 'RETURNING_FOR_LANDING';
    jet.jetAIState.stateEnteredFrame = priv.frameCounter;

    // Destroy the airfield.
    airfield.destroyed = true;

    logic.update(1 / 30);

    // No other airfield exists, should circle.
    expect(jet.jetAIState.state).toBe('CIRCLING_DEAD_AIRFIELD');
  });

  it('applies out-of-ammo damage while circling dead airfield', () => {
    const bundle = makeJetBundle({ OutOfAmmoDamagePerSecond: 50 }); // 50% per 100 / sec  0.5
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestJet', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;

    // Manually set to CIRCLING state.
    jet.jetAIState.state = 'CIRCLING_DEAD_AIRFIELD';
    jet.jetAIState.stateEnteredFrame = priv.frameCounter;
    jet.jetAIState.circlingNextCheckFrame = priv.frameCounter + 30;
    jet.producerEntityId = 0; // no producer

    const healthBefore = jet.health;

    for (let i = 0; i < 30; i++) logic.update(1 / 30);

    // OutOfAmmoDamagePerSecond = 50  0.5 (per second ratio of max health).
    // 30 frames = 1 second. Expected damage = maxHealth * 0.5 * 1 = 100.
    expect(jet.health).toBeLessThan(healthBefore);
    expect(jet.health).toBeCloseTo(healthBefore - 100, 0);
  });

  it('returns to base after idle timer expires', () => {
    const bundle = makeJetBundle({ ReturnToBaseIdleTime: 1000 }); // 30 frames
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 30, 30),
        makeMapObject('TestAirfield', 90, 90),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    const airfield = priv.spawnedEntities.get(2)!;
    jet.jetAIState.producerX = airfield.x;
    jet.jetAIState.producerZ = airfield.z;
    jet.producerEntityId = airfield.id;

    // Set idle timer to expire shortly.
    jet.jetAIState.returnToBaseFrame = priv.frameCounter + 5;
    jet.moving = false;
    jet.attackTargetEntityId = null;

    // Run for 10 frames  idle timer should expire and trigger return.
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    // Should be returning to base (or already landing if very close).
    expect(['RETURNING_FOR_LANDING', 'LANDING']).toContain(jet.jetAIState.state);
  });

  it('airborne aircraft use direct-path movement (skip pathfinding)', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestJet', 20, 20)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;

    // Issue move command to airborne jet.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 100, targetZ: 100 });
    logic.update(1 / 30);

    expect(jet.moving).toBe(true);
    expect(jet.movePath.length).toBe(1);
    expect(jet.movePath[0]).toEqual({ x: 100, z: 100 });
  });

  it('airborne aircraft maintain cruise altitude above terrain', () => {
    const bundle = makeJetBundle({ MinHeight: 80 });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestJet', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;

    // Give it a destination so movement update runs.
    logic.submitCommand({ type: 'moveTo', entityId: 1, targetX: 80, targetZ: 80 });
    logic.update(1 / 30);

    // Y should be approximately terrainHeight + baseHeight + cruiseHeight.
    // Terrain is flat at 0, baseHeight is nominalHeight/2 for air category.
    expect(jet.y).toBeGreaterThan(50);
  });

  it('AIRBORNE_TARGET enables anti-air weapon targeting', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('TestJet', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const state = logic.getEntityState(1);
    expect(state?.statusFlags).toContain('AIRBORNE_TARGET');
  });

  it('airborne aircraft excluded from ground collision separation', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 50, 50),
        makeMapObject('TestJet', 50, 50),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as any;
    const jet1 = priv.spawnedEntities.get(1)!;
    const jet2 = priv.spawnedEntities.get(2)!;

    const x1Before = jet1.x;
    const x2Before = jet2.x;

    // Run a few frames  collision separation should not push them apart.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Airborne aircraft should not be separated (AIRBORNE_TARGET exclusion).
    expect(jet1.x).toBeCloseTo(x1Before, 1);
    expect(jet2.x).toBeCloseTo(x2Before, 1);
  });

  it('commands while PARKED queue as pending and trigger takeoff', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TestJet', 50, 50),
        makeMapObject('TestAirfield', 50, 50),
        makeMapObject('EnemyTank', 100, 100),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    const priv = logic as any;
    const jet = priv.spawnedEntities.get(1)!;
    const airfield = priv.spawnedEntities.get(2)!;

    // Set to PARKED state.
    jet.jetAIState.state = 'PARKED';
    jet.jetAIState.allowAirLoco = false;
    jet.jetAIState.producerX = airfield.x;
    jet.jetAIState.producerZ = airfield.z;
    jet.producerEntityId = airfield.id;
    jet.objectStatusFlags.delete('AIRBORNE_TARGET');

    // Issue attack command  queued until next update.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3 });

    // After update: command is intercepted (stored as pending), then updateJetAI transitions to TAKING_OFF.
    logic.update(1 / 30);
    expect(jet.jetAIState.state).toBe('TAKING_OFF');
    // Pending command is kept until AIRBORNE entry.
    expect(jet.jetAIState.pendingCommand).toEqual({ type: 'attackEntity', targetId: 3 });
  });
});

describe('HelicopterSlowDeathBehavior', () => {
  function makeHeliBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('Helicopter', 'America', ['VEHICLE', 'AIRCRAFT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SD', {
            DeathTypes: 'ALL',
            DestructionDelay: 3000,
            SinkRate: 0,
            ProbabilityModifier: 100,
          }),
          makeBlock('Behavior', 'HelicopterSlowDeathBehavior ModuleTag_HSD', {
            DeathTypes: 'ALL',
            DestructionDelay: 3000,
            SinkRate: 0,
            ProbabilityModifier: 1,
            SpiralOrbitTurnRate: 180,          // 180 deg/s
            SpiralOrbitForwardSpeed: 60,       // 60 units/s  2 units/frame
            SpiralOrbitForwardSpeedDamping: 0.98,
            MinSelfSpin: 90,                   // 90 deg/s  ~0.052 rad/frame
            MaxSelfSpin: 360,                  // 360 deg/s  ~0.209 rad/frame
            SelfSpinUpdateDelay: 200,          // 200ms  6 frames
            SelfSpinUpdateAmount: 30,          // 30 degrees  ~0.524 rad
            FallHowFast: 50,                   // 50% gravity
            DelayFromGroundToFinalDeath: 500,  // 500ms  15 frames
          }),
        ]),
        makeObjectDef('Killer', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('BigGun', {
          AttackRange: 300,
          PrimaryDamage: 9999,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
          AntiAirborneVehicle: true,
        }),
      ],
    });
  }

  it('extracts helicopter slow death profiles from INI', () => {
    const bundle = makeHeliBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Helicopter', 128, 128),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        helicopterSlowDeathProfiles: { spiralOrbitTurnRate: number; deathTypes: Set<string> }[];
        slowDeathProfiles: { deathTypes: Set<string>; probabilityModifier: number }[];
      }>;
    };

    const heli = [...priv.spawnedEntities.values()][0]!;
    // Verify helicopter slow death profiles were extracted.
    expect(heli.helicopterSlowDeathProfiles.length).toBe(1);
    expect(heli.helicopterSlowDeathProfiles[0]!.spiralOrbitTurnRate).toBeGreaterThan(0);
    // Verify slow death profiles also include helicopter (since it extends SlowDeathBehavior).
    expect(heli.slowDeathProfiles.length).toBeGreaterThanOrEqual(1);
  });

  it('initializes helicopter spiral death state when killed', () => {
    const bundle = makeHeliBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Helicopter', 10, 10),
        makeMapObject('Killer', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number;
        helicopterSlowDeathState: { forwardAngle: number; forwardSpeed: number; hitGroundFrame: number; profileIndex: number } | null;
        helicopterSlowDeathProfiles: unknown[];
        slowDeathState: unknown;
      }>;
    };

    const heli = [...priv.spawnedEntities.values()].find(e => e.helicopterSlowDeathProfiles.length > 0)!;
    expect(heli).toBeDefined();
    // Elevate helicopter so it can spiral down.
    heli.y = 100;

    // Kill the helicopter  give enough frames for combat to execute.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (heli.health <= 0) break;
    }

    // After lethal damage, helicopter should have slow death state initialized.
    expect(heli.health).toBeLessThanOrEqual(0);
    expect(heli.destroyed).toBe(false);
    expect(heli.slowDeathState).not.toBeNull();
    expect(heli.helicopterSlowDeathState).not.toBeNull();
    expect(heli.helicopterSlowDeathState!.profileIndex).toBe(0);
    expect(heli.helicopterSlowDeathState!.hitGroundFrame).toBe(0);
  });

  it('spirals and descends per frame while airborne', () => {
    const bundle = makeHeliBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Helicopter', 10, 10),
        makeMapObject('Killer', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number; x: number; z: number; heading: number;
        helicopterSlowDeathState: {
          forwardAngle: number; forwardSpeed: number; hitGroundFrame: number;
          verticalVelocity: number; selfSpin: number;
        } | null;
        helicopterSlowDeathProfiles: unknown[];
      }>;
    };

    const heli = [...priv.spawnedEntities.values()].find(e => e.helicopterSlowDeathProfiles.length > 0)!;
    heli.y = 200; // Start high up.

    // Kill it  give enough frames for combat.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (heli.health <= 0) break;
    }

    const hs = heli.helicopterSlowDeathState!;
    expect(hs).not.toBeNull();
    const initX = heli.x;
    const initZ = heli.z;
    const initY = heli.y;

    // Run several frames of spiral death.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Helicopter should have moved laterally (spiral orbit).
    expect(Math.abs(heli.x - initX) + Math.abs(heli.z - initZ)).toBeGreaterThan(0.1);
    // Should be descending (lower Y).
    expect(heli.y).toBeLessThan(initY);
    // Forward speed should be damped.
    expect(hs.forwardSpeed).toBeLessThan(2); // Was ~2 units/frame initially.
    // Vertical velocity should be increasingly negative.
    expect(hs.verticalVelocity).toBeLessThan(0);
  });

  it('hits ground and destroys after delay', () => {
    const bundle = makeHeliBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Helicopter', 10, 10),
        makeMapObject('Killer', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number;
        helicopterSlowDeathState: { hitGroundFrame: number } | null;
        helicopterSlowDeathProfiles: unknown[];
      }>;
    };

    const heli = [...priv.spawnedEntities.values()].find(e => e.helicopterSlowDeathProfiles.length > 0)!;
    heli.y = 30; // Start relatively low  will hit ground quickly.

    // Kill it  give enough frames for combat.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (heli.health <= 0) break;
    }

    expect(heli.helicopterSlowDeathState).not.toBeNull();

    // Run frames until it hits the ground.
    let hitGround = false;
    for (let i = 0; i < 200; i++) {
      logic.update(1 / 30);
      if (heli.helicopterSlowDeathState?.hitGroundFrame && heli.helicopterSlowDeathState.hitGroundFrame > 0) {
        hitGround = true;
        break;
      }
      if (heli.destroyed) break;
    }
    expect(hitGround || heli.destroyed).toBe(true);

    // If it hit ground but isn't destroyed yet, run more frames for the delay.
    if (!heli.destroyed) {
      // DelayFromGroundToFinalDeath = 500ms  15 frames.
      for (let i = 0; i < 20; i++) {
        logic.update(1 / 30);
        if (heli.destroyed) break;
      }
      expect(heli.destroyed).toBe(true);
    }
  });

  it('self-spin oscillates between min and max rates', () => {
    const bundle = makeHeliBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Helicopter', 10, 10),
        makeMapObject('Killer', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number;
        helicopterSlowDeathState: {
          selfSpin: number; selfSpinTowardsMax: boolean; hitGroundFrame: number;
        } | null;
        helicopterSlowDeathProfiles: unknown[];
      }>;
    };

    const heli = [...priv.spawnedEntities.values()].find(e => e.helicopterSlowDeathProfiles.length > 0)!;
    heli.y = 500; // Very high  won't hit ground during test.

    // Kill it  give enough frames for combat.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (heli.health <= 0) break;
    }

    const hs = heli.helicopterSlowDeathState!;
    expect(hs).not.toBeNull();
    const initSpin = hs.selfSpin;

    // SelfSpinUpdateDelay = 200ms  6 frames. Run enough frames for spin to update.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // Spin should have changed from the initial value (started at minSelfSpin, heading toward max).
    expect(hs.selfSpin).not.toBe(initSpin);
    // The helicopter should still be airborne.
    expect(hs.hitGroundFrame).toBe(0);
  });
});

describe('JetSlowDeathBehavior', () => {
  function makeJetBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('FighterJet', 'America', ['VEHICLE', 'AIRCRAFT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('Behavior', 'SlowDeathBehavior ModuleTag_SD', {
            DeathTypes: 'ALL',
            DestructionDelay: 5000,
            SinkRate: 0,
            ProbabilityModifier: 100,
          }),
          makeBlock('Behavior', 'JetSlowDeathBehavior ModuleTag_JSD', {
            DeathTypes: 'ALL',
            RollRate: 5,                         // 5 raw float (C++ parseReal, not degrees)
            RollRateDelta: 95,                   // 0.95 multiplier (parsePercentToReal)
            PitchRate: 3,                        // 3 raw float (C++ parseReal, not degrees)
            FallHowFast: 60,                     // 60% gravity (parsePercentToReal)
            DelaySecondaryFromInitialDeath: 500, // 500ms  15 frames
            DelayFinalBlowUpFromHitGround: 300,  // 300ms  9 frames
          }),
        ]),
        makeObjectDef('AAGun', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'AAAGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('AAAGun', {
          AttackRange: 300,
          PrimaryDamage: 9999,
          PrimaryDamageRadius: 0,
          WeaponSpeed: 999999,
          DelayBetweenShots: 5000,
          AntiAirborneVehicle: true,
        }),
      ],
    });
  }

  it('extracts jet slow death profiles from INI', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('FighterJet', 128, 128)], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        jetSlowDeathProfiles: { rollRate: number; fallHowFast: number; rollRateDelta: number; deathTypes: Set<string> }[];
      }>;
    };

    const jet = [...priv.spawnedEntities.values()][0]!;
    expect(jet.jetSlowDeathProfiles.length).toBe(1);
    const p = jet.jetSlowDeathProfiles[0]!;
    // RollRate: 5 raw float (C++ parseReal  no degree conversion).
    expect(p.rollRate).toBeCloseTo(5, 4);
    // RollRateDelta: 95%  0.95
    expect(p.rollRateDelta).toBeCloseTo(0.95, 4);
    // FallHowFast: 60%  0.6
    expect(p.fallHowFast).toBeCloseTo(0.6, 4);
  });

  it('initializes jet death state when killed airborne', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('FighterJet', 10, 10),
        makeMapObject('AAGun', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number;
        jetSlowDeathState: {
          deathFrame: number; groundFrame: number; rollRate: number;
          forwardSpeed: number; profileIndex: number;
        } | null;
        jetSlowDeathProfiles: unknown[];
        slowDeathState: unknown;
      }>;
    };

    const jet = [...priv.spawnedEntities.values()].find(e =>
      (e as { jetSlowDeathProfiles: unknown[] }).jetSlowDeathProfiles.length > 0)!;
    expect(jet).toBeDefined();
    // Elevate jet so it dies airborne (above isSignificantlyAboveTerrain threshold of 9.0).
    jet.y = 150;

    // Kill the jet.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (jet.health <= 0) break;
    }

    expect(jet.health).toBeLessThanOrEqual(0);
    expect(jet.destroyed).toBe(false);
    expect(jet.slowDeathState).not.toBeNull();
    expect(jet.jetSlowDeathState).not.toBeNull();
    expect(jet.jetSlowDeathState!.profileIndex).toBe(0);
    expect(jet.jetSlowDeathState!.groundFrame).toBe(0); // Still airborne.
    expect(jet.jetSlowDeathState!.forwardSpeed).toBeGreaterThan(0);
  });

  it('flies forward and descends while airborne', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('FighterJet', 10, 10),
        makeMapObject('AAGun', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number; x: number; z: number;
        jetSlowDeathState: {
          rollAngle: number; verticalVelocity: number; groundFrame: number;
        } | null;
        jetSlowDeathProfiles: unknown[];
      }>;
    };

    const jet = [...priv.spawnedEntities.values()].find(e =>
      (e as { jetSlowDeathProfiles: unknown[] }).jetSlowDeathProfiles.length > 0)!;
    jet.y = 300; // Start very high.

    // Kill it.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (jet.health <= 0) break;
    }

    const js = jet.jetSlowDeathState!;
    expect(js).not.toBeNull();
    const initX = jet.x;
    const initZ = jet.z;
    const initY = jet.y;

    // Run several frames of jet death.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
    }

    // Jet should have moved forward (straight line, not spiral).
    expect(Math.abs(jet.x - initX) + Math.abs(jet.z - initZ)).toBeGreaterThan(0.1);
    // Should be descending.
    expect(jet.y).toBeLessThan(initY);
    // Roll angle should have accumulated.
    expect(Math.abs(js.rollAngle)).toBeGreaterThan(0);
    // Vertical velocity should be negative.
    expect(js.verticalVelocity).toBeLessThan(0);
  });

  it('hits ground and destroys after final delay', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('FighterJet', 10, 10),
        makeMapObject('AAGun', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number;
        jetSlowDeathState: { groundFrame: number; pitchAngle: number } | null;
        jetSlowDeathProfiles: unknown[];
      }>;
    };

    const jet = [...priv.spawnedEntities.values()].find(e =>
      (e as { jetSlowDeathProfiles: unknown[] }).jetSlowDeathProfiles.length > 0)!;
    jet.y = 30; // Start low  will hit ground quickly.

    // Kill it.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (jet.health <= 0) break;
    }

    expect(jet.jetSlowDeathState).not.toBeNull();

    // Run frames until it hits the ground.
    let hitGround = false;
    for (let i = 0; i < 200; i++) {
      logic.update(1 / 30);
      if (jet.jetSlowDeathState?.groundFrame && jet.jetSlowDeathState.groundFrame > 0) {
        hitGround = true;
        break;
      }
      if (jet.destroyed) break;
    }
    expect(hitGround || jet.destroyed).toBe(true);

    // If it hit ground but isn't destroyed yet, run a frame so the else branch
    // (ground phase) executes, then check pitch accumulation.
    // C++ parity: ground-hit frame sets groundFrame; pitch starts next frame.
    if (!jet.destroyed) {
      logic.update(1 / 30);
      if (!jet.destroyed) {
        expect(jet.jetSlowDeathState!.pitchAngle).not.toBe(0);
      }
      for (let i = 0; i < 15; i++) {
        logic.update(1 / 30);
        if (jet.destroyed) break;
      }
      expect(jet.destroyed).toBe(true);
    }
  });

  it('skips jet slow death if killed on ground', () => {
    const bundle = makeJetBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('FighterJet', 10, 10),
        makeMapObject('AAGun', 30, 10),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number; y: number; baseHeight: number;
        jetSlowDeathState: unknown | null;
        jetSlowDeathProfiles: unknown[];
      }>;
    };

    const jet = [...priv.spawnedEntities.values()].find(e =>
      (e as { jetSlowDeathProfiles: unknown[] }).jetSlowDeathProfiles.length > 0)!;
    // Keep jet at ground level (not significantly above terrain).
    // Don't elevate  let it stay at spawn height.

    // Kill it.
    logic.submitCommand({ type: 'attackEntity', entityId: 2, targetEntityId: 1 });
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (jet.health <= 0) break;
    }

    // Jet slow death state should NOT be initialized (killed on ground).
    expect(jet.jetSlowDeathState).toBeNull();
  });
});

describe('CleanupHazardUpdate', () => {
  function makeCleanupBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('Worker', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'CleanupGun'] }),
          makeBlock('Behavior', 'CleanupHazardUpdate ModuleTag_CHU', {
            WeaponSlot: 'PRIMARY',
            ScanRate: 200,   // 200ms  6 frames
            ScanRange: 100,
          }),
        ]),
        makeObjectDef('ToxinPuddle', 'Neutral', ['CLEANUP_HAZARD'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('CleanupGun', {
          AttackRange: 80,
          PrimaryDamage: 100,
          WeaponSpeed: 999999,
          DelayBetweenShots: 500,
        }),
      ],
    });
  }

  it('extracts cleanup hazard profile from INI', () => {
    const bundle = makeCleanupBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Worker', 10, 10)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        cleanupHazardProfile: { weaponSlot: string; scanFrames: number; scanRange: number } | null;
      }>;
    };

    const worker = [...priv.spawnedEntities.values()][0]!;
    expect(worker.cleanupHazardProfile).not.toBeNull();
    expect(worker.cleanupHazardProfile!.scanRange).toBe(100);
    expect(worker.cleanupHazardProfile!.scanFrames).toBe(6); // 200ms  6 frames
  });

  it('auto-attacks nearby CLEANUP_HAZARD entities', () => {
    const bundle = makeCleanupBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Worker', 10, 10),
        makeMapObject('ToxinPuddle', 25, 10), // 15 units away  well within scan range of 100
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    // Worker and ToxinPuddle are both neutral/enemy? Worker is America, puddle is Neutral.
    // CleanupHazard doesn't need enemy relationship  it targets CLEANUP_HAZARD by kindOf.
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
        cleanupHazardState: { bestTargetId: number } | null;
      }>;
    };

    const puddle = [...priv.spawnedEntities.values()].find(e => e.health === 50)!;
    expect(puddle).toBeDefined();

    // Run frames for the worker to scan and attack.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
      if (puddle.health < 50) break;
    }

    // The puddle should have taken damage or be destroyed.
    expect(puddle.health).toBeLessThan(50);
  });

  it('ignores hazards outside scan range', () => {
    const bundle = makeCleanupBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Worker', 10, 10),
        makeMapObject('ToxinPuddle', 200, 200), // ~270 units away  beyond scan range of 100
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
      }>;
    };

    const puddle = [...priv.spawnedEntities.values()].find(e => e.health === 50)!;

    // Run many frames.
    for (let i = 0; i < 30; i++) {
      logic.update(1 / 30);
    }

    // Puddle should be unharmed.
    expect(puddle.health).toBe(50);
  });
});

describe('AssistedTargetingUpdate', () => {
  function makeAssistedBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('Patriot', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'PatriotMissile'] }),
          makeBlock('Behavior', 'AssistedTargetingUpdate ModuleTag_AT', {
            AssistingClipSize: 4,
            AssistingWeaponSlot: 'PRIMARY',
            LaserFromAssisted: 'AssistLaser1',
            LaserToTarget: 'AssistLaser2',
          }),
        ]),
        makeObjectDef('Target', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('Designator', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('PatriotMissile', {
          AttackRange: 200,
          PrimaryDamage: 80,
          WeaponSpeed: 999999,
          DelayBetweenShots: 1000,
        }),
      ],
    });
  }

  it('extracts assisted targeting profile from INI', () => {
    const bundle = makeAssistedBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Patriot', 10, 10)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        assistedTargetingProfile: { clipSize: number; weaponSlot: string; laserFromAssisted: string } | null;
      }>;
    };

    const patriot = [...priv.spawnedEntities.values()][0]!;
    expect(patriot.assistedTargetingProfile).not.toBeNull();
    expect(patriot.assistedTargetingProfile!.clipSize).toBe(4);
    expect(patriot.assistedTargetingProfile!.weaponSlot).toBe('PRIMARY');
    expect(patriot.assistedTargetingProfile!.laserFromAssisted).toBe('AssistLaser1');
  });

  it('isFreeToAssist returns true when weapon is ready', () => {
    const bundle = makeAssistedBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('Patriot', 10, 10)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; assistedTargetingProfile: unknown;
        attackCooldownRemaining: number; destroyed: boolean;
      }>;
    };

    const patriot = [...priv.spawnedEntities.values()][0]!;
    // Should be free to assist when weapon is ready (cooldown=0).
    expect((logic as unknown as { isEntityFreeToAssist: (e: unknown) => boolean }).isEntityFreeToAssist(patriot)).toBe(true);

    // Set cooldown  should no longer be free.
    patriot.attackCooldownRemaining = 10;
    expect((logic as unknown as { isEntityFreeToAssist: (e: unknown) => boolean }).isEntityFreeToAssist(patriot)).toBe(false);
  });

  it('issueAssistedAttack causes the assisted entity to attack the target', () => {
    const bundle = makeAssistedBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Patriot', 10, 10),
        makeMapObject('Target', 30, 10), // 20 units away  within range
        makeMapObject('Designator', 10, 20),
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; destroyed: boolean; health: number;
        attackTargetEntityId: number | null;
      }>;
    };

    const target = [...priv.spawnedEntities.values()].find(e => e.health === 200)!;
    const patriot = [...priv.spawnedEntities.values()].find(e => e.health === 300)!;

    // Issue assisted attack.
    (logic as unknown as { issueAssistedAttack: (a: number, t: number) => void }).issueAssistedAttack(patriot.id, target.id);

    // Run frames for the attack to fire.
    for (let i = 0; i < 10; i++) {
      logic.update(1 / 30);
      if (target.health < 200) break;
    }

    // Target should have taken damage from the patriot.
    expect(target.health).toBeLessThan(200);
  });
});

describe('RepairDockUpdate', () => {
  function makeRepairDockBundle(timeForFullHealMs = 3000) {
    return makeBundle({
      objects: [
        makeObjectDef('RepairDock', 'America', ['STRUCTURE', 'REPAIR_PAD'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2000, InitialHealth: 2000 }),
          makeBlock('Behavior', 'RepairDockUpdate ModuleTag_Repair', {
            TimeForFullHeal: timeForFullHealMs,
          }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 8,
          GeometryMinorRadius: 8,
        }),
        makeObjectDef('DamagedVehicle', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 150 }),
          makeBlock('LocomotorSet', 'SET_NORMAL VehicleLocomotor', {}),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 4,
          GeometryMinorRadius: 4,
        }),
        makeObjectDef('SupportDrone', 'America', ['DRONE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 25 }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
        makeObjectDef('EnemyVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 150 }),
          makeBlock('LocomotorSet', 'SET_NORMAL VehicleLocomotor', {}),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 4,
          GeometryMinorRadius: 4,
        }),
      ],
      locomotors: [
        makeLocomotorDef('VehicleLocomotor', 180),
      ],
    });
  }

  it('extracts RepairDockUpdate profile from INI', () => {
    const bundle = makeRepairDockBundle(3000);
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('RepairDock', 55, 55)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        repairDockProfile: { timeForFullHealFrames: number } | null;
      }>;
    };

    const dock = priv.spawnedEntities.get(1)!;
    expect(dock.repairDockProfile).not.toBeNull();
    // Source parity: parseDurationReal converts 3000ms to 90.0 frames at 30fps.
    expect(dock.repairDockProfile!.timeForFullHealFrames).toBeCloseTo(90, 5);
  });

  it('heals docked vehicle over configured full-heal duration then completes docking', () => {
    const bundle = makeRepairDockBundle(3000);
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('RepairDock', 55, 55),     // id 1
        makeMapObject('DamagedVehicle', 55, 55), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        maxHealth: number;
      }>;
      pendingRepairDockActions: Map<number, {
        dockObjectId: number;
        healthToAddPerFrame: number;
        lastRepairDockObjectId: number;
      }>;
    };

    const vehicle = priv.spawnedEntities.get(2)!;
    expect(vehicle.health).toBe(150);

    logic.submitCommand({
      type: 'enterObject',
      entityId: 2,
      targetObjectId: 1,
      action: 'repairVehicle',
    });

    // First update should resolve enter action and apply first repair tick.
    logic.update(1 / 30);
    expect(vehicle.health).toBeGreaterThan(150);
    expect(priv.pendingRepairDockActions.get(2)?.dockObjectId).toBe(1);

    // 3000ms -> 90 frames to full heal from initial health.
    for (let i = 0; i < 120; i++) {
      logic.update(1 / 30);
    }

    expect(vehicle.health).toBeCloseTo(vehicle.maxHealth, 5);
    expect(priv.pendingRepairDockActions.has(2)).toBe(false);
  });

  it('fully heals associated drone each dock action tick', () => {
    const bundle = makeRepairDockBundle(3000);
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('RepairDock', 55, 55),     // id 1
        makeMapObject('DamagedVehicle', 55, 55), // id 2
        makeMapObject('SupportDrone', 65, 55),   // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        maxHealth: number;
        producerEntityId: number;
      }>;
    };
    const drone = priv.spawnedEntities.get(3)!;
    drone.producerEntityId = 2;
    expect(drone.health).toBe(25);

    logic.submitCommand({
      type: 'enterObject',
      entityId: 2,
      targetObjectId: 1,
      action: 'repairVehicle',
    });

    logic.update(1 / 30);
    expect(drone.health).toBe(drone.maxHealth);
  });

  it('rejects repairVehicle enter actions from enemy units', () => {
    const bundle = makeRepairDockBundle(3000);
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('RepairDock', 55, 55),    // id 1
        makeMapObject('EnemyVehicle', 75, 55),  // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { health: number }>;
      pendingRepairDockActions: Map<number, unknown>;
    };

    const enemy = priv.spawnedEntities.get(2)!;
    expect(enemy.health).toBe(150);

    logic.submitCommand({
      type: 'enterObject',
      entityId: 2,
      targetObjectId: 1,
      action: 'repairVehicle',
    });
    for (let i = 0; i < 5; i++) {
      logic.update(1 / 30);
    }

    expect(enemy.health).toBe(150);
    expect(priv.pendingRepairDockActions.has(2)).toBe(false);
  });
});

describe('SupplyWarehouseCripplingBehavior', () => {
  function makeCripplingBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('SupplyWarehouse', 'America', ['SUPPLY_SOURCE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 20,
            DeleteWhenEmpty: 'No',
          }),
          makeBlock('Behavior', 'SupplyWarehouseCripplingBehavior ModuleTag_Cripple', {
            SelfHealSupression: 3000,   // 3000ms  90 frames
            SelfHealDelay: 1000,         // 1000ms  30 frames
            SelfHealAmount: 50,
          }),
        ]),
        makeObjectDef('Attacker', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'BigGun'] }),
        ]),
      ],
      weapons: [
        makeWeaponDef('BigGun', {
          AttackRange: 200,
          PrimaryDamage: 100,
          WeaponSpeed: 999999,
          DelayBetweenShots: 100,
        }),
      ],
    });
  }

  it('extracts crippling profile from INI', () => {
    const bundle = makeCripplingBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SupplyWarehouse', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        supplyWarehouseCripplingProfile: {
          selfHealSuppressionFrames: number;
          selfHealDelayFrames: number;
          selfHealAmount: number;
        } | null;
      }>;
    };

    const warehouse = [...priv.spawnedEntities.values()][0]!;
    expect(warehouse.supplyWarehouseCripplingProfile).not.toBeNull();
    expect(warehouse.supplyWarehouseCripplingProfile!.selfHealSuppressionFrames).toBe(90);
    expect(warehouse.supplyWarehouseCripplingProfile!.selfHealDelayFrames).toBe(30);
    expect(warehouse.supplyWarehouseCripplingProfile!.selfHealAmount).toBe(50);
  });

  it('disables dock when health drops to REALLYDAMAGED', () => {
    const bundle = makeCripplingBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SupplyWarehouse', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; health: number; maxHealth: number; destroyed: boolean;
        swCripplingDockDisabled: boolean;
      }>;
      applyWeaponDamageAmount: (
        sourceEntityId: number | null, target: unknown, amount: number,
        damageType: string, weaponDeathType?: string,
      ) => void;
    };

    const warehouse = [...priv.spawnedEntities.values()][0]!;
    expect(warehouse.swCripplingDockDisabled).toBe(false);

    // Damage warehouse to REALLYDAMAGED: health ratio <= 0.1 (health <= 100).
    // MaxHealth=1000, so deal 950 damage  health=50, ratio=0.05  REALLYDAMAGED.
    priv.applyWeaponDamageAmount(null, warehouse, 950, 'ARMOR_PIERCING');
    expect(warehouse.health).toBe(50);
    expect(warehouse.swCripplingDockDisabled).toBe(true);
  });

  it('self-heals after suppression delay expires', () => {
    const bundle = makeCripplingBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SupplyWarehouse', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; health: number; maxHealth: number; destroyed: boolean;
        swCripplingDockDisabled: boolean;
      }>;
      applyWeaponDamageAmount: (
        sourceEntityId: number | null, target: unknown, amount: number,
        damageType: string, weaponDeathType?: string,
      ) => void;
    };

    const warehouse = [...priv.spawnedEntities.values()][0]!;
    // Damage to health=400 (ratio 0.4  DAMAGED state since 0.4 <= 0.5).
    priv.applyWeaponDamageAmount(null, warehouse, 600, 'ARMOR_PIERCING');
    expect(warehouse.health).toBe(400);

    // Suppression is 90 frames. Run 89 frames  should NOT have healed yet.
    for (let i = 0; i < 89; i++) {
      logic.update(1 / 30);
    }
    expect(warehouse.health).toBe(400);

    // Run 2 more frames to pass suppression + first heal tick.
    logic.update(1 / 30); // frame 90: suppression expires
    logic.update(1 / 30); // frame 91: heal tick fires
    expect(warehouse.health).toBeGreaterThan(400);
  });

  it('re-enables dock when health heals past REALLYDAMAGED threshold', () => {
    const bundle = makeCripplingBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SupplyWarehouse', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; health: number; maxHealth: number; destroyed: boolean;
        swCripplingDockDisabled: boolean;
      }>;
      applyWeaponDamageAmount: (
        sourceEntityId: number | null, target: unknown, amount: number,
        damageType: string, weaponDeathType?: string,
      ) => void;
    };

    const warehouse = [...priv.spawnedEntities.values()][0]!;

    // Damage to health=50 (ratio 0.05  REALLYDAMAGED since 0.05 <= 0.1).
    priv.applyWeaponDamageAmount(null, warehouse, 950, 'ARMOR_PIERCING');
    expect(warehouse.health).toBe(50);
    expect(warehouse.swCripplingDockDisabled).toBe(true);

    // Wait for suppression to expire (90 frames) and enough heal ticks to cross threshold.
    // selfHealAmount=50, every 30 frames. REALLYDAMAGED threshold is ratio > 0.1  health > 100.
    // Need to heal from 50 to >100, so 2 ticks of 50 = 100 total heal  health=150 (ratio 0.15  DAMAGED).
    // After suppression (90 frames), first heal at frame 90, second at frame 120.
    for (let i = 0; i < 130; i++) {
      logic.update(1 / 30);
    }

    // Health should have healed past 100.
    expect(warehouse.health).toBeGreaterThan(100);
    // Dock should be re-enabled since health is no longer REALLYDAMAGED.
    expect(warehouse.swCripplingDockDisabled).toBe(false);
  });

  it('damage resets heal suppression timer', () => {
    const bundle = makeCripplingBundle();
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SupplyWarehouse', 50, 50)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number; health: number; maxHealth: number; destroyed: boolean;
      }>;
      applyWeaponDamageAmount: (
        sourceEntityId: number | null, target: unknown, amount: number,
        damageType: string, weaponDeathType?: string,
      ) => void;
    };

    const warehouse = [...priv.spawnedEntities.values()][0]!;

    // First damage: health 1000  600.
    priv.applyWeaponDamageAmount(null, warehouse, 400, 'ARMOR_PIERCING');
    expect(warehouse.health).toBe(600);

    // Run 80 frames (not yet past 90 frame suppression).
    for (let i = 0; i < 80; i++) {
      logic.update(1 / 30);
    }
    expect(warehouse.health).toBe(600); // Still suppressed.

    // Second damage: resets suppression timer. Health 600  500.
    priv.applyWeaponDamageAmount(null, warehouse, 100, 'ARMOR_PIERCING');
    expect(warehouse.health).toBe(500);

    // Run 80 more frames  still within NEW suppression window (90 frames from second hit).
    for (let i = 0; i < 80; i++) {
      logic.update(1 / 30);
    }
    expect(warehouse.health).toBe(500); // Still suppressed from second hit.

    // Run 12 more frames to pass new suppression window + first tick.
    for (let i = 0; i < 12; i++) {
      logic.update(1 / 30);
    }
    expect(warehouse.health).toBeGreaterThan(500); // Healing has started.
  });
});

describe('TransportAI attack delegation', () => {
  function makeTransportBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('Humvee', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'HumveeMG'] }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            PassengersAllowedToFire: 'Yes',
            ContainMax: 5,
          }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'RangerGun'] }),
        ]),
        makeObjectDef('EnemyTank', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('HumveeMG', {
          PrimaryDamage: 10, AttackRange: 100, DelayBetweenShots: 100, DamageType: 'SMALL_ARMS',
        }),
        makeWeaponDef('RangerGun', {
          PrimaryDamage: 5, AttackRange: 80, DelayBetweenShots: 100, DamageType: 'SMALL_ARMS',
        }),
      ],
    });
  }

  it('player attack command on transport propagates to contained passengers', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeTransportBundle());

    const map = makeMap([
      makeMapObject('Humvee', 50, 50),    // id 1
      makeMapObject('Ranger', 50, 50),     // id 2  adjacent to Humvee
      makeMapObject('EnemyTank', 60, 50),  // id 3  within range
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    // Enter transport.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    // Verify passenger is inside.
    const priv = logic as any;
    const passenger = priv.spawnedEntities.get(2)!;
    expect(passenger.transportContainerId).toBe(1);

    // Issue attack command on the transport.
    logic.submitCommand({
      type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER',
    });
    logic.update(1 / 30);

    // Passenger should also target the enemy.
    expect(passenger.attackTargetEntityId).toBe(3);
  });

  it('AI auto-target attack does NOT propagate to passengers', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeTransportBundle());

    const map = makeMap([
      makeMapObject('Humvee', 50, 50),
      makeMapObject('Ranger', 50, 50),
      makeMapObject('EnemyTank', 60, 50),
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    const priv = logic as any;
    const passenger = priv.spawnedEntities.get(2)!;

    // Issue AI-sourced attack (e.g., auto-retaliation)  should NOT propagate.
    logic.submitCommand({
      type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'AI',
    });
    logic.update(1 / 30);

    // Passenger should NOT have the target set by transport delegation.
    // (It may acquire its own target via auto-targeting, but not from this delegation.)
    expect(passenger.attackTargetEntityId).not.toBe(3);
  });

  it('skips disabled PORTABLE_STRUCTURE passengers', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Overlord', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'OverlordCannon'] }),
          makeBlock('Behavior', 'OverlordContain ModuleTag_Contain', {
            PassengersAllowedToFire: 'Yes',
            ContainMax: 5,
          }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 15,
          GeometryMinorRadius: 15,
        }),
        makeObjectDef('GattlingUpgrade', 'China', ['PORTABLE_STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'GattlingGun'] }),
        ]),
        makeObjectDef('EnemyUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('OverlordCannon', {
          PrimaryDamage: 50, AttackRange: 150, DelayBetweenShots: 200, DamageType: 'ARMOR_PIERCING',
        }),
        makeWeaponDef('GattlingGun', {
          PrimaryDamage: 10, AttackRange: 100, DelayBetweenShots: 50, DamageType: 'SMALL_ARMS',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(bundle);

    const map = makeMap([
      makeMapObject('Overlord', 50, 50),        // id 1
      makeMapObject('GattlingUpgrade', 50, 50),  // id 2  portable structure passenger
      makeMapObject('EnemyUnit', 60, 50),        // id 3
    ]);

    logic.loadMapObjects(map, registry, makeHeightmap());
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    const priv = logic as any;
    const gattling = priv.spawnedEntities.get(2)!;

    // Put gattling inside overlord via helixCarrierId (Overlord contain type).
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    // Disable the gattling with EMP.
    gattling.objectStatusFlags.add('DISABLED_EMP');

    // Attack with overlord.
    logic.submitCommand({
      type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER',
    });
    logic.update(1 / 30);

    // Disabled PORTABLE_STRUCTURE should NOT receive the attack delegation.
    expect(gattling.attackTargetEntityId).not.toBe(3);
  });
});

describe('InternetHackContain', () => {
  it('auto-issues hackInternet command when hacker enters internet center', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InternetCenter', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'InternetHackContain ModuleTag_Contain', {
            ContainMax: 8,
          }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 20,
          GeometryMinorRadius: 20,
        }),
        makeObjectDef('Hacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'HackInternetAIUpdate ModuleTag_Hack', {
            UnpackTime: 0,
            CashUpdateDelay: 0,
            CashUpdateDelayFast: 0,
            RegularCashAmount: 50,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('InternetCenter', 30, 30),  // id 1
        makeMapObject('Hacker', 30, 30),           // id 2  adjacent to center
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 0 });

    // Enter the internet center.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30); // process enter
    logic.update(1 / 30); // process auto-issued hackInternet command

    // Run a few frames to accumulate hack income.
    for (let frame = 0; frame < 3; frame++) {
      logic.update(1 / 30);
    }

    // Hacker should be generating money from inside the internet center.
    expect(logic.getSideCredits('China')).toBeGreaterThan(0);
  });

  it('uses fast cash update delay when hacker is inside internet center', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InternetCenter', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'InternetHackContain ModuleTag_Contain', {
            ContainMax: 8,
          }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 20,
          GeometryMinorRadius: 20,
        }),
        makeObjectDef('Hacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'HackInternetAIUpdate ModuleTag_Hack', {
            UnpackTime: 0,
            CashUpdateDelay: 3000,
            CashUpdateDelayFast: 0,
            RegularCashAmount: 100,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('InternetCenter', 30, 30),  // id 1
        makeMapObject('Hacker', 30, 30),           // id 2
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'China', amount: 0 });

    // Enter the internet center to trigger fast hack.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30); // process enter
    logic.update(1 / 30); // process auto-hackInternet

    // Run 5 frames  with CashUpdateDelayFast=0, should generate quickly.
    // With normal CashUpdateDelay=3000 (90 frames), no cash would appear yet.
    for (let frame = 0; frame < 5; frame++) {
      logic.update(1 / 30);
    }

    // Fast delay should have generated cash; normal delay would not have.
    expect(logic.getSideCredits('China')).toBeGreaterThan(0);
  });
});

describe('LeechRangeWeapon', () => {
  it('maintains attack on target that moves out of normal weapon range', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'HackWeapon'] }),
        ]),
        makeObjectDef('EnemyVehicle', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('HackWeapon', {
          PrimaryDamage: 5, AttackRange: 50, DelayBetweenShots: 100,
          DamageType: 'INFORMATION', LeechRangeWeapon: 'Yes',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Hacker', 10, 10),       // id 1
        makeMapObject('EnemyVehicle', 40, 10),  // id 2  within 50 range
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Issue attack and run a few frames so weapon fires.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2, commandSource: 'PLAYER' });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as any;
    const hacker = priv.spawnedEntities.get(1)!;
    const enemy = priv.spawnedEntities.get(2)!;

    // Leech range should be active after first shot.
    expect(hacker.leechRangeActive).toBe(true);

    // Move target way beyond normal weapon range.
    enemy.x = 200;
    enemy.z = 10;

    // Run more frames  hacker should STILL be attacking (leech range = unlimited).
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Hacker should still have the target locked despite being far out of range.
    expect(hacker.attackTargetEntityId).toBe(2);
  });

  it('clears leechRangeActive when attack target is cleared', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Hacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'HackWeapon'] }),
        ]),
        makeObjectDef('EnemyVehicle', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('HackWeapon', {
          PrimaryDamage: 5, AttackRange: 50, DelayBetweenShots: 100,
          DamageType: 'INFORMATION', LeechRangeWeapon: 'Yes',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Hacker', 10, 10),       // id 1
        makeMapObject('EnemyVehicle', 40, 10),  // id 2
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2, commandSource: 'PLAYER' });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as any;
    const hacker = priv.spawnedEntities.get(1)!;
    expect(hacker.leechRangeActive).toBe(true);

    // Stop the hacker (clears attack target).
    logic.submitCommand({ type: 'stop', entityId: 1 });
    logic.update(1 / 30);

    // Leech range should be cleared.
    expect(hacker.leechRangeActive).toBe(false);
  });

  it('does NOT grant leech range to normal weapons', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Tank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'TankCannon'] }),
        ]),
        makeObjectDef('EnemyUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('TankCannon', {
          PrimaryDamage: 50, AttackRange: 100, DelayBetweenShots: 500, DamageType: 'ARMOR_PIERCING',
        }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Tank', 10, 10),      // id 1
        makeMapObject('EnemyUnit', 40, 10),  // id 2
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('America', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'America', 0);

    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 2, commandSource: 'PLAYER' });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    const priv = logic as any;
    const tank = priv.spawnedEntities.get(1)!;

    // Normal weapon should NOT activate leech range.
    expect(tank.leechRangeActive).toBe(false);
  });
});

describe('AssaultTransportAIUpdate', () => {
  function makeAssaultTransportBundle() {
    return makeBundle({
      objects: [
        makeObjectDef('TroopCrawler', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            PassengersAllowedToFire: 'No',
            ContainMax: 8,
          }),
          makeBlock('Behavior', 'AssaultTransportAIUpdate ModuleTag_AssaultAI', {
            MembersGetHealedAtLifeRatio: 0.3,
          }),
        ], {
          Geometry: 'CYLINDER',
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
        makeObjectDef('RedGuard', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'RedGuardGun'] }),
        ]),
        makeObjectDef('EnemyTank', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('RedGuardGun', {
          PrimaryDamage: 5, AttackRange: 80, DelayBetweenShots: 100, DamageType: 'SMALL_ARMS',
        }),
      ],
    });
  }

  it('extracts AssaultTransportProfile from INI', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([makeMapObject('TroopCrawler', 50, 50)], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    const priv = logic as any;
    const crawler = priv.spawnedEntities.get(1)!;
    expect(crawler.assaultTransportProfile).not.toBeNull();
    expect(crawler.assaultTransportProfile.membersGetHealedAtLifeRatio).toBeCloseTo(0.3);
  });

  it('deploys passengers when transport receives attack command', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopCrawler', 50, 50),   // id 1
        makeMapObject('RedGuard', 50, 50),         // id 2
        makeMapObject('EnemyTank', 100, 50),       // id 3
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Load passenger.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    const priv = logic as any;
    const guard = priv.spawnedEntities.get(2)!;
    expect(guard.transportContainerId).toBe(1);

    // Attack command on transport  should begin assault and deploy passengers.
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER' });
    // Run several frames for command processing + assault transport update.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Verify assault transport state was created.
    const assaultState = priv.assaultTransportStateByEntityId.get(1);
    expect(assaultState).toBeDefined();
    expect(assaultState.designatedTargetId).toBe(3);

    // After some frames, member should be ejected (exitContainer queued).
    // Guard should no longer be contained once eject processes.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);
    expect(guard.transportContainerId).toBeNull();
  });

  it('recalls wounded members back into transport', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopCrawler', 50, 50),   // id 1
        makeMapObject('RedGuard', 50, 50),         // id 2
        makeMapObject('EnemyTank', 100, 50),       // id 3
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Load passenger, then attack to deploy.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER' });
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as any;
    const guard = priv.spawnedEntities.get(2)!;
    // Guard should be outside now.
    expect(guard.transportContainerId).toBeNull();

    // Wound the guard below the heal ratio (0.3 * 100 = 30 health).
    guard.health = 20;

    // Run assault transport update  should recall wounded member.
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Guard should be back in the transport.
    expect(guard.transportContainerId).toBe(1);
  });

  it('transfers attack orders to troops when transport is destroyed', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopCrawler', 50, 50),   // id 1
        makeMapObject('RedGuard', 55, 50),         // id 2  nearby, not inside
        makeMapObject('EnemyTank', 100, 50),       // id 3
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Load passenger, attack to deploy.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER' });
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as any;
    const guard = priv.spawnedEntities.get(2)!;
    // Ensure guard is deployed outside.
    expect(guard.transportContainerId).toBeNull();

    // Destroy the transport via markEntityDestroyed.
    (priv as { markEntityDestroyed: (id: number, attackerId: number) => void }).markEntityDestroyed(1, -1);
    logic.update(1 / 30);

    // Assault transport state should be cleaned up.
    expect(priv.assaultTransportStateByEntityId.has(1)).toBe(false);

    // Guard should have received attack orders for the target.
    expect(guard.attackTargetEntityId).toBe(3);
  });

  it('resets state and recalls members on stop command', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopCrawler', 50, 50),   // id 1
        makeMapObject('RedGuard', 50, 50),         // id 2
        makeMapObject('EnemyTank', 100, 50),       // id 3
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Load, attack, deploy.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER' });
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as any;
    const guard = priv.spawnedEntities.get(2)!;
    expect(guard.transportContainerId).toBeNull();

    // Stop command  recalls all members.
    logic.submitCommand({ type: 'stop', entityId: 1 });
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // State should be deleted and member recalled.
    expect(priv.assaultTransportStateByEntityId.has(1)).toBe(false);
    expect(guard.transportContainerId).toBe(1);
  });

  it('continues attack-move when designated target dies', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopCrawler', 50, 50),   // id 1
        makeMapObject('RedGuard', 50, 50),         // id 2
        makeMapObject('EnemyTank', 80, 50),        // id 3
      ], 128, 128),
      registry,
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Load passenger.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);

    // Issue attack-move to far position.
    logic.submitCommand({
      type: 'attackMoveTo', entityId: 1, targetX: 200, targetZ: 50, attackDistance: 0,
    });
    for (let i = 0; i < 10; i++) logic.update(1 / 30);

    const priv = logic as any;
    const state = priv.assaultTransportStateByEntityId.get(1);
    expect(state).toBeTruthy();
    expect(state.isAttackMove).toBe(true);

    // Kill the enemy while assault transport has it targeted.
    state.designatedTargetId = 3;
    (priv as { markEntityDestroyed: (id: number, a: number) => void }).markEntityDestroyed(3, -1);
    for (let i = 0; i < 5; i++) logic.update(1 / 30);

    // Transport should still be in attack-move mode (not cleared).
    expect(state.isAttackMove).toBe(true);
    // Target should be cleared.
    expect(state.designatedTargetId).toBeNull();
  });

  it('aborts attack when all members are new (isAttackPointless)', () => {
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(makeAssaultTransportBundle());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopCrawler', 50, 50),   // id 1
        makeMapObject('RedGuard', 50, 50),         // id 2
        makeMapObject('EnemyTank', 100, 50),       // id 3
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'GLA', 0);
    logic.setTeamRelationship('GLA', 'China', 0);

    // Load passenger, then attack to start assault transport state.
    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.update(1 / 30);
    logic.submitCommand({ type: 'attackEntity', entityId: 1, targetEntityId: 3, commandSource: 'PLAYER' });
    logic.update(1 / 30);

    const priv = logic as any;
    const state = priv.assaultTransportStateByEntityId.get(1);
    expect(state).toBeTruthy();

    // Mark all members as new  simulates all troops loaded after attack was issued.
    for (const member of state.members) {
      member.isNew = true;
    }

    // Source parity: isAttackPointless requires IS_ATTACKING to be set on the transport.
    const transport = priv.spawnedEntities.get(1)!;
    transport.objectStatusFlags.add('IS_ATTACKING');

    // Update should detect all-new members and abort.
    logic.update(1 / 30);

    // Attack state should be cleared.
    expect(state.isAttackObject).toBe(false);
    expect(state.isAttackMove).toBe(false);
  });
});

describe('Sabotage building effects', () => {
  it('sabotage power plant forces timed brownout on victim side', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BlackLotus', 'China', ['INFANTRY'], [
          makeBlock('Behavior', 'SabotagePowerPlantCrateCollide ModuleTag_SabotagePP', {
            SabotagePowerDuration: 3000, // 3 seconds = ~90 frames
          }),
        ]),
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE', 'FS_POWER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], { EnergyBonus: 5 }),
        makeObjectDef('WarFactory', 'America', ['STRUCTURE', 'FS_WARFACTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 }),
        ], { EnergyBonus: -3 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BlackLotus', 10, 10),   // id 1
        makeMapObject('PowerPlant', 20, 10),    // id 2
        makeMapObject('WarFactory', 30, 10),    // id 3
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'China', 0);

    // Verify side is NOT browned out initially (5 production > 3 consumption).
    expect(logic.getSidePowerState('America').brownedOut).toBe(false);

    // Sabotage the power plant.
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'sabotageBuilding',
    });
    logic.update(1 / 30); // Frame 1: command processed, sabotage resolves (entity within range).
    logic.update(1 / 30); // Frame 2: updatePowerBrownOut picks up the sabotaged-until-frame.

    // Should be browned out now due to sabotage.
    expect(logic.getSidePowerState('America').brownedOut).toBe(true);

    // Black Lotus is consumed (destroyed as part of sabotage action).
    expect(logic.getEntityState(1)).toBeNull();

    // After sabotage duration expires, brownout should clear.
    for (let i = 0; i < 100; i++) logic.update(1 / 30);
    expect(logic.getSidePowerState('America').brownedOut).toBe(false);
  });

  it('sabotage command center resets special power cooldowns', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BlackLotus', 'China', ['INFANTRY'], [
          makeBlock('Behavior', 'SabotageCommandCenterCrateCollide ModuleTag_SabotageCC', {}),
        ]),
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'COMMANDCENTER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SP', { SpecialPowerTemplate: 'SuperweaponParticleCannon' }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    const registry = makeRegistry(bundle);
    // Add a special power definition with 60s reload time.
    registry.specialPowers.set('SUPERWEAPONPARTICLECANNON', {
      type: 'SpecialPower',
      name: 'SuperweaponParticleCannon',
      fields: { ReloadTime: '60000' },
      blocks: [],
    });
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BlackLotus', 10, 10),     // id 1
        makeMapObject('CommandCenter', 20, 10),   // id 2
      ], 64, 64),
      registry,
      makeHeightmap(64, 64),
    );
    logic.setTeamRelationship('China', 'America', 0);
    logic.setTeamRelationship('America', 'China', 0);

    const priv = logic as any;

    // Sabotage the command center.
    logic.submitCommand({
      type: 'enterObject',
      entityId: 1,
      targetObjectId: 2,
      action: 'sabotageBuilding',
    });
    logic.update(1 / 30);

    // The command center's special power should have its cooldown reset.
    // Check the source entity tracking map for the ready frame.
    const sourcesMap = priv.shortcutSpecialPowerSourceByName as Map<string, Map<number, number>>;
    const cannonSources = sourcesMap?.get('SUPERWEAPONPARTICLECANNON');
    if (cannonSources) {
      const readyFrame = cannonSources.get(2);
      // The ready frame should be in the future (frameCounter + reloadFrames).
      expect(readyFrame).toBeGreaterThan(priv.frameCounter);
    }

    // Black Lotus consumed.
    expect(logic.getEntityState(1)).toBeNull();
  });
});

describe('PowerPlantUpdate', () => {
  it('extracts PowerPlantUpdateProfile from INI', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ChinaPowerPlant', 'China', ['STRUCTURE', 'FS_POWER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'PowerPlantUpdate ModuleTag_PPUpdate', {
            RodsExtendTime: 2000,
          }),
        ], { EnergyBonus: 5 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('ChinaPowerPlant', 30, 30)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as any;
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.powerPlantUpdateProfile).toBeTruthy();
    // 2000ms  ~60 frames at 30 fps.
    expect(entity.powerPlantUpdateProfile.rodsExtendTimeFrames).toBe(60);
    expect(entity.powerPlantUpdateState).toBeTruthy();
    expect(entity.powerPlantUpdateState.extended).toBe(false);
  });

  it('transitions UPGRADING  UPGRADED after RodsExtendTime', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ChinaPowerPlant', 'China', ['STRUCTURE', 'FS_POWER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'PowerPlantUpdate ModuleTag_PPUpdate', {
            RodsExtendTime: 300, // 300ms  9 frames
          }),
          makeBlock('Behavior', 'PowerPlantUpgrade ModuleTag_PPUpgrade', {
            TriggeredBy: 'Upgrade_ChinaOvercharge',
          }),
        ], { EnergyBonus: 5 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('ChinaPowerPlant', 30, 30)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as any;
    const entity = priv.spawnedEntities.get(1)!;

    // Simulate upgrade application by calling extendRods directly.
    (priv as { extendPowerPlantRods: (e: any, extend: boolean) => void }).extendPowerPlantRods(entity, true);

    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADING')).toBe(true);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADED')).toBe(false);
    expect(entity.powerPlantUpdateState.extended).toBe(true);

    // Run for 8 frames (not yet done  need 9 frames).
    for (let i = 0; i < 8; i++) logic.update(1 / 30);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADING')).toBe(true);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADED')).toBe(false);

    // Frame 9+ should transition.
    logic.update(1 / 30);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADING')).toBe(false);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADED')).toBe(true);
  });

  it('de-extends instantly when extendRods(false) is called', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ChinaPowerPlant', 'China', ['STRUCTURE', 'FS_POWER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'PowerPlantUpdate ModuleTag_PPUpdate', {
            RodsExtendTime: 1000,
          }),
        ], { EnergyBonus: 5 }),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('ChinaPowerPlant', 30, 30)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as any;
    const entity = priv.spawnedEntities.get(1)!;
    const fn = priv as { extendPowerPlantRods: (e: any, extend: boolean) => void };

    // Extend rods and let it finish.
    fn.extendPowerPlantRods(entity, true);
    for (let i = 0; i < 40; i++) logic.update(1 / 30);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADED')).toBe(true);

    // De-extend: both flags cleared instantly.
    fn.extendPowerPlantRods(entity, false);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADING')).toBe(false);
    expect(entity.modelConditionFlags.has('POWER_PLANT_UPGRADED')).toBe(false);
    expect(entity.powerPlantUpdateState.extended).toBe(false);
  });
});

describe('AnimationSteeringUpdate', () => {
  it('extracts MinTransitionTime into transitionFrames', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SteeringUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'AnimationSteeringUpdate ModuleTag_AnimSteer', {
            MinTransitionTime: 100, // 100ms -> 3 frames
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SteeringUnit', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        animationSteeringProfile: { transitionFrames: number } | null;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.animationSteeringProfile).toBeTruthy();
    expect(entity.animationSteeringProfile?.transitionFrames).toBe(3);
  });

  it('transitions turn model conditions with transition-frame gating', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SteeringUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'AnimationSteeringUpdate ModuleTag_AnimSteer', {
            MinTransitionTime: 100, // 3 frames
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SteeringUnit', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      frameCounter: number;
      spawnedEntities: Map<number, {
        rotationY: number;
        modelConditionFlags: Set<string>;
        animationSteeringCurrentTurnAnim: string | null;
        animationSteeringNextTransitionFrame: number;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    // Frame 1: negative turn delta => CENTER_TO_RIGHT.
    entity.rotationY -= 0.5;
    logic.update(1 / 30);
    expect(entity.animationSteeringCurrentTurnAnim).toBe('CENTER_TO_RIGHT');
    expect(entity.modelConditionFlags.has('CENTER_TO_RIGHT')).toBe(true);
    const firstTransitionFrame = entity.animationSteeringNextTransitionFrame;
    expect(firstTransitionFrame).toBeGreaterThan(priv.frameCounter);

    // Frames 2-3: no turn, but still in transition lock window.
    logic.update(1 / 30);
    logic.update(1 / 30);
    expect(priv.frameCounter).toBeLessThan(firstTransitionFrame);
    expect(entity.animationSteeringCurrentTurnAnim).toBe('CENTER_TO_RIGHT');
    expect(entity.modelConditionFlags.has('CENTER_TO_RIGHT')).toBe(true);

    // Frame 4: transition window elapsed, recenter to RIGHT_TO_CENTER.
    logic.update(1 / 30);
    expect(entity.animationSteeringCurrentTurnAnim).toBe('RIGHT_TO_CENTER');
    expect(entity.modelConditionFlags.has('CENTER_TO_RIGHT')).toBe(false);
    expect(entity.modelConditionFlags.has('RIGHT_TO_CENTER')).toBe(true);

    // Hold recenter animation until its own transition time expires.
    logic.update(1 / 30);
    logic.update(1 / 30);
    expect(entity.animationSteeringCurrentTurnAnim).toBe('RIGHT_TO_CENTER');
    expect(entity.modelConditionFlags.has('RIGHT_TO_CENTER')).toBe(true);

    // Next eligible frame with TURN_NONE clears recenter flags and returns to INVALID.
    logic.update(1 / 30);
    expect(entity.animationSteeringCurrentTurnAnim).toBeNull();
    expect(entity.modelConditionFlags.has('LEFT_TO_CENTER')).toBe(false);
    expect(entity.modelConditionFlags.has('RIGHT_TO_CENTER')).toBe(false);
  });
});

describe('TensileFormationUpdate', () => {
  it('extracts Enabled and CrackSound from INI', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CollapseChunk', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'TensileFormationUpdate ModuleTag_Tensile', {
            Enabled: true,
            CrackSound: 'BuildingCollapseCrack',
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('CollapseChunk', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        tensileFormationProfile: { enabled: boolean; crackSound: string } | null;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.tensileFormationProfile).toBeTruthy();
    expect(entity.tensileFormationProfile?.enabled).toBe(true);
    expect(entity.tensileFormationProfile?.crackSound).toBe('BuildingCollapseCrack');
  });

  it('enables on damaged state, sets collapse flags, and propagates BODY_DAMAGED', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CollapseChunk', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'TensileFormationUpdate ModuleTag_Tensile', {
            Enabled: false,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CollapseChunk', 20, 20), // id 1
        makeMapObject('CollapseChunk', 26, 20), // id 2, within 100 range
      ], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        modelConditionFlags: Set<string>;
      }>;
    };
    const first = priv.spawnedEntities.get(1)!;
    const second = priv.spawnedEntities.get(2)!;

    // Make the first member BODY_DAMAGED (health <= 49).
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, first, 60, 'CRUSH');
    expect(first.health).toBe(40);
    expect(second.health).toBe(100);

    // At life 29, propagateDislodgement should set nearby members to BODY_DAMAGED.
    for (let i = 0; i < 29; i++) {
      logic.update(1 / 30);
    }

    expect(first.modelConditionFlags.has('POST_COLLAPSE')).toBe(true);
    expect(first.modelConditionFlags.has('MOVING')).toBe(true);
    expect(second.health).toBe(49); // ActiveBody::setDamageState(BODY_DAMAGED): max*0.5 - 1
  });

  it('enters rubble state after life exceeds 300 frames', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CollapseChunk', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'TensileFormationUpdate ModuleTag_Tensile', {
            Enabled: true,
          }),
        ]),
      ],
    });

    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('CollapseChunk', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        destroyed: boolean;
        modelConditionFlags: Set<string>;
        tensileFormationState: { done: boolean } | null;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    for (let i = 0; i < 301; i++) {
      logic.update(1 / 30);
    }

    expect(entity.tensileFormationState?.done).toBe(true);
    expect(entity.health).toBe(0);
    expect(entity.destroyed).toBe(false);
    expect(entity.modelConditionFlags.has('POST_COLLAPSE')).toBe(false);
    expect(entity.modelConditionFlags.has('MOVING')).toBe(false);
    expect(entity.modelConditionFlags.has('FREEFALL')).toBe(false);
  });
});

// 
// UndeadBody
// 

describe('UndeadBody', () => {
  it('extracts UNDEAD body type and SecondLifeMaxHealth from INI', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UndeadUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'UndeadBody ModuleTag_Body', {
            MaxHealth: 200,
            InitialHealth: 200,
            SecondLifeMaxHealth: 50,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('UndeadUnit', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        bodyType: string;
        undeadSecondLifeMaxHealth: number;
        undeadIsSecondLife: boolean;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.bodyType).toBe('UNDEAD');
    expect(entity.undeadSecondLifeMaxHealth).toBe(50);
    expect(entity.undeadIsSecondLife).toBe(false);
  });

  it('caps fatal damage on first life and transitions to second life', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UndeadUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'UndeadBody ModuleTag_Body', {
            MaxHealth: 200,
            InitialHealth: 200,
            SecondLifeMaxHealth: 50,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('UndeadUnit', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        maxHealth: number;
        destroyed: boolean;
        bodyType: string;
        undeadIsSecondLife: boolean;
        armorSetFlagsMask: number;
        modelConditionFlags: Set<string>;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    // Apply fatal damage  should NOT kill, should trigger second life.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, entity, 9999, 'EXPLOSION');

    expect(entity.destroyed).toBe(false);
    expect(entity.undeadIsSecondLife).toBe(true);
    expect(entity.maxHealth).toBe(50);
    expect(entity.health).toBe(50); // FULLY_HEAL at new max health
    expect(entity.armorSetFlagsMask & (1 << 5)).not.toBe(0); // ARMOR_SET_FLAG_SECOND_LIFE
    expect(entity.modelConditionFlags.has('SECOND_LIFE')).toBe(true);
  });

  it('takes normal damage on second life and dies normally', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UndeadUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'UndeadBody ModuleTag_Body', {
            MaxHealth: 200,
            InitialHealth: 200,
            SecondLifeMaxHealth: 50,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('UndeadUnit', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        maxHealth: number;
        destroyed: boolean;
        undeadIsSecondLife: boolean;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    const applyDmg = (d: number, dt: string) =>
      (logic as unknown as {
        applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
      }).applyWeaponDamageAmount(null, entity, d, dt);

    // First: trigger second life.
    applyDmg(9999, 'EXPLOSION');
    expect(entity.undeadIsSecondLife).toBe(true);
    expect(entity.health).toBe(50);

    // Second: apply fatal damage on second life  should die normally.
    applyDmg(9999, 'EXPLOSION');
    logic.update(1 / 30);
    expect(entity.health).toBe(0);
    expect(entity.destroyed).toBe(true);
  });

  it('non-fatal damage on first life does not trigger second life', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UndeadUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'UndeadBody ModuleTag_Body', {
            MaxHealth: 200,
            InitialHealth: 200,
            SecondLifeMaxHealth: 50,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('UndeadUnit', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        maxHealth: number;
        destroyed: boolean;
        undeadIsSecondLife: boolean;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    // Apply non-fatal damage (100 out of 200 HP)  should NOT trigger second life.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, entity, 100, 'EXPLOSION');

    expect(entity.destroyed).toBe(false);
    expect(entity.undeadIsSecondLife).toBe(false);
    expect(entity.maxHealth).toBe(200); // unchanged
    expect(entity.health).toBe(100); // took normal damage
  });

  it('UNRESISTABLE damage kills on first life without second life', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UndeadUnit', 'GLA', ['VEHICLE'], [
          makeBlock('Body', 'UndeadBody ModuleTag_Body', {
            MaxHealth: 200,
            InitialHealth: 200,
            SecondLifeMaxHealth: 50,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('UndeadUnit', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        health: number;
        destroyed: boolean;
        undeadIsSecondLife: boolean;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    // UNRESISTABLE should bypass the second life mechanic.
    (logic as unknown as {
      applyWeaponDamageAmount(a: null, t: unknown, d: number, dt: string): void;
    }).applyWeaponDamageAmount(null, entity, 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(entity.undeadIsSecondLife).toBe(false);
    expect(entity.health).toBe(0);
    expect(entity.destroyed).toBe(true);
  });
});

// 
// LockWeaponCreate
// 

describe('LockWeaponCreate', () => {
  it('extracts weapon slot lock from INI and applies on creation', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('LockedUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'LockWeaponCreate ModuleTag_LWC', {
            SlotToLock: 'SECONDARY_WEAPON',
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('LockedUnit', 50, 50)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        lockWeaponCreateSlot: number | null;
        forcedWeaponSlot: number | null;
        weaponLockStatus: string;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.lockWeaponCreateSlot).toBe(1); // SECONDARY_WEAPON
    expect(entity.forcedWeaponSlot).toBe(1);
    expect(entity.weaponLockStatus).toBe('LOCKED_PERMANENTLY');
  });

  it('locks PRIMARY_WEAPON by default', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('LockedUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'LockWeaponCreate ModuleTag_LWC', {
            SlotToLock: 'PRIMARY_WEAPON',
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('LockedUnit', 50, 50)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        forcedWeaponSlot: number | null;
        weaponLockStatus: string;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;
    expect(entity.forcedWeaponSlot).toBe(0); // PRIMARY_WEAPON
    expect(entity.weaponLockStatus).toBe('LOCKED_PERMANENTLY');
  });
});

// 
// ExperienceScalarUpgrade
// 

describe('ExperienceScalarUpgrade', () => {
  it('adds XP scalar on upgrade application', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScalarUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'ExperienceScalarUpgrade ModuleTag_XPScalar', {
            TriggeredBy: 'Upgrade_XPBoost',
            AddXPScalar: 0.5,
          }),
        ], {
          ExperienceRequired: '100 200 400',
          ExperienceValue: 50,
        }),
      ],
      upgrades: [makeUpgradeDef('Upgrade_XPBoost', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('ScalarUnit', 100, 100)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        experienceState: { experienceScalar: number };
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    // Before upgrade: scalar should be 1.0 (default).
    expect(entity.experienceState.experienceScalar).toBe(1.0);

    // Apply upgrade.
    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_XPBoost' });
    logic.update(1 / 30);

    // After upgrade: scalar should be 1.0 + 0.5 = 1.5.
    expect(entity.experienceState.experienceScalar).toBe(1.5);
  });
});

// 
// ModelConditionUpgrade
// 

describe('ModelConditionUpgrade', () => {
  it('sets model condition flag on upgrade application', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CondUnit', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'ModelConditionUpgrade ModuleTag_MCU', {
            TriggeredBy: 'Upgrade_Visual',
            ConditionFlag: 'UPGRADE',
          }),
        ]),
      ],
      upgrades: [makeUpgradeDef('Upgrade_Visual', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('CondUnit', 50, 50)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        modelConditionFlags: Set<string>;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    expect(entity.modelConditionFlags.has('UPGRADE')).toBe(false);

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Visual' });
    logic.update(1 / 30);

    expect(entity.modelConditionFlags.has('UPGRADE')).toBe(true);
  });
});

// 
// ObjectCreationUpgrade
// 

describe('ObjectCreationUpgrade', () => {
  it('spawns OCL entities on upgrade application', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OCLUpgradeBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'ObjectCreationUpgrade ModuleTag_OCU', {
            TriggeredBy: 'Upgrade_SpawnDrone',
            UpgradeObject: 'OCL_SpawnDrone',
          }),
        ]),
        makeObjectDef('DroneUnit', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 50, InitialHealth: 50 }),
        ]),
      ],
      upgrades: [makeUpgradeDef('Upgrade_SpawnDrone', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });
    // Add OCL definition to bundle.
    (bundle as Record<string, unknown>).objectCreationLists = [
      {
        name: 'OCL_SpawnDrone',
        fields: {},
        blocks: [{
          type: 'CreateObject',
          name: 'CreateObject',
          fields: { ObjectNames: 'DroneUnit', Count: '1' },
          blocks: [],
        }],
      },
    ];
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('OCLUpgradeBuilding', 100, 100)]), makeRegistry(bundle), makeHeightmap());

    // Before upgrade: only 1 entity.
    expect(logic.getEntityState(1)).toBeDefined();
    expect(logic.getEntityState(2)).toBeNull();

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_SpawnDrone' });
    logic.update(1 / 30);

    // After upgrade: OCL should have spawned a DroneUnit.
    const droneState = logic.getEntityState(2);
    expect(droneState).toBeDefined();
    expect(droneState!.templateName).toBe('DroneUnit');
  });
});

// 
// ActiveShroudUpgrade
// 

describe('ActiveShroudUpgrade', () => {
  it('sets entity shroud range (not vision range) on upgrade application', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ShroudUnit', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Behavior', 'ActiveShroudUpgrade ModuleTag_ASU', {
            TriggeredBy: 'Upgrade_Shroud',
            NewShroudRange: 500,
          }),
        ], { VisionRange: 200 }),
      ],
      upgrades: [makeUpgradeDef('Upgrade_Shroud', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('ShroudUnit', 80, 80)]), makeRegistry(bundle), makeHeightmap());
    const priv = logic as unknown as {
      spawnedEntities: Map<number, {
        visionRange: number;
        shroudRange: number;
      }>;
    };
    const entity = priv.spawnedEntities.get(1)!;

    // Source parity: ActiveShroudUpgrade sets shroudRange, NOT visionRange.
    expect(entity.shroudRange).toBe(0);
    expect(entity.visionRange).toBe(200);

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Shroud' });
    logic.update(1 / 30);

    expect(entity.shroudRange).toBe(500);
    expect(entity.visionRange).toBe(200); // visionRange unchanged
  });
});

// 
// ReplaceObjectUpgrade
// 

describe('ReplaceObjectUpgrade', () => {
  it('destroys old entity and spawns replacement at same position', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OldBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'ReplaceObjectUpgrade ModuleTag_ROU', {
            TriggeredBy: 'Upgrade_Replace',
            ReplaceObject: 'NewBuilding',
          }),
        ]),
        makeObjectDef('NewBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 }),
        ]),
      ],
      upgrades: [makeUpgradeDef('Upgrade_Replace', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('OldBuilding', 50, 50)]), makeRegistry(bundle), makeHeightmap());

    // Entity 1 is OldBuilding.
    expect(logic.getEntityState(1)!.templateName).toBe('OldBuilding');

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_Replace' });
    logic.update(1 / 30);

    // Old entity should be destroyed and finalized (removed from map after update).
    expect(logic.getEntityState(1)).toBeNull();

    // New entity should exist as entity 2.
    const newState = logic.getEntityState(2);
    expect(newState).toBeDefined();
    expect(newState!.templateName).toBe('NewBuilding');
    // Same position as old entity.
    expect(newState!.x).toBeCloseTo(50, 0);
    expect(newState!.z).toBeCloseTo(50, 0);
    // Verify replacement has correct max health via internal state.
    const priv = logic as unknown as { spawnedEntities: Map<number, { maxHealth: number; side: string }> };
    const newEntity = priv.spawnedEntities.get(2)!;
    expect(newEntity.maxHealth).toBe(800);
    expect(newEntity.side).toBe('America');
  });

  it('fires onBuildComplete hooks on replacement entity', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OldFactory', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
          makeBlock('Behavior', 'ReplaceObjectUpgrade ModuleTag_ROU', {
            TriggeredBy: 'Upgrade_ReplaceFactory',
            ReplaceObject: 'NewFactory',
          }),
        ]),
        makeObjectDef('NewFactory', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
          makeBlock('Behavior', 'GrantUpgradeCreate ModuleTag_GUC', {
            UpgradeToGrant: 'Upgrade_FactoryBonus',
          }),
        ]),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_ReplaceFactory', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 }),
        makeUpgradeDef('Upgrade_FactoryBonus', { Type: 'OBJECT', BuildTime: 0.1, BuildCost: 0 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('OldFactory', 60, 60)]), makeRegistry(bundle), makeHeightmap());

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_ReplaceFactory' });
    logic.update(1 / 30);

    // The replacement entity should have received GrantUpgradeCreate's onBuildComplete,
    // which grants Upgrade_FactoryBonus to the entity.
    const priv = logic as unknown as { spawnedEntities: Map<number, { completedUpgrades: Set<string> }> };
    const newEntity = priv.spawnedEntities.get(2);
    expect(newEntity).toBeDefined();
    expect(newEntity!.completedUpgrades.has('UPGRADE_FACTORYBONUS')).toBe(true);
  });

  it('applies VeterancyGainCreate on replacement using final owner side sciences', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OldVehicle', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
          makeBlock('Behavior', 'ReplaceObjectUpgrade ModuleTag_ROU', {
            TriggeredBy: 'Upgrade_ReplaceVehicle',
            ReplaceObject: 'NewVehicle',
          }),
        ]),
        makeObjectDef('NewVehicle', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
          makeBlock('Behavior', 'VeterancyGainCreate ModuleTag_VetCreate', {
            StartingLevel: 'VETERAN',
            ScienceRequired: 'SCIENCE_REPLACE_VET',
          }),
        ], { ExperienceRequired: [0, 50, 200, 500], ExperienceValue: [10, 20, 30, 40] }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_ReplaceVehicle', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 }),
      ],
      sciences: [makeScienceDef('SCIENCE_REPLACE_VET', { IsGrantable: 'Yes' })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    (logic as unknown as { sideSciences: Map<string, Set<string>> }).sideSciences.set(
      'america',
      new Set(['SCIENCE_REPLACE_VET']),
    );
    logic.loadMapObjects(makeMap([makeMapObject('OldVehicle', 80, 80)]), makeRegistry(bundle), makeHeightmap());

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_ReplaceVehicle' });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      spawnedEntities: Map<number, { side: string; experienceState: { currentLevel: number } }>;
    };
    const replacement = priv.spawnedEntities.get(2);
    expect(replacement).toBeDefined();
    expect(replacement!.side).toBe('America');
    expect(replacement!.experienceState.currentLevel).toBe(1);
  });

  it('refreshes navigation grid after replacement structure construction callback', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('OldStruct', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'ReplaceObjectUpgrade ModuleTag_ROU', {
            TriggeredBy: 'Upgrade_ReplaceStruct',
            ReplaceObject: 'NewStruct',
          }),
        ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('NewStruct', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 700, InitialHealth: 700 }),
        ], { GeometryMajorRadius: 35, GeometryMinorRadius: 35 }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_ReplaceStruct', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('OldStruct', 100, 100)], 128, 128), makeRegistry(bundle), makeHeightmap(128, 128));

    const privBefore = logic as unknown as { navigationGrid: { blocked: Uint8Array } | null };
    const beforeBlocked = Array.from(privBefore.navigationGrid!.blocked);

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_ReplaceStruct' });
    logic.update(1 / 30);

    const privAfter = logic as unknown as {
      navigationGrid: { blocked: Uint8Array } | null;
      spawnedEntities: Map<number, { templateName: string }>;
    };
    expect(privAfter.spawnedEntities.get(2)?.templateName).toBe('NewStruct');
    const afterBlocked = Array.from(privAfter.navigationGrid!.blocked);

    let changedCells = 0;
    for (let i = 0; i < beforeBlocked.length; i++) {
      if (beforeBlocked[i] !== afterBlocked[i]) changedCells++;
    }
    expect(changedCells).toBeGreaterThan(0);
  });

  it('returns false for unknown replacement template', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BadReplaceBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Behavior', 'ReplaceObjectUpgrade ModuleTag_ROU', {
            TriggeredBy: 'Upgrade_BadReplace',
            ReplaceObject: 'NonExistentTemplate',
          }),
        ]),
      ],
      upgrades: [makeUpgradeDef('Upgrade_BadReplace', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('BadReplaceBuilding', 70, 70)]), makeRegistry(bundle), makeHeightmap());

    logic.submitCommand({ type: 'applyUpgrade', entityId: 1, upgradeName: 'Upgrade_BadReplace' });
    logic.update(1 / 30);

    // Entity should still exist and not be destroyed (template not found  no replacement).
    const priv = logic as unknown as { spawnedEntities: Map<number, { destroyed: boolean }> };
    expect(priv.spawnedEntities.get(1)!.destroyed).toBe(false);
  });
});

// 
// SpecialPowerCreate
// 

describe('SpecialPowerCreate', () => {
  it('starts non-shared special power countdown when building completes construction', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SuperweaponBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SuperWeapon', {
            SpecialPowerTemplate: 'SuperweaponParticleCannon',
          }),
        ], { BuildTime: 0.5 }),
        makeObjectDef('Dozer', 'America', ['DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SuperweaponParticleCannon', { ReloadTime: 6000 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    // Place dozer right at the build site so it doesn't need to walk.
    logic.loadMapObjects(makeMap([makeMapObject('Dozer', 100, 100)]), makeRegistry(bundle), makeHeightmap());

    // Place a building via dozer.
    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'SuperweaponBuilding',
      targetPosition: [100, 0, 100] as const,
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30);

    const priv = logic as unknown as {
      shortcutSpecialPowerSourceByName: Map<string, Map<number, number>>;
      frameCounter: number;
    };

    // Before construction completes: no special power timer set.
    const beforeSources = priv.shortcutSpecialPowerSourceByName.get('SUPERWEAPONPARTICLECANNON');
    expect(beforeSources?.size ?? 0).toBe(0);

    // Fast-forward construction to completion (0.5s = 15 frames + margin).
    for (let i = 0; i < 25; i++) {
      logic.update(1 / 30);
    }

    // After construction completes: special power timer should be set.
    const afterSources = priv.shortcutSpecialPowerSourceByName.get('SUPERWEAPONPARTICLECANNON');
    expect(afterSources).toBeDefined();
    expect(afterSources!.size).toBe(1);

    // Non-shared power: readyFrame = completionFrame + reloadFrames.
    // ReloadTime 6000ms = 180 frames. Ready frame should be ~completionFrame + 180.
    const readyFrame = afterSources!.values().next().value;
    expect(readyFrame).toBeGreaterThan(priv.frameCounter);
  });

  it('emits SUPERWEAPON_DETECTED EVA on superweapon structure completion with own/ally/enemy relationships', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SuperweaponBuilding', 'America', ['STRUCTURE', 'FS_SUPERWEAPON'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SuperWeapon', {
            SpecialPowerTemplate: 'SuperweaponParticleCannon',
          }),
        ], { BuildTime: 0.5 }),
        makeObjectDef('Dozer', 'America', ['DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('AllyScout', 'China', ['INFANTRY'], []),
        makeObjectDef('EnemyScout', 'GLA', ['INFANTRY'], []),
      ],
      specialPowers: [
        makeSpecialPowerDef('SuperweaponParticleCannon', { ReloadTime: 6000 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Dozer', 100, 100),      // id 1 (America)
        makeMapObject('AllyScout', 20, 20),    // id 2 (China)
        makeMapObject('EnemyScout', 30, 30),   // id 3 (GLA)
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // China is allied with America; GLA remains non-allied (treated as enemy for EVA).
    logic.setTeamRelationship('China', 'America', 2);
    logic.setTeamRelationship('America', 'China', 2);

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'SuperweaponBuilding',
      targetPosition: [100, 0, 100] as const,
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30);

    // Complete construction.
    for (let i = 0; i < 25; i += 1) {
      logic.update(1 / 30);
    }

    const detected = logic
      .drainEvaEvents()
      .filter((event) => event.type === 'SUPERWEAPON_DETECTED'
        && (event.detail ?? '').toUpperCase() === 'SUPERWEAPONPARTICLECANNON');

    expect(detected.some((event) => event.side === 'america' && event.relationship === 'own')).toBe(true);
    expect(detected.some((event) => event.side === 'china' && event.relationship === 'ally')).toBe(true);
    expect(detected.some((event) => event.side === 'gla' && event.relationship === 'enemy')).toBe(true);
  });

  it('map-placed building with SpecialPowerCreate starts timer immediately', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SuperweaponBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SuperWeapon', {
            SpecialPowerTemplate: 'SuperweaponParticleCannon',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SuperweaponParticleCannon', { ReloadTime: 6000 }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('SuperweaponBuilding', 100, 100)]), makeRegistry(bundle), makeHeightmap());

    const priv = logic as unknown as {
      shortcutSpecialPowerSourceByName: Map<string, Map<number, number>>;
      frameCounter: number;
    };

    // Map-placed building born complete: timer starts immediately at creation.
    const sources = priv.shortcutSpecialPowerSourceByName.get('SUPERWEAPONPARTICLECANNON');
    expect(sources).toBeDefined();
    expect(sources!.size).toBe(1);
    const readyFrame = sources!.values().next().value;
    // ReloadTime 6000ms = 180 frames. Ready at frame 0 + 180 = 180.
    expect(readyFrame).toBe(180);
  });

  it('shared synced power is ready immediately on build complete', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2000, InitialHealth: 2000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_GenPower', {
            SpecialPowerTemplate: 'GeneralsPower_Paladin',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('GeneralsPower_Paladin', {
          ReloadTime: 3000,
          SharedSyncedTimer: true,
        }),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(makeMap([makeMapObject('CommandCenter', 100, 100)]), makeRegistry(bundle), makeHeightmap());

    const priv = logic as unknown as {
      shortcutSpecialPowerSourceByName: Map<string, Map<number, number>>;
      sharedShortcutSpecialPowerReadyFrames: Map<string, number>;
      frameCounter: number;
    };

    // SharedNSync power: ready immediately (readyFrame = currentFrame = 0).
    const sharedReady = priv.sharedShortcutSpecialPowerReadyFrames.get('GENERALSPOWER_PALADIN');
    expect(sharedReady).toBe(0);
  });
});

describe('onStructureConstructionComplete parity hooks', () => {
  it('tracks structure score and script topology notifications on completion', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('ScoreBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ], { BuildCost: 500, BuildTime: 0.5 }),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 100, 100)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setSideCredits('America', 5000);

    expect(logic.getSideScoreState('America')).toEqual({ structuresBuilt: 0, moneySpent: 0 });
    expect(logic.getScriptObjectTopologyVersion()).toBe(0);

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'ScoreBuilding',
      targetPosition: [100, 0, 100] as const,
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30);

    for (let i = 0; i < 25; i += 1) {
      logic.update(1 / 30);
    }

    expect(logic.getSideScoreState('America')).toEqual({ structuresBuilt: 1, moneySpent: 500 });
    expect(logic.getScriptObjectTopologyVersion()).toBe(2);
    expect(logic.getScriptObjectCountChangedFrame()).toBeGreaterThan(0);
  });

  it('notifies skirmish AI on produced structure completion', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Dozer', 'America', ['DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('PatriotBattery', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ], { BuildCost: 800, BuildTime: 0.5 }),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Dozer', 80, 80)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.setSideCredits('America', 5000);
    logic.enableSkirmishAI('America');

    const priv = logic as unknown as {
      skirmishAIStates: Map<string, { builtStructureKeywords: Set<string> }>;
    };
    expect(priv.skirmishAIStates.get('america')?.builtStructureKeywords.has('PATRIOT')).toBe(false);

    logic.submitCommand({
      type: 'constructBuilding',
      entityId: 1,
      templateName: 'PatriotBattery',
      targetPosition: [80, 0, 80] as const,
      angle: 0,
      lineEndPosition: null,
    });
    logic.update(1 / 30);

    for (let i = 0; i < 25; i += 1) {
      logic.update(1 / 30);
    }

    expect(priv.skirmishAIStates.get('america')?.builtStructureKeywords.has('PATRIOT')).toBe(true);
  });

  it('updates script object-change frame when an entity is removed from world', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Target', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Target', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    expect(logic.getScriptObjectTopologyVersion()).toBe(0);
    expect(logic.getScriptObjectCountChangedFrame()).toBe(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
      frameCounter: number;
    };
    const target = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(null, target, 200, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.getEntityState(1)).toBeNull();
    expect(logic.getScriptObjectTopologyVersion()).toBe(1);
    expect(logic.getScriptObjectCountChangedFrame()).toBe(privateApi.frameCounter);
  });
});

describe('Script object-count + trigger groundwork', () => {
  it('provides script object-count filtering and change-since-frame checks', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('UnitB', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('UnitA', 10, 10),
        makeMapObject('UnitA', 12, 10),
        makeMapObject('UnitB', 20, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.getScriptObjectCount()).toBe(3);
    expect(logic.getScriptObjectCount({ side: 'America' })).toBe(2);
    expect(logic.getScriptObjectCount({ templateName: 'UnitA' })).toBe(2);
    expect(logic.getScriptObjectCount({ kindOfAll: ['INFANTRY'] })).toBe(3);
    expect(logic.didScriptObjectCountChangeSince(0)).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.getScriptObjectCount()).toBe(2);
    expect(logic.getScriptObjectCount({ side: 'America' })).toBe(1);
    expect(logic.didScriptObjectCountChangeSince(0)).toBe(true);
  });

  it('counts entities inside named map trigger polygons', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericanUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('ChineseUnit', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('AmericanUnit', 5, 5),
      makeMapObject('ChineseUnit', 10, 10),
      makeMapObject('ChineseUnit', 60, 60),
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'SpawnZone',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 0, y: 0, z: 0 },
        { x: 20, y: 0, z: 0 },
        { x: 20, y: 20, z: 0 },
        { x: 0, y: 20, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));

    expect(logic.getMapTriggerNames()).toEqual(['SpawnZone']);
    expect(logic.isPointInsideMapTrigger('SpawnZone', 6, 6)).toBe(true);
    expect(logic.isPointInsideMapTrigger('SpawnZone', 50, 50)).toBe(false);
    expect(logic.getScriptObjectCount({ triggerName: 'SpawnZone' })).toBe(2);
    expect(logic.getScriptObjectCount({ triggerName: 'SpawnZone', side: 'America' })).toBe(1);
    expect(logic.getScriptObjectCount({ triggerName: 'UnknownZone' })).toBe(0);
  });
});

describe('Map script execution', () => {
  it('runs map scripts from sides list and resolves player-side names', () => {
    const bundle = makeBundle({
      objects: [],
      factions: [{
        name: 'FactionAmerica',
        side: 'America',
        fields: {},
      }],
    });

    const map = makeMap([]);
    map.sidesList = {
      sides: [{
        dict: {
          playerName: 'Player_1',
          playerFaction: 'FactionAmerica',
          skirmishDifficulty: 1,
        },
        buildList: [],
        scripts: {
          scripts: [{
            name: 'InitScript',
            comment: '',
            conditionComment: '',
            actionComment: '',
            active: true,
            oneShot: true,
            easy: true,
            normal: true,
            hard: true,
            subroutine: false,
            delayEvaluationSeconds: 0,
            conditions: [{
              conditions: [{
                conditionType: 3, // CONDITION_TRUE
                params: [],
              }],
            }],
            actions: [{
              actionType: 1, // SET_FLAG
              params: [
                { type: 5, intValue: 0, realValue: 0, stringValue: 'MissionFlag' },
                { type: 8, intValue: 1, realValue: 0, stringValue: '' },
              ],
            }, {
              actionType: 154, // PLAYER_SET_MONEY
              params: [
                { type: 11, intValue: 0, realValue: 0, stringValue: 'Player_1' },
                { type: 0, intValue: 1500, realValue: 0, stringValue: '' },
              ],
            }],
            falseActions: [],
          }],
          groups: [],
        },
      }],
      teams: [{
        dict: {
          teamName: 'teamPlayer_1',
          teamOwner: 'Player_1',
          teamIsSingleton: true,
        },
      }],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap());
    logic.update(1 / 30);

    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', true],
    })).toBe(true);
    expect(logic.getSideCredits('America')).toBe(1500);
  });

  it('executes sequential scripts triggered by map scripts', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      factions: [{
        name: 'FactionAmerica',
        side: 'America',
        fields: {},
      }],
    });

    const map = makeMap([
      makeMapObject('ScriptUnit', 20, 20, {
        objectName: 'ScriptUnitAlpha',
        originalOwner: 'teamPlayer_1',
      }),
    ]);
    map.sidesList = {
      sides: [{
        dict: {
          playerName: 'Player_1',
          playerFaction: 'FactionAmerica',
        },
        buildList: [],
        scripts: {
          scripts: [{
            name: 'StartSeq',
            comment: '',
            conditionComment: '',
            actionComment: '',
            active: true,
            oneShot: true,
            easy: true,
            normal: true,
            hard: true,
            subroutine: false,
            delayEvaluationSeconds: 0,
            conditions: [{
              conditions: [{
                conditionType: 3, // CONDITION_TRUE
                params: [],
              }],
            }],
            actions: [{
              actionType: 392, // UNIT_EXECUTE_SEQUENTIAL_SCRIPT
              params: [
                { type: 14, intValue: 0, realValue: 0, stringValue: 'ScriptUnitAlpha' },
                { type: 2, intValue: 0, realValue: 0, stringValue: 'SeqScript' },
              ],
            }],
            falseActions: [],
          }, {
            name: 'SeqScript',
            comment: '',
            conditionComment: '',
            actionComment: '',
            active: true,
            oneShot: false,
            easy: true,
            normal: true,
            hard: true,
            subroutine: true,
            delayEvaluationSeconds: 0,
            conditions: [],
            actions: [{
              actionType: 1, // SET_FLAG
              params: [
                { type: 5, intValue: 0, realValue: 0, stringValue: 'SeqFlag' },
                { type: 8, intValue: 1, realValue: 0, stringValue: '' },
              ],
            }],
            falseActions: [],
          }],
          groups: [],
        },
      }],
      teams: [{
        dict: {
          teamName: 'teamPlayer_1',
          teamOwner: 'Player_1',
          teamIsSingleton: true,
        },
      }],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap());

    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['SeqFlag', true],
    })).toBe(false);

    logic.update(1 / 30);

    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['SeqFlag', true],
    })).toBe(true);
  });
});

describe('Script condition groundwork', () => {
  it('evaluates player object-comparison and built-by-player conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('UnitA', 10, 10),
        makeMapObject('UnitA', 14, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptPlayerHasObjectComparison({
      side: 'America',
      comparison: 3, // GREATER_EQUAL
      count: 2,
      templateName: 'UnitA',
      conditionCacheId: 'player-has-unita',
    })).toBe(true);
    expect(logic.evaluateScriptBuiltByPlayer({
      side: 'America',
      templateName: 'UnitA',
      conditionCacheId: 'built-unita',
    })).toBe(true);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptPlayerHasObjectComparison({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      count: 2,
      templateName: 'UnitA',
      conditionCacheId: 'player-has-unita',
    })).toBe(false);

    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptBuiltByPlayer({
      side: 'America',
      templateName: 'UnitA',
      conditionCacheId: 'built-unita',
    })).toBe(false);
  });

  it('evaluates player-unit-condition as object-comparison subset', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('UnitA', 10, 10), // id 1
        makeMapObject('UnitA', 12, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptPlayerUnitCondition({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      count: 2,
      unitType: 'UnitA',
      conditionCacheId: 'player-unit-condition-ge-2',
    })).toBe(true);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptPlayerUnitCondition({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      count: 2,
      unitType: 'UnitA',
      conditionCacheId: 'player-unit-condition-ge-2',
    })).toBe(false);
    expect(logic.evaluateScriptPlayerUnitCondition({
      side: 'America',
      comparison: 'EQUAL',
      count: 1,
      unitType: 'UnitA',
      conditionCacheId: 'player-unit-condition-eq-1',
    })).toBe(true);
  });

  it('evaluates enemy-sighted with relation, range, stealth, and same-map filters', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScoutA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 60 }),
        makeObjectDef('EnemyB', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('NeutralC', 'Civilian', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScoutA', 10, 10),   // id 1
        makeMapObject('EnemyB', 20, 10),   // id 2
        makeMapObject('NeutralC', 24, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0); // enemies
    logic.setTeamRelationship('China', 'America', 0); // enemies
    logic.setTeamRelationship('America', 'Civilian', 1); // neutral
    logic.setTeamRelationship('Civilian', 'America', 1); // neutral

    expect(logic.evaluateScriptEnemySighted({
      entityId: 1,
      alliance: 'ENEMY',
      side: 'China',
    })).toBe(true);
    expect(logic.evaluateScriptEnemySighted({
      entityId: 1,
      alliance: 'NEUTRAL',
      side: 'Civilian',
    })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number; objectStatusFlags: Set<string> }>;
    };
    privateApi.spawnedEntities.get(2)!.objectStatusFlags.add('STEALTHED');
    expect(logic.evaluateScriptEnemySighted({
      entityId: 1,
      alliance: 'ENEMY',
      side: 'China',
    })).toBe(false);

    privateApi.spawnedEntities.get(2)!.objectStatusFlags.add('DETECTED');
    expect(logic.evaluateScriptEnemySighted({
      entityId: 1,
      alliance: 'ENEMY',
      side: 'China',
    })).toBe(true);

    privateApi.spawnedEntities.get(2)!.x = -5;
    privateApi.spawnedEntities.get(2)!.z = -5;
    expect(logic.evaluateScriptEnemySighted({
      entityId: 1,
      alliance: 'ENEMY',
      side: 'China',
    })).toBe(false);
  });

  it('evaluates type-sighted as template subset with range, stealth, and same-map filters', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScoutA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 60 }),
        makeObjectDef('TankA', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
        makeObjectDef('TankB', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScoutA', 10, 10), // id 1
        makeMapObject('TankA', 20, 10),  // id 2
        makeMapObject('TankB', 90, 10),  // id 3 (out of range)
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptTypeSighted({
      entityId: 1,
      objectType: 'TankA',
      side: 'China',
    })).toBe(true);
    expect(logic.evaluateScriptTypeSighted({
      entityId: 1,
      objectType: 'TankB',
      side: 'China',
    })).toBe(false);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number; objectStatusFlags: Set<string> }>;
    };
    privateApi.spawnedEntities.get(2)!.objectStatusFlags.add('STEALTHED');
    expect(logic.evaluateScriptTypeSighted({
      entityId: 1,
      objectType: 'TankA',
      side: 'China',
    })).toBe(false);

    privateApi.spawnedEntities.get(2)!.objectStatusFlags.add('DETECTED');
    expect(logic.evaluateScriptTypeSighted({
      entityId: 1,
      objectType: 'TankA',
      side: 'China',
    })).toBe(true);

    privateApi.spawnedEntities.get(2)!.x = -4;
    privateApi.spawnedEntities.get(2)!.z = -4;
    expect(logic.evaluateScriptTypeSighted({
      entityId: 1,
      objectType: 'TankA',
      side: 'China',
    })).toBe(false);
  });

  it('evaluates bridge-broken and bridge-repaired only on bridge-change frames', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('BridgeAnchor', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('BridgeAnchor', 10, 10), // id 1
        makeMapObject('BridgeAnchor', 20, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      bridgeSegments: Map<number, { passable: boolean; cellIndices: number[]; transitionIndices: number[] }>;
      bridgeSegmentByControlEntity: Map<number, number>;
    };
    privateApi.bridgeSegments.set(0, { passable: true, cellIndices: [], transitionIndices: [] });
    privateApi.bridgeSegmentByControlEntity.set(1, 0);
    privateApi.bridgeSegmentByControlEntity.set(2, 0);

    expect(logic.evaluateScriptBridgeBroken({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptBridgeRepaired({ entityId: 1 })).toBe(false);

    logic.update(1 / 30);
    expect(logic.onObjectDestroyed(1)).toBe(true);
    expect(logic.evaluateScriptBridgeBroken({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptBridgeRepaired({ entityId: 1 })).toBe(false);

    logic.update(1 / 30);
    expect(logic.evaluateScriptBridgeBroken({ entityId: 1 })).toBe(false);
    expect(logic.onObjectRepaired(1)).toBe(true);
    expect(logic.evaluateScriptBridgeBroken({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptBridgeRepaired({ entityId: 1 })).toBe(true);

    logic.update(1 / 30);
    expect(logic.evaluateScriptBridgeRepaired({ entityId: 1 })).toBe(false);
  });

  it('evaluates all-destroyed, all-build-facilities-destroyed, and named-owned-by-player', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenterA', 'America', ['STRUCTURE', 'COMMANDCENTER', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
        makeObjectDef('FactoryA', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', { MaxQueueEntries: 3 }),
        ]),
        makeObjectDef('InfantryA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('TankA', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], {
          Prerequisites: 'OBJECT FactoryA',
        }),
        makeObjectDef('EnemyB', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CommandCenterA', 10, 10), // id 1
        makeMapObject('FactoryA', 20, 10),       // id 2
        makeMapObject('InfantryA', 30, 10),      // id 3
        makeMapObject('EnemyB', 40, 10),         // id 4
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptAllDestroyed({ side: 'America' })).toBe(false);
    expect(logic.evaluateScriptAllDestroyed({ side: 'UnknownSide' })).toBe(true);
    expect(logic.evaluateScriptAllBuildFacilitiesDestroyed({ side: 'America' })).toBe(false);
    expect(logic.evaluateScriptAllBuildFacilitiesDestroyed({ side: 'UnknownSide' })).toBe(true);

    expect(logic.evaluateScriptNamedOwnedByPlayer({ entityId: 4, side: 'China' })).toBe(true);
    expect(logic.evaluateScriptNamedOwnedByPlayer({ entityId: 4, side: 'America' })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };

    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    // No facilities left, but side still has infantry.
    expect(logic.evaluateScriptAllBuildFacilitiesDestroyed({ side: 'America' })).toBe(true);
    expect(logic.evaluateScriptAllDestroyed({ side: 'America' })).toBe(false);

    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(3), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    expect(logic.evaluateScriptAllDestroyed({ side: 'America' })).toBe(true);
  });

  it('evaluates named-discovered with held/stealth visibility gating', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScoutA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 40 }),
        makeObjectDef('ScoutC', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 40 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScoutA', 10, 10), // id 1
        makeMapObject('ScoutC', 15, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.update(1 / 30);
    expect(logic.evaluateScriptNamedDiscovered({ entityId: 1, side: 'China' })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    privateApi.spawnedEntities.get(1)!.objectStatusFlags.add('STEALTHED');
    expect(logic.evaluateScriptNamedDiscovered({ entityId: 1, side: 'China' })).toBe(false);

    privateApi.spawnedEntities.get(1)!.objectStatusFlags.add('DETECTED');
    expect(logic.evaluateScriptNamedDiscovered({ entityId: 1, side: 'China' })).toBe(true);

    privateApi.spawnedEntities.get(1)!.objectStatusFlags.add('DISABLED_HELD');
    expect(logic.evaluateScriptNamedDiscovered({ entityId: 1, side: 'China' })).toBe(false);
  });

  it('evaluates named-selected from current selection state', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Scout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Scout', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptNamedSelected({ entityId: 1 })).toBe(false);

    logic.submitCommand({ type: 'select', entityId: 1 });
    logic.update(0);
    expect(logic.evaluateScriptNamedSelected({ entityId: 1 })).toBe(true);

    logic.submitCommand({ type: 'clearSelection' });
    logic.update(0);
    expect(logic.evaluateScriptNamedSelected({ entityId: 1 })).toBe(false);
  });

  it('evaluates multiplayer allied-victory/allied-defeat/player-defeat conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('UnitC', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('UnitG', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const victoryLogic = new GameLogicSubsystem(new THREE.Scene());
    victoryLogic.loadMapObjects(
      makeMap([
        makeMapObject('UnitA', 10, 10), // id 1
        makeMapObject('UnitC', 20, 10), // id 2
        makeMapObject('UnitG', 30, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    victoryLogic.setPlayerSide(0, 'America');
    victoryLogic.setPlayerSide(1, 'China');
    victoryLogic.setPlayerSide(2, 'GLA');
    victoryLogic.setTeamRelationship('America', 'China', 2);
    victoryLogic.setTeamRelationship('China', 'America', 2);

    const victoryApi = victoryLogic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    victoryApi.applyWeaponDamageAmount(null, victoryApi.spawnedEntities.get(3), 9999, 'UNRESISTABLE');
    victoryLogic.update(1 / 30);

    expect(victoryLogic.evaluateScriptMultiplayerAlliedVictory()).toBe(true);
    expect(victoryLogic.evaluateScriptMultiplayerAlliedDefeat()).toBe(false);
    expect(victoryLogic.evaluateScriptMultiplayerPlayerDefeat()).toBe(false);

    const defeatLogic = new GameLogicSubsystem(new THREE.Scene());
    defeatLogic.loadMapObjects(
      makeMap([
        makeMapObject('UnitA', 10, 10), // id 1
        makeMapObject('UnitC', 20, 10), // id 2
        makeMapObject('UnitG', 30, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    defeatLogic.setPlayerSide(0, 'America');
    defeatLogic.setPlayerSide(1, 'China');
    defeatLogic.setPlayerSide(2, 'GLA');
    defeatLogic.setTeamRelationship('America', 'China', 2);
    defeatLogic.setTeamRelationship('China', 'America', 2);

    const defeatApi = defeatLogic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };

    // Local side (America) is defeated first while ally China is still alive.
    defeatApi.applyWeaponDamageAmount(null, defeatApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    defeatLogic.update(1 / 30);

    expect(defeatLogic.evaluateScriptMultiplayerAlliedVictory()).toBe(false);
    expect(defeatLogic.evaluateScriptMultiplayerAlliedDefeat()).toBe(false);
    expect(defeatLogic.evaluateScriptMultiplayerPlayerDefeat()).toBe(true);

    // Allies lose once China is also eliminated and only GLA remains.
    defeatApi.applyWeaponDamageAmount(null, defeatApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    defeatLogic.update(1 / 30);

    expect(defeatLogic.evaluateScriptMultiplayerAlliedDefeat()).toBe(true);
    expect(defeatLogic.evaluateScriptMultiplayerPlayerDefeat()).toBe(false);
  });

  it('keeps mission-attempt and player-destroyed-N-buildings conditions at source TODO behavior', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenterA', 'America', ['STRUCTURE', 'COMMANDCENTER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CommandCenterA', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptMissionAttempts({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      attempts: 1,
    })).toBe(false);
    expect(logic.evaluateScriptPlayerDestroyedNOrMoreBuildings({
      side: 'America',
      count: 1,
      opponentSide: 'China',
    })).toBe(false);
  });

  it('consumes video/speech/audio/music script completion events', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptVideoHasCompleted({ videoName: 'IntroMovie' })).toBe(false);
    logic.notifyScriptVideoCompleted('IntroMovie');
    expect(logic.evaluateScriptVideoHasCompleted({ videoName: 'IntroMovie' })).toBe(true);
    expect(logic.evaluateScriptVideoHasCompleted({ videoName: 'IntroMovie' })).toBe(false);

    expect(logic.evaluateScriptSpeechHasCompleted({ speechName: 'SpeechLineA' })).toBe(false);
    logic.notifyScriptSpeechCompleted('SpeechLineA');
    expect(logic.evaluateScriptSpeechHasCompleted({ speechName: 'SpeechLineA' })).toBe(true);
    expect(logic.evaluateScriptSpeechHasCompleted({ speechName: 'SpeechLineA' })).toBe(false);

    expect(logic.evaluateScriptAudioHasCompleted({ audioName: 'AudioCueA' })).toBe(false);
    logic.notifyScriptAudioCompleted('AudioCueA');
    expect(logic.evaluateScriptAudioHasCompleted({ audioName: 'AudioCueA' })).toBe(true);
    expect(logic.evaluateScriptAudioHasCompleted({ audioName: 'AudioCueA' })).toBe(false);

    expect(logic.evaluateScriptMusicHasCompleted({ musicName: 'TrackA', index: 2 })).toBe(false);
    logic.notifyScriptMusicCompleted('TrackA', 2);
    expect(logic.evaluateScriptMusicHasCompleted({ musicName: 'TrackA', index: 1 })).toBe(false);
    expect(logic.evaluateScriptMusicHasCompleted({ musicName: 'TrackA', index: 2 })).toBe(true);
    expect(logic.evaluateScriptMusicHasCompleted({ musicName: 'TrackA', index: 2 })).toBe(false);
  });

  it('dispatches script conditions using source enum names/indices and positional params', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setSideCredits('America', 1000);

    expect(logic.evaluateScriptCondition(null)).toBe(false);
    expect(logic.evaluateScriptCondition({ conditionType: 'UNKNOWN_CONDITION' })).toBe(false);
    expect(logic.evaluateScriptCondition({
      conditionType: 'CAMERA_MOVEMENT_FINISHED',
    })).toBe(true);
    logic.setScriptCameraMovementFinished(false);
    expect(logic.evaluateScriptCondition({
      conditionType: 9, // CAMERA_MOVEMENT_FINISHED
    })).toBe(false);
    logic.setScriptCameraMovementFinished(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'CAMERA_MOVEMENT_FINISHED',
    })).toBe(true);

    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_HAS_CREDITS',
      params: [1000, 'EQUAL', 'America'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 26, // PLAYER_HAS_CREDITS
      params: [1000, 'EQUAL', 'America'],
    })).toBe(true);

    expect(logic.evaluateScriptCondition({
      conditionType: 'ALL_DESTROYED', // alias to PLAYER_ALL_DESTROYED
      params: ['America'],
    })).toBe(false);

    expect(logic.evaluateScriptCondition({
      conditionType: 47, // HAS_FINISHED_VIDEO
      params: ['IntroMovie'],
    })).toBe(false);
    logic.notifyScriptVideoCompleted('IntroMovie');
    expect(logic.evaluateScriptCondition({
      conditionType: 'HAS_FINISHED_VIDEO',
      params: ['IntroMovie'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'HAS_FINISHED_VIDEO',
      params: ['IntroMovie'],
    })).toBe(false);

    expect(logic.evaluateScriptCondition({
      id: 'built-check',
      conditionType: 'BUILT_BY_PLAYER',
      params: ['Ranger', 'America'],
    })).toBe(true);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
      scriptConditionCacheById: Map<string, unknown>;
    };
    expect(privateApi.scriptConditionCacheById.has('SCRIPT_CONDITION:built-check')).toBe(true);
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptCondition({
      conditionType: 5, // PLAYER_ALL_DESTROYED
      params: ['America'],
    })).toBe(true);
  });

  it('evaluates CAMERA_MOVEMENT_FINISHED via TacticalView callback when provided', () => {
    let cameraMovementFinished = true;
    const logic = new GameLogicSubsystem(new THREE.Scene(), {
      isCameraMovementFinished: () => cameraMovementFinished,
    });
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptCondition({
      conditionType: 'CAMERA_MOVEMENT_FINISHED',
    })).toBe(true);

    cameraMovementFinished = false;
    expect(logic.evaluateScriptCondition({
      conditionType: 'CAMERA_MOVEMENT_FINISHED',
    })).toBe(false);

    // Callback parity: TacticalView state wins over local fallback.
    logic.setScriptCameraMovementFinished(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 9, // CAMERA_MOVEMENT_FINISHED
    })).toBe(false);

    cameraMovementFinished = true;
    expect(logic.evaluateScriptCondition({
      conditionType: 9, // CAMERA_MOVEMENT_FINISHED
    })).toBe(true);
  });

  it('evaluates COUNTER/FLAG/TIMER_EXPIRED condition types with source-style state', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    // Source parity: counters default to 0 when first referenced.
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['MissionCounter', 'EQUAL', 0],
    })).toBe(true);

    logic.setScriptCounter('MissionCounter', 5);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['MissionCounter', 'GREATER_EQUAL', 5],
    })).toBe(true);
    logic.addScriptCounter('MissionCounter', -2);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['MissionCounter', 'EQUAL', 3],
    })).toBe(true);

    // Source parity: flags default false and can be one-frame satisfied by UI interaction hooks.
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', 1],
    })).toBe(false);
    logic.setScriptFlag('MissionFlag', true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', 1],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', 0],
    })).toBe(false);
    logic.notifyScriptUIInteraction('MissionFlag');
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', 0],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', 0],
    })).toBe(false);

    // Source parity: countdown timer decrements every frame and expires when value < 1.
    expect(logic.evaluateScriptCondition({
      conditionType: 'TIMER_EXPIRED',
      params: ['MissionTimer'],
    })).toBe(false);
    logic.startScriptTimer('MissionTimer', 2);
    expect(logic.evaluateScriptCondition({
      conditionType: 'TIMER_EXPIRED',
      params: ['MissionTimer'],
    })).toBe(false);
    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'TIMER_EXPIRED',
      params: ['MissionTimer'],
    })).toBe(false);
    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'TIMER_EXPIRED',
      params: ['MissionTimer'],
    })).toBe(true);
    logic.pauseScriptTimer('MissionTimer');
    expect(logic.evaluateScriptCondition({
      conditionType: 'TIMER_EXPIRED',
      params: ['MissionTimer'],
    })).toBe(false);
  });

  it('executes script counter/flag/timer actions using source action ids and params', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );
    const privateApi = logic as unknown as {
      getSideRankStateMap: (side: string) => {
        rankLevel: number;
        skillPoints: number;
        sciencePurchasePoints: number;
      };
    };

    expect(logic.executeScriptAction(null)).toBe(false);
    expect(logic.executeScriptAction({ actionType: 'UNKNOWN_ACTION' })).toBe(false);
    expect(logic.executeScriptAction({ actionType: 5 })).toBe(true); // NO_OP
    expect(logic.executeScriptAction({ actionType: 9, params: ['Subroutine_Mission'] })).toBe(true); // DISABLE_SCRIPT
    expect(logic.isScriptActive('Subroutine_Mission')).toBe(false);
    expect(logic.executeScriptAction({ actionType: 'ENABLE_SCRIPT', params: ['Subroutine_Mission'] })).toBe(true);
    expect(logic.isScriptActive('Subroutine_Mission')).toBe(true);
    expect(logic.executeScriptAction({ actionType: 10, params: ['Subroutine_Mission'] })).toBe(true); // CALL_SUBROUTINE
    expect(logic.consumeScriptSubroutineCall('Subroutine_Mission')).toBe(true);
    expect(logic.consumeScriptSubroutineCall('Subroutine_Mission')).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 'SET_COUNTER',
      params: ['MissionCounter', 10],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 15, // INCREMENT_COUNTER
      params: [5, 'MissionCounter'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 'DECREMENT_COUNTER',
      params: [3, 'MissionCounter'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['MissionCounter', 'EQUAL', 12],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 1, // SET_FLAG
      params: ['MissionFlag', 1],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['MissionFlag', 1],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 'TEAM_SET_STATE',
      params: ['AlphaTeam', 'ATTACKING'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'TEAM_STATE_IS',
      params: ['AlphaTeam', 'ATTACKING'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 37, // TEAM_SET_STATE
      params: ['AlphaTeam', 'RETREATING'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'TEAM_STATE_IS_NOT',
      params: ['AlphaTeam', 'ATTACKING'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 153, // TEAM_TRANSFER_TO_PLAYER
      params: ['AlphaTeam', 'China'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'TEAM_OWNED_BY_PLAYER',
      params: ['AlphaTeam', 'China'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 154, // PLAYER_SET_MONEY
      params: ['America', 500],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_HAS_CREDITS',
      params: ['America', 'GREATER_EQUAL', 500],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 'PLAYER_GIVE_MONEY',
      params: ['America', -125],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_HAS_CREDITS',
      params: ['America', 'EQUAL', 375],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 272, // PLAYER_ADD_SKILLPOINTS
      params: ['America', 500],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(3);
    expect(privateApi.getSideRankStateMap('america').skillPoints).toBe(500);
    expect(logic.executeScriptAction({
      actionType: 273, // PLAYER_ADD_RANKLEVEL
      params: ['America', 1],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(4);
    expect(logic.executeScriptAction({
      actionType: 'PLAYER_SET_RANKLEVEL',
      params: ['America', 2],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(2);
    expect(privateApi.getSideRankStateMap('america').skillPoints).toBe(200);
    expect(logic.executeScriptAction({
      actionType: 275, // PLAYER_SET_RANKLEVELLIMIT
      params: [2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 272, // PLAYER_ADD_SKILLPOINTS
      params: ['America', 5000],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(2);
    expect(privateApi.getSideRankStateMap('america').skillPoints).toBe(200);

    expect(logic.executeScriptAction({
      actionType: 6, // SET_TIMER
      params: ['ActionTimer', 2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 149, // STOP_TIMER
      params: ['ActionTimer'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['ActionTimer', 'EQUAL', 2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 150, // RESTART_TIMER
      params: ['ActionTimer'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['ActionTimer', 'EQUAL', 1],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 20, // SET_MILLISECOND_TIMER
      params: ['SecondTimer', 1.5],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['SecondTimer', 'EQUAL', 45],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 151, // ADD_TO_MSEC_TIMER
      params: [0.25, 'SecondTimer'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['SecondTimer', 'EQUAL', 53],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 152, // SUB_FROM_MSEC_TIMER
      params: [0.25, 'SecondTimer'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['SecondTimer', 'EQUAL', 46],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 147, // SET_RANDOM_TIMER
      params: ['RandomFrameTimer', 3, 5],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['RandomFrameTimer', 'GREATER_EQUAL', 3],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['RandomFrameTimer', 'LESS_EQUAL', 5],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 148, // SET_RANDOM_MSEC_TIMER
      params: ['RandomSecondTimer', 1.0, 2.0],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['RandomSecondTimer', 'GREATER_EQUAL', 30],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'COUNTER',
      params: ['RandomSecondTimer', 'LESS_EQUAL', 60],
    })).toBe(true);
  });

  it('executes script science grant/purchase actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
      sciences: [
        makeScienceDef('SCIENCE_ALPHA', {
          SciencePurchasePointCost: 2,
          IsGrantable: 'Yes',
        }),
        makeScienceDef('SCIENCE_BETA', {
          SciencePurchasePointCost: 3,
          PrerequisiteSciences: 'SCIENCE_ALPHA',
          IsGrantable: 'Yes',
        }),
        makeScienceDef('SCIENCE_GAMMA', {
          SciencePurchasePointCost: 1,
          IsGrantable: 'Yes',
        }),
        makeScienceDef('SCIENCE_NOT_GRANTABLE', {
          SciencePurchasePointCost: 1,
          IsGrantable: 'No',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CommandCenter', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      getSideRankStateMap: (side: string) => { sciencePurchasePoints: number };
    };
    privateApi.getSideRankStateMap('america').sciencePurchasePoints = 5;

    expect(logic.executeScriptAction({
      actionType: 276, // PLAYER_GRANT_SCIENCE
      params: ['America', 'SCIENCE_ALPHA'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_ACQUIRED_SCIENCE',
      params: ['America', 'SCIENCE_ALPHA'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 277, // PLAYER_PURCHASE_SCIENCE
      params: ['America', 'SCIENCE_BETA'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_ACQUIRED_SCIENCE',
      params: ['America', 'SCIENCE_BETA'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_HAS_SCIENCEPURCHASEPOINTS',
      params: ['America', 2],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 'PLAYER_PURCHASE_SCIENCE',
      params: ['America', 'SCIENCE_BETA'],
    })).toBe(false);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_CAN_PURCHASE_SCIENCE',
      params: ['America', 'SCIENCE_GAMMA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 298, // PLAYER_SCIENCE_AVAILABILITY
      params: ['America', 'SCIENCE_GAMMA', 'Disabled'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_CAN_PURCHASE_SCIENCE',
      params: ['America', 'SCIENCE_GAMMA'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 'PLAYER_SCIENCE_AVAILABILITY',
      params: ['America', 'SCIENCE_GAMMA', 'Available'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_CAN_PURCHASE_SCIENCE',
      params: ['America', 'SCIENCE_GAMMA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 'PLAYER_SCIENCE_AVAILABILITY',
      params: ['America', 'SCIENCE_GAMMA', 'Hidden'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_CAN_PURCHASE_SCIENCE',
      params: ['America', 'SCIENCE_GAMMA'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 'PLAYER_GRANT_SCIENCE',
      params: ['America', 'SCIENCE_NOT_GRANTABLE'],
    })).toBe(false);
  });

  it('executes offset source action ids for rank/science actions and rejects hunt-with-command-button', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
      sciences: [
        makeScienceDef('SCIENCE_ALPHA', {
          SciencePurchasePointCost: 2,
          IsGrantable: 'Yes',
        }),
        makeScienceDef('SCIENCE_BETA', {
          SciencePurchasePointCost: 3,
          PrerequisiteSciences: 'SCIENCE_ALPHA',
          IsGrantable: 'Yes',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CommandCenter', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AliasTeam', [1])).toBe(true);

    const privateApi = logic as unknown as {
      getSideRankStateMap: (side: string) => {
        rankLevel: number;
        skillPoints: number;
        sciencePurchasePoints: number;
      };
    };

    expect(logic.executeScriptAction({
      actionType: 477, // PLAYER_ADD_SKILLPOINTS (offset id)
      params: ['America', 500],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(3);
    expect(privateApi.getSideRankStateMap('america').skillPoints).toBe(500);

    expect(logic.executeScriptAction({
      actionType: 478, // PLAYER_ADD_RANKLEVEL (offset id)
      params: ['America', 1],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(4);

    expect(logic.executeScriptAction({
      actionType: 479, // PLAYER_SET_RANKLEVEL (offset id)
      params: ['America', 2],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 480, // PLAYER_SET_RANKLEVELLIMIT (offset id)
      params: [2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 477, // PLAYER_ADD_SKILLPOINTS (offset id)
      params: ['America', 5000],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').rankLevel).toBe(2);

    privateApi.getSideRankStateMap('america').sciencePurchasePoints = 5;
    expect(logic.executeScriptAction({
      actionType: 481, // PLAYER_GRANT_SCIENCE (offset id)
      params: ['America', 'SCIENCE_ALPHA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 482, // PLAYER_PURCHASE_SCIENCE (offset id)
      params: ['America', 'SCIENCE_BETA'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_ACQUIRED_SCIENCE',
      params: ['America', 'SCIENCE_BETA'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 483, // TEAM_HUNT_WITH_COMMAND_BUTTON (offset id)
      params: ['AliasTeam', 'Command_Missing'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 278, // TEAM_HUNT_WITH_COMMAND_BUTTON (raw id)
      params: ['AliasTeam', 'Command_Missing'],
    })).toBe(false);
  });

  it('executes script team-hunt-with-command-button action using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('HunterUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_HuntPower', {
            SpecialPowerTemplate: 'ScriptHuntPower',
          }),
          makeBlock('Behavior', 'CommandButtonHuntUpdate ModuleTag_Hunt', {
            ScanRate: 33,
            ScanRange: 300,
          }),
        ], {
          CommandSet: 'HunterCommandSet',
        }),
        makeObjectDef('EnemyTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 150, InitialHealth: 150 }),
        ]),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_HuntPower', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptHuntPower',
          Options: 'NEED_TARGET_ENEMY_OBJECT',
        }),
      ],
      commandSets: [
        makeCommandSetDef('HunterCommandSet', {
          1: 'Command_HuntPower',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptHuntPower', {
          ReloadTime: 0,
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('HunterUnit', 20, 20), // id 1
        makeMapObject('EnemyTarget', 60, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('HuntTeam', [1])).toBe(true);
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 278, // TEAM_HUNT_WITH_COMMAND_BUTTON (raw id)
      params: ['HuntTeam', 'Command_HuntPower'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTHUNTPOWER',
      dispatchType: 'OBJECT',
      targetEntityId: 2,
    });

    expect(logic.executeScriptAction({
      actionType: 483, // TEAM_HUNT_WITH_COMMAND_BUTTON (offset id)
      params: ['HuntTeam', 'Command_HuntPower'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(2);

    logic.submitCommand({
      type: 'moveTo',
      entityId: 1,
      targetX: 10,
      targetZ: 10,
      commandSource: 'PLAYER',
    });
    logic.update(1 / 30);
    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { commandButtonHuntMode: string }>;
    };
    expect(privateApi.spawnedEntities.get(1)?.commandButtonHuntMode).toBe('NONE');
  });

  it('executes script skill-point modifier action and scales PLAYER_ADD_SKILLPOINTS gains', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );
    const privateApi = logic as unknown as {
      getSideRankStateMap: (side: string) => {
        skillPoints: number;
      };
    };

    expect(logic.executeScriptAction({
      actionType: 310, // PLAYER_AFFECT_RECEIVING_EXPERIENCE (raw id)
      params: ['America', 0.5],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 272, // PLAYER_ADD_SKILLPOINTS
      params: ['America', 101],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').skillPoints).toBe(51); // ceil(101 * 0.5)

    expect(logic.executeScriptAction({
      actionType: 515, // PLAYER_AFFECT_RECEIVING_EXPERIENCE (offset id)
      params: ['America', 2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 272,
      params: ['America', 10],
    })).toBe(true);
    expect(privateApi.getSideRankStateMap('america').skillPoints).toBe(71); // +ceil(10 * 2)

    expect(logic.executeScriptAction({
      actionType: 310,
      params: ['', 1],
    })).toBe(false);
  });

  it('executes script player-select-skillset action using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 301, // PLAYER_SELECT_SKILLSET (raw id)
      params: ['America', 3],
    })).toBe(true);
    expect(logic.getSideScriptSkillset('America')).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 506, // PLAYER_SELECT_SKILLSET (offset id)
      params: ['America', 1],
    })).toBe(true);
    expect(logic.getSideScriptSkillset('America')).toBe(0);

    expect(logic.executeScriptAction({
      actionType: 301,
      params: ['', 2],
    })).toBe(false);
  });

  it('executes script scoring-toggle and score-screen exclusion actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScoreStructure', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ], {
          BuildCost: 600,
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('ScoreStructure', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, unknown>;
      onStructureConstructionComplete: (builder: unknown, structure: unknown, isRebuild: boolean) => void;
    };
    const structure = privateApi.spawnedEntities.get(1);
    expect(structure).toBeDefined();

    expect(logic.getSideScoreState('America')).toEqual({ structuresBuilt: 0, moneySpent: 0 });

    expect(logic.executeScriptAction({
      actionType: 314, // DISABLE_SCORING (raw id)
    })).toBe(true);
    expect(logic.isScriptScoringEnabled()).toBe(false);
    privateApi.onStructureConstructionComplete(null, structure, false);
    expect(logic.getSideScoreState('America')).toEqual({ structuresBuilt: 0, moneySpent: 0 });

    expect(logic.executeScriptAction({
      actionType: 518, // ENABLE_SCORING (offset id)
    })).toBe(true);
    expect(logic.isScriptScoringEnabled()).toBe(true);
    privateApi.onStructureConstructionComplete(null, structure, false);
    expect(logic.getSideScoreState('America')).toEqual({ structuresBuilt: 1, moneySpent: 600 });

    expect(logic.executeScriptAction({
      actionType: 311, // PLAYER_EXCLUDE_FROM_SCORE_SCREEN (raw id)
      params: ['America'],
    })).toBe(true);
    expect(logic.isSideExcludedFromScoreScreen('America')).toBe(true);
    privateApi.onStructureConstructionComplete(null, structure, false);
    expect(logic.getSideScoreState('America')).toEqual({ structuresBuilt: 1, moneySpent: 600 });

    expect(logic.executeScriptAction({
      actionType: 516, // PLAYER_EXCLUDE_FROM_SCORE_SCREEN (offset id)
      params: ['GLA'],
    })).toBe(true);
    expect(logic.isSideExcludedFromScoreScreen('GLA')).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 311,
      params: [''],
    })).toBe(false);
  });

  it('executes script team-guard-supply-center action using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('SupplyWarehouseRich', 'America', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 8, // 800 cash
            DeleteWhenEmpty: false,
          }),
        ]),
        makeObjectDef('SupplyWarehousePoor', 'America', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 2, // 200 cash
            DeleteWhenEmpty: false,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('SupplyWarehouseRich', 35, 10), // id 2
        makeMapObject('SupplyWarehousePoor', 75, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('SupplyGuardTeam', [1])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { guardObjectId: number }>;
    };

    expect(logic.executeScriptAction({
      actionType: 312, // TEAM_GUARD_SUPPLY_CENTER (raw id)
      params: ['SupplyGuardTeam', 600],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardObjectId).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 517, // TEAM_GUARD_SUPPLY_CENTER (offset id)
      params: ['SupplyGuardTeam', 100],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardObjectId).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 312,
      params: ['SupplyGuardTeam', 5000],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardObjectId).toBe(2);
    expect(logic.executeScriptAction({
      actionType: 312,
      params: ['MissingTeam', 100],
    })).toBe(false);
  });

  it('executes script team-guard-in-tunnel-network action using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GLATunnelNetwork', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'TunnelContain ModuleTag_Tunnel', {}),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene(), { maxTunnelCapacity: 10 });
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GLATunnelNetwork', 50, 50), // id 1
        makeMapObject('Ranger', 50, 50), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('TunnelGuardTeam', [2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 322, // TEAM_GUARD_IN_TUNNEL_NETWORK (raw id)
      params: ['TunnelGuardTeam'],
    })).toBe(true);
    expect(logic.getEntityState(2)?.statusFlags).toContain('DISABLED_HELD');

    logic.submitCommand({ type: 'exitContainer', entityId: 2 });
    logic.update(1 / 30);
    expect(logic.getEntityState(2)?.statusFlags).not.toContain('DISABLED_HELD');

    expect(logic.executeScriptAction({
      actionType: 527, // TEAM_GUARD_IN_TUNNEL_NETWORK (offset id)
      params: ['TunnelGuardTeam'],
    })).toBe(true);
    expect(logic.getEntityState(2)?.statusFlags).toContain('DISABLED_HELD');

    logic.submitCommand({ type: 'exitContainer', entityId: 2 });
    logic.update(1 / 30);
    expect(logic.executeScriptAction({
      actionType: 323, // ID-collision path: 323 + 1 param => TEAM_GUARD_IN_TUNNEL_NETWORK
      params: ['TunnelGuardTeam'],
    })).toBe(true);
    expect(logic.getEntityState(2)?.statusFlags).toContain('DISABLED_HELD');

    expect(logic.executeScriptAction({
      actionType: 322,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script face actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 10, 10), // id 1
      makeMapObject('Ranger', 14, 10), // id 2
      makeMapObject('Ranger', 22, 10), // id 3 target
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'FaceWaypointA',
          position: { x: 14, y: 30, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    expect(logic.setScriptTeamMembers('FaceTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number; rotationY: number }>;
    };

    const angleTo = (sourceEntityId: number, targetX: number, targetZ: number): number => {
      const state = privateApi.spawnedEntities.get(sourceEntityId)!;
      return Math.atan2(targetZ - state.z, targetX - state.x);
    };

    const rotationOf = (entityId: number): number =>
      privateApi.spawnedEntities.get(entityId)?.rotationY ?? Number.NaN;

    expect(logic.executeScriptAction({
      actionType: 303, // NAMED_FACE_NAMED (raw id)
      params: [1, 3],
    })).toBe(true);
    expect(rotationOf(1)).toBeCloseTo(angleTo(1, 22, 10), 6);

    expect(logic.executeScriptAction({
      actionType: 509, // NAMED_FACE_WAYPOINT (offset id)
      params: [1, 'FaceWaypointA'],
    })).toBe(true);
    expect(rotationOf(1)).toBeCloseTo(angleTo(1, 14, 30), 6);

    expect(logic.executeScriptAction({
      actionType: 510, // TEAM_FACE_NAMED (offset id)
      params: ['FaceTeam', 3],
    })).toBe(true);
    expect(rotationOf(1)).toBeCloseTo(angleTo(1, 22, 10), 6);
    expect(rotationOf(2)).toBeCloseTo(angleTo(2, 22, 10), 6);

    expect(logic.executeScriptAction({
      actionType: 306, // TEAM_FACE_WAYPOINT (raw id)
      params: ['FaceTeam', 'FaceWaypointA'],
    })).toBe(true);
    expect(rotationOf(1)).toBeCloseTo(angleTo(1, 14, 30), 6);
    expect(rotationOf(2)).toBeCloseTo(angleTo(2, 14, 30), 6);

    expect(logic.executeScriptAction({
      actionType: 303,
      params: [1, 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 304,
      params: [1, 'MissingWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 305,
      params: ['MissingTeam', 3],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 306,
      params: ['FaceTeam', 'MissingWaypoint'],
    })).toBe(false);
  });

  it('executes script named-fire-weapon-following-waypoint-path action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WaypointLauncher', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('WeaponSet', 'WeaponSet', { Weapon: ['PRIMARY', 'WaypointMissileWeapon'] }),
        ]),
        makeObjectDef('WaypointProjectile', 'America', ['SMALL_MISSILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
        ]),
        makeObjectDef('WaypointTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        ]),
      ],
      weapons: [
        makeWeaponDef('WaypointMissileWeapon', {
          AttackRange: 500,
          PrimaryDamage: 80,
          PrimaryDamageRadius: 0,
          DamageType: 'EXPLOSION',
          DelayBetweenShots: 1,
          WeaponSpeed: 999999,
          ProjectileObject: 'WaypointProjectile',
        }),
      ],
    });

    const map = makeMap([
      makeMapObject('WaypointLauncher', 10, 10), // id 1
      makeMapObject('WaypointTarget', 40, 20), // id 2
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'WP_START',
          position: { x: 20, y: 20, z: 0 },
          pathLabel1: 'WeaponPath',
        },
        {
          id: 2,
          name: 'WP_END',
          position: { x: 40, y: 20, z: 0 },
          pathLabel1: 'WeaponPath',
        },
      ],
      links: [
        { waypoint1: 1, waypoint2: 2 },
      ],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 387, // NAMED_FIRE_WEAPON_FOLLOWING_WAYPOINT_PATH
      params: [1, 'WeaponPath'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.attackTargetEntityId).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 387,
      params: [1, 'MissingPath'],
    })).toBe(false);
  });

  it('executes script volume and border-shroud actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.getScriptSoundVolumeScale()).toBe(1);
    expect(logic.executeScriptAction({
      actionType: 315, // SOUND_SET_VOLUME (raw id)
      params: [25],
    })).toBe(true);
    expect(logic.getScriptSoundVolumeScale()).toBe(0.25);
    expect(logic.executeScriptAction({
      actionType: 520, // SOUND_SET_VOLUME (offset id)
      params: [150],
    })).toBe(true);
    expect(logic.getScriptSoundVolumeScale()).toBe(1);

    expect(logic.getScriptSpeechVolumeScale()).toBe(1);
    expect(logic.executeScriptAction({
      actionType: 316, // SPEECH_SET_VOLUME (raw id)
      params: [-10],
    })).toBe(true);
    expect(logic.getScriptSpeechVolumeScale()).toBe(0);
    expect(logic.executeScriptAction({
      actionType: 521, // SPEECH_SET_VOLUME (offset id)
      params: [40],
    })).toBe(true);
    expect(logic.getScriptSpeechVolumeScale()).toBe(0.4);

    expect(logic.isScriptBorderShroudEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 317, // DISABLE_BORDER_SHROUD (raw id)
    })).toBe(true);
    expect(logic.isScriptBorderShroudEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 523, // ENABLE_BORDER_SHROUD (offset id)
    })).toBe(true);
    expect(logic.isScriptBorderShroudEnabled()).toBe(true);
  });

  it('executes script object-allow-bonuses action using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { receivingDifficultyBonus: boolean }>;
    };
    expect(logic.isScriptObjectsReceiveDifficultyBonusEnabled()).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.receivingDifficultyBonus).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 319, // OBJECT_ALLOW_BONUSES (raw id)
      params: [0],
    })).toBe(true);
    expect(logic.isScriptObjectsReceiveDifficultyBonusEnabled()).toBe(false);
    expect(privateApi.spawnedEntities.get(1)?.receivingDifficultyBonus).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 524, // OBJECT_ALLOW_BONUSES (offset id)
      params: [1],
    })).toBe(true);
    expect(logic.isScriptObjectsReceiveDifficultyBonusEnabled()).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.receivingDifficultyBonus).toBe(true);
  });

  it('executes script victory/defeat actions using source action ids', () => {
    const createLogic = (): GameLogicSubsystem => {
      const logic = new GameLogicSubsystem(new THREE.Scene());
      logic.loadMapObjects(
        makeMap([], 128, 128),
        makeRegistry(makeBundle({ objects: [] })),
        makeHeightmap(128, 128),
      );
      logic.setPlayerSide(0, 'America');
      logic.setPlayerSide(1, 'China');
      return logic;
    };

    const victoryLogic = createLogic();
    expect(victoryLogic.executeScriptAction({
      actionType: 3, // VICTORY
    })).toBe(true);
    expect(victoryLogic.getGameEndState()).toMatchObject({
      status: 'VICTORY',
    });

    const defeatLogic = createLogic();
    expect(defeatLogic.executeScriptAction({
      actionType: 4, // DEFEAT
    })).toBe(true);
    expect(defeatLogic.getGameEndState()).toMatchObject({
      status: 'DEFEAT',
    });

    const quickVictoryLogic = createLogic();
    expect(quickVictoryLogic.executeScriptAction({
      actionType: 324, // QUICKVICTORY
    })).toBe(true);
    expect(quickVictoryLogic.getGameEndState()).toMatchObject({
      status: 'VICTORY',
    });

    const localDefeatLogic = createLogic();
    expect(localDefeatLogic.executeScriptAction({
      actionType: 296, // LOCALDEFEAT
    })).toBe(true);
    expect(localDefeatLogic.getGameEndState()).toMatchObject({
      status: 'DEFEAT',
    });
  });

  it('executes script input disable/enable actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene(), {
      pickObjectByInput: () => 1,
    });
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    const camera = new THREE.PerspectiveCamera();

    expect(logic.executeScriptAction({
      actionType: 299, // DISABLE_INPUT
    })).toBe(true);
    expect(logic.isScriptInputDisabled()).toBe(true);
    logic.handlePointerInput(makeInputState({
      leftMouseClick: true,
    }), camera);
    logic.update(1 / 30);
    expect(logic.getLocalPlayerSelectionIds()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 300, // ENABLE_INPUT
    })).toBe(true);
    expect(logic.isScriptInputDisabled()).toBe(false);
    logic.handlePointerInput(makeInputState({
      leftMouseClick: true,
    }), camera);
    logic.update(1 / 30);
    expect(logic.getLocalPlayerSelectionIds()).toEqual([1]);
  });

  it('executes script radar disable/enable/force/revert actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 293, // RADAR_DISABLE
    })).toBe(true);
    expect(logic.isScriptRadarHidden()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 294, // RADAR_ENABLE
    })).toBe(true);
    expect(logic.isScriptRadarHidden()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 413, // RADAR_FORCE_ENABLE
    })).toBe(true);
    expect(logic.isScriptRadarForced()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 414, // RADAR_REVERT_TO_NORMAL
    })).toBe(true);
    expect(logic.isScriptRadarForced()).toBe(false);

    expect(logic.getScriptRadarRefreshRequestedFrame()).toBeNull();
    expect(logic.executeScriptAction({
      actionType: 170, // REFRESH_RADAR (raw id)
    })).toBe(true);
    expect(logic.getScriptRadarRefreshRequestedFrame()).toBe(0);

    logic.update(1 / 30);
    logic.update(1 / 30);
    expect(logic.executeScriptAction({
      actionType: 375, // REFRESH_RADAR (offset id)
    })).toBe(true);
    expect(logic.getScriptRadarRefreshRequestedFrame()).toBe(2);
  });

  it('executes script EVA and options UI toggle actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptEvaEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 498, // EVA_SET_ENABLED_DISABLED (offset id)
      params: [0],
    })).toBe(true);
    expect(logic.isScriptEvaEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 293, // ID collision path: 293 + 1 param => EVA_SET_ENABLED_DISABLED
      params: [1],
    })).toBe(true);
    expect(logic.isScriptEvaEnabled()).toBe(true);

    expect(logic.isScriptOcclusionModeEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 499, // OPTIONS_SET_OCCLUSION_MODE (offset id)
      params: [1],
    })).toBe(true);
    expect(logic.isScriptOcclusionModeEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 294, // ID collision path: 294 + 1 param => OPTIONS_SET_OCCLUSION_MODE
      params: [0],
    })).toBe(true);
    expect(logic.isScriptOcclusionModeEnabled()).toBe(false);

    expect(logic.isScriptDrawIconUIEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 500, // OPTIONS_SET_DRAWICON_UI_MODE (offset id)
      params: [0],
    })).toBe(true);
    expect(logic.isScriptDrawIconUIEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 295, // OPTIONS_SET_DRAWICON_UI_MODE (raw id)
      params: [1],
    })).toBe(true);
    expect(logic.isScriptDrawIconUIEnabled()).toBe(true);
  });

  it('executes script particle-cap toggle action using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptDynamicLodEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 297, // OPTIONS_SET_PARTICLE_CAP_MODE (raw id)
      params: [0],
    })).toBe(true);
    expect(logic.isScriptDynamicLodEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 502, // OPTIONS_SET_PARTICLE_CAP_MODE (offset id)
      params: [1],
    })).toBe(true);
    expect(logic.isScriptDynamicLodEnabled()).toBe(true);
  });

  it('executes script object-panel flag actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 14, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('PanelTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        objectStatusFlags: Set<string>;
        isIndestructible: boolean;
        scriptAiRecruitable: boolean;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 299, // ID collision path: 299 + 3 params => UNIT_AFFECT_OBJECT_PANEL_FLAGS
      params: [1, 'Enabled', 0],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('SCRIPT_DISABLED')).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 504, // UNIT_AFFECT_OBJECT_PANEL_FLAGS (offset id)
      params: [1, 'Enabled', 1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('SCRIPT_DISABLED')).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 300, // ID collision path: 300 + 3 params => TEAM_AFFECT_OBJECT_PANEL_FLAGS
      params: ['PanelTeam', 'Selectable', 0],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('UNSELECTABLE')).toBe(true);
    expect(privateApi.spawnedEntities.get(2)?.objectStatusFlags.has('UNSELECTABLE')).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 505, // TEAM_AFFECT_OBJECT_PANEL_FLAGS (offset id)
      params: ['PanelTeam', 'AI Recruitable', 0],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptAiRecruitable).toBe(false);
    expect(privateApi.spawnedEntities.get(2)?.scriptAiRecruitable).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 504,
      params: [1, 'Indestructible', 1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.isIndestructible).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 504,
      params: [1, 'Player Targetable', 1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('SCRIPT_TARGETABLE')).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 505,
      params: ['PanelTeam', 'Unsellable', 1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('SCRIPT_UNSELLABLE')).toBe(true);
    expect(privateApi.spawnedEntities.get(2)?.objectStatusFlags.has('SCRIPT_UNSELLABLE')).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 504,
      params: [1, 'UnknownFlag', 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 505,
      params: ['MissingTeam', 'Enabled', 1],
    })).toBe(false);
  });

  it('executes script screen-shake action using source action id', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 415, // SCREEN_SHAKE
      params: [2],
    })).toBe(true);
    expect(logic.getScriptScreenShakeState()).toEqual({
      intensity: 2,
      frame: 0,
    });
    expect(logic.executeScriptAction({
      actionType: 415,
      params: ['invalid'],
    })).toBe(true);
    expect(logic.getScriptScreenShakeState()).toEqual({
      intensity: 0,
      frame: 0,
    });
  });

  it('executes script commandbar add/remove button actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
            ExitDelay: 0,
          }),
        ], {
          CommandSet: 'CommandSet_WarFactory',
        }),
        makeObjectDef('BuildableUnit', 'America', ['VEHICLE'], [], {
          BuildCost: 100,
          BuildTime: 0.1,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_BuildableUnit', {
          Command: 'UNIT_BUILD',
          Object: 'BuildableUnit',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_WarFactory', {
          1: 'Command_BuildableUnit',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('WarFactory', 12, 12)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });

    expect(logic.executeScriptAction({
      actionType: 307, // COMMANDBAR_REMOVE_BUTTON_OBJECTTYPE (raw id)
      params: ['Command_BuildableUnit', 'WarFactory'],
    })).toBe(true);
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    logic.update(1 / 30);
    expect(logic.getProductionState(1)?.queueEntryCount ?? 0).toBe(0);
    expect(logic.getSideCredits('America')).toBe(500);

    expect(logic.executeScriptAction({
      actionType: 513, // COMMANDBAR_ADD_BUTTON_OBJECTTYPE_SLOT (offset id)
      params: ['Command_BuildableUnit', 'WarFactory', 1],
    })).toBe(true);
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    logic.update(1 / 30);
    expect(logic.getProductionState(1)?.queueEntryCount ?? 0).toBe(1);
    expect(logic.getSideCredits('America')).toBe(400);

    expect(logic.executeScriptAction({
      actionType: 512, // COMMANDBAR_REMOVE_BUTTON_OBJECTTYPE (offset id)
      params: ['Command_BuildableUnit', 'WarFactory'],
    })).toBe(true);
    logic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    logic.update(1 / 30);
    expect(logic.getProductionState(1)?.queueEntryCount ?? 0).toBe(1);
    expect(logic.getSideCredits('America')).toBe(400);
  });

  it('executes script buildability-override action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'QueueProductionExitUpdate ModuleTag_Exit', {
            UnitCreatePoint: [8, 0, 0],
            ExitDelay: 0,
          }),
        ], {
          CommandSet: 'CommandSet_WarFactory',
        }),
        makeObjectDef('BuildableUnit', 'America', ['VEHICLE'], [], {
          BuildCost: 100,
          BuildTime: 0.1,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_BuildableUnit', {
          Command: 'UNIT_BUILD',
          Object: 'BuildableUnit',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_WarFactory', {
          1: 'Command_BuildableUnit',
        }),
      ],
    });

    const createLogic = (): GameLogicSubsystem => {
      const logic = new GameLogicSubsystem(new THREE.Scene());
      logic.loadMapObjects(
        makeMap([makeMapObject('WarFactory', 12, 12)], 64, 64),
        makeRegistry(bundle),
        makeHeightmap(64, 64),
      );
      logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
      return logic;
    };

    const humanLogic = createLogic();
    humanLogic.setSidePlayerType('America', 'HUMAN');

    expect(humanLogic.executeScriptAction({
      actionType: 416, // TECHTREE_MODIFY_BUILDABILITY_OBJECT
      params: ['BuildableUnit', 2],
    })).toBe(true);
    humanLogic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    humanLogic.update(1 / 30);
    expect(humanLogic.getProductionState(1)?.queueEntryCount ?? 0).toBe(0);
    expect(humanLogic.getSideCredits('America')).toBe(500);

    expect(humanLogic.executeScriptAction({
      actionType: 416,
      params: ['BuildableUnit', 0],
    })).toBe(true);
    humanLogic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    humanLogic.update(1 / 30);
    expect(humanLogic.getProductionState(1)?.queueEntryCount ?? 0).toBe(1);
    expect(humanLogic.getSideCredits('America')).toBe(400);

    const aiOnlyLogic = createLogic();
    aiOnlyLogic.setSidePlayerType('America', 'HUMAN');
    expect(aiOnlyLogic.executeScriptAction({
      actionType: 416,
      params: ['BuildableUnit', 'ONLY_BY_AI'],
    })).toBe(true);
    aiOnlyLogic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    aiOnlyLogic.update(1 / 30);
    expect(aiOnlyLogic.getProductionState(1)?.queueEntryCount ?? 0).toBe(0);
    expect(aiOnlyLogic.getSideCredits('America')).toBe(500);

    aiOnlyLogic.setSidePlayerType('America', 'COMPUTER');
    aiOnlyLogic.submitCommand({ type: 'queueUnitProduction', entityId: 1, unitTemplateName: 'BuildableUnit' });
    aiOnlyLogic.update(1 / 30);
    expect(aiOnlyLogic.getProductionState(1)?.queueEntryCount ?? 0).toBe(1);
    expect(aiOnlyLogic.getSideCredits('America')).toBe(400);

    expect(aiOnlyLogic.executeScriptAction({
      actionType: 416,
      params: ['MissingTemplate', 2],
    })).toBe(false);
  });

  it('executes script warehouse-set-value action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 8,
            DeleteWhenEmpty: false,
          }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyWarehouse', 10, 10),
        makeMapObject('Ranger', 18, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      supplyWarehouseStates: Map<number, { currentBoxes: number }>;
    };
    expect(privateApi.supplyWarehouseStates.get(1)?.currentBoxes).toBe(8);

    expect(logic.executeScriptAction({
      actionType: 417, // WAREHOUSE_SET_VALUE
      params: [1, 250],
    })).toBe(true);
    expect(privateApi.supplyWarehouseStates.get(1)?.currentBoxes).toBe(3);

    expect(logic.executeScriptAction({
      actionType: 417,
      params: [1, -150],
    })).toBe(true);
    expect(privateApi.supplyWarehouseStates.get(1)?.currentBoxes).toBe(-1);

    expect(logic.executeScriptAction({
      actionType: 417,
      params: [2, 100],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 417,
      params: [999, 100],
    })).toBe(false);
  });

  it('executes script object/team radar-event actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 8,
            DeleteWhenEmpty: false,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 16, 10), // id 2
        makeMapObject('SupplyWarehouse', 22, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AlphaTeam', [1, 2])).toBe(true);
    expect(logic.setScriptTeamMembers('StructureTeam', [3])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 418, // OBJECT_CREATE_RADAR_EVENT
      params: [1, 3],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 419, // TEAM_CREATE_RADAR_EVENT
      params: ['AlphaTeam', 4],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 419,
      params: ['AlphaTeam', 5], // beacon pulse does not update "last event"
    })).toBe(true);

    const radarEvents = logic.getScriptRadarEvents();
    expect(radarEvents).toHaveLength(3);
    expect(radarEvents[0]).toMatchObject({
      eventType: 3,
      sourceEntityId: 1,
      sourceTeamName: null,
      frame: 0,
      expireFrame: 120,
    });
    expect(radarEvents[1]).toMatchObject({
      eventType: 4,
      sourceEntityId: 1,
      sourceTeamName: 'ALPHATEAM',
      frame: 0,
      expireFrame: 120,
    });
    expect(radarEvents[2]).toMatchObject({
      eventType: 5,
      sourceEntityId: 1,
      sourceTeamName: 'ALPHATEAM',
      frame: 0,
      expireFrame: 120,
    });
    expect(logic.getScriptLastRadarEventState()).toMatchObject({
      eventType: 4,
      sourceEntityId: 1,
      sourceTeamName: 'ALPHATEAM',
    });

    expect(logic.executeScriptAction({
      actionType: 418,
      params: [999, 4],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 419,
      params: ['MissingTeam', 4],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 419,
      params: ['StructureTeam', 4],
    })).toBe(false);

    for (let frame = 0; frame <= 120; frame += 1) {
      logic.update(1 / 30);
    }
    expect(logic.getScriptRadarEvents()).toEqual([]);
    expect(logic.getScriptLastRadarEventState()).toMatchObject({
      eventType: 4,
      sourceEntityId: 1,
      sourceTeamName: 'ALPHATEAM',
    });
  });

  it('executes script cinematic-text and popup actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 420, // DISPLAY_CINEMATIC_TEXT
      params: ['MissionCinematicText', 'Arial - Size: 16 [Bold]', 7],
    })).toBe(true);
    expect(logic.getScriptCinematicTextState()).toEqual({
      text: 'MissionCinematicText',
      fontType: 'Arial - Size: 16 [Bold]',
      timeSeconds: 7,
      durationFrames: 210,
      frame: 0,
    });

    expect(logic.executeScriptAction({
      actionType: 420,
      params: ['MissionCinematicText2', 'Tahoma - Size: 14', 'invalid'],
    })).toBe(true);
    expect(logic.getScriptCinematicTextState()).toEqual({
      text: 'MissionCinematicText2',
      fontType: 'Tahoma - Size: 14',
      timeSeconds: 0,
      durationFrames: 0,
      frame: 0,
    });

    expect(logic.executeScriptAction({
      actionType: 428, // INGAME_POPUP_MESSAGE
      params: ['Primary objective updated', 120, 220, 360, 1],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 428,
      params: ['Secondary objective available', 40, 60, 280, 0],
    })).toBe(true);

    expect(logic.drainScriptPopupMessages()).toEqual([
      {
        message: 'Primary objective updated',
        x: 120,
        y: 220,
        width: 360,
        pause: true,
        frame: 0,
      },
      {
        message: 'Secondary objective available',
        x: 40,
        y: 60,
        width: 280,
        pause: false,
        frame: 0,
      },
    ]);
    expect(logic.drainScriptPopupMessages()).toEqual([]);
  });

  it('executes script display/hide-counter actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 441, // DISPLAY_COUNTER
      params: ['MissionCounter', 'MissionCounterText'],
    })).toBe(true);
    expect(logic.getScriptDisplayedCounters()).toEqual([
      {
        counterName: 'MissionCounter',
        counterText: 'MissionCounterText',
        isCountdown: false,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 441,
      params: ['MissionCounter', 'UpdatedCounterText'],
    })).toBe(true);
    expect(logic.getScriptDisplayedCounters()).toEqual([
      {
        counterName: 'MissionCounter',
        counterText: 'UpdatedCounterText',
        isCountdown: false,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 442, // HIDE_COUNTER
      params: ['MissionCounter'],
    })).toBe(true);
    expect(logic.getScriptDisplayedCounters()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 441,
      params: ['', 'NoCounterName'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 442,
      params: [''],
    })).toBe(false);
  });

  it('executes script countdown-timer display actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptNamedTimerDisplayEnabled()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 160, // DISPLAY_COUNTDOWN_TIMER (raw id)
      params: ['MissionTimer', 'MissionTimerText'],
    })).toBe(true);
    expect(logic.getScriptDisplayedCounters()).toEqual([
      {
        counterName: 'MissionTimer',
        counterText: 'MissionTimerText',
        isCountdown: true,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 365, // DISPLAY_COUNTDOWN_TIMER (offset id)
      params: ['MissionTimer', 'MissionTimerText2'],
    })).toBe(true);
    expect(logic.getScriptDisplayedCounters()).toEqual([
      {
        counterName: 'MissionTimer',
        counterText: 'MissionTimerText2',
        isCountdown: true,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 368, // DISABLE_COUNTDOWN_TIMER_DISPLAY (offset id)
    })).toBe(true);
    expect(logic.isScriptNamedTimerDisplayEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 162, // ENABLE_COUNTDOWN_TIMER_DISPLAY (raw id)
    })).toBe(true);
    expect(logic.isScriptNamedTimerDisplayEnabled()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 161, // HIDE_COUNTDOWN_TIMER (raw id)
      params: ['MissionTimer'],
    })).toBe(true);
    expect(logic.getScriptDisplayedCounters()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 160,
      params: ['', 'InvalidTimerName'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 366, // HIDE_COUNTDOWN_TIMER (offset id)
      params: [''],
    })).toBe(false);
  });

  it('executes script special-power-display actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptSpecialPowerDisplayEnabled()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 156, // DISABLE_SPECIAL_POWER_DISPLAY (raw id)
    })).toBe(true);
    expect(logic.isScriptSpecialPowerDisplayEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 362, // ENABLE_SPECIAL_POWER_DISPLAY (offset id)
    })).toBe(true);
    expect(logic.isScriptSpecialPowerDisplayEnabled()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 158, // NAMED_HIDE_SPECIAL_POWER_DISPLAY (raw id)
      params: [1],
    })).toBe(true);
    expect(logic.getScriptHiddenSpecialPowerDisplayEntityIds()).toEqual([1]);

    expect(logic.executeScriptAction({
      actionType: 364, // NAMED_SHOW_SPECIAL_POWER_DISPLAY (offset id)
      params: [1],
    })).toBe(true);
    expect(logic.getScriptHiddenSpecialPowerDisplayEntityIds()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 363, // NAMED_HIDE_SPECIAL_POWER_DISPLAY (offset id)
      params: [1],
    })).toBe(true);
    expect(logic.getScriptHiddenSpecialPowerDisplayEntityIds()).toEqual([1]);

    expect(logic.executeScriptAction({
      actionType: 159, // NAMED_SHOW_SPECIAL_POWER_DISPLAY (raw id)
      params: [1],
    })).toBe(true);
    expect(logic.getScriptHiddenSpecialPowerDisplayEntityIds()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 158,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 159,
      params: [999],
    })).toBe(false);
  });

  it('executes script sound/audio-control actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SoundSourceUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const map = makeMap([
      makeMapObject('SoundSourceUnit', 24, 30, { objectName: 'SoundSource' }),
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'AudioWaypoint',
          position: { x: 48, y: 64, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 7, // PLAY_SOUND_EFFECT (raw id)
      params: ['MissionStart'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 212, // PLAY_SOUND_EFFECT (offset/collision id)
      params: ['MissionStartOffset'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 11, // PLAY_SOUND_EFFECT_AT (raw id)
      params: ['MissionAt', 'AudioWaypoint'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 216, // PLAY_SOUND_EFFECT_AT (offset id)
      params: ['MissionAtOffset', 'AudioWaypoint'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 82, // SOUND_PLAY_NAMED (raw id)
      params: ['MissionFromUnit', 'SoundSource'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 83, // SPEECH_PLAY (raw id)
      params: ['CommanderLine', 0],
    })).toBe(true);
    expect(logic.drainScriptAudioPlaybackRequests()).toEqual([
      {
        audioName: 'MissionStart',
        playbackType: 'SOUND_EFFECT',
        allowOverlap: true,
        sourceEntityId: null,
        x: null,
        y: null,
        z: null,
        frame: 0,
      },
      {
        audioName: 'MissionStartOffset',
        playbackType: 'SOUND_EFFECT',
        allowOverlap: true,
        sourceEntityId: null,
        x: null,
        y: null,
        z: null,
        frame: 0,
      },
      {
        audioName: 'MissionAt',
        playbackType: 'SOUND_EFFECT',
        allowOverlap: true,
        sourceEntityId: null,
        x: 48,
        y: 0,
        z: 64,
        frame: 0,
      },
      {
        audioName: 'MissionAtOffset',
        playbackType: 'SOUND_EFFECT',
        allowOverlap: true,
        sourceEntityId: null,
        x: 48,
        y: 0,
        z: 64,
        frame: 0,
      },
      {
        audioName: 'MissionFromUnit',
        playbackType: 'SOUND_EFFECT',
        allowOverlap: true,
        sourceEntityId: 1,
        x: 24,
        y: 1,
        z: 30,
        frame: 0,
      },
      {
        audioName: 'CommanderLine',
        playbackType: 'SPEECH',
        allowOverlap: false,
        sourceEntityId: null,
        x: null,
        y: null,
        z: null,
        frame: 0,
      },
    ]);

    expect(logic.isScriptBackgroundSoundsPaused()).toBe(false);
    expect(logic.isScriptAmbientSoundsPaused()).toBe(false);
    expect(logic.getScriptMusicTrackState()).toBeNull();
    expect(logic.getScriptMusicVolumeScale()).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 24, // SUSPEND_BACKGROUND_SOUNDS (raw id)
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 229, // SUSPEND_BACKGROUND_SOUNDS (offset/collision id)
    })).toBe(true);
    expect(logic.isScriptBackgroundSoundsPaused()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 25, // RESUME_BACKGROUND_SOUNDS (raw id)
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 230, // RESUME_BACKGROUND_SOUNDS (offset/collision id)
    })).toBe(true);
    expect(logic.isScriptBackgroundSoundsPaused()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 97, // SOUND_AMBIENT_PAUSE (raw id)
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 302, // SOUND_AMBIENT_PAUSE (offset id)
    })).toBe(true);
    expect(logic.isScriptAmbientSoundsPaused()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 98, // SOUND_AMBIENT_RESUME (raw id)
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 303, // SOUND_AMBIENT_RESUME (offset/collision id)
      params: [],
    })).toBe(true);
    expect(logic.isScriptAmbientSoundsPaused()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 99, // MUSIC_SET_TRACK (raw id)
      params: ['BattleTrackA', 1, 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 304, // MUSIC_SET_TRACK (offset/collision id)
      params: ['BattleTrackB', 0, 1],
    })).toBe(true);
    expect(logic.getScriptMusicTrackState()).toEqual({
      trackName: 'BattleTrackB',
      fadeOut: false,
      fadeIn: true,
      frame: 0,
    });

    expect(logic.executeScriptAction({
      actionType: 144, // MUSIC_SET_VOLUME (raw id)
      params: [40],
    })).toBe(true);
    expect(logic.getScriptMusicVolumeScale()).toBe(0.4);
    expect(logic.executeScriptAction({
      actionType: 349, // MUSIC_SET_VOLUME (offset id)
      params: [75],
    })).toBe(true);
    expect(logic.getScriptMusicVolumeScale()).toBe(0.75);

    expect(logic.executeScriptAction({
      actionType: 422, // SOUND_DISABLE_TYPE
      params: ['MissionAlert'],
    })).toBe(true);
    expect(logic.getScriptDisabledAudioEventNames()).toEqual(['MissionAlert']);

    expect(logic.executeScriptAction({
      actionType: 423, // SOUND_ENABLE_TYPE
      params: ['MissionAlert'],
    })).toBe(true);
    expect(logic.getScriptDisabledAudioEventNames()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 422,
      params: ['MissionAlert'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 422,
      params: ['SecondaryAlert'],
    })).toBe(true);
    expect(logic.getScriptDisabledAudioEventNames()).toEqual(['MissionAlert', 'SecondaryAlert']);
    expect(logic.executeScriptAction({
      actionType: 424, // SOUND_ENABLE_ALL
    })).toBe(true);
    expect(logic.getScriptDisabledAudioEventNames()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 425, // AUDIO_OVERRIDE_VOLUME_TYPE
      params: ['MissionAlert', 150],
    })).toBe(true);
    expect(logic.getScriptAudioVolumeOverrides()).toEqual([
      { eventName: 'MissionAlert', volumeScale: 1.5 },
    ]);

    expect(logic.executeScriptAction({
      actionType: 426, // AUDIO_RESTORE_VOLUME_TYPE
      params: ['MissionAlert'],
    })).toBe(true);
    expect(logic.getScriptAudioVolumeOverrides()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 425,
      params: ['TrackA', 80],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 425,
      params: ['TrackB', 120],
    })).toBe(true);
    expect(logic.getScriptAudioVolumeOverrides()).toEqual([
      { eventName: 'TrackA', volumeScale: 0.8 },
      { eventName: 'TrackB', volumeScale: 1.2 },
    ]);
    expect(logic.executeScriptAction({
      actionType: 427, // AUDIO_RESTORE_VOLUME_ALL_TYPE
    })).toBe(true);
    expect(logic.getScriptAudioVolumeOverrides()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 320, // SOUND_REMOVE_ALL_DISABLED (raw id)
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 525, // SOUND_REMOVE_ALL_DISABLED (offset id)
    })).toBe(true);
    expect(logic.drainScriptAudioRemovalRequests()).toEqual([
      { eventName: null, removeDisabledOnly: true, frame: 0 },
      { eventName: null, removeDisabledOnly: true, frame: 0 },
    ]);

    expect(logic.executeScriptAction({
      actionType: 321, // SOUND_REMOVE_TYPE (raw id)
      params: ['MissionAlert'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 526, // SOUND_REMOVE_TYPE (offset id)
      params: ['SecondaryAlert'],
    })).toBe(true);
    expect(logic.drainScriptAudioRemovalRequests()).toEqual([
      { eventName: 'MissionAlert', removeDisabledOnly: false, frame: 0 },
      { eventName: 'SecondaryAlert', removeDisabledOnly: false, frame: 0 },
    ]);
    expect(logic.executeScriptAction({
      actionType: 321,
      params: [''],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 11,
      params: ['MissionAt', 'MissingWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 82,
      params: ['MissionFromUnit', 'MissingUnit'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 83,
      params: ['', 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 99,
      params: ['', 1, 1],
    })).toBe(false);
  });

  it('executes script set-cave-index action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NeutralCaveA', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
          makeBlock('Behavior', 'CaveContain ModuleTag_Cave', { CaveIndex: 0 }),
        ]),
        makeObjectDef('NeutralCaveB', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
          makeBlock('Behavior', 'CaveContain ModuleTag_Cave', { CaveIndex: 1 }),
        ]),
        makeObjectDef('NeutralInfantry', 'Neutral', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('NeutralCaveA', 30, 30),
        makeMapObject('NeutralCaveB', 70, 30),
        makeMapObject('NeutralInfantry', 30, 30),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.getCaveContainIndex(1)).toBe(0);
    expect(logic.getCaveContainIndex(2)).toBe(1);

    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    logic.update(1 / 30);
    expect(logic.getEntityState(3)?.statusFlags).toContain('DISABLED_HELD');

    expect(logic.executeScriptAction({
      actionType: 429, // SET_CAVE_INDEX
      params: [1, 2],
    })).toBe(false);
    expect(logic.getCaveContainIndex(1)).toBe(0);

    logic.submitCommand({ type: 'exitContainer', entityId: 3 });
    logic.update(1 / 30);
    expect(logic.getEntityState(3)?.statusFlags).not.toContain('DISABLED_HELD');

    expect(logic.executeScriptAction({
      actionType: 429,
      params: [1, 2],
    })).toBe(true);
    expect(logic.getCaveContainIndex(1)).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 429,
      params: [3, 4],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 429,
      params: [999, 1],
    })).toBe(false);
  });

  it('executes script named-set-held action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10, { objectName: 'HeldRanger' })], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 430, // NAMED_SET_HELD
      params: ['HeldRanger', 1],
    })).toBe(true);
    expect(logic.getEntityState(1)?.statusFlags).toContain('DISABLED_HELD');

    expect(logic.executeScriptAction({
      actionType: 430,
      params: [1, 0],
    })).toBe(true);
    expect(logic.getEntityState(1)?.statusFlags).not.toContain('DISABLED_HELD');

    expect(logic.executeScriptAction({
      actionType: 430,
      params: ['MissingRanger', 1],
    })).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 430,
      params: [999, 1],
    })).toBe(false);
  });

  it('executes script named-set-evac-left-or-right action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TransportTruck', 'America', ['VEHICLE', 'TRANSPORT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 4,
          }),
        ], {
          GeometryMajorRadius: 6,
          GeometryMinorRadius: 3,
        }),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TransportTruck', 40, 40), // id 1
        makeMapObject('Passenger', 40, 40), // id 2
        makeMapObject('Passenger', 40, 40), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        x: number;
        z: number;
      }>;
    };

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    logic.submitCommand({ type: 'enterTransport', entityId: 3, targetTransportId: 1 });
    for (let i = 0; i < 5; i += 1) {
      logic.update(1 / 30);
    }

    const container = privateApi.spawnedEntities.get(1)!;
    expect(logic.executeScriptAction({
      actionType: 334, // NAMED_SET_EVAC_LEFT_OR_RIGHT
      params: [1, 1],
    })).toBe(true);
    logic.submitCommand({ type: 'exitContainer', entityId: 2 });
    logic.update(1 / 30);
    const leftPassenger = privateApi.spawnedEntities.get(2)!;
    expect(leftPassenger.z).toBeGreaterThan(container.z);

    expect(logic.executeScriptAction({
      actionType: 334,
      params: [1, 2],
    })).toBe(true);
    logic.submitCommand({ type: 'exitContainer', entityId: 3 });
    logic.update(1 / 30);
    const rightPassenger = privateApi.spawnedEntities.get(3)!;
    expect(rightPassenger.z).toBeLessThan(container.z);

    expect(logic.executeScriptAction({
      actionType: 334,
      params: [2, 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 334,
      params: [999, 1],
    })).toBe(false);
  });

  it('executes script building-exit actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CivilianBunker', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_Garrison', {
            ContainMax: 4,
          }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 6,
        }),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CivilianBunker', 40, 40), // id 1
        makeMapObject('Passenger', 40, 40), // id 2
        makeMapObject('Passenger', 40, 40), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('ExitTeam', [2, 3])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        garrisonContainerId: number | null;
      }>;
    };

    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 3, targetBuildingId: 1 });
    for (let i = 0; i < 5; i += 1) {
      logic.update(1 / 30);
    }
    expect(privateApi.spawnedEntities.get(2)?.garrisonContainerId).toBe(1);
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 109, // NAMED_EXIT_BUILDING
      params: [2],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.garrisonContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 104, // EXIT_SPECIFIC_BUILDING
      params: [1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBeNull();

    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 3, targetBuildingId: 1 });
    for (let i = 0; i < 5; i += 1) {
      logic.update(1 / 30);
    }
    expect(logic.executeScriptAction({
      actionType: 106, // TEAM_EXIT_ALL_BUILDINGS
      params: ['ExitTeam'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.garrisonContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 109,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 104,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 106,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script garrison actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CivilianBunker', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_Garrison', {
            ContainMax: 4,
          }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 6,
        }),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('EnemyPassenger', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CivilianBunker', 40, 40), // id 1
        makeMapObject('CivilianBunker', 70, 40), // id 2
        makeMapObject('Passenger', 42, 40), // id 3
        makeMapObject('Passenger', 42, 44), // id 4
        makeMapObject('EnemyPassenger', 70, 40), // id 5
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('GarrisonTeam', [3, 4])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        garrisonContainerId: number | null;
      }>;
    };

    // Occupy bunker #2 with enemy infantry so America units cannot garrison it.
    logic.submitCommand({ type: 'garrisonBuilding', entityId: 5, targetBuildingId: 2 });
    for (let i = 0; i < 5; i += 1) {
      logic.update(1 / 30);
    }
    expect(privateApi.spawnedEntities.get(5)?.garrisonContainerId).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 103, // TEAM_GARRISON_SPECIFIC_BUILDING
      params: ['GarrisonTeam', 1],
    })).toBe(true);
    for (let i = 0; i < 5; i += 1) {
      logic.update(1 / 30);
    }
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBe(1);
    expect(privateApi.spawnedEntities.get(4)?.garrisonContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 106, // TEAM_EXIT_ALL_BUILDINGS
      params: ['GarrisonTeam'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(4)?.garrisonContainerId).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 107, // NAMED_GARRISON_SPECIFIC_BUILDING
      params: [3, 1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 109, // NAMED_EXIT_BUILDING
      params: [3],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 108, // NAMED_GARRISON_NEAREST_BUILDING
      params: [4],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(4)?.garrisonContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 111, // PLAYER_EXIT_ALL_BUILDINGS
      params: ['America'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(4)?.garrisonContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(5)?.garrisonContainerId).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 110, // PLAYER_GARRISON_ALL_BUILDINGS
      params: ['America'],
    })).toBe(true);
    for (let i = 0; i < 5; i += 1) {
      logic.update(1 / 30);
    }
    expect(privateApi.spawnedEntities.get(3)?.garrisonContainerId).toBe(1);
    expect(privateApi.spawnedEntities.get(4)?.garrisonContainerId).toBe(1);
    expect(privateApi.spawnedEntities.get(5)?.garrisonContainerId).toBe(2);

    expect(logic.executeScriptAction({
      actionType: 103,
      params: ['MissingTeam', 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 107,
      params: [3, 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 108,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 110,
      params: ['MissingSide'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 111,
      params: ['MissingSide'],
    })).toBe(false);
  });

  it('executes script transport enter/exit-all actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TroopTransport', 'America', ['VEHICLE', 'TRANSPORT'], [
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            ContainMax: 4,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TroopTransport', 20, 20), // id 1
        makeMapObject('Ranger', 20, 20), // id 2
        makeMapObject('Ranger', 22, 20), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('RideTeam', [2, 3])).toBe(true);
    expect(logic.setScriptTeamMembers('TransportTeam', [1])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        transportContainerId: number | null;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 52, // NAMED_ENTER_NAMED
      params: [2, 1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.transportContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 53, // TEAM_ENTER_NAMED
      params: ['RideTeam', 1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.transportContainerId).toBe(1);
    expect(privateApi.spawnedEntities.get(3)?.transportContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 54, // NAMED_EXIT_ALL
      params: [1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.transportContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(3)?.transportContainerId).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 53,
      params: ['RideTeam', 1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.transportContainerId).toBe(1);
    expect(privateApi.spawnedEntities.get(3)?.transportContainerId).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 55, // TEAM_EXIT_ALL
      params: ['TransportTeam'],
    })).toBe(true);
    logic.update(1 / 30);
    expect(privateApi.spawnedEntities.get(2)?.transportContainerId).toBeNull();
    expect(privateApi.spawnedEntities.get(3)?.transportContainerId).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 52,
      params: [999, 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 53,
      params: ['MissingTeam', 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 54,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 55,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script named-set-topple-direction action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ToppleTree', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'ToppleUpdate ModuleTag_Topple', {}),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('ToppleTree', 20, 20)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 431, // NAMED_SET_TOPPLE_DIRECTION
      params: [1, { x: 0, y: 1, z: 0 }],
    })).toBe(true);
    expect(logic.getScriptNamedToppleDirection(1)).toEqual({ x: 0, z: 1 });

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, unknown>;
      applyTopplingForce: (entity: unknown, dirX: number, dirZ: number, speed: number) => void;
    };
    const entity = privateApi.spawnedEntities.get(1);
    expect(entity).toBeDefined();
    privateApi.applyTopplingForce(entity!, 1, 0, 1);

    const toppledState = privateApi.spawnedEntities.get(1) as { toppleDirX: number; toppleDirZ: number };
    expect(toppledState.toppleDirX).toBeCloseTo(0, 5);
    expect(toppledState.toppleDirZ).toBeCloseTo(1, 5);

    expect(logic.executeScriptAction({
      actionType: 431,
      params: [999, { x: 1, y: 0, z: 0 }],
    })).toBe(false);
  });

  it('executes script move-towards-nearest-object-type actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('TargetBeacon', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('AltTarget', 'Neutral', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 10, 10), // id 1
      makeMapObject('Ranger', 14, 10), // id 2
      makeMapObject('AltTarget', 18, 10), // id 3 (nearest list target)
      makeMapObject('TargetBeacon', 25, 10), // id 4 (nearest)
      makeMapObject('TargetBeacon', 70, 70), // id 5 (farther)
      makeMapObject('TargetBeacon', 118, 118), // id 6 (outside trigger)
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'MoveArea',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 0, y: 0, z: 0 },
        { x: 96, y: 0, z: 0 },
        { x: 96, y: 96, z: 0 },
        { x: 0, y: 96, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    expect(logic.setScriptTeamMembers('MoveTeam', [1, 2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 432, // UNIT_MOVE_TOWARDS_NEAREST_OBJECT_TYPE
      params: [1, 'TargetBeacon', 'MoveArea'],
    })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        moveTarget: { x: number; z: number } | null;
        movePath: Array<{ x: number; z: number }>;
      }>;
    };
    const unitOneAfterSingle = privateApi.spawnedEntities.get(1);
    expect(unitOneAfterSingle?.moveTarget).not.toBeNull();
    expect((unitOneAfterSingle?.movePath.length ?? 0) > 0).toBe(true);
    const unitOneSingleFinal = unitOneAfterSingle?.movePath.at(-1);
    expect(unitOneSingleFinal).toBeDefined();
    expect(Math.hypot(unitOneSingleFinal!.x - 25, unitOneSingleFinal!.z - 10)).toBeLessThanOrEqual(20);

    expect(logic.executeScriptAction({
      actionType: 433, // TEAM_MOVE_TOWARDS_NEAREST_OBJECT_TYPE
      params: ['MoveTeam', 'TargetBeacon', 'MoveArea'],
    })).toBe(true);
    const unitOneAfterTeam = privateApi.spawnedEntities.get(1);
    const unitTwoAfterTeam = privateApi.spawnedEntities.get(2);
    expect(unitOneAfterTeam?.moveTarget).not.toBeNull();
    expect(unitTwoAfterTeam?.moveTarget).not.toBeNull();
    const unitOneTeamFinal = unitOneAfterTeam?.movePath.at(-1);
    const unitTwoTeamFinal = unitTwoAfterTeam?.movePath.at(-1);
    expect(unitOneTeamFinal).toBeDefined();
    expect(unitTwoTeamFinal).toBeDefined();
    expect(Math.hypot(unitOneTeamFinal!.x - 25, unitOneTeamFinal!.z - 10)).toBeLessThanOrEqual(20);
    expect(Math.hypot(unitTwoTeamFinal!.x - 25, unitTwoTeamFinal!.z - 10)).toBeLessThanOrEqual(20);

    expect(logic.executeScriptAction({
      actionType: 432,
      params: [999, 'TargetBeacon', 'MoveArea'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 432,
      params: [1, 'TargetBeacon', 'MissingArea'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 432,
      params: [1, 'MissingType', 'MoveArea'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 433,
      params: ['MissingTeam', 'TargetBeacon', 'MoveArea'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 433,
      params: ['MoveTeam', 'TargetBeacon', 'MissingArea'],
    })).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 287, // OBJECTLIST_ADDOBJECTTYPE
      params: ['MoveTargets', 'TargetBeacon'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 287,
      params: ['MoveTargets', 'AltTarget'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 432,
      params: [1, 'MoveTargets', 'MoveArea'],
    })).toBe(true);
    const unitOneAfterList = privateApi.spawnedEntities.get(1);
    const unitOneListFinal = unitOneAfterList?.movePath.at(-1);
    expect(unitOneListFinal).toBeDefined();
    expect(Math.hypot(unitOneListFinal!.x - 18, unitOneListFinal!.z - 10)).toBeLessThanOrEqual(20);

    expect(logic.executeScriptAction({
      actionType: 288, // OBJECTLIST_REMOVEOBJECTTYPE
      params: ['MoveTargets', 'TargetBeacon'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 288,
      params: ['MoveTargets', 'AltTarget'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 432,
      params: [1, 'MoveTargets', 'MoveArea'],
    })).toBe(false);
  });

  it('executes script map-reveal-at-waypoint actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericaScout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
        makeObjectDef('GLAScout', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
      ],
    });

    const map = makeMap([
      makeMapObject('AmericaScout', 16, 16),
      makeMapObject('GLAScout', 240, 240),
    ], 256, 256);
    map.waypoints = {
      nodes: [
        {
          id: 77,
          name: 'RevealSpot',
          position: { x: 220, y: 220, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );

    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'HUMAN' });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'GLA', playerType: 'COMPUTER' });
    logic.update(1 / 30);

    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 90, // MAP_REVEAL_AT_WAYPOINT (raw id)
      params: ['RevealSpot', 40, 'MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 145, // MAP_SHROUD_AT_WAYPOINT (raw id)
      params: ['RevealSpot', 40, 'America'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 295, // MAP_REVEAL_AT_WAYPOINT (offset/collision id)
      params: ['RevealSpot', 40, 'MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);

    expect(logic.executeScriptAction({
      actionType: 90,
      params: ['RevealSpot', 40, 'GLA'],
    })).toBe(true);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_FOGGED);
    expect(logic.executeScriptAction({
      actionType: 350, // MAP_SHROUD_AT_WAYPOINT (offset/collision id)
      params: ['RevealSpot', 40, 'GLA'],
    })).toBe(true);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 90,
      params: ['MissingWaypoint', 40, 'America'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 145,
      params: ['MissingWaypoint', 40, 'America'],
    })).toBe(false);
  });

  it('executes script map-reveal-all and map-shroud-all actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericaScout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
        makeObjectDef('GLAScout', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('AmericaScout', 16, 16),
        makeMapObject('GLAScout', 240, 240),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );

    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'HUMAN' });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'GLA', playerType: 'COMPUTER' });
    logic.update(1 / 30);

    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 102, // MAP_REVEAL_ALL (raw id)
      params: ['MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 146, // MAP_SHROUD_ALL (raw id)
      params: ['MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 307, // MAP_REVEAL_ALL (offset/collision id)
      params: ['MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);

    expect(logic.executeScriptAction({
      actionType: 351, // MAP_SHROUD_ALL (offset id)
      params: ['MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 102,
      params: ['GLA'],
    })).toBe(true);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_FOGGED);
    expect(logic.executeScriptAction({
      actionType: 146,
      params: ['GLA'],
    })).toBe(true);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);
  });

  it('executes script map-reveal-all-perm actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericaScout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
        makeObjectDef('GLAScout', 'GLA', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('AmericaScout', 16, 16),
        makeMapObject('GLAScout', 240, 240),
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );

    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'HUMAN' });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'GLA', playerType: 'COMPUTER' });
    logic.update(1 / 30);

    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 434, // MAP_REVEAL_ALL_PERM
      params: ['MissingPlayerName'],
    })).toBe(true);
    // Unknown playerName falls back to all human players (America only in this setup).
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_CLEAR);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 435, // MAP_REVEAL_ALL_UNDO_PERM
      params: ['MissingPlayerName'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 434,
      params: ['GLA'],
    })).toBe(true);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_CLEAR);

    expect(logic.executeScriptAction({
      actionType: 435,
      params: ['GLA'],
    })).toBe(true);
    expect(logic.getCellVisibility('GLA', 220, 220)).toBe(CELL_FOGGED);
  });

  it('executes script waypoint permanent-reveal actions using raw and offset source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericaScout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 0 }),
      ],
    });

    const map = makeMap([
      makeMapObject('AmericaScout', 16, 16), // id 1
    ], 256, 256);
    map.waypoints = {
      nodes: [
        {
          id: 91,
          name: 'RevealPoint',
          position: { x: 220, y: 220, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'HUMAN' });
    logic.update(1 / 30);

    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_SHROUDED);

    expect(logic.executeScriptAction({
      actionType: 289, // MAP_REVEAL_PERMANENTLY_AT_WAYPOINT (raw id)
      params: ['RevealPoint', 35, 'America', 'LookAlpha'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_CLEAR);

    expect(logic.executeScriptAction({
      actionType: 290, // MAP_UNDO_REVEAL_PERMANENTLY_AT_WAYPOINT (raw id)
      params: ['LookAlpha'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);

    expect(logic.executeScriptAction({
      actionType: 494, // MAP_REVEAL_PERMANENTLY_AT_WAYPOINT (offset id)
      params: ['RevealPoint', 35, 'America', 'LookBeta'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_CLEAR);

    expect(logic.executeScriptAction({
      actionType: 495, // MAP_UNDO_REVEAL_PERMANENTLY_AT_WAYPOINT (offset id)
      params: ['LookBeta'],
    })).toBe(true);
    expect(logic.getCellVisibility('America', 220, 220)).toBe(CELL_FOGGED);

    expect(logic.executeScriptAction({
      actionType: 289,
      params: ['MissingWaypoint', 35, 'America', 'LookGamma'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 290,
      params: ['MissingLook'],
    })).toBe(false);
  });

  it('executes script stealth-enable actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('StealthUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'StealthUpdate ModuleTag_Stealth', {
            InnateStealth: 'Yes',
            StealthDelay: 0,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('StealthUnit', 10, 10), // id 1
        makeMapObject('StealthUnit', 14, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('StealthTeam', [1, 2])).toBe(true);

    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.statusFlags).toContain('STEALTHED');
    expect(logic.getEntityState(2)?.statusFlags).toContain('STEALTHED');

    expect(logic.executeScriptAction({
      actionType: 291, // ID collision path: raw id 291 + 2 params => NAMED_SET_STEALTH_ENABLED
      params: [1, 0],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.statusFlags).toContain('SCRIPT_UNSTEALTHED');
    expect(logic.getEntityState(1)?.statusFlags).not.toContain('STEALTHED');
    expect(logic.getEntityState(2)?.statusFlags).toContain('STEALTHED');

    expect(logic.executeScriptAction({
      actionType: 497, // TEAM_SET_STEALTH_ENABLED (offset id)
      params: ['StealthTeam', 0],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.statusFlags).toContain('SCRIPT_UNSTEALTHED');
    expect(logic.getEntityState(2)?.statusFlags).toContain('SCRIPT_UNSTEALTHED');
    expect(logic.getEntityState(1)?.statusFlags).not.toContain('STEALTHED');
    expect(logic.getEntityState(2)?.statusFlags).not.toContain('STEALTHED');

    expect(logic.executeScriptAction({
      actionType: 496, // NAMED_SET_STEALTH_ENABLED (offset id)
      params: [1, 1],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 497,
      params: ['StealthTeam', 1],
    })).toBe(true);
    logic.update(1 / 30);
    expect(logic.getEntityState(1)?.statusFlags).not.toContain('SCRIPT_UNSTEALTHED');
    expect(logic.getEntityState(2)?.statusFlags).not.toContain('SCRIPT_UNSTEALTHED');
    expect(logic.getEntityState(1)?.statusFlags).toContain('STEALTHED');
    expect(logic.getEntityState(2)?.statusFlags).toContain('STEALTHED');

    expect(logic.executeScriptAction({
      actionType: 496,
      params: [999, 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 497,
      params: ['MissingTeam', 0],
    })).toBe(false);
  });

  it('executes script repulsor actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 14, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.setScriptTeamMembers('RepulsorTeam', [1, 2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 436, // NAMED_SET_REPULSOR
      params: [1, 1],
    })).toBe(true);
    expect(logic.getEntityState(1)?.statusFlags).toContain('REPULSOR');

    expect(logic.executeScriptAction({
      actionType: 436,
      params: [1, 0],
    })).toBe(true);
    expect(logic.getEntityState(1)?.statusFlags).not.toContain('REPULSOR');

    expect(logic.executeScriptAction({
      actionType: 437, // TEAM_SET_REPULSOR
      params: ['RepulsorTeam', 1],
    })).toBe(true);
    expect(logic.getEntityState(1)?.statusFlags).toContain('REPULSOR');
    expect(logic.getEntityState(2)?.statusFlags).toContain('REPULSOR');

    expect(logic.executeScriptAction({
      actionType: 437,
      params: ['RepulsorTeam', 0],
    })).toBe(true);
    expect(logic.getEntityState(1)?.statusFlags).not.toContain('REPULSOR');
    expect(logic.getEntityState(2)?.statusFlags).not.toContain('REPULSOR');

    expect(logic.executeScriptAction({
      actionType: 436,
      params: [999, 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 437,
      params: ['MissingTeam', 1],
    })).toBe(false);
  });

  it('executes script team-wander-in-place action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('LocomotorSet', 'SET_NORMAL WanderLoco', {}),
          makeBlock('LocomotorSet', 'SET_WANDER WanderLoco', {}),
        ]),
      ],
      locomotors: [
        { ...makeLocomotorDef('WanderLoco', 90), fields: { Speed: 90, WanderAboutPointRadius: 30 } },
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 20, 20), // id 1
        makeMapObject('Ranger', 28, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('WanderTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        x: number;
        z: number;
        activeLocomotorSet: string;
        scriptWanderInPlaceActive: boolean;
      }>;
    };
    const unitOne = privateApi.spawnedEntities.get(1)!;
    const unitTwo = privateApi.spawnedEntities.get(2)!;
    const startOne = { x: unitOne.x, z: unitOne.z };
    const startTwo = { x: unitTwo.x, z: unitTwo.z };

    expect(logic.executeScriptAction({
      actionType: 438, // TEAM_WANDER_IN_PLACE
      params: ['WanderTeam'],
    })).toBe(true);
    expect(unitOne.activeLocomotorSet).toBe('SET_WANDER');
    expect(unitTwo.activeLocomotorSet).toBe('SET_WANDER');
    expect(unitOne.scriptWanderInPlaceActive).toBe(true);
    expect(unitTwo.scriptWanderInPlaceActive).toBe(true);

    for (let frame = 0; frame < 60; frame += 1) {
      logic.update(1 / 30);
    }

    const movedOne = Math.hypot(unitOne.x - startOne.x, unitOne.z - startOne.z) > 0.1;
    const movedTwo = Math.hypot(unitTwo.x - startTwo.x, unitTwo.z - startTwo.z) > 0.1;
    expect(movedOne || movedTwo).toBe(true);

    logic.submitCommand({ type: 'stop', entityId: 1 });
    logic.update(1 / 30);
    expect(unitOne.scriptWanderInPlaceActive).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 438,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script team-wander/team-panic actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL NormalLoco', {}),
          makeBlock('LocomotorSet', 'SET_WANDER WanderLoco', {}),
          makeBlock('LocomotorSet', 'SET_PANIC PanicLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('NormalLoco', 50),
        makeLocomotorDef('WanderLoco', 70),
        makeLocomotorDef('PanicLoco', 90),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 10, 20), // id 1
      makeMapObject('Ranger', 14, 22), // id 2
    ], 128, 128);
    map.waypoints = {
      nodes: [
        { id: 11, name: 'Path_A', position: { x: 20, y: 20, z: 0 }, pathLabel1: 'PanicPath', biDirectional: false },
        { id: 12, name: 'Path_B', position: { x: 45, y: 20, z: 0 }, pathLabel1: 'PanicPath', biDirectional: false },
        { id: 13, name: 'Path_C', position: { x: 70, y: 20, z: 0 }, pathLabel1: 'PanicPath', biDirectional: false },
      ],
      links: [
        { waypoint1: 11, waypoint2: 12 },
        { waypoint1: 12, waypoint2: 13 },
      ],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('PathTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        activeLocomotorSet: string;
        moveTarget: { x: number; z: number } | null;
        movePath: Array<{ x: number; z: number }>;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 112, // TEAM_WANDER
      params: ['PathTeam', 'PanicPath'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.activeLocomotorSet).toBe('SET_WANDER');
    expect(privateApi.spawnedEntities.get(2)?.activeLocomotorSet).toBe('SET_WANDER');
    expect(privateApi.spawnedEntities.get(1)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(2)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(1)?.movePath.length).toBeGreaterThan(0);
    expect(privateApi.spawnedEntities.get(2)?.movePath.length).toBeGreaterThan(0);

    logic.submitCommand({ type: 'stop', entityId: 1 });
    logic.submitCommand({ type: 'stop', entityId: 2 });
    logic.update(1 / 30);

    expect(logic.executeScriptAction({
      actionType: 113, // TEAM_PANIC
      params: ['PathTeam', 'PanicPath'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.activeLocomotorSet).toBe('SET_PANIC');
    expect(privateApi.spawnedEntities.get(2)?.activeLocomotorSet).toBe('SET_PANIC');
    expect(privateApi.spawnedEntities.get(1)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(2)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(1)?.movePath.length).toBeGreaterThan(0);
    expect(privateApi.spawnedEntities.get(2)?.movePath.length).toBeGreaterThan(0);

    expect(logic.executeScriptAction({
      actionType: 112,
      params: ['MissingTeam', 'PanicPath'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 112,
      params: ['PathTeam', 'MissingPath'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 113,
      params: ['PathTeam', 'MissingPath'],
    })).toBe(false);
  });

  it('executes script team-priority actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 20, 20)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    expect(logic.setScriptTeamMembers('PriorityTeam', [1])).toBe(true);
    expect(logic.setScriptTeamPriorityValues('PriorityTeam', 10, 3, 2)).toBe(true);
    expect(logic.getScriptTeamPriorityState('PriorityTeam')).toEqual({
      productionPriority: 10,
      successIncrease: 3,
      failureDecrease: 2,
    });

    expect(logic.executeScriptAction({
      actionType: 439, // TEAM_INCREASE_PRIORITY
      params: ['PriorityTeam'],
    })).toBe(true);
    expect(logic.getScriptTeamPriorityState('PriorityTeam')?.productionPriority).toBe(13);

    expect(logic.executeScriptAction({
      actionType: 440, // TEAM_DECREASE_PRIORITY
      params: ['PriorityTeam'],
    })).toBe(true);
    expect(logic.getScriptTeamPriorityState('PriorityTeam')?.productionPriority).toBe(11);

    expect(logic.executeScriptAction({
      actionType: 439,
      params: ['MissingTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 440,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script idle-all/resume-supply-trucking actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_WarehouseDock', {
            StartingBoxes: 20,
            DeleteWhenEmpty: false,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
        makeObjectDef('SupplyCenter', 'America', ['STRUCTURE'], [
          makeBlock('Behavior', 'SupplyCenterDockUpdate ModuleTag_CenterDock', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ]),
        makeObjectDef('SupplyTruck', 'America', ['VEHICLE', 'HARVESTER'], [
          makeBlock('Behavior', 'SupplyTruckAIUpdate ModuleTag_SupplyTruckAI', {
            MaxBoxes: 3,
            SupplyCenterActionDelay: 0,
            SupplyWarehouseActionDelay: 0,
            SupplyWarehouseScanDistance: 500,
          }),
          makeBlock('LocomotorSet', 'SET_NORMAL SupplyTruckLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('SupplyTruckLoco', 60),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyWarehouse', 10, 10), // id 1
        makeMapObject('SupplyCenter', 100, 10), // id 2
        makeMapObject('SupplyTruck', 20, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'HUMAN' });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'China', playerType: 'COMPUTER' });
    logic.update(1 / 30);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        x: number;
        z: number;
      }>;
      sideUnitsShouldIdleOrResume: Map<string, boolean>;
    };
    const truck = privateApi.spawnedEntities.get(3)!;

    for (let frame = 0; frame < 20; frame += 1) {
      logic.update(1 / 30);
    }
    const beforeIdle = { x: truck.x, z: truck.z };

    expect(logic.executeScriptAction({
      actionType: 451, // IDLE_ALL_UNITS
    })).toBe(true);
    expect(privateApi.sideUnitsShouldIdleOrResume.get('america')).toBe(true);

    for (let frame = 0; frame < 20; frame += 1) {
      logic.update(1 / 30);
    }
    const idleDistance = Math.hypot(truck.x - beforeIdle.x, truck.z - beforeIdle.z);
    expect(idleDistance).toBeLessThan(0.1);

    expect(logic.executeScriptAction({
      actionType: 452, // RESUME_SUPPLY_TRUCKING
    })).toBe(true);
    expect(privateApi.sideUnitsShouldIdleOrResume.get('america')).toBe(false);

    for (let frame = 0; frame < 20; frame += 1) {
      logic.update(1 / 30);
    }
    const resumedDistance = Math.hypot(truck.x - beforeIdle.x, truck.z - beforeIdle.z);
    expect(resumedDistance).toBeGreaterThan(0.1);
  });

  it('executes script skirmish-build-building action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], {
          GeometryMajorRadius: 5,
          GeometryMinorRadius: 5,
        }),
        makeObjectDef('USAPowerPlant', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20), // id 1
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 2000 });
    logic.update(0);

    const privateApi = logic as unknown as {
      pendingConstructionActions: Map<number, number>;
      spawnedEntities: Map<number, {
        templateName: string;
        constructionPercent: number;
      }>;
    };

    // Source action depends on ScriptEngine current-player context.
    expect(logic.executeScriptAction({
      actionType: 449, // SKIRMISH_BUILD_BUILDING
      params: ['USAPowerPlant'],
    })).toBe(false);

    expect(logic.setScriptCurrentPlayerSide('America')).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 449, // SKIRMISH_BUILD_BUILDING
      params: ['USAPowerPlant'],
    })).toBe(true);

    const constructedId = privateApi.pendingConstructionActions.get(1);
    expect(constructedId).toBeDefined();
    expect(privateApi.spawnedEntities.get(constructedId!)?.templateName).toBe('USAPowerPlant');
    expect(privateApi.spawnedEntities.get(constructedId!)?.constructionPercent).toBe(0);

    expect(logic.executeScriptAction({
      actionType: 449,
      params: ['MissingTemplate'],
    })).toBe(false);

    logic.clearScriptCurrentPlayerSide();
    expect(logic.executeScriptAction({
      actionType: 449,
      params: ['USAPowerPlant'],
    })).toBe(false);
  });

  it('executes skirmish approach-path actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL TestInfantryLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('EnemyBarracks', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
      ],
      locomotors: [
        makeLocomotorDef('TestInfantryLoco', 60),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 5, 20), // id 1
      makeMapObject('Ranger', 8, 22), // id 2
      makeMapObject('EnemyBarracks', 110, 20), // id 3
    ], 128, 128);
    map.waypoints = {
      nodes: [
        { id: 10, name: 'Approach_A', position: { x: 20, y: 20, z: 0 }, pathLabel1: 'ApproachPath2', biDirectional: false },
        { id: 11, name: 'Approach_B', position: { x: 60, y: 20, z: 0 }, pathLabel1: 'ApproachPath2', biDirectional: false },
        { id: 12, name: 'Approach_C', position: { x: 90, y: 20, z: 0 }, pathLabel1: 'ApproachPath2', biDirectional: false },
      ],
      links: [
        { waypoint1: 10, waypoint2: 11 },
        { waypoint1: 11, waypoint2: 12 },
      ],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AttackTeam', [1, 2])).toBe(true);
    logic.setTeamRelationship('America', 'China', 0);
    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'COMPUTER' });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'China', playerType: 'HUMAN' });
    expect(logic.setSkirmishPlayerStartPosition('America', 1)).toBe(true);
    expect(logic.setSkirmishPlayerStartPosition('China', 2)).toBe(true);
    logic.update(0);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        moveTarget: { x: number; z: number } | null;
        movePath: Array<{ x: number; z: number }>;
      }>;
    };

    // Source actions depend on ScriptEngine current-player context.
    expect(logic.executeScriptAction({
      actionType: 454, // SKIRMISH_MOVE_TO_APPROACH_PATH
      params: ['AttackTeam', 'ApproachPath'],
    })).toBe(false);

    expect(logic.setScriptCurrentPlayerSide('America')).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 454, // SKIRMISH_MOVE_TO_APPROACH_PATH
      params: ['AttackTeam', 'ApproachPath'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(1)?.movePath.length).toBeGreaterThan(0);
    expect(privateApi.spawnedEntities.get(2)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(2)?.movePath.length).toBeGreaterThan(0);

    expect(logic.executeScriptAction({
      actionType: 450, // SKIRMISH_FOLLOW_APPROACH_PATH
      params: ['AttackTeam', 'ApproachPath', 0],
    })).toBe(true);
    expect(
      privateApi.spawnedEntities.get(1)?.movePath.some((node) => Math.hypot(node.x - 60, node.z - 20) < 0.5),
    ).toBe(true);
    expect(
      privateApi.spawnedEntities.get(1)?.movePath.some((node) => Math.hypot(node.x - 90, node.z - 20) < 0.5),
    ).toBe(true);
    expect(
      privateApi.spawnedEntities.get(2)?.movePath.some((node) => Math.hypot(node.x - 60, node.z - 20) < 0.5),
    ).toBe(true);
    expect(
      privateApi.spawnedEntities.get(2)?.movePath.some((node) => Math.hypot(node.x - 90, node.z - 20) < 0.5),
    ).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 450,
      params: ['MissingTeam', 'ApproachPath', 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 454,
      params: ['AttackTeam', 'MissingPath'],
    })).toBe(false);

    logic.clearScriptCurrentPlayerSide();
    expect(logic.executeScriptAction({
      actionType: 450,
      params: ['AttackTeam', 'ApproachPath', 0],
    })).toBe(false);
  });

  it('executes follow-waypoints actions using raw and offset source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL TestInfantryLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('TestInfantryLoco', 60),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 16, 20), // id 1
      makeMapObject('Ranger', 18, 22), // id 2
    ], 128, 128);
    map.waypoints = {
      nodes: [
        { id: 21, name: 'Patrol_A', position: { x: 20, y: 20, z: 0 }, pathLabel1: 'PatrolPathA', biDirectional: false },
        { id: 22, name: 'Patrol_B', position: { x: 45, y: 20, z: 0 }, pathLabel1: 'PatrolPathA', biDirectional: false },
        { id: 23, name: 'Patrol_C', position: { x: 70, y: 20, z: 0 }, pathLabel1: 'PatrolPathA', biDirectional: false },
      ],
      links: [
        { waypoint1: 21, waypoint2: 22 },
        { waypoint1: 22, waypoint2: 23 },
      ],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('PatrolTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        moveTarget: { x: number; z: number } | null;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 36, // TEAM_FOLLOW_WAYPOINTS (raw id)
      params: ['PatrolTeam', 'PatrolPathA', 0],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.moveTarget).not.toBeNull();
    expect(privateApi.spawnedEntities.get(2)?.moveTarget).not.toBeNull();

    expect(logic.executeScriptAction({
      actionType: 241, // TEAM_FOLLOW_WAYPOINTS (offset id)
      params: ['PatrolTeam', 'PatrolPathA', 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 56, // NAMED_FOLLOW_WAYPOINTS (raw id)
      params: [1, 'PatrolPathA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 261, // NAMED_FOLLOW_WAYPOINTS (offset id)
      params: [2, 'PatrolPathA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 281, // TEAM_FOLLOW_WAYPOINTS_EXACT (raw id)
      params: ['PatrolTeam', 'PatrolPathA', 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 486, // TEAM_FOLLOW_WAYPOINTS_EXACT (offset id)
      params: ['PatrolTeam', 'PatrolPathA', 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 282, // NAMED_FOLLOW_WAYPOINTS_EXACT (raw id)
      params: [1, 'PatrolPathA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 487, // NAMED_FOLLOW_WAYPOINTS_EXACT (offset id)
      params: [2, 'PatrolPathA'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 36,
      params: ['MissingTeam', 'PatrolPathA', 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 56,
      params: [1, 'MissingPath'],
    })).toBe(false);
  });

  it('records waypoint-path completion from follow-waypoints actions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL TestInfantryLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('TestInfantryLoco', 60),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 18, 20), // id 1
    ], 128, 128);
    map.waypoints = {
      nodes: [
        { id: 31, name: 'Route_A', position: { x: 20, y: 20, z: 0 }, pathLabel1: 'RouteAlpha', biDirectional: false },
        { id: 32, name: 'Route_B', position: { x: 40, y: 20, z: 0 }, pathLabel1: 'RouteAlpha', biDirectional: false },
        { id: 33, name: 'Route_C', position: { x: 60, y: 20, z: 0 }, pathLabel1: 'RouteAlpha', biDirectional: false },
      ],
      links: [
        { waypoint1: 31, waypoint2: 32 },
        { waypoint1: 32, waypoint2: 33 },
      ],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 56, // NAMED_FOLLOW_WAYPOINTS (raw id)
      params: [1, 'RouteAlpha'],
    })).toBe(true);

    for (let frame = 0; frame < 80; frame += 1) {
      logic.update(1 / 30);
    }

    expect(logic.evaluateScriptNamedReachedWaypointsEnd({
      entityId: 1,
      waypointPathName: 'RouteAlpha',
    })).toBe(true);
  });

  it('executes script skirmish-build-base-defense-front action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], {
          CommandSet: 'DozerConstructSet',
          GeometryMajorRadius: 5,
          GeometryMinorRadius: 5,
        }),
        makeObjectDef('PatriotBattery', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ConstructPatriot', {
          Command: 'DOZER_CONSTRUCT',
          Object: 'PatriotBattery',
        }),
      ],
      commandSets: [
        makeCommandSetDef('DozerConstructSet', {
          1: 'Command_ConstructPatriot',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20), // id 1
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 5000 });
    logic.update(0);

    const privateApi = logic as unknown as {
      pendingConstructionActions: Map<number, number>;
      spawnedEntities: Map<number, {
        templateName: string;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 455, // SKIRMISH_BUILD_BASE_DEFENSE_FRONT
    })).toBe(false);

    expect(logic.setScriptCurrentPlayerSide('America')).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 455, // SKIRMISH_BUILD_BASE_DEFENSE_FRONT
    })).toBe(true);

    const buildId = privateApi.pendingConstructionActions.get(1);
    expect(buildId).toBeDefined();
    expect(privateApi.spawnedEntities.get(buildId!)?.templateName).toBe('PatriotBattery');

    logic.clearScriptCurrentPlayerSide();
    expect(logic.executeScriptAction({
      actionType: 455,
    })).toBe(false);
  });

  it('executes script skirmish flank/structure build actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], {
          CommandSet: 'DozerConstructSet',
          GeometryMajorRadius: 5,
          GeometryMinorRadius: 5,
        }),
        makeObjectDef('PatriotBattery', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
        makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ConstructPatriot', {
          Command: 'DOZER_CONSTRUCT',
          Object: 'PatriotBattery',
        }),
        makeCommandButtonDef('Command_ConstructBarracks', {
          Command: 'DOZER_CONSTRUCT',
          Object: 'USABarracks',
        }),
      ],
      commandSets: [
        makeCommandSetDef('DozerConstructSet', {
          1: 'Command_ConstructPatriot',
          2: 'Command_ConstructBarracks',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20), // id 1
        makeMapObject('USADozer', 60, 20), // id 2
        makeMapObject('USADozer', 100, 20), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 10000 });
    logic.update(0);

    const privateApi = logic as unknown as {
      pendingConstructionActions: Map<number, number>;
      spawnedEntities: Map<number, {
        templateName: string;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 459, // SKIRMISH_BUILD_BASE_DEFENSE_FLANK
    })).toBe(false);

    expect(logic.setScriptCurrentPlayerSide('America')).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 459, // SKIRMISH_BUILD_BASE_DEFENSE_FLANK
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 460, // SKIRMISH_BUILD_STRUCTURE_FRONT
      params: ['USABarracks'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 461, // SKIRMISH_BUILD_STRUCTURE_FLANK
      params: ['USABarracks'],
    })).toBe(true);

    const pendingIds = Array.from(privateApi.pendingConstructionActions.values());
    const templates = pendingIds.map((id) => privateApi.spawnedEntities.get(id)?.templateName ?? '');
    expect(templates).toContain('PatriotBattery');
    expect(templates.filter((templateName) => templateName === 'USABarracks').length).toBeGreaterThanOrEqual(2);

    expect(logic.executeScriptAction({
      actionType: 460,
      params: ['MissingTemplate'],
    })).toBe(false);
    logic.clearScriptCurrentPlayerSide();
    expect(logic.executeScriptAction({
      actionType: 461,
      params: ['USABarracks'],
    })).toBe(false);
  });

  it('executes script skirmish-attack-nearest-group-with-value action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL TestInfantryLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], {
          BuildCost: 300,
        }),
        makeObjectDef('EnemyLight', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], {
          BuildCost: 1000,
        }),
        makeObjectDef('EnemyValuableNear', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
        ], {
          BuildCost: 1800,
        }),
        makeObjectDef('EnemyValuableFar', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], {
          BuildCost: 2400,
        }),
      ],
      locomotors: [
        makeLocomotorDef('TestInfantryLoco', 60),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 20, 20), // id 1
        makeMapObject('Ranger', 24, 20), // id 2
        makeMapObject('EnemyLight', 70, 20), // id 3
        makeMapObject('EnemyValuableNear', 70, 80), // id 4
        makeMapObject('EnemyValuableFar', 180, 180), // id 5
      ], 256, 256),
      makeRegistry(bundle),
      makeHeightmap(256, 256),
    );
    expect(logic.setScriptTeamMembers('AttackValueTeam', [1, 2])).toBe(true);
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 462, // SKIRMISH_ATTACK_NEAREST_GROUP_WITH_VALUE
      params: ['AttackValueTeam', 3, 1200], // GREATER_EQUAL 1200
    })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        moveTarget: { x: number; z: number } | null;
        movePath: Array<{ x: number; z: number }>;
      }>;
    };
    const unitOne = privateApi.spawnedEntities.get(1)!;
    const unitTwo = privateApi.spawnedEntities.get(2)!;
    expect(unitOne.moveTarget).not.toBeNull();
    expect(unitTwo.moveTarget).not.toBeNull();
    const finalOne = unitOne.movePath.at(-1);
    const finalTwo = unitTwo.movePath.at(-1);
    expect(finalOne).toBeDefined();
    expect(finalTwo).toBeDefined();
    expect(Math.hypot(finalOne!.x - 70, finalOne!.z - 80)).toBeLessThanOrEqual(35);
    expect(Math.hypot(finalTwo!.x - 70, finalTwo!.z - 80)).toBeLessThanOrEqual(35);

    expect(logic.executeScriptAction({
      actionType: 462,
      params: ['AttackValueTeam', 2, 1200], // EQUAL (unsupported in source subset)
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 462,
      params: ['MissingTeam', 3, 1200],
    })).toBe(false);
  });

  it('executes script command-button-on-most-valuable-object action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptCaster', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_OnNamed', {
            SpecialPowerTemplate: 'ScriptPowerOnNamed',
          }),
        ], {
          CommandSet: 'ScriptCasterCommandSet',
          BuildCost: 300,
        }),
        makeObjectDef('EnemyCheap', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], {
          BuildCost: 500,
        }),
        makeObjectDef('EnemyExpensive', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], {
          BuildCost: 2000,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ScriptOnNamed', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerOnNamed',
          Options: 'NEED_TARGET_ENEMY_OBJECT',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptCasterCommandSet', {
          1: 'Command_ScriptOnNamed',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerOnNamed', { ReloadTime: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScriptCaster', 20, 20), // id 1
        makeMapObject('EnemyCheap', 60, 20), // id 2
        makeMapObject('EnemyExpensive', 70, 20), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AbilityValueTeam', [1])).toBe(true);
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 463, // SKIRMISH_PERFORM_COMMANDBUTTON_ON_MOST_VALUABLE_OBJECT
      params: ['AbilityValueTeam', 'Command_ScriptOnNamed', 200, 1],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      targetEntityId: 3,
    });

    expect(logic.executeScriptAction({
      actionType: 463,
      params: ['AbilityValueTeam', 'Command_Missing', 200, 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 463,
      params: ['MissingTeam', 'Command_ScriptOnNamed', 200, 0],
    })).toBe(false);
  });

  it('executes script skirmish wait-for-command-button actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptCaster', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_NoTarget', {
            SpecialPowerTemplate: 'ScriptPowerNoTarget',
          }),
        ], {
          CommandSet: 'ScriptCasterCommandSet',
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ScriptNoTarget', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerNoTarget',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptCasterCommandSet', {
          1: 'Command_ScriptNoTarget',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerNoTarget', { ReloadTime: 10 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScriptCaster', 20, 20), // id 1
        makeMapObject('ScriptCaster', 28, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('WaitTeam', [1, 2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 445, // NAMED_USE_COMMANDBUTTON_ABILITY
      params: [1, 'Command_ScriptNoTarget'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 464, // SKIRMISH_WAIT_FOR_COMMANDBUTTON_AVAILABLE_ALL
      params: ['America', 'WaitTeam', 'Command_ScriptNoTarget'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 465, // SKIRMISH_WAIT_FOR_COMMANDBUTTON_AVAILABLE_PARTIAL
      params: ['America', 'WaitTeam', 'Command_ScriptNoTarget'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 464,
      params: ['America', 'MissingTeam', 'Command_ScriptNoTarget'],
    })).toBe(false);
  });

  it('executes script team wait-for-not-contained actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 20, 20), // id 1
        makeMapObject('Ranger', 28, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('ContainTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
    };
    privateApi.spawnedEntities.get(1)!.transportContainerId = 99;
    privateApi.spawnedEntities.get(2)!.transportContainerId = 99;

    expect(logic.executeScriptAction({
      actionType: 484, // TEAM_WAIT_FOR_NOT_CONTAINED_ALL
      params: ['ContainTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 279, // TEAM_WAIT_FOR_NOT_CONTAINED_ALL (raw id)
      params: ['ContainTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 485, // TEAM_WAIT_FOR_NOT_CONTAINED_PARTIAL
      params: ['ContainTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 280, // TEAM_WAIT_FOR_NOT_CONTAINED_PARTIAL (raw id)
      params: ['ContainTeam'],
    })).toBe(false);

    privateApi.spawnedEntities.get(1)!.transportContainerId = null;
    expect(logic.executeScriptAction({
      actionType: 484,
      params: ['ContainTeam'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 279,
      params: ['ContainTeam'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 485,
      params: ['ContainTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 280,
      params: ['ContainTeam'],
    })).toBe(false);

    privateApi.spawnedEntities.get(2)!.transportContainerId = null;
    expect(logic.executeScriptAction({
      actionType: 485,
      params: ['ContainTeam'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 280,
      params: ['ContainTeam'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 484,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('holds sequential scripts on team wait-for-not-contained actions until containment clears', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 20, 20), // id 1
        makeMapObject('Ranger', 28, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('ContainTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
      mapScriptsByNameUpper: Map<string, {
        actions: Array<{ actionType: number; params: Array<{ type: number; value: unknown }> }>;
      }>;
    };
    privateApi.mapScriptsByNameUpper.set('WAITCONTAINSEQ', {
      actions: [
        {
          actionType: 485, // TEAM_WAIT_FOR_NOT_CONTAINED_PARTIAL
          params: [{ type: 2, value: 'ContainTeam' }],
        },
        {
          actionType: 1, // SET_FLAG
          params: [
            { type: 5, value: 'ContainmentCleared' },
            { type: 8, value: true },
          ],
        },
      ],
    });

    privateApi.spawnedEntities.get(1)!.transportContainerId = 99;

    expect(logic.executeScriptAction({
      actionType: 395, // TEAM_EXECUTE_SEQUENTIAL_SCRIPT
      params: ['ContainTeam', 'WaitContainSeq'],
    })).toBe(true);

    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['ContainmentCleared', true],
    })).toBe(false);

    privateApi.spawnedEntities.get(1)!.transportContainerId = null;
    logic.update(1 / 30);
    expect(logic.evaluateScriptCondition({
      conditionType: 'FLAG',
      params: ['ContainmentCleared', true],
    })).toBe(true);
  });

  it('executes script team spin-for-framecount action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 20, 20), // id 1
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('SpinTeam', [1])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 395, // TEAM_EXECUTE_SEQUENTIAL_SCRIPT
      params: ['SpinTeam', 'SpinScript'],
    })).toBe(true);

    const privateApi = logic as unknown as {
      scriptSequentialScripts: Array<{
        teamNameUpper: string | null;
        framesToWait: number;
      }>;
    };
    const spinScript = privateApi.scriptSequentialScripts.find(
      (script) => script.teamNameUpper === 'SPINTEAM',
    );
    expect(spinScript).toBeTruthy();
    expect(spinScript?.framesToWait).toBe(-1);

    expect(logic.executeScriptAction({
      actionType: 466, // TEAM_SPIN_FOR_FRAMECOUNT
      params: ['SpinTeam', 45],
    })).toBe(true);
    expect(spinScript?.framesToWait).toBe(45);

    expect(logic.executeScriptAction({
      actionType: 466,
      params: ['MissingTeam', 45],
    })).toBe(false);
  });

  it('executes script sequential-script actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 20, 20)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('SeqTeam', [1])).toBe(true);

    const privateApi = logic as unknown as {
      scriptSequentialScripts: Array<{
        scriptNameUpper: string;
        objectId: number | null;
        teamNameUpper: string | null;
        timesToLoop: number;
        currentInstruction: number;
        framesToWait: number;
        nextScript: unknown | null;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 392, // UNIT_EXECUTE_SEQUENTIAL_SCRIPT
      params: [1, 'UnitSeq'],
    })).toBe(true);
    const unitSeq = privateApi.scriptSequentialScripts.find((script) => script.objectId === 1);
    expect(unitSeq?.scriptNameUpper).toBe('UNITSEQ');
    expect(unitSeq?.timesToLoop).toBe(0);
    expect(unitSeq?.currentInstruction).toBe(-1);
    expect(unitSeq?.framesToWait).toBe(-1);

    expect(logic.executeScriptAction({
      actionType: 393, // UNIT_EXECUTE_SEQUENTIAL_SCRIPT_LOOPING
      params: [1, 'UnitSeqLoop', 2],
    })).toBe(true);
    const unitNext = unitSeq?.nextScript as { scriptNameUpper: string; timesToLoop: number } | null;
    expect(unitNext?.scriptNameUpper).toBe('UNITSEQLOOP');
    expect(unitNext?.timesToLoop).toBe(1);

    expect(logic.executeScriptAction({
      actionType: 394, // UNIT_STOP_SEQUENTIAL_SCRIPT
      params: [1],
    })).toBe(true);
    expect(privateApi.scriptSequentialScripts.some((script) => script.objectId === 1)).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 395, // TEAM_EXECUTE_SEQUENTIAL_SCRIPT
      params: ['SeqTeam', 'TeamSeq'],
    })).toBe(true);
    const teamSeq = privateApi.scriptSequentialScripts.find((script) => script.teamNameUpper === 'SEQTEAM');
    expect(teamSeq?.scriptNameUpper).toBe('TEAMSEQ');
    expect(teamSeq?.timesToLoop).toBe(0);

    expect(logic.executeScriptAction({
      actionType: 396, // TEAM_EXECUTE_SEQUENTIAL_SCRIPT_LOOPING
      params: ['SeqTeam', 'TeamSeqLoop', 0],
    })).toBe(true);
    const teamNext = teamSeq?.nextScript as { scriptNameUpper: string; timesToLoop: number } | null;
    expect(teamNext?.scriptNameUpper).toBe('TEAMSEQLOOP');
    expect(teamNext?.timesToLoop).toBe(-1);

    expect(logic.executeScriptAction({
      actionType: 397, // TEAM_STOP_SEQUENTIAL_SCRIPT
      params: ['SeqTeam'],
    })).toBe(true);
    expect(privateApi.scriptSequentialScripts.some((script) => script.teamNameUpper === 'SEQTEAM')).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 392,
      params: [999, 'MissingUnit'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 395,
      params: ['MissingTeam', 'MissingScript'],
    })).toBe(false);
  });

  it('executes script guard/idle-for-framecount actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 14, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('FrameTeam', [1, 2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 392, // UNIT_EXECUTE_SEQUENTIAL_SCRIPT
      params: [1, 'UnitFrameSeq'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 395, // TEAM_EXECUTE_SEQUENTIAL_SCRIPT
      params: ['FrameTeam', 'TeamFrameSeq'],
    })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { guardState: string }>;
      scriptSequentialScripts: Array<{
        objectId: number | null;
        teamNameUpper: string | null;
        framesToWait: number;
      }>;
    };
    const unitSeq = privateApi.scriptSequentialScripts.find((script) => script.objectId === 1)!;
    const teamSeq = privateApi.scriptSequentialScripts.find((script) => script.teamNameUpper === 'FRAMETEAM')!;

    expect(logic.executeScriptAction({
      actionType: 398, // UNIT_GUARD_FOR_FRAMECOUNT
      params: [1, 12],
    })).toBe(true);
    expect(unitSeq.framesToWait).toBe(12);
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');

    expect(logic.executeScriptAction({
      actionType: 399, // UNIT_IDLE_FOR_FRAMECOUNT
      params: [1, 8],
    })).toBe(true);
    expect(unitSeq.framesToWait).toBe(8);
    expect(privateApi.spawnedEntities.get(1)?.guardState).toBe('NONE');

    expect(logic.executeScriptAction({
      actionType: 400, // TEAM_GUARD_FOR_FRAMECOUNT
      params: ['FrameTeam', 20],
    })).toBe(true);
    expect(teamSeq.framesToWait).toBe(20);

    expect(logic.executeScriptAction({
      actionType: 401, // TEAM_IDLE_FOR_FRAMECOUNT
      params: ['FrameTeam', 5],
    })).toBe(true);
    expect(teamSeq.framesToWait).toBe(5);

    expect(logic.executeScriptAction({
      actionType: 398,
      params: [999, 10],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 400,
      params: ['MissingTeam', 10],
    })).toBe(false);
  });

  it('executes script water height actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 50, 50), // id 1
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'WaterAreaA',
      isWaterArea: true,
      isRiver: false,
      points: [
        { x: 40, y: 40, z: 0 },
        { x: 60, y: 40, z: 0 },
        { x: 60, y: 60, z: 0 },
        { x: 40, y: 60, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));

    const privateApi = logic as unknown as {
      waterPolygonData: Array<{ waterHeight: number }>;
      spawnedEntities: Map<number, { destroyed: boolean }>;
    };
    expect(privateApi.waterPolygonData[0]?.waterHeight).toBe(0);

    expect(logic.executeScriptAction({
      actionType: 402, // WATER_CHANGE_HEIGHT
      params: ['WaterAreaA', 10],
    })).toBe(true);
    expect(privateApi.waterPolygonData[0]?.waterHeight).toBe(10);
    expect(privateApi.spawnedEntities.get(1)?.destroyed).toBe(true);

    const mapOverTime = makeMap([
      makeMapObject('Ranger', 50, 50), // id 1
    ], 128, 128);
    mapOverTime.triggers = map.triggers;

    const logicOverTime = new GameLogicSubsystem(new THREE.Scene());
    logicOverTime.loadMapObjects(mapOverTime, makeRegistry(bundle), makeHeightmap(128, 128));
    const privateOverTime = logicOverTime as unknown as {
      waterPolygonData: Array<{ waterHeight: number }>;
      dynamicWaterUpdates: Array<{ waterIndex: number }>;
    };

    expect(logicOverTime.executeScriptAction({
      actionType: 405, // WATER_CHANGE_HEIGHT_OVER_TIME
      params: ['WaterAreaA', 6, 1, 0],
    })).toBe(true);
    expect(privateOverTime.dynamicWaterUpdates.length).toBe(1);

    for (let frame = 0; frame < 30; frame += 1) {
      logicOverTime.update(1 / 30);
    }
    expect(privateOverTime.dynamicWaterUpdates.length).toBe(0);
    expect(privateOverTime.waterPolygonData[0]?.waterHeight).toBeCloseTo(6, 4);

    expect(logicOverTime.executeScriptAction({
      actionType: 402,
      params: ['MissingWater', 5],
    })).toBe(false);
  });

  it('executes script map-switch-border action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10)], 64, 64),
      makeRegistry(bundle),
      makeHeightmap(64, 64),
    );

    const privateApi = logic as unknown as { scriptActiveBoundaryIndex: number | null };
    expect(logic.executeScriptAction({
      actionType: 406, // MAP_SWITCH_BORDER
      params: [2],
    })).toBe(true);
    expect(privateApi.scriptActiveBoundaryIndex).toBe(2);
  });

  it('executes team all-use command-button target actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptCaster', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_OnNamed', {
            SpecialPowerTemplate: 'ScriptPowerOnNamed',
          }),
        ], {
          CommandSet: 'ScriptCasterCommandSet',
        }),
        makeObjectDef('EnemyUnit', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
        makeObjectDef('EnemyGarrison', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_Garrison', { ContainMax: 5 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
        makeObjectDef('EnemyBuilding', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
        makeObjectDef('EnemyPowerBuilding', 'China', ['STRUCTURE', 'FS_POWER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
        ], {
          GeometryMajorRadius: 10,
          GeometryMinorRadius: 10,
        }),
        makeObjectDef('SpecificTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ScriptOnNamed', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerOnNamed',
          Options: 'NEED_TARGET_ENEMY_OBJECT',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptCasterCommandSet', {
          1: 'Command_ScriptOnNamed',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerOnNamed', { ReloadTime: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScriptCaster', 20, 20), // id 1
        makeMapObject('ScriptCaster', 24, 20), // id 2
        makeMapObject('EnemyUnit', 58, 20), // id 3
        makeMapObject('EnemyGarrison', 68, 20), // id 4
        makeMapObject('EnemyBuilding', 78, 20), // id 5
        makeMapObject('EnemyPowerBuilding', 88, 20), // id 6
        makeMapObject('SpecificTarget', 52, 48), // id 7
      ], 196, 196),
      makeRegistry(bundle),
      makeHeightmap(196, 196),
    );
    expect(logic.setScriptTeamMembers('AllUseTeam', [1, 2])).toBe(true);
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 467, // TEAM_ALL_USE_COMMANDBUTTON_ON_NAMED
      params: ['AllUseTeam', 'Command_ScriptOnNamed', 5],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(5);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(5);

    expect(logic.executeScriptAction({
      actionType: 468, // TEAM_ALL_USE_COMMANDBUTTON_ON_NEAREST_ENEMY_UNIT
      params: ['AllUseTeam', 'Command_ScriptOnNamed'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(3);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(3);

    expect(logic.executeScriptAction({
      actionType: 469, // TEAM_ALL_USE_COMMANDBUTTON_ON_NEAREST_GARRISONED_BUILDING
      params: ['AllUseTeam', 'Command_ScriptOnNamed'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(4);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(4);

    expect(logic.executeScriptAction({
      actionType: 470, // TEAM_ALL_USE_COMMANDBUTTON_ON_NEAREST_KINDOF
      params: ['AllUseTeam', 'Command_ScriptOnNamed', 'FS_POWER'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(6);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(6);

    expect(logic.executeScriptAction({
      actionType: 471, // TEAM_ALL_USE_COMMANDBUTTON_ON_NEAREST_ENEMY_BUILDING
      params: ['AllUseTeam', 'Command_ScriptOnNamed'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(4);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(4);

    expect(logic.executeScriptAction({
      actionType: 472, // TEAM_ALL_USE_COMMANDBUTTON_ON_NEAREST_ENEMY_BUILDING_CLASS
      params: ['AllUseTeam', 'Command_ScriptOnNamed', 'FS_POWER'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(6);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(6);

    expect(logic.executeScriptAction({
      actionType: 473, // TEAM_ALL_USE_COMMANDBUTTON_ON_NEAREST_OBJECTTYPE
      params: ['AllUseTeam', 'Command_ScriptOnNamed', 'SpecificTarget'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch?.targetEntityId).toBe(7);
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch?.targetEntityId).toBe(7);

    expect(logic.executeScriptAction({
      actionType: 468,
      params: ['AllUseTeam', 'Command_Missing'],
    })).toBe(false);
  });

  it('executes script team-partial-use-command-button action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptCaster', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_NoTarget', {
            SpecialPowerTemplate: 'ScriptPowerNoTarget',
          }),
        ], {
          CommandSet: 'ScriptCasterCommandSet',
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ScriptNoTarget', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerNoTarget',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptCasterCommandSet', {
          1: 'Command_ScriptNoTarget',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerNoTarget', { ReloadTime: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScriptCaster', 20, 20), // id 1
        makeMapObject('ScriptCaster', 28, 20), // id 2
        makeMapObject('ScriptCaster', 36, 20), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('PartialTeam', [1, 2, 3])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 474, // TEAM_PARTIAL_USE_COMMANDBUTTON
      params: [50, 'PartialTeam', 'Command_ScriptNoTarget'],
    })).toBe(true);

    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERNOTARGET',
      dispatchType: 'NO_TARGET',
    });
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERNOTARGET',
      dispatchType: 'NO_TARGET',
    });
    expect(logic.getEntityState(3)?.lastSpecialPowerDispatch).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 474,
      params: [50, 'PartialTeam', 'Command_Missing'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 474,
      params: [50, 'MissingTeam', 'Command_ScriptNoTarget'],
    })).toBe(false);
  });

  it('executes script team-capture-nearest-unowned-faction-unit action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CaptureInfantry', 'America', ['INFANTRY'], [
          makeBlock('LocomotorSet', 'SET_NORMAL TestInfantryLoco', {}),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('AbandonedVehicle', 'Civilian', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
        ]),
      ],
      locomotors: [
        makeLocomotorDef('TestInfantryLoco', 60),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CaptureInfantry', 20, 20), // id 1
        makeMapObject('CaptureInfantry', 24, 20), // id 2
        makeMapObject('AbandonedVehicle', 30, 20), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('CaptureTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        side: string | null;
        objectStatusFlags: Set<string>;
      }>;
    };
    privateApi.spawnedEntities.get(3)?.objectStatusFlags.add('DISABLED_UNMANNED');

    expect(logic.executeScriptAction({
      actionType: 475, // TEAM_CAPTURE_NEAREST_UNOWNED_FACTION_UNIT
      params: ['CaptureTeam'],
    })).toBe(true);

    for (let frame = 0; frame < 60; frame += 1) {
      logic.update(1 / 30);
    }

    const captured = privateApi.spawnedEntities.get(3);
    expect(captured).toBeDefined();
    expect((captured?.side ?? '').toLowerCase()).toBe('america');
    expect(captured?.objectStatusFlags.has('DISABLED_UNMANNED')).toBe(false);

    const capturerOneAlive = logic.getEntityState(1) !== null;
    const capturerTwoAlive = logic.getEntityState(2) !== null;
    expect(capturerOneAlive && capturerTwoAlive).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 475,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script player-create-team-from-captured-units action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 20, 20), // id 1
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('CapturedTeam', [1])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 476, // PLAYER_CREATE_TEAM_FROM_CAPTURED_UNITS
      params: ['America', 'CapturedTeam'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 271, // PLAYER_CREATE_TEAM_FROM_CAPTURED_UNITS (raw id)
      params: ['America', 'CapturedTeam'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 476,
      params: ['America', 'MissingTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 271,
      params: ['America', 'MissingTeam'],
    })).toBe(false);
  });

  it('executes script skirmish-fire-special-power-at-most-cost action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ParticleCannon', 'America', ['STRUCTURE', 'FS_SUPERWEAPON'], [
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_Strike', {
            SpecialPowerTemplate: 'ScriptPowerStrike',
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2500, InitialHealth: 2500 }),
        ], {
          BuildCost: 5000,
          GeometryMajorRadius: 18,
          GeometryMinorRadius: 18,
        }),
        makeObjectDef('ChinaCommandCenter', 'China', ['STRUCTURE', 'COMMANDCENTER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2000, InitialHealth: 2000 }),
        ], {
          BuildCost: 10000,
          GeometryMajorRadius: 16,
          GeometryMinorRadius: 16,
        }),
        makeObjectDef('EnemyWarFactory', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1600, InitialHealth: 1600 }),
        ], {
          BuildCost: 2000,
          GeometryMajorRadius: 14,
          GeometryMinorRadius: 14,
        }),
        makeObjectDef('EnemyPropagandaCenter', 'China', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1600, InitialHealth: 1600 }),
        ], {
          BuildCost: 2000,
          GeometryMajorRadius: 14,
          GeometryMinorRadius: 14,
        }),
        makeObjectDef('EnemyNukeSilo', 'China', ['STRUCTURE', 'FS_SUPERWEAPON'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 2200, InitialHealth: 2200 }),
        ], {
          BuildCost: 5000,
          GeometryMajorRadius: 16,
          GeometryMinorRadius: 16,
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerStrike', {
          ReloadTime: 0,
          RadiusCursorRadius: 80,
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ParticleCannon', 40, 40), // id 1
        makeMapObject('ChinaCommandCenter', 20, 20), // id 2
        makeMapObject('EnemyWarFactory', 200, 200), // id 3
        makeMapObject('EnemyPropagandaCenter', 220, 200), // id 4
        makeMapObject('EnemyNukeSilo', 380, 380), // id 5
      ], 512, 512),
      makeRegistry(bundle),
      makeHeightmap(512, 512),
    );
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 456, // SKIRMISH_FIRE_SPECIAL_POWER_AT_MOST_COST
      params: ['America', 'ScriptPowerStrike'],
    })).toBe(true);

    const dispatch = logic.getEntityState(1)?.lastSpecialPowerDispatch;
    expect(dispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERSTRIKE',
      dispatchType: 'POSITION',
      targetEntityId: null,
    });

    const targetX = dispatch?.targetX ?? 0;
    const targetZ = dispatch?.targetZ ?? 0;
    const highValueDistance = Math.min(
      Math.hypot(targetX - 200, targetZ - 200),
      Math.hypot(targetX - 220, targetZ - 200),
    );
    const commandCenterDistance = Math.hypot(targetX - 20, targetZ - 20);
    const superweaponDistance = Math.hypot(targetX - 380, targetZ - 380);
    expect(highValueDistance).toBeLessThan(commandCenterDistance);
    expect(highValueDistance).toBeLessThan(superweaponDistance);

    expect(logic.executeScriptAction({
      actionType: 456,
      params: ['America', 'MissingPower'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 456,
      params: ['', 'ScriptPowerStrike'],
    })).toBe(false);
  });

  it('executes script named-fire-special-power actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerCaster', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_AtWaypoint', {
            SpecialPowerTemplate: 'ScriptPowerAtWaypoint',
          }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_AtNamed', {
            SpecialPowerTemplate: 'ScriptPowerAtNamed',
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('SpecialPowerTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 250, InitialHealth: 250 }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerAtWaypoint', { ReloadTime: 0 }),
        makeSpecialPowerDef('ScriptPowerAtNamed', { ReloadTime: 0 }),
      ],
    });

    const map = makeMap([
      makeMapObject('SpecialPowerCaster', 12, 12), // id 1
      makeMapObject('SpecialPowerTarget', 40, 20), // id 2
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'SpecialPowerWaypoint',
          position: { x: 64, y: 80, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 168, // NAMED_FIRE_SPECIAL_POWER_AT_WAYPOINT (raw id)
      params: [1, 'ScriptPowerAtWaypoint', 'SpecialPowerWaypoint'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: '',
      targetEntityId: null,
      targetX: 64,
      targetZ: 80,
    });

    expect(logic.executeScriptAction({
      actionType: 373, // NAMED_FIRE_SPECIAL_POWER_AT_WAYPOINT (offset id)
      params: [1, 'ScriptPowerAtWaypoint', 'SpecialPowerWaypoint'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      targetEntityId: null,
      targetX: 64,
      targetZ: 80,
    });

    expect(logic.executeScriptAction({
      actionType: 169, // NAMED_FIRE_SPECIAL_POWER_AT_NAMED (raw id)
      params: [1, 'ScriptPowerAtNamed', 2],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: '',
      targetEntityId: 2,
      targetX: null,
      targetZ: null,
    });
    expect(logic.executeScriptAction({
      actionType: 374, // NAMED_FIRE_SPECIAL_POWER_AT_NAMED (offset id)
      params: [1, 'ScriptPowerAtNamed', 2],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATNAMED',
      dispatchType: 'OBJECT',
      targetEntityId: 2,
    });

    expect(logic.executeScriptAction({
      actionType: 168,
      params: [1, 'MissingPower', 'SpecialPowerWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 168,
      params: [1, 'ScriptPowerAtWaypoint', 'MissingWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 169,
      params: [1, 'ScriptPowerAtNamed', 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 169,
      params: [999, 'ScriptPowerAtNamed', 2],
    })).toBe(false);
  });

  it('executes script named special-power countdown actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerCountdownCaster', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_Countdown', {
            SpecialPowerTemplate: 'ScriptPowerCountdown',
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerCountdown', { ReloadTime: 0 }),
      ],
    });

    const map = makeMap([makeMapObject('SpecialPowerCountdownCaster', 10, 10)], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'CountdownWaypoint',
          position: { x: 40, y: 40, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const isReady = (): boolean => logic.evaluateScriptSkirmishSpecialPowerIsReady({
      side: 'America',
      specialPowerName: 'ScriptPowerCountdown',
    });

    expect(isReady()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 166, // NAMED_SET_SPECIAL_POWER_COUNTDOWN (raw id)
      params: [1, 'ScriptPowerCountdown', 3],
    })).toBe(true);
    expect(isReady()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 167, // NAMED_ADD_SPECIAL_POWER_COUNTDOWN (raw id)
      params: [1, 'ScriptPowerCountdown', 1],
    })).toBe(true);
    expect(isReady()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 369, // NAMED_STOP_SPECIAL_POWER_COUNTDOWN (offset id)
      params: [1, 'ScriptPowerCountdown'],
    })).toBe(true);
    for (let frame = 0; frame < 200; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 165, // NAMED_START_SPECIAL_POWER_COUNTDOWN (raw id)
      params: [1, 'ScriptPowerCountdown'],
    })).toBe(true);
    for (let frame = 0; frame < 119; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(false);
    for (let frame = 0; frame < 2; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 371, // NAMED_SET_SPECIAL_POWER_COUNTDOWN (offset id)
      params: [1, 'ScriptPowerCountdown', 2],
    })).toBe(true);
    for (let frame = 0; frame < 59; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(false);
    for (let frame = 0; frame < 2; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 372, // NAMED_ADD_SPECIAL_POWER_COUNTDOWN (offset id)
      params: [1, 'ScriptPowerCountdown', 1],
    })).toBe(true);
    for (let frame = 0; frame < 28; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(false);
    for (let frame = 0; frame < 2; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 164, // NAMED_STOP_SPECIAL_POWER_COUNTDOWN (raw id)
      params: [1, 'ScriptPowerCountdown'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 371,
      params: [1, 'ScriptPowerCountdown', 1],
    })).toBe(true);
    for (let frame = 0; frame < 120; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 370, // NAMED_START_SPECIAL_POWER_COUNTDOWN (offset id)
      params: [1, 'ScriptPowerCountdown'],
    })).toBe(true);
    for (let frame = 0; frame < 29; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(false);
    for (let frame = 0; frame < 2; frame += 1) {
      logic.update(1 / 30);
    }
    expect(isReady()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 166,
      params: [999, 'ScriptPowerCountdown', 1],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 166,
      params: [1, 'MissingPower', 1],
    })).toBe(false);
  });

  it('executes script command-button ability actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptCaster', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_NoTarget', {
            SpecialPowerTemplate: 'ScriptPowerNoTarget',
          }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_OnNamed', {
            SpecialPowerTemplate: 'ScriptPowerOnNamed',
          }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_AtWaypoint', {
            SpecialPowerTemplate: 'ScriptPowerAtWaypoint',
          }),
        ], {
          CommandSet: 'ScriptCasterCommandSet',
        }),
        makeObjectDef('ScriptTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ScriptNoTarget', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerNoTarget',
        }),
        makeCommandButtonDef('Command_ScriptOnNamed', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerOnNamed',
          Options: 'NEED_TARGET_ENEMY_OBJECT',
        }),
        makeCommandButtonDef('Command_ScriptAtWaypoint', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPowerAtWaypoint',
          Options: 'NEED_TARGET_POS',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptCasterCommandSet', {
          1: 'Command_ScriptNoTarget',
          2: 'Command_ScriptOnNamed',
          3: 'Command_ScriptAtWaypoint',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPowerNoTarget', { ReloadTime: 0 }),
        makeSpecialPowerDef('ScriptPowerOnNamed', { ReloadTime: 0 }),
        makeSpecialPowerDef('ScriptPowerAtWaypoint', { ReloadTime: 0 }),
      ],
    });

    const map = makeMap([
      makeMapObject('ScriptCaster', 10, 10), // id 1
      makeMapObject('ScriptCaster', 18, 10), // id 2
      makeMapObject('ScriptTarget', 40, 10), // id 3
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'AbilityWaypoint',
          position: { x: 96, y: 80, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setTeamRelationship('America', 'China', 0);
    expect(logic.setScriptTeamMembers('AbilityTeam', [1, 2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 445, // NAMED_USE_COMMANDBUTTON_ABILITY
      params: [1, 'Command_ScriptNoTarget'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERNOTARGET',
      dispatchType: 'NO_TARGET',
      commandButtonId: 'Command_ScriptNoTarget',
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    expect(logic.executeScriptAction({
      actionType: 240, // NAMED_USE_COMMANDBUTTON_ABILITY (raw id)
      params: [1, 'Command_ScriptNoTarget'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERNOTARGET',
      dispatchType: 'NO_TARGET',
      commandButtonId: 'Command_ScriptNoTarget',
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    expect(logic.executeScriptAction({
      actionType: 403, // NAMED_USE_COMMANDBUTTON_ABILITY_ON_NAMED
      params: [1, 'Command_ScriptOnNamed', 3],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: 'Command_ScriptOnNamed',
      targetEntityId: 3,
    });
    expect(logic.executeScriptAction({
      actionType: 198, // NAMED_USE_COMMANDBUTTON_ABILITY_ON_NAMED (raw id)
      params: [1, 'Command_ScriptOnNamed', 3],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: 'Command_ScriptOnNamed',
      targetEntityId: 3,
    });

    expect(logic.executeScriptAction({
      actionType: 404, // NAMED_USE_COMMANDBUTTON_ABILITY_AT_WAYPOINT
      params: [1, 'Command_ScriptAtWaypoint', 'AbilityWaypoint'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_ScriptAtWaypoint',
      targetEntityId: null,
      targetX: 96,
      targetZ: 80,
    });
    expect(logic.executeScriptAction({
      actionType: 199, // NAMED_USE_COMMANDBUTTON_ABILITY_AT_WAYPOINT (raw id)
      params: [1, 'Command_ScriptAtWaypoint', 'AbilityWaypoint'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_ScriptAtWaypoint',
      targetEntityId: null,
      targetX: 96,
      targetZ: 80,
    });

    expect(logic.executeScriptAction({
      actionType: 443, // TEAM_USE_COMMANDBUTTON_ABILITY_ON_NAMED
      params: ['AbilityTeam', 'Command_ScriptOnNamed', 3],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: 'Command_ScriptOnNamed',
      targetEntityId: 3,
    });
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: 'Command_ScriptOnNamed',
      targetEntityId: 3,
    });
    expect(logic.executeScriptAction({
      actionType: 238, // TEAM_USE_COMMANDBUTTON_ABILITY_ON_NAMED (raw id)
      params: ['AbilityTeam', 'Command_ScriptOnNamed', 3],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: 'Command_ScriptOnNamed',
      targetEntityId: 3,
    });
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERONNAMED',
      dispatchType: 'OBJECT',
      commandButtonId: 'Command_ScriptOnNamed',
      targetEntityId: 3,
    });

    expect(logic.executeScriptAction({
      actionType: 444, // TEAM_USE_COMMANDBUTTON_ABILITY_AT_WAYPOINT
      params: ['AbilityTeam', 'Command_ScriptAtWaypoint', 'AbilityWaypoint'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_ScriptAtWaypoint',
      targetEntityId: null,
      targetX: 96,
      targetZ: 80,
    });
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_ScriptAtWaypoint',
      targetEntityId: null,
      targetX: 96,
      targetZ: 80,
    });
    expect(logic.executeScriptAction({
      actionType: 239, // TEAM_USE_COMMANDBUTTON_ABILITY_AT_WAYPOINT (raw id)
      params: ['AbilityTeam', 'Command_ScriptAtWaypoint', 'AbilityWaypoint'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_ScriptAtWaypoint',
      targetEntityId: null,
      targetX: 96,
      targetZ: 80,
    });
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERATWAYPOINT',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_ScriptAtWaypoint',
      targetEntityId: null,
      targetX: 96,
      targetZ: 80,
    });

    expect(logic.executeScriptAction({
      actionType: 446, // TEAM_USE_COMMANDBUTTON_ABILITY
      params: ['AbilityTeam', 'Command_ScriptNoTarget'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERNOTARGET',
      dispatchType: 'NO_TARGET',
      commandButtonId: 'Command_ScriptNoTarget',
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    expect(logic.getEntityState(2)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPOWERNOTARGET',
      dispatchType: 'NO_TARGET',
      commandButtonId: 'Command_ScriptNoTarget',
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });

    expect(logic.executeScriptAction({
      actionType: 445,
      params: [999, 'Command_ScriptNoTarget'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 445,
      params: [1, 'Command_Missing'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 403,
      params: [999, 'Command_ScriptOnNamed', 3],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 403,
      params: [1, 'Command_ScriptOnNamed', 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 404,
      params: [1, 'Command_ScriptAtWaypoint', 'MissingWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 443,
      params: ['MissingTeam', 'Command_ScriptOnNamed', 3],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 443,
      params: ['AbilityTeam', 'Command_ScriptOnNamed', 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 444,
      params: ['AbilityTeam', 'Command_ScriptAtWaypoint', 'MissingWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 446,
      params: ['AbilityTeam', 'Command_Missing'],
    })).toBe(false);
  });

  it('executes script command-button production and upgrade actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptFactory', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 4,
          }),
        ], {
          CommandSet: 'ScriptFactoryCommandSet',
        }),
        makeObjectDef('ScriptInfantry', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], {
          BuildCost: 100,
          BuildTime: 0.1,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_BuildScriptInfantry', {
          Command: 'UNIT_BUILD',
          Object: 'ScriptInfantry',
        }),
        makeCommandButtonDef('Command_ResearchScriptUpgrade', {
          Command: 'PLAYER_UPGRADE',
          Upgrade: 'Upgrade_ScriptResearch',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptFactoryCommandSet', {
          1: 'Command_BuildScriptInfantry',
          2: 'Command_ResearchScriptUpgrade',
        }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_ScriptResearch', {
          Type: 'PLAYER',
          BuildCost: 150,
          BuildTime: 0.2,
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('ScriptFactory', 12, 12)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 500 });
    logic.update(1 / 30);

    expect(logic.executeScriptAction({
      actionType: 445, // NAMED_USE_COMMANDBUTTON_ABILITY
      params: [1, 'Command_BuildScriptInfantry'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 445, // NAMED_USE_COMMANDBUTTON_ABILITY
      params: [1, 'Command_ResearchScriptUpgrade'],
    })).toBe(true);

    const productionState = logic.getProductionState(1);
    expect(productionState?.queueEntryCount).toBe(2);
    expect(logic.getSideCredits('America')).toBe(250);
    expect(logic.getSideUpgradeState('America').inProduction).toEqual(['UPGRADE_SCRIPTRESEARCH']);
  });

  it('executes script dozer-construct command-button ability at waypoint', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptDozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], {
          CommandSet: 'ScriptDozerCommandSet',
        }),
        makeObjectDef('ScriptBarracks', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ], {
          BuildCost: 300,
          BuildTime: 1,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ConstructScriptBarracks', {
          Command: 'DOZER_CONSTRUCT',
          Object: 'ScriptBarracks',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptDozerCommandSet', {
          1: 'Command_ConstructScriptBarracks',
        }),
      ],
    });

    const map = makeMap([makeMapObject('ScriptDozer', 10, 10)], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'BuildWaypoint',
          position: { x: 40, y: 40, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.update(1 / 30);

    expect(logic.executeScriptAction({
      actionType: 404, // NAMED_USE_COMMANDBUTTON_ABILITY_AT_WAYPOINT
      params: [1, 'Command_ConstructScriptBarracks', 'BuildWaypoint'],
    })).toBe(true);

    const priv = logic as unknown as {
      pendingConstructionActions: Map<number, number>;
    };
    const buildingId = priv.pendingConstructionActions.get(1);
    expect(typeof buildingId).toBe('number');
    if (typeof buildingId === 'number') {
      expect(logic.getEntityState(buildingId)?.templateName).toBe('ScriptBarracks');
      expect(logic.getEntityState(buildingId)?.statusFlags).toContain('UNDER_CONSTRUCTION');
    }
    expect(logic.getSideCredits('America')).toBe(700);
  });

  it('enforces source fire-weapon command-button target-context requirements', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptShooter', 'America', ['INFANTRY', 'CAN_ATTACK'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], {
          CommandSet: 'ScriptShooterCommandSet',
        }),
        makeObjectDef('ScriptTarget', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_FireNoTarget', {
          Command: 'FIRE_WEAPON',
          WeaponSlot: 'PRIMARY',
        }),
        makeCommandButtonDef('Command_FireNeedObject', {
          Command: 'FIRE_WEAPON',
          WeaponSlot: 'PRIMARY',
          Options: 'NEED_TARGET_ENEMY_OBJECT',
        }),
        makeCommandButtonDef('Command_FireNeedPosition', {
          Command: 'FIRE_WEAPON',
          WeaponSlot: 'PRIMARY',
          Options: 'NEED_TARGET_POS',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptShooterCommandSet', {
          1: 'Command_FireNoTarget',
          2: 'Command_FireNeedObject',
          3: 'Command_FireNeedPosition',
        }),
      ],
    });

    const map = makeMap([
      makeMapObject('ScriptShooter', 10, 10), // id 1
      makeMapObject('ScriptTarget', 30, 10), // id 2
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'FireWaypoint',
          position: { x: 48, y: 48, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);

    expect(logic.executeScriptAction({
      actionType: 445, // NAMED_USE_COMMANDBUTTON_ABILITY
      params: [1, 'Command_FireNoTarget'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 403, // NAMED_USE_COMMANDBUTTON_ABILITY_ON_NAMED
      params: [1, 'Command_FireNeedObject', 2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 404, // NAMED_USE_COMMANDBUTTON_ABILITY_AT_WAYPOINT
      params: [1, 'Command_FireNeedPosition', 'FireWaypoint'],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 445,
      params: [1, 'Command_FireNeedObject'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 445,
      params: [1, 'Command_FireNeedPosition'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 403,
      params: [1, 'Command_FireNoTarget', 2],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 403,
      params: [1, 'Command_FireNeedPosition', 2],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 404,
      params: [1, 'Command_FireNoTarget', 'FireWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 404,
      params: [1, 'Command_FireNeedObject', 'FireWaypoint'],
    })).toBe(false);
  });

  it('executes source waypoint-path command-button action for CAN_USE_WAYPOINTS special powers', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScriptPathCaster', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_PathAllowed', {
            SpecialPowerTemplate: 'ScriptPathPowerAllowed',
          }),
          makeBlock('Behavior', 'SpecialPowerModule ModuleTag_PathBlocked', {
            SpecialPowerTemplate: 'ScriptPathPowerBlocked',
          }),
        ], {
          CommandSet: 'ScriptPathCasterCommandSet',
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_PathPowerAllowed', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPathPowerAllowed',
          Options: 'NEED_TARGET_POS CAN_USE_WAYPOINTS',
        }),
        makeCommandButtonDef('Command_PathPowerBlocked', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'ScriptPathPowerBlocked',
          Options: 'NEED_TARGET_POS',
        }),
      ],
      commandSets: [
        makeCommandSetDef('ScriptPathCasterCommandSet', {
          1: 'Command_PathPowerAllowed',
          2: 'Command_PathPowerBlocked',
        }),
      ],
      specialPowers: [
        makeSpecialPowerDef('ScriptPathPowerAllowed', { ReloadTime: 0 }),
        makeSpecialPowerDef('ScriptPathPowerBlocked', { ReloadTime: 0 }),
      ],
    });

    const map = makeMap([makeMapObject('ScriptPathCaster', 28, 35)], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'PathNodeFar',
          position: { x: 90, y: 90, z: 0 },
          pathLabel1: 'PathAlpha',
        },
        {
          id: 2,
          name: 'PathNodeNear',
          position: { x: 30, y: 35, z: 0 },
          pathLabel1: 'PathAlpha',
        },
        {
          id: 3,
          name: 'PathNodeMid',
          position: { x: 60, y: 35, z: 0 },
          pathLabel1: 'PathAlpha',
        },
      ],
      links: [
        { waypoint1: 2, waypoint2: 3 },
        { waypoint1: 3, waypoint2: 1 },
      ],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 542, // NAMED_USE_COMMANDBUTTON_ABILITY_USING_WAYPOINT_PATH
      params: [1, 'Command_PathPowerAllowed', 'pathalpha'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPATHPOWERALLOWED',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_PathPowerAllowed',
      targetEntityId: null,
      targetX: 30,
      targetZ: 35,
    });
    expect(logic.executeScriptAction({
      actionType: 337, // NAMED_USE_COMMANDBUTTON_ABILITY_USING_WAYPOINT_PATH (raw id)
      params: [1, 'Command_PathPowerAllowed', 'PathAlpha'],
    })).toBe(true);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      specialPowerTemplateName: 'SCRIPTPATHPOWERALLOWED',
      dispatchType: 'POSITION',
      commandButtonId: 'Command_PathPowerAllowed',
      targetEntityId: null,
      targetX: 30,
      targetZ: 35,
    });

    expect(logic.executeScriptAction({
      actionType: 542,
      params: [1, 'Command_PathPowerBlocked', 'PathAlpha'],
    })).toBe(false);
    expect(logic.getEntityState(1)?.lastSpecialPowerDispatch).toMatchObject({
      commandButtonId: 'Command_PathPowerAllowed',
      targetX: 30,
      targetZ: 35,
    });

    expect(logic.executeScriptAction({
      actionType: 542,
      params: [1, 'Command_PathPowerAllowed', 'MissingPath'],
    })).toBe(false);
  });

  it('executes script flash-white actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 18, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('FlashTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        scriptFlashCount: number;
        scriptFlashColor: number;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 447, // NAMED_FLASH_WHITE
      params: [1, 3],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptFlashColor).toBe(0xffffff);
    expect(privateApi.spawnedEntities.get(1)?.scriptFlashCount).toBe(6);

    expect(logic.executeScriptAction({
      actionType: 448, // TEAM_FLASH_WHITE
      params: ['FlashTeam', 2],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptFlashColor).toBe(0xffffff);
    expect(privateApi.spawnedEntities.get(2)?.scriptFlashColor).toBe(0xffffff);
    expect(privateApi.spawnedEntities.get(1)?.scriptFlashCount).toBe(4);
    expect(privateApi.spawnedEntities.get(2)?.scriptFlashCount).toBe(4);

    for (let frame = 0; frame < 15; frame += 1) {
      logic.update(1 / 30);
    }
    expect(privateApi.spawnedEntities.get(1)?.scriptFlashCount).toBe(3);
    expect(privateApi.spawnedEntities.get(2)?.scriptFlashCount).toBe(3);

    expect(logic.executeScriptAction({
      actionType: 447,
      params: [999, 2],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 448,
      params: ['MissingTeam', 2],
    })).toBe(false);
  });

  it('executes script named-custom-color action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Ranger', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        customIndicatorColor: number | null;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 453, // NAMED_CUSTOM_COLOR
      params: [1, 0x12ab34],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.customIndicatorColor).toBe(0x12ab34);

    expect(logic.executeScriptAction({
      actionType: 453,
      params: [999, 0xff00ff],
    })).toBe(false);
  });

  it('executes script named-receive-upgrade action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UpgradeTarget', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 500 }),
          makeBlock('Behavior', 'ModelConditionUpgrade ModuleTag_Visual', {
            TriggeredBy: 'Upgrade_ScriptVisual',
            ConditionFlag: 'UPGRADE',
          }),
        ]),
      ],
      upgrades: [makeUpgradeDef('Upgrade_ScriptVisual', { Type: 'PLAYER', BuildTime: 0.1, BuildCost: 0 })],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('UpgradeTarget', 20, 20)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        completedUpgrades: Set<string>;
        modelConditionFlags: Set<string>;
      }>;
    };
    const entity = privateApi.spawnedEntities.get(1)!;
    expect(entity.completedUpgrades.has('UPGRADE_SCRIPTVISUAL')).toBe(false);
    expect(entity.modelConditionFlags.has('UPGRADE')).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 457, // NAMED_RECEIVE_UPGRADE
      params: [1, 'Upgrade_ScriptVisual'],
    })).toBe(true);
    expect(entity.completedUpgrades.has('UPGRADE_SCRIPTVISUAL')).toBe(true);
    expect(entity.modelConditionFlags.has('UPGRADE')).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 457,
      params: [1, 'Upgrade_Missing'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 457,
      params: [999, 'Upgrade_ScriptVisual'],
    })).toBe(false);
  });

  it('executes script player-repair-named-structure action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('USADozer', 'America', ['VEHICLE', 'DOZER'], [
          makeBlock('Behavior', 'DozerAIUpdate ModuleTag_DozerAI', {
            RepairHealthPercentPerSecond: '30%',
            BoredTime: 999999,
            BoredRange: 300,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ], { GeometryMajorRadius: 5, GeometryMinorRadius: 5 }),
        makeObjectDef('USABarracks', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 500, InitialHealth: 250 }),
        ], { GeometryMajorRadius: 10, GeometryMinorRadius: 10 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('USADozer', 20, 20), // id 1
        makeMapObject('USABarracks', 20, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.submitCommand({ type: 'setSideCredits', side: 'America', amount: 1000 });
    logic.submitCommand({ type: 'setSidePlayerType', side: 'America', playerType: 'COMPUTER' });
    logic.update(0);

    const privateApi = logic as unknown as {
      pendingRepairActions: Map<number, number>;
    };

    const before = logic.getEntityState(2)!.health;
    expect(logic.executeScriptAction({
      actionType: 458, // PLAYER_REPAIR_NAMED_STRUCTURE
      params: ['America', 2],
    })).toBe(true);
    expect(privateApi.pendingRepairActions.get(1)).toBe(2);

    logic.update(1 / 30);
    const after = logic.getEntityState(2)!.health;
    expect(after).toBeGreaterThan(before);

    expect(logic.executeScriptAction({
      actionType: 458,
      params: ['America', 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 458,
      params: ['', 2],
    })).toBe(false);
  });

  it('executes script camera tether/default actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([makeMapObject('Ranger', 10, 10)], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'CameraWaypointA',
          position: { x: 64, y: 72, z: 0 },
        },
        {
          id: 2,
          name: 'CameraWaypointB',
          position: { x: 88, y: 96, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 171, // CAMERA_TETHER_NAMED (raw id)
      params: [1, 0, 150],
    })).toBe(true);
    expect(logic.getScriptCameraTetherState()).toEqual({
      entityId: 1,
      immediate: false,
      play: 150,
    });

    expect(logic.executeScriptAction({
      actionType: 172, // CAMERA_STOP_TETHER_NAMED (raw id)
    })).toBe(true);
    expect(logic.getScriptCameraTetherState()).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 173, // CAMERA_SET_DEFAULT (raw id)
      params: [20, 90, 400],
    })).toBe(true);
    expect(logic.getScriptCameraDefaultViewState()).toEqual({
      pitch: 20,
      angle: 90,
      maxHeight: 400,
    });

    expect(logic.executeScriptAction({
      actionType: 376, // CAMERA_TETHER_NAMED
      params: [1, 1, 250],
    })).toBe(true);
    expect(logic.getScriptCameraTetherState()).toEqual({
      entityId: 1,
      immediate: true,
      play: 250,
    });

    expect(logic.executeScriptAction({
      actionType: 377, // CAMERA_STOP_TETHER_NAMED
    })).toBe(true);
    expect(logic.getScriptCameraTetherState()).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 378, // CAMERA_SET_DEFAULT
      params: [35, 120, 500],
    })).toBe(true);
    expect(logic.getScriptCameraDefaultViewState()).toEqual({
      pitch: 35,
      angle: 120,
      maxHeight: 500,
    });

    expect(logic.executeScriptAction({
      actionType: 386, // CAMERA_LOOK_TOWARD_OBJECT
      params: [1, 1.5, 0.75, 0.25, 0.5],
    })).toBe(true);
    expect(logic.getScriptCameraLookTowardObjectState()).toEqual({
      entityId: 1,
      durationMs: 1500,
      holdMs: 750,
      easeInMs: 250,
      easeOutMs: 500,
    });

    expect(logic.executeScriptAction({
      actionType: 411, // CAMERA_LOOK_TOWARD_WAYPOINT
      params: ['CameraWaypointA', 2.5, 0.25, 0.75, 1],
    })).toBe(true);
    expect(logic.getScriptCameraLookTowardWaypointState()).toEqual({
      waypointName: 'CameraWaypointA',
      x: 64,
      z: 72,
      durationMs: 2500,
      easeInMs: 250,
      easeOutMs: 750,
      reverseRotation: true,
    });

    expect(logic.executeScriptAction({
      actionType: 119, // CAMERA_FOLLOW_NAMED (raw id)
      params: [1, 1],
    })).toBe(true);
    expect(logic.getScriptCameraFollowState()).toEqual({
      entityId: 1,
      snapToUnit: true,
    });

    expect(logic.executeScriptAction({
      actionType: 324, // CAMERA_FOLLOW_NAMED (offset/collision id)
      params: [1, 0],
    })).toBe(true);
    expect(logic.getScriptCameraFollowState()).toEqual({
      entityId: 1,
      snapToUnit: false,
    });

    expect(logic.executeScriptAction({
      actionType: 132, // CAMERA_STOP_FOLLOW (raw id)
    })).toBe(true);
    expect(logic.getScriptCameraFollowState()).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 119,
      params: [1, 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 337, // CAMERA_STOP_FOLLOW (offset/collision id)
      params: [],
    })).toBe(true);
    expect(logic.getScriptCameraFollowState()).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 14, // MOVE_CAMERA_TO (raw id)
      params: ['CameraWaypointA', 2, 0.5, 0.25, 0.75],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 219, // MOVE_CAMERA_TO (offset/collision id)
      params: ['CameraWaypointA', 1, 0.1, 0.2, 0.3],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 17, // MOVE_CAMERA_ALONG_WAYPOINT_PATH (raw id)
      params: ['CameraWaypointA', 1.5, 0.2, 0.4, 0.6],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 222, // MOVE_CAMERA_ALONG_WAYPOINT_PATH (offset/collision id)
      params: ['CameraWaypointA', 0.75, 0.05, 0.1, 0.15],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 18, // ROTATE_CAMERA (raw id)
      params: [1.25, 2, 0.5, 0.75],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 223, // ROTATE_CAMERA (offset/collision id)
      params: [0.5, 1, 0.2, 0.3],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 19, // RESET_CAMERA (raw id)
      params: ['CameraWaypointA', 2.5, 0.4, 0.2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 224, // RESET_CAMERA (offset/collision id)
      params: ['CameraWaypointA', 1.25, 0.1, 0.05],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 114, // SETUP_CAMERA (raw id)
      params: ['CameraWaypointA', 300, 30, 'CameraWaypointB'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 319, // SETUP_CAMERA (offset/collision id)
      params: ['CameraWaypointA', 450, 35, 'CameraWaypointB'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 117, // ZOOM_CAMERA (raw id)
      params: [350, 1.5, 0.25, 0.5],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 322, // ZOOM_CAMERA (offset/collision id)
      params: [500, 2.25, 0.1, 0.2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 118, // PITCH_CAMERA (raw id)
      params: [40, 2.5, 0.3, 0.6],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 323, // PITCH_CAMERA (offset/collision id)
      params: [25, 1.75, 0.2, 0.4],
    })).toBe(true);
    expect(logic.drainScriptCameraActionRequests()).toEqual([
      {
        requestType: 'MOVE_TO',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: null,
        x: 64,
        z: 72,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 2000,
        cameraStutterMs: 500,
        easeInMs: 250,
        easeOutMs: 750,
        rotations: null,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'MOVE_TO',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: null,
        x: 64,
        z: 72,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 1000,
        cameraStutterMs: 100,
        easeInMs: 200,
        easeOutMs: 300,
        rotations: null,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'MOVE_ALONG_WAYPOINT_PATH',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: null,
        x: 64,
        z: 72,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 1500,
        cameraStutterMs: 200,
        easeInMs: 400,
        easeOutMs: 600,
        rotations: null,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'MOVE_ALONG_WAYPOINT_PATH',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: null,
        x: 64,
        z: 72,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 750,
        cameraStutterMs: 50,
        easeInMs: 100,
        easeOutMs: 150,
        rotations: null,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'ROTATE',
        waypointName: null,
        lookAtWaypointName: null,
        x: null,
        z: null,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 2000,
        cameraStutterMs: 0,
        easeInMs: 500,
        easeOutMs: 750,
        rotations: 1.25,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'ROTATE',
        waypointName: null,
        lookAtWaypointName: null,
        x: null,
        z: null,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 1000,
        cameraStutterMs: 0,
        easeInMs: 200,
        easeOutMs: 300,
        rotations: 0.5,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'RESET',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: null,
        x: 64,
        z: 72,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 2500,
        cameraStutterMs: 0,
        easeInMs: 400,
        easeOutMs: 200,
        rotations: null,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'RESET',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: null,
        x: 64,
        z: 72,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 1250,
        cameraStutterMs: 0,
        easeInMs: 100,
        easeOutMs: 50,
        rotations: null,
        zoom: null,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'SETUP',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: 'CameraWaypointB',
        x: 64,
        z: 72,
        lookAtX: 88,
        lookAtZ: 96,
        durationMs: 0,
        cameraStutterMs: 0,
        easeInMs: 0,
        easeOutMs: 0,
        rotations: null,
        zoom: 300,
        pitch: 30,
        frame: 0,
      },
      {
        requestType: 'SETUP',
        waypointName: 'CameraWaypointA',
        lookAtWaypointName: 'CameraWaypointB',
        x: 64,
        z: 72,
        lookAtX: 88,
        lookAtZ: 96,
        durationMs: 0,
        cameraStutterMs: 0,
        easeInMs: 0,
        easeOutMs: 0,
        rotations: null,
        zoom: 450,
        pitch: 35,
        frame: 0,
      },
      {
        requestType: 'ZOOM',
        waypointName: null,
        lookAtWaypointName: null,
        x: null,
        z: null,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 1500,
        cameraStutterMs: 0,
        easeInMs: 250,
        easeOutMs: 500,
        rotations: null,
        zoom: 350,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'ZOOM',
        waypointName: null,
        lookAtWaypointName: null,
        x: null,
        z: null,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 2250,
        cameraStutterMs: 0,
        easeInMs: 100,
        easeOutMs: 200,
        rotations: null,
        zoom: 500,
        pitch: null,
        frame: 0,
      },
      {
        requestType: 'PITCH',
        waypointName: null,
        lookAtWaypointName: null,
        x: null,
        z: null,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 2500,
        cameraStutterMs: 0,
        easeInMs: 300,
        easeOutMs: 600,
        rotations: null,
        zoom: null,
        pitch: 40,
        frame: 0,
      },
      {
        requestType: 'PITCH',
        waypointName: null,
        lookAtWaypointName: null,
        x: null,
        z: null,
        lookAtX: null,
        lookAtZ: null,
        durationMs: 1750,
        cameraStutterMs: 0,
        easeInMs: 200,
        easeOutMs: 400,
        rotations: null,
        zoom: null,
        pitch: 25,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 376,
      params: [999, 0, 100],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 386,
      params: [999, 1, 0, 0, 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 411,
      params: ['MissingWaypoint', 1, 0, 0, 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 119,
      params: [999, 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 14,
      params: ['MissingWaypoint', 1, 0, 0, 0],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 114,
      params: ['CameraWaypointA', 300, 30, 'MissingWaypoint'],
    })).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 376,
      params: [1, 0, 100],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 119,
      params: [1, 0],
    })).toBe(true);
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    expect(logic.getScriptCameraTetherState()).toBeNull();
    expect(logic.getScriptCameraFollowState()).toBeNull();
    expect(logic.getScriptCameraLookTowardObjectState()).toBeNull();
  });

  it('executes script skybox and camera-motion-blur actions using source action ids', () => {
    const map = makeMap([], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'BlurWaypoint',
          position: { x: 40, y: 52, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptSkyboxEnabled()).toBe(false);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 126, // CAMERA_BW_MODE_END (raw id)
      params: [9],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(false);
    expect(logic.drainScriptCameraBlackWhiteRequests()).toEqual([]);

    expect(logic.executeScriptAction({
      actionType: 125, // CAMERA_BW_MODE_BEGIN (raw id)
      params: [15],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 330, // CAMERA_BW_MODE_BEGIN (offset id)
      params: [8],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 126, // CAMERA_BW_MODE_END (raw id)
      params: [6],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 331, // CAMERA_BW_MODE_END (offset id)
      params: [4],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(false);
    expect(logic.drainScriptCameraBlackWhiteRequests()).toEqual([
      { enabled: true, fadeFrames: 15, frame: 0 },
      { enabled: true, fadeFrames: 8, frame: 0 },
      { enabled: false, fadeFrames: 6, frame: 0 },
    ]);

    expect(logic.executeScriptAction({
      actionType: 127, // DRAW_SKYBOX_BEGIN (raw id)
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 128, // DRAW_SKYBOX_END (raw id)
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 332, // DRAW_SKYBOX_BEGIN (offset id)
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 333, // DRAW_SKYBOX_END (offset id)
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 133, // CAMERA_MOTION_BLUR (raw id)
      params: [1, 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 338, // CAMERA_MOTION_BLUR (offset id)
      params: [0, 1],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 134, // CAMERA_MOTION_BLUR_JUMP (raw id)
      params: ['BlurWaypoint', 1],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 339, // CAMERA_MOTION_BLUR_JUMP (offset id)
      params: ['BlurWaypoint', 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 135, // CAMERA_MOTION_BLUR_FOLLOW (raw id)
      params: [2],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 340, // CAMERA_MOTION_BLUR_FOLLOW (offset id)
      params: [4],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 136, // CAMERA_MOTION_BLUR_END_FOLLOW (raw id)
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 341, // CAMERA_MOTION_BLUR_END_FOLLOW (offset id)
    })).toBe(true);

    expect(logic.drainScriptCameraFilterRequests()).toEqual([
      {
        requestType: 'MOTION_BLUR',
        zoomIn: true,
        saturate: false,
        waypointName: null,
        x: null,
        z: null,
        followMode: null,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR',
        zoomIn: false,
        saturate: true,
        waypointName: null,
        x: null,
        z: null,
        followMode: null,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR_JUMP',
        zoomIn: null,
        saturate: true,
        waypointName: 'BlurWaypoint',
        x: 40,
        z: 52,
        followMode: null,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR_JUMP',
        zoomIn: null,
        saturate: false,
        waypointName: 'BlurWaypoint',
        x: 40,
        z: 52,
        followMode: null,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR_FOLLOW',
        zoomIn: null,
        saturate: null,
        waypointName: null,
        x: null,
        z: null,
        followMode: 2,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR_FOLLOW',
        zoomIn: null,
        saturate: null,
        waypointName: null,
        x: null,
        z: null,
        followMode: 4,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR_END_FOLLOW',
        zoomIn: null,
        saturate: null,
        waypointName: null,
        x: null,
        z: null,
        followMode: null,
        frame: 0,
      },
      {
        requestType: 'MOTION_BLUR_END_FOLLOW',
        zoomIn: null,
        saturate: null,
        waypointName: null,
        x: null,
        z: null,
        followMode: null,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 134,
      params: ['MissingWaypoint', 1],
    })).toBe(false);
    expect(logic.drainScriptCameraFilterRequests()).toEqual([]);
  });

  it('executes script camera-slave and camera-shaker actions using source id collisions', () => {
    const map = makeMap([], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'ShakeWaypoint',
          position: { x: 40, y: 60, z: 0 },
        },
      ],
      links: [],
    };

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 330, // CAMERA_BW_MODE_BEGIN collision path when 1 param
      params: [8],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(true);

    expect(logic.getScriptCameraSlaveModeState()).toBeNull();
    expect(logic.executeScriptAction({
      actionType: 330, // CAMERA_ENABLE_SLAVE_MODE when 2 params
      params: ['CineTank', 'TurretBone'],
    })).toBe(true);
    expect(logic.getScriptCameraSlaveModeState()).toEqual({
      thingTemplateName: 'CineTank',
      boneName: 'TurretBone',
    });

    expect(logic.executeScriptAction({
      actionType: 331, // CAMERA_BW_MODE_END collision path when 1 param
      params: [4],
    })).toBe(true);
    expect(logic.isScriptCameraBlackWhiteEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 331, // CAMERA_DISABLE_SLAVE_MODE when 0 params
      params: [],
    })).toBe(true);
    expect(logic.getScriptCameraSlaveModeState()).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 332, // DRAW_SKYBOX_BEGIN collision path when 0 params
      params: [],
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 332, // CAMERA_ADD_SHAKER_AT when 4 params
      params: ['ShakeWaypoint', 2.5, 1.75, 120],
    })).toBe(true);
    expect(logic.drainScriptCameraShakerRequests()).toEqual([
      {
        waypointName: 'ShakeWaypoint',
        x: 40,
        z: 60,
        amplitude: 2.5,
        durationSeconds: 1.75,
        radius: 120,
        frame: 0,
      },
    ]);

    expect(logic.executeScriptAction({
      actionType: 332,
      params: ['MissingWaypoint', 1, 1, 1],
    })).toBe(false);
    expect(logic.drainScriptCameraBlackWhiteRequests()).toEqual([
      { enabled: true, fadeFrames: 8, frame: 0 },
      { enabled: false, fadeFrames: 4, frame: 0 },
    ]);
  });

  it('executes script unmanned and boobytrap actions using source action id collisions', () => {
    const map = makeMap([
      makeMapObject('TrapTarget', 12, 12), // id 1
      makeMapObject('TrapTarget', 18, 12), // id 2
      makeMapObject('TrapTarget', 24, 12), // id 3
      makeMapObject('TrapTarget', 30, 12), // id 4
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'BlurWaypoint',
          position: { x: 40, y: 52, z: 0 },
        },
      ],
      links: [],
    };

    const bundle = makeBundle({
      objects: [
        makeObjectDef('TrapTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], {
          GeometryMajorRadius: 6,
          GeometryMinorRadius: 4,
        }),
        makeObjectDef('BoobyBomb', 'America', ['BOOBY_TRAP'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1, InitialHealth: 1 }),
          makeBlock('Behavior', 'StickyBombUpdate ModuleTag_StickyBomb', {}),
        ], {
          GeometryMajorRadius: 1,
          GeometryMinorRadius: 1,
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      map,
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('UnmannedTeam', [2])).toBe(true);
    expect(logic.setScriptTeamMembers('TrapTeam', [4])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        id: number;
        x: number;
        z: number;
        side: string;
        controllingPlayerToken: string | null;
        objectStatusFlags: Set<string>;
        stickyBombTargetId: number;
        stickyBombProfile: unknown;
      }>;
    };

    // Collision parity: 338-341 keep camera behavior with their camera signatures.
    expect(logic.executeScriptAction({
      actionType: 338,
      params: [1, 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 339,
      params: ['BlurWaypoint', 1],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 340,
      params: [3],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 341,
      params: [],
    })).toBe(true);
    expect(logic.drainScriptCameraFilterRequests().map((request) => request.requestType)).toEqual([
      'MOTION_BLUR',
      'MOTION_BLUR_JUMP',
      'MOTION_BLUR_FOLLOW',
      'MOTION_BLUR_END_FOLLOW',
    ]);

    expect(logic.executeScriptAction({
      actionType: 338, // NAMED_SET_UNMANNED_STATUS when param count == 1
      params: [1],
    })).toBe(true);
    const unmannedNamed = privateApi.spawnedEntities.get(1)!;
    expect(unmannedNamed.objectStatusFlags.has('DISABLED_UNMANNED')).toBe(true);
    expect(unmannedNamed.side).toBe('');
    expect(unmannedNamed.controllingPlayerToken).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 339, // TEAM_SET_UNMANNED_STATUS when param count == 1
      params: ['UnmannedTeam'],
    })).toBe(true);
    const unmannedTeamMember = privateApi.spawnedEntities.get(2)!;
    expect(unmannedTeamMember.objectStatusFlags.has('DISABLED_UNMANNED')).toBe(true);
    expect(unmannedTeamMember.side).toBe('');
    expect(unmannedTeamMember.controllingPlayerToken).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 340, // NAMED_SET_BOOBYTRAPPED when param count == 2
      params: ['BoobyBomb', 3],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 341, // TEAM_SET_BOOBYTRAPPED when param count == 2
      params: ['BoobyBomb', 'TrapTeam'],
    })).toBe(true);

    const targetThree = privateApi.spawnedEntities.get(3)!;
    const targetFour = privateApi.spawnedEntities.get(4)!;
    expect(targetThree.objectStatusFlags.has('BOOBY_TRAPPED')).toBe(true);
    expect(targetFour.objectStatusFlags.has('BOOBY_TRAPPED')).toBe(true);

    const attachedBombs = [...privateApi.spawnedEntities.values()]
      .filter((entity) => entity.stickyBombProfile && entity.stickyBombTargetId !== 0);
    expect(attachedBombs).toHaveLength(2);
    expect(new Set(attachedBombs.map((entity) => entity.stickyBombTargetId))).toEqual(new Set([3, 4]));
    const namedBomb = attachedBombs.find((entity) => entity.stickyBombTargetId === 3)!;
    const teamBomb = attachedBombs.find((entity) => entity.stickyBombTargetId === 4)!;
    expect(Math.hypot(namedBomb.x - targetThree.x, namedBomb.z - targetThree.z)).toBeGreaterThan(0.1);
    expect(Math.hypot(teamBomb.x - targetFour.x, teamBomb.z - targetFour.z)).toBeGreaterThan(0.1);

    expect(logic.executeScriptAction({
      actionType: 338,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 339,
      params: ['MissingTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 340,
      params: ['MissingBomb', 3],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 341,
      params: ['BoobyBomb', 'MissingTeam'],
    })).toBe(false);
  });

  it('executes script oversize-terrain action using source action id', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.getScriptTerrainOversizeAmount()).toBe(0);
    expect(logic.executeScriptAction({
      actionType: 120, // OVERSIZE_TERRAIN
      params: [4],
    })).toBe(true);
    expect(logic.getScriptTerrainOversizeAmount()).toBe(4);

    expect(logic.executeScriptAction({
      actionType: 120,
      params: [-3],
    })).toBe(true);
    expect(logic.getScriptTerrainOversizeAmount()).toBe(-3);
  });

  it('executes script train-held and object-sound actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TrainCar', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Behavior', 'RailedTransportAIUpdate ModuleTag_Rail', {
            PathPrefixName: 'TrainRoute',
          }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TrainCar', 12, 12), // id 1
        makeMapObject('Ranger', 18, 12), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        objectStatusFlags: Set<string>;
        scriptAmbientSoundEnabled: boolean;
      }>;
    };

    expect(logic.isScriptSkyboxEnabled()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 332, // DRAW_SKYBOX_BEGIN
      params: [],
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 333, // DRAW_SKYBOX_END collision path when no params
      params: [],
    })).toBe(true);
    expect(logic.isScriptSkyboxEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 333, // SET_TRAIN_HELD collision path when 2 params
      params: [1, 1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('DISABLED_HELD')).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 333,
      params: [1, 0],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.objectStatusFlags.has('DISABLED_HELD')).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 333,
      params: [2, 1],
    })).toBe(false);

    expect(privateApi.spawnedEntities.get(1)?.scriptAmbientSoundEnabled).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 336, // DISABLE_OBJECT_SOUND
      params: [1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptAmbientSoundEnabled).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 335, // ENABLE_OBJECT_SOUND
      params: [1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptAmbientSoundEnabled).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 335,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 336,
      params: [999],
    })).toBe(false);
  });

  it('executes script freeze-time and weather actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptTimeFrozenByScript()).toBe(false);
    expect(logic.isScriptWeatherVisible()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 137, // FREEZE_TIME (raw id)
    })).toBe(true);
    expect(logic.isScriptTimeFrozenByScript()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 342, // FREEZE_TIME (offset/collision id when no params)
      params: [],
    })).toBe(true);
    expect(logic.isScriptTimeFrozenByScript()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 138, // UNFREEZE_TIME (raw id)
    })).toBe(true);
    expect(logic.isScriptTimeFrozenByScript()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 343, // UNFREEZE_TIME (offset id)
    })).toBe(true);
    expect(logic.isScriptTimeFrozenByScript()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 342, // SHOW_WEATHER (raw id when params are present)
      params: [0],
    })).toBe(true);
    expect(logic.isScriptWeatherVisible()).toBe(false);
    expect(logic.isScriptTimeFrozenByScript()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 342,
      params: [1],
    })).toBe(true);
    expect(logic.isScriptWeatherVisible()).toBe(true);
  });

  it('executes script camera-fade actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 121, // CAMERA_FADE_ADD (raw id)
      params: [0, 1, 30, 20, 10],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 326, // CAMERA_FADE_ADD (offset id)
      params: [0.1, 0.9, 3, 2, 1],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 122, // CAMERA_FADE_SUBTRACT (raw id)
      params: [1, 0, 8, 7, 6],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 327, // CAMERA_FADE_SUBTRACT (offset id)
      params: [0.8, 0.2, 5, 4, 3],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 123, // CAMERA_FADE_SATURATE (raw id)
      params: [0.5, 1, 9, 8, 7],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 328, // CAMERA_FADE_SATURATE (offset id)
      params: [0.4, 0.9, 6, 5, 4],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 124, // CAMERA_FADE_MULTIPLY (raw id)
      params: [1, 0.2, 12, 11, 10],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 329, // CAMERA_FADE_MULTIPLY (offset id)
      params: [0.9, 0.1, 2, 1, 0],
    })).toBe(true);

    expect(logic.drainScriptCameraFadeRequests()).toEqual([
      {
        fadeType: 'ADD',
        minFade: 0,
        maxFade: 1,
        increaseFrames: 30,
        holdFrames: 20,
        decreaseFrames: 10,
        frame: 0,
      },
      {
        fadeType: 'ADD',
        minFade: 0.1,
        maxFade: 0.9,
        increaseFrames: 3,
        holdFrames: 2,
        decreaseFrames: 1,
        frame: 0,
      },
      {
        fadeType: 'SUBTRACT',
        minFade: 1,
        maxFade: 0,
        increaseFrames: 8,
        holdFrames: 7,
        decreaseFrames: 6,
        frame: 0,
      },
      {
        fadeType: 'SUBTRACT',
        minFade: 0.8,
        maxFade: 0.2,
        increaseFrames: 5,
        holdFrames: 4,
        decreaseFrames: 3,
        frame: 0,
      },
      {
        fadeType: 'SATURATE',
        minFade: 0.5,
        maxFade: 1,
        increaseFrames: 9,
        holdFrames: 8,
        decreaseFrames: 7,
        frame: 0,
      },
      {
        fadeType: 'SATURATE',
        minFade: 0.4,
        maxFade: 0.9,
        increaseFrames: 6,
        holdFrames: 5,
        decreaseFrames: 4,
        frame: 0,
      },
      {
        fadeType: 'MULTIPLY',
        minFade: 1,
        maxFade: 0.2,
        increaseFrames: 12,
        holdFrames: 11,
        decreaseFrames: 10,
        frame: 0,
      },
      {
        fadeType: 'MULTIPLY',
        minFade: 0.9,
        maxFade: 0.1,
        increaseFrames: 2,
        holdFrames: 1,
        decreaseFrames: 0,
        frame: 0,
      },
    ]);
  });

  it('executes script delete-living/guardband/unmanned-delete/choose-victim actions using source id collisions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('Jeep', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 12, 10), // id 2
        makeMapObject('Jeep', 14, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('DeleteTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        destroyed: boolean;
        objectStatusFlags: Set<string>;
      }>;
    };

    // Collision parity: 326-329 keep camera-fade behavior with 5-parameter signatures.
    expect(logic.executeScriptAction({
      actionType: 326,
      params: [0.1, 0.9, 3, 2, 1],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 327,
      params: [0.8, 0.2, 5, 4, 3],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 328,
      params: [0.4, 0.9, 6, 5, 4],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 329,
      params: [0.9, 0.1, 2, 1, 0],
    })).toBe(true);
    expect(logic.drainScriptCameraFadeRequests().map((request) => request.fadeType)).toEqual([
      'ADD',
      'SUBTRACT',
      'SATURATE',
      'MULTIPLY',
    ]);

    expect(logic.executeScriptAction({
      actionType: 326, // TEAM_DELETE_LIVING when param count == 1
      params: ['DeleteTeam'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.destroyed).toBe(true);
    expect(privateApi.spawnedEntities.get(2)?.destroyed).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 326,
      params: ['MissingTeam'],
    })).toBe(false);

    expect(logic.getScriptViewGuardbandBias()).toBeNull();
    expect(logic.executeScriptAction({
      actionType: 327, // RESIZE_VIEW_GUARDBAND when param count == 2
      params: [12, 8],
    })).toBe(true);
    expect(logic.getScriptViewGuardbandBias()).toEqual({ x: 12, y: 8 });

    privateApi.spawnedEntities.get(3)?.objectStatusFlags.add('DISABLED_UNMANNED');
    expect(logic.executeScriptAction({
      actionType: 328, // DELETE_ALL_UNMANNED when param count == 0
      params: [],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(3)?.destroyed).toBe(true);

    expect(logic.isScriptChooseVictimAlwaysUsesNormal()).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 329, // CHOOSE_VICTIM_ALWAYS_USES_NORMAL when param count == 1
      params: [1],
    })).toBe(true);
    expect(logic.isScriptChooseVictimAlwaysUsesNormal()).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 329,
      params: [0],
    })).toBe(true);
    expect(logic.isScriptChooseVictimAlwaysUsesNormal()).toBe(false);
  });

  it('executes script movie and letterbox actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.isScriptLetterboxEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 115, // CAMERA_LETTERBOX_BEGIN (raw id)
    })).toBe(true);
    expect(logic.isScriptLetterboxEnabled()).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 116, // CAMERA_LETTERBOX_END (raw id)
    })).toBe(true);
    expect(logic.isScriptLetterboxEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 115,
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 321, // CAMERA_LETTERBOX_END (offset/collision id when no params)
      params: [],
    })).toBe(true);
    expect(logic.isScriptLetterboxEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 80, // MOVIE_PLAY_FULLSCREEN (raw id)
      params: ['IntroMovieA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 285, // MOVIE_PLAY_FULLSCREEN (offset id)
      params: ['IntroMovieB'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 81, // MOVIE_PLAY_RADAR (raw id)
      params: ['RadarMovieA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 286, // MOVIE_PLAY_RADAR (offset id)
      params: ['RadarMovieB'],
    })).toBe(true);
    expect(logic.drainScriptMoviePlaybackRequests()).toEqual([
      { movieName: 'IntroMovieA', playbackType: 'FULLSCREEN', frame: 0 },
      { movieName: 'IntroMovieB', playbackType: 'FULLSCREEN', frame: 0 },
      { movieName: 'RadarMovieA', playbackType: 'RADAR', frame: 0 },
      { movieName: 'RadarMovieB', playbackType: 'RADAR', frame: 0 },
    ]);

    expect(logic.executeScriptAction({
      actionType: 80,
      params: [''],
    })).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 321, // SOUND_REMOVE_TYPE when params are present
      params: ['MissionAlert'],
    })).toBe(true);
    expect(logic.drainScriptAudioRemovalRequests()).toEqual([
      { eventName: 'MissionAlert', removeDisabledOnly: false, frame: 0 },
    ]);
  });

  it('executes script display-text and military-caption actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 76, // DISPLAY_TEXT (raw id)
      params: ['MissionTextA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 281, // DISPLAY_TEXT (offset/collision id)
      params: ['MissionTextB'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 139, // SHOW_MILITARY_CAPTION (raw id)
      params: ['MilitaryCaptionA', 3000],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 344, // SHOW_MILITARY_CAPTION (offset id)
      params: ['MilitaryCaptionB', 1500],
    })).toBe(true);
    expect(logic.drainScriptDisplayMessages()).toEqual([
      { messageType: 'DISPLAY_TEXT', text: 'MissionTextA', duration: null, frame: 0 },
      { messageType: 'DISPLAY_TEXT', text: 'MissionTextB', duration: null, frame: 0 },
      { messageType: 'MILITARY_CAPTION', text: 'MilitaryCaptionA', duration: 3000, frame: 0 },
      { messageType: 'MILITARY_CAPTION', text: 'MilitaryCaptionB', duration: 1500, frame: 0 },
    ]);

    expect(logic.executeScriptAction({
      actionType: 76,
      params: [''],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 139,
      params: ['', 3000],
    })).toBe(false);
  });

  it('executes script camera-audible-distance and fps-limit actions using source action ids', () => {
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([], 128, 128),
      makeRegistry(makeBundle({ objects: [] })),
      makeHeightmap(128, 128),
    );
    logic.setSideCredits('America', 1000);

    expect(logic.getScriptCameraAudibleDistance()).toBe(0);
    expect(logic.getScriptFramesPerSecondLimit()).toBe(0);
    expect(logic.isScriptFpsLimitEnabled()).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 140, // CAMERA_SET_AUDIBLE_DISTANCE (raw id)
      params: [220],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 345, // CAMERA_SET_AUDIBLE_DISTANCE (offset id)
      params: [330],
    })).toBe(true);
    expect(logic.getScriptCameraAudibleDistance()).toBe(330);

    expect(logic.executeScriptAction({
      actionType: 143, // SET_FPS_LIMIT (raw id)
      params: [45],
    })).toBe(true);
    expect(logic.isScriptFpsLimitEnabled()).toBe(true);
    expect(logic.getScriptFramesPerSecondLimit()).toBe(45);

    expect(logic.executeScriptAction({
      actionType: 348, // SET_FPS_LIMIT (offset/collision id with 1 param)
      params: [72],
    })).toBe(true);
    expect(logic.getScriptFramesPerSecondLimit()).toBe(72);

    expect(logic.executeScriptAction({
      actionType: 348, // PLAYER_SET_MONEY (offset/collision id with 2 params)
      params: ['America', 250],
    })).toBe(true);
    expect(logic.getSideCredits('America')).toBe(250);

    expect(logic.executeScriptAction({
      actionType: 143,
      params: [0],
    })).toBe(true);
    expect(logic.getScriptFramesPerSecondLimit()).toBe(0);
  });

  it('executes script stopping-distance actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
          makeBlock('LocomotorSet', 'SET_NORMAL ScriptLoco', {}),
        ], {
          GeometryMajorRadius: 2,
          GeometryMinorRadius: 2,
        }),
      ],
      locomotors: [makeLocomotorDef('ScriptLoco', 30)],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 20, 20), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.setScriptTeamMembers('StopTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        x: number;
        z: number;
        moving: boolean;
        scriptStoppingDistanceOverride: number | null;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 141, // SET_STOPPING_DISTANCE (raw id)
      params: ['StopTeam', 8],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 346, // SET_STOPPING_DISTANCE (offset id)
      params: ['StopTeam', 12],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptStoppingDistanceOverride).toBe(12);
    expect(privateApi.spawnedEntities.get(2)?.scriptStoppingDistanceOverride).toBe(12);

    expect(logic.executeScriptAction({
      actionType: 142, // NAMED_SET_STOPPING_DISTANCE (raw id)
      params: [1, 6],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 347, // NAMED_SET_STOPPING_DISTANCE (offset id)
      params: [2, 4],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptStoppingDistanceOverride).toBe(6);
    expect(privateApi.spawnedEntities.get(2)?.scriptStoppingDistanceOverride).toBe(4);

    expect(logic.executeScriptAction({
      actionType: 142,
      params: [1, 0.25], // < 0.5 should be ignored (source parity)
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.scriptStoppingDistanceOverride).toBe(6);

    expect(logic.executeScriptAction({
      actionType: 141,
      params: ['MissingTeam', 5],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 142,
      params: [999, 5],
    })).toBe(false);

    logic.submitCommand({
      type: 'moveTo',
      entityId: 1,
      targetX: 80,
      targetZ: 10,
    });
    for (let frame = 0; frame < 300; frame += 1) {
      logic.update(1 / 30);
      if (!privateApi.spawnedEntities.get(1)?.moving) {
        break;
      }
    }

    const moved = privateApi.spawnedEntities.get(1)!;
    expect(moved.moving).toBe(false);
    const distanceToTarget = Math.hypot(moved.x - 80, moved.z - 10);
    expect(distanceToTarget).toBeLessThanOrEqual(6.1);
    expect(distanceToTarget).toBeGreaterThan(0.1);
  });

  it('executes script force-select and destroy-all-contained actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TransportTruck', 'America', ['VEHICLE', 'TRANSPORT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', {
            Slots: 4,
          }),
        ]),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('MissileDefender', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TransportTruck', 10, 10), // id 1
        makeMapObject('Passenger', 10, 10), // id 2
        makeMapObject('Ranger', 20, 20), // id 3
        makeMapObject('Ranger', 22, 20), // id 4
        makeMapObject('MissileDefender', 24, 20), // id 5
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.setScriptTeamMembers('SelectTeam', [3, 4, 5])).toBe(true);

    logic.submitCommand({ type: 'select', entityId: 5 });
    logic.update(0);
    expect(logic.getLocalPlayerSelectionIds()).toEqual([5]);

    expect(logic.executeScriptAction({
      actionType: 410, // OBJECT_FORCE_SELECT
      params: ['SelectTeam', 'Ranger', 0, ''],
    })).toBe(true);
    expect(logic.getLocalPlayerSelectionIds()).toEqual([3]);

    expect(logic.executeScriptAction({
      actionType: 410,
      params: ['MissingTeam', 'Ranger', 0, ''],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 410,
      params: ['SelectTeam', 'MissingType', 0, ''],
    })).toBe(false);

    logic.submitCommand({ type: 'enterTransport', entityId: 2, targetTransportId: 1 });
    for (let frame = 0; frame < 4; frame += 1) {
      logic.update(1 / 30);
    }

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        transportContainerId: number | null;
        destroyed: boolean;
      }>;
    };

    expect(privateApi.spawnedEntities.get(2)?.transportContainerId).toBe(1);
    expect(logic.executeScriptAction({
      actionType: 412, // UNIT_DESTROY_ALL_CONTAINED
      params: [1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(2)?.destroyed).toBe(true);

    logic.update(1 / 30);
    expect(logic.getEntityState(2)).toBeNull();

    expect(logic.executeScriptAction({
      actionType: 412,
      params: [999],
    })).toBe(false);
  });

  it('executes script named/team guard actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10), // id 1
        makeMapObject('Ranger', 14, 12), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('GuardTeam', [1, 2])).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        guardState: string;
        guardPositionX: number;
        guardPositionZ: number;
      }>;
    };

    expect(logic.executeScriptAction({
      actionType: 57, // NAMED_GUARD
      params: [1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(1)?.guardPositionX).toBeCloseTo(10, 5);
    expect(privateApi.spawnedEntities.get(1)?.guardPositionZ).toBeCloseTo(10, 5);

    expect(logic.executeScriptAction({
      actionType: 58, // TEAM_GUARD
      params: ['GuardTeam'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(1)?.guardPositionX).toBeCloseTo(10, 5);
    expect(privateApi.spawnedEntities.get(1)?.guardPositionZ).toBeCloseTo(10, 5);
    expect(privateApi.spawnedEntities.get(2)?.guardPositionX).toBeCloseTo(14, 5);
    expect(privateApi.spawnedEntities.get(2)?.guardPositionZ).toBeCloseTo(12, 5);

    expect(logic.executeScriptAction({
      actionType: 57,
      params: [999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 58,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script team guard position/object actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('Ranger', 10, 10), // id 1
      makeMapObject('Ranger', 14, 10), // id 2
      makeMapObject('Ranger', 35, 35), // id 3 target
    ], 128, 128);
    map.waypoints = {
      nodes: [
        {
          id: 1,
          name: 'GuardWaypointA',
          position: { x: 80, y: 90, z: 0 },
        },
      ],
      links: [],
    };
    map.triggers = [{
      id: 1,
      name: 'GuardAreaA',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 40, y: 40, z: 0 },
        { x: 60, y: 40, z: 0 },
        { x: 60, y: 60, z: 0 },
        { x: 40, y: 60, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    expect(logic.setScriptTeamMembers('GuardTeam', [1, 2])).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 407, // TEAM_GUARD_POSITION
      params: ['GuardTeam', 'GuardWaypointA'],
    })).toBe(true);
    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        guardState: string;
        guardObjectId: number;
        guardAreaTriggerIndex: number;
        guardPositionX: number;
        guardPositionZ: number;
      }>;
    };
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(1)?.guardObjectId).toBe(0);
    expect(privateApi.spawnedEntities.get(2)?.guardObjectId).toBe(0);
    expect(privateApi.spawnedEntities.get(1)?.guardPositionX).toBe(80);
    expect(privateApi.spawnedEntities.get(1)?.guardPositionZ).toBe(90);
    expect(privateApi.spawnedEntities.get(2)?.guardPositionX).toBe(80);
    expect(privateApi.spawnedEntities.get(2)?.guardPositionZ).toBe(90);

    expect(logic.executeScriptAction({
      actionType: 408, // TEAM_GUARD_OBJECT
      params: ['GuardTeam', 3],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardObjectId).toBe(3);
    expect(privateApi.spawnedEntities.get(2)?.guardObjectId).toBe(3);

    expect(logic.executeScriptAction({
      actionType: 409, // TEAM_GUARD_AREA
      params: ['GuardTeam', 'GuardAreaA'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardObjectId).toBe(0);
    expect(privateApi.spawnedEntities.get(2)?.guardObjectId).toBe(0);
    expect(privateApi.spawnedEntities.get(1)?.guardAreaTriggerIndex).toBe(0);
    expect(privateApi.spawnedEntities.get(2)?.guardAreaTriggerIndex).toBe(0);
    expect(privateApi.spawnedEntities.get(1)?.guardPositionX).toBe(50);
    expect(privateApi.spawnedEntities.get(1)?.guardPositionZ).toBe(50);
    expect(privateApi.spawnedEntities.get(2)?.guardPositionX).toBe(50);
    expect(privateApi.spawnedEntities.get(2)?.guardPositionZ).toBe(50);

    expect(logic.executeScriptAction({
      actionType: 407,
      params: ['GuardTeam', 'MissingWaypoint'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 407,
      params: ['MissingTeam', 'GuardWaypointA'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 408,
      params: ['GuardTeam', 999],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 408,
      params: ['MissingTeam', 3],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 409,
      params: ['GuardTeam', 'MissingArea'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 409,
      params: ['MissingTeam', 'GuardAreaA'],
    })).toBe(false);
  });

  it('executes script named/team stop actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10),
        makeMapObject('Ranger', 14, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AlphaTeam', [1, 2])).toBe(true);

    logic.submitCommand({ type: 'guardPosition', entityId: 1, targetX: 90, targetZ: 90, guardMode: 0 });
    logic.submitCommand({ type: 'guardPosition', entityId: 2, targetX: 92, targetZ: 90, guardMode: 0 });
    logic.update(0);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { guardState: string }>;
    };
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).not.toBe('NONE');

    expect(logic.executeScriptAction({
      actionType: 379, // NAMED_STOP
      params: [1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardState).toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).not.toBe('NONE');

    logic.submitCommand({ type: 'guardPosition', entityId: 1, targetX: 90, targetZ: 90, guardMode: 0 });
    logic.update(0);
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(logic.executeScriptAction({
      actionType: 174, // NAMED_STOP (raw id)
      params: [1],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardState).toBe('NONE');

    expect(logic.executeScriptAction({
      actionType: 380, // TEAM_STOP
      params: ['AlphaTeam'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(2)?.guardState).toBe('NONE');

    logic.submitCommand({ type: 'guardPosition', entityId: 1, targetX: 90, targetZ: 90, guardMode: 0 });
    logic.submitCommand({ type: 'guardPosition', entityId: 2, targetX: 92, targetZ: 90, guardMode: 0 });
    logic.update(0);
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).not.toBe('NONE');
    expect(logic.executeScriptAction({
      actionType: 175, // TEAM_STOP (raw id)
      params: ['AlphaTeam'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardState).toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).toBe('NONE');

    expect(logic.executeScriptAction({
      actionType: 380,
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script team stop-and-disband action using source action id', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10),
        makeMapObject('Ranger', 14, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AlphaTeam', [1, 2])).toBe(true);
    expect(logic.evaluateScriptHasUnits({ teamName: 'AlphaTeam' })).toBe(true);

    logic.submitCommand({ type: 'guardPosition', entityId: 1, targetX: 90, targetZ: 90, guardMode: 0 });
    logic.submitCommand({ type: 'guardPosition', entityId: 2, targetX: 92, targetZ: 90, guardMode: 0 });
    logic.update(0);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { guardState: string }>;
    };
    expect(privateApi.spawnedEntities.get(1)?.guardState).not.toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).not.toBe('NONE');

    expect(logic.executeScriptAction({
      actionType: 176, // TEAM_STOP_AND_DISBAND (raw id)
      params: ['AlphaTeam'],
    })).toBe(true);
    expect(privateApi.spawnedEntities.get(1)?.guardState).toBe('NONE');
    expect(privateApi.spawnedEntities.get(2)?.guardState).toBe('NONE');
    expect(logic.evaluateScriptHasUnits({ teamName: 'AlphaTeam' })).toBe(false);

    expect(logic.setScriptTeamMembers('BravoTeam', [1, 2])).toBe(true);
    logic.submitCommand({ type: 'guardPosition', entityId: 1, targetX: 90, targetZ: 90, guardMode: 0 });
    logic.submitCommand({ type: 'guardPosition', entityId: 2, targetX: 92, targetZ: 90, guardMode: 0 });
    logic.update(0);

    expect(logic.executeScriptAction({
      actionType: 381, // TEAM_STOP_AND_DISBAND (offset id)
      params: ['BravoTeam'],
    })).toBe(true);
    expect(logic.evaluateScriptHasUnits({ teamName: 'BravoTeam' })).toBe(false);

    expect(logic.executeScriptAction({
      actionType: 380, // TEAM_STOP
      params: ['AlphaTeam'],
    })).toBe(false);
    expect(logic.executeScriptAction({
      actionType: 381, // TEAM_STOP_AND_DISBAND
      params: ['MissingTeam'],
    })).toBe(false);
  });

  it('executes script relation-override actions using source action ids', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('TankHunter', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Ranger', 10, 10),
        makeMapObject('TankHunter', 20, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    expect(logic.setScriptTeamMembers('AlphaTeam', [1])).toBe(true);
    expect(logic.setScriptTeamMembers('BravoTeam', [2])).toBe(true);

    expect(logic.getEntityRelationship(1, 2)).toBe('neutral');
    expect(logic.executeScriptAction({
      actionType: 291, // PLAYER_RELATES_PLAYER
      params: ['America', 'China', 0],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('enemies');
    expect(logic.getEntityRelationship(2, 1)).toBe('neutral');
    logic.removePlayerRelationship('America', 'China');
    expect(logic.getEntityRelationship(1, 2)).toBe('neutral');

    expect(logic.executeScriptAction({
      actionType: 383, // TEAM_SET_OVERRIDE_RELATION_TO_TEAM
      params: ['AlphaTeam', 'BravoTeam', 0],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('enemies');

    expect(logic.executeScriptAction({
      actionType: 384, // TEAM_REMOVE_OVERRIDE_RELATION_TO_TEAM
      params: ['AlphaTeam', 'BravoTeam'],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('neutral');

    expect(logic.executeScriptAction({
      actionType: 388, // TEAM_SET_OVERRIDE_RELATION_TO_PLAYER
      params: ['AlphaTeam', 'China', 0],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('enemies');
    expect(logic.executeScriptAction({
      actionType: 389, // TEAM_REMOVE_OVERRIDE_RELATION_TO_PLAYER
      params: ['AlphaTeam', 'China'],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('neutral');

    expect(logic.executeScriptAction({
      actionType: 390, // PLAYER_SET_OVERRIDE_RELATION_TO_TEAM
      params: ['America', 'BravoTeam', 0],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('enemies');
    expect(logic.executeScriptAction({
      actionType: 391, // PLAYER_REMOVE_OVERRIDE_RELATION_TO_TEAM
      params: ['America', 'BravoTeam'],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('neutral');

    expect(logic.executeScriptAction({
      actionType: 383, // TEAM_SET_OVERRIDE_RELATION_TO_TEAM
      params: ['AlphaTeam', 'BravoTeam', 0],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 388, // TEAM_SET_OVERRIDE_RELATION_TO_PLAYER
      params: ['AlphaTeam', 'China', 0],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('enemies');
    expect(logic.executeScriptAction({
      actionType: 385, // TEAM_REMOVE_ALL_OVERRIDE_RELATIONS
      params: ['AlphaTeam'],
    })).toBe(true);
    expect(logic.getEntityRelationship(1, 2)).toBe('neutral');

    expect(logic.executeScriptAction({
      actionType: 383,
      params: ['MissingTeam', 'BravoTeam', 0],
    })).toBe(false);
  });

  it('evaluates named-reached-waypoints-end from completed waypoint labels', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('UnitA', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptNamedReachedWaypointsEnd({
      entityId: 1,
      waypointPathName: 'PatrolPathA',
    })).toBe(false);

    logic.notifyScriptWaypointPathCompleted(1, 'PatrolPathA');
    expect(logic.evaluateScriptNamedReachedWaypointsEnd({
      entityId: 1,
      waypointPathName: 'PatrolPathA',
    })).toBe(true);
    expect(logic.evaluateScriptNamedReachedWaypointsEnd({
      entityId: 1,
      waypointPathName: 'DifferentPath',
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptNamedReachedWaypointsEnd({
      entityId: 1,
      waypointPathName: 'PatrolPathA',
    })).toBe(false);
  });

  it('evaluates named-area existence and in-area type/kind conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InfantryA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('SupplyCrate', 'America', ['CRATE', 'INERT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('InfantryA', 6, 6),
      makeMapObject('SupplyCrate', 8, 8),
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'SpawnZone',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 0, y: 0, z: 0 },
        { x: 20, y: 0, z: 0 },
        { x: 20, y: 20, z: 0 },
        { x: 0, y: 20, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));

    expect(logic.evaluateScriptSkirmishNamedAreaExists('SpawnZone')).toBe(true);
    expect(logic.evaluateScriptSkirmishNamedAreaExists('MissingZone')).toBe(false);

    expect(logic.evaluateScriptPlayerHasUnitTypeInArea({
      side: 'America',
      comparison: 'EQUAL',
      count: 1,
      templateName: 'SupplyCrate',
      triggerName: 'SpawnZone',
      conditionCacheId: 'unit-type-area',
    })).toBe(true);

    expect(logic.evaluateScriptPlayerHasUnitKindInArea({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      count: 1,
      kindOf: 'INFANTRY',
      triggerName: 'SpawnZone',
      conditionCacheId: 'unit-kind-area',
    })).toBe(true);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptPlayerHasUnitKindInArea({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      count: 1,
      kindOf: 'INFANTRY',
      triggerName: 'SpawnZone',
      conditionCacheId: 'unit-kind-area',
    })).toBe(false);
  });

  it('tracks player-lost-object-type transitions against previous counts', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('UnitB', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('UnitA', 10, 10),
        makeMapObject('UnitA', 12, 10),
        makeMapObject('UnitB', 14, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.executeScriptAction({
      actionType: 287, // OBJECTLIST_ADDOBJECTTYPE
      params: ['LossList', 'UnitA'],
    })).toBe(true);
    expect(logic.executeScriptAction({
      actionType: 287,
      params: ['LossList', 'UnitB'],
    })).toBe(true);

    expect(logic.evaluateScriptPlayerLostObjectType({
      side: 'America',
      templateName: 'UnitA',
    })).toBe(false);
    expect(logic.evaluateScriptPlayerLostObjectType({
      side: 'America',
      templateName: 'LossList',
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptPlayerLostObjectType({
      side: 'America',
      templateName: 'UnitA',
    })).toBe(true);
    expect(logic.evaluateScriptPlayerLostObjectType({
      side: 'America',
      templateName: 'LossList',
    })).toBe(true);
    expect(logic.evaluateScriptPlayerLostObjectType({
      side: 'America',
      templateName: 'UnitA',
    })).toBe(false);
    expect(logic.evaluateScriptPlayerLostObjectType({
      side: 'America',
      templateName: 'LossList',
    })).toBe(false);
  });

  it('evaluates skirmish player area-presence and outside-area conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('InfantryA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('DummyProjectile', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('DummyInert', 'America', ['INERT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('InfantryA', 6, 6),
      makeMapObject('DummyProjectile', 8, 8),
      makeMapObject('DummyInert', 10, 10),
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'SpawnZone',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 0, y: 0, z: 0 },
        { x: 20, y: 0, z: 0 },
        { x: 20, y: 20, z: 0 },
        { x: 0, y: 20, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));

    expect(logic.evaluateScriptSkirmishPlayerHasUnitsInArea({
      side: 'America',
      triggerName: 'SpawnZone',
      conditionCacheId: 'skirmish-in-area',
    })).toBe(true);
    expect(logic.evaluateScriptSkirmishPlayerIsOutsideArea({
      side: 'America',
      triggerName: 'SpawnZone',
      conditionCacheId: 'skirmish-outside',
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 500, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptSkirmishPlayerHasUnitsInArea({
      side: 'America',
      triggerName: 'SpawnZone',
      conditionCacheId: 'skirmish-in-area',
    })).toBe(false);
    expect(logic.evaluateScriptSkirmishPlayerIsOutsideArea({
      side: 'America',
      triggerName: 'SpawnZone',
      conditionCacheId: 'skirmish-outside',
    })).toBe(true);
  });

  it('evaluates skirmish player attacked-by-player condition', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Target', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('Attacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Target', 10, 10),
        makeMapObject('Attacker', 20, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptSkirmishPlayerHasBeenAttackedByPlayer({
      side: 'America',
      attackedBySide: 'China',
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(2, privateApi.spawnedEntities.get(1), 10, 'SMALL_ARMS');

    expect(logic.evaluateScriptSkirmishPlayerHasBeenAttackedByPlayer({
      side: 'America',
      attackedBySide: 'China',
    })).toBe(true);
  });

  it('evaluates player credits and building-count script conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
        ]),
        makeObjectDef('Bunker', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 600, InitialHealth: 600 }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('CommandCenter', 10, 10),
        makeMapObject('Bunker', 20, 10),
        makeMapObject('Ranger', 30, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setSideCredits('America', 1000);

    // Source parity: compare requested credits against current money.
    expect(logic.evaluateScriptPlayerHasCredits({
      side: 'America',
      comparison: 'LESS_THAN',
      credits: 900,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerHasCredits({
      side: 'America',
      comparison: 'GREATER',
      credits: 1100,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerHasCredits({
      side: 'America',
      comparison: 'EQUAL',
      credits: 1000,
    })).toBe(true);

    expect(logic.evaluateScriptPlayerHasNOrFewerBuildings({
      side: 'America',
      buildingCount: 2,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerHasNOrFewerBuildings({
      side: 'America',
      buildingCount: 1,
    })).toBe(false);

    expect(logic.evaluateScriptPlayerHasNOrFewerFactionBuildings({
      side: 'America',
      buildingCount: 1,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerHasNOrFewerFactionBuildings({
      side: 'America',
      buildingCount: 0,
    })).toBe(false);
  });

  it('evaluates science-acquired, can-purchase-science, and science-points conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
      sciences: [
        makeScienceDef('SCIENCE_ALPHA', {
          SciencePurchasePointCost: 2,
          IsGrantable: 'Yes',
        }),
        makeScienceDef('SCIENCE_BETA', {
          SciencePurchasePointCost: 3,
          PrerequisiteSciences: 'SCIENCE_ALPHA',
          IsGrantable: 'Yes',
        }),
        makeScienceDef('SCIENCE_NOT_PURCHASABLE', {
          SciencePurchasePointCost: 0,
          IsGrantable: 'Yes',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CommandCenter', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      getSideRankStateMap: (side: string) => { sciencePurchasePoints: number };
    };
    privateApi.getSideRankStateMap('america').sciencePurchasePoints = 3;

    expect(logic.evaluateScriptCanPurchaseScience({
      side: 'America',
      scienceName: 'SCIENCE_ALPHA',
    })).toBe(true);
    expect(logic.evaluateScriptCanPurchaseScience({
      side: 'America',
      scienceName: 'SCIENCE_BETA',
    })).toBe(false);
    expect(logic.evaluateScriptCanPurchaseScience({
      side: 'America',
      scienceName: 'SCIENCE_NOT_PURCHASABLE',
    })).toBe(false);

    expect(logic.evaluateScriptSciencePurchasePoints({
      side: 'America',
      pointsNeeded: 3,
    })).toBe(true);
    expect(logic.evaluateScriptSciencePurchasePoints({
      side: 'America',
      pointsNeeded: 4,
    })).toBe(false);

    logic.submitCommand({
      type: 'grantSideScience',
      side: 'America',
      scienceName: 'SCIENCE_ALPHA',
    });
    logic.update(1 / 30);

    // Source parity: evaluateScienceAcquired consumes the event once.
    expect(logic.evaluateScriptScienceAcquired({
      side: 'America',
      scienceName: 'SCIENCE_ALPHA',
    })).toBe(true);
    expect(logic.evaluateScriptScienceAcquired({
      side: 'America',
      scienceName: 'SCIENCE_ALPHA',
    })).toBe(false);

    expect(logic.evaluateScriptCanPurchaseScience({
      side: 'America',
      scienceName: 'SCIENCE_ALPHA',
    })).toBe(false);
    expect(logic.evaluateScriptCanPurchaseScience({
      side: 'America',
      scienceName: 'SCIENCE_BETA',
    })).toBe(true);
  });

  it('evaluates upgrade-from-unit-complete with source filtering and event consumption', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UpgradeLab', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 }),
          makeBlock('Behavior', 'ProductionUpdate ModuleTag_Production', {
            MaxQueueEntries: 2,
          }),
          makeBlock('Behavior', 'CommandSetUpgrade ModuleTag_UpgradeObjectA', {
            TriggeredBy: 'Upgrade_ObjectA',
            CommandSet: 'CommandSet_UpgradeLab',
          }),
        ], { CommandSet: 'CommandSet_UpgradeLab' }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_ObjectA', {
          Type: 'OBJECT',
          BuildTime: 0.1,
          BuildCost: 50,
        }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_UpgradeObjectA', {
          Command: 'UNIT_BUILD',
          Upgrade: 'Upgrade_ObjectA',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_UpgradeLab', { '1': 'Command_UpgradeObjectA' }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('UpgradeLab', 20, 20),
        makeMapObject('UpgradeLab', 30, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setSideCredits('America', 1000);
    logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 1, upgradeName: 'Upgrade_ObjectA' });
    logic.submitCommand({ type: 'queueUpgradeProduction', entityId: 2, upgradeName: 'Upgrade_ObjectA' });
    for (let i = 0; i < 4; i += 1) {
      logic.update(1 / 30);
    }

    expect(logic.evaluateScriptUpgradeFromUnitComplete({
      side: 'America',
      upgradeName: 'Upgrade_ObjectA',
      sourceEntityId: 1,
    })).toBe(true);
    expect(logic.evaluateScriptUpgradeFromUnitComplete({
      side: 'America',
      upgradeName: 'Upgrade_ObjectA',
      sourceEntityId: 1,
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Source parity: with explicit source unit, dead source resolves to false and does not consume.
    expect(logic.evaluateScriptUpgradeFromUnitComplete({
      side: 'America',
      upgradeName: 'Upgrade_ObjectA',
      sourceEntityId: 2,
    })).toBe(false);

    expect(logic.evaluateScriptUpgradeFromUnitComplete({
      side: 'America',
      upgradeName: 'Upgrade_ObjectA',
    })).toBe(true);
    expect(logic.evaluateScriptUpgradeFromUnitComplete({
      side: 'America',
      upgradeName: 'Upgrade_ObjectA',
    })).toBe(false);
  });

  it('evaluates player-special-power-triggered with source filtering and event consumption', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerSource', 'America', ['INFANTRY'], [
          makeBlock('Behavior', 'SpecialPowerModule SourceNoTarget', {
            SpecialPowerTemplate: 'SpecialPowerTrigger',
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerTrigger', { ReloadTime: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('SpecialPowerSource', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_TRIGGER',
      specialPowerName: 'SpecialPowerTrigger',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    logic.update(0);

    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(false);

    logic.submitCommand({
      type: 'issueSpecialPower',
      commandButtonId: 'CMD_TRIGGER',
      specialPowerName: 'SpecialPowerTrigger',
      commandOption: 0,
      issuingEntityIds: [1],
      sourceEntityId: 1,
      targetEntityId: null,
      targetX: null,
      targetZ: null,
    });
    logic.update(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Source parity: explicit source lookup fails if source object no longer exists.
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(false);

    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
    })).toBe(true);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
    })).toBe(false);
  });

  it('evaluates player-special-power-midway/complete with source filtering and event consumption', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SpecialPowerSource', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
        makeObjectDef('SpecialPowerPayload', 'America', ['PROJECTILE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
          makeBlock('Behavior', 'SpecialPowerCompletionDie ModuleTag_Complete', {
            SpecialPowerTemplate: 'SpecialPowerTrigger',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SpecialPowerTrigger', { ReloadTime: 0 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SpecialPowerSource', 10, 10),   // id 1
        makeMapObject('SpecialPowerPayload', 12, 10),  // id 2
        makeMapObject('SpecialPowerPayload', 14, 10),  // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        specialPowerCompletionDieProfiles: Array<{ specialPowerTemplateName: string }>;
        specialPowerCompletionCreatorId: number;
        specialPowerCompletionCreatorSet: boolean;
      }>;
      sideScriptMidwaySpecialPowerEvents: Map<string, Array<{ name: string; sourceEntityId: number }>>;
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
    };

    // Verify profile extraction and seed creator IDs.
    expect(privateApi.spawnedEntities.get(2)!.specialPowerCompletionDieProfiles[0]!.specialPowerTemplateName).toBe('SPECIALPOWERTRIGGER');
    privateApi.spawnedEntities.get(2)!.specialPowerCompletionCreatorId = 1;
    privateApi.spawnedEntities.get(2)!.specialPowerCompletionCreatorSet = true;
    privateApi.spawnedEntities.get(3)!.specialPowerCompletionCreatorId = 1;
    privateApi.spawnedEntities.get(3)!.specialPowerCompletionCreatorSet = true;

    // Midway list parity (no producer in current subset): consume once.
    privateApi.sideScriptMidwaySpecialPowerEvents.set('america', [{
      name: 'SPECIALPOWERTRIGGER',
      sourceEntityId: 1,
    }]);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitMidway({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitMidway({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(false);

    // Kill payload #1 and consume completion event by explicit source.
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitComplete({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitComplete({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(false);

    // Kill payload #2, then kill source.
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(3), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    // Source-specific lookup fails when source no longer exists, but event remains.
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitComplete({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
      sourceEntityId: 1,
    })).toBe(false);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitComplete({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
    })).toBe(true);
    expect(logic.evaluateScriptPlayerSpecialPowerFromUnitComplete({
      side: 'America',
      specialPowerName: 'SpecialPowerTrigger',
    })).toBe(false);
  });

  it('evaluates named-unit lifecycle conditions with did-exist parity', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Scout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('Scout', 10, 10, { objectName: 'NamedScout' })], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptNamedCreated({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedUnitExists({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedUnitDestroyed({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitDying({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitTotallyDead({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptCondition({ conditionType: 'NAMED_DESTROYED', params: ['NamedScout'] })).toBe(false);

    // Never-existing unit id should stay false for destroyed/totally-dead checks.
    expect(logic.evaluateScriptNamedUnitDestroyed({ entityId: 999 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitTotallyDead({ entityId: 999 })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');

    // During death pipeline, object still exists but is effectively dead.
    expect(logic.evaluateScriptNamedCreated({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedUnitExists({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitDestroyed({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedUnitDying({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedUnitTotallyDead({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptCondition({ conditionType: 'NAMED_DESTROYED', params: ['NamedScout'] })).toBe(true);

    logic.update(1 / 30);

    // After finalization, object is gone but did exist.
    expect(logic.evaluateScriptNamedCreated({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitExists({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitDestroyed({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedUnitDying({ entityId: 1 })).toBe(false);
    expect(logic.evaluateScriptNamedUnitTotallyDead({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptCondition({ conditionType: 'NAMED_DESTROYED', params: ['NamedScout'] })).toBe(true);
  });

  it('evaluates named-attacked-by-player using persistent last-damage source side', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Target', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
        makeObjectDef('Attacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Target', 10, 10),   // id 1
        makeMapObject('Attacker', 20, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptNamedAttackedByPlayer({
      entityId: 1,
      attackedBySide: 'China',
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(2, privateApi.spawnedEntities.get(1), 10, 'SMALL_ARMS');

    expect(logic.evaluateScriptNamedAttackedByPlayer({
      entityId: 1,
      attackedBySide: 'China',
    })).toBe(true);
    expect(logic.evaluateScriptNamedAttackedByPlayer({
      entityId: 1,
      attackedBySide: 'America',
    })).toBe(false);

    // Source parity: last-damage source player remains available even if attacker is gone.
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    expect(logic.evaluateScriptNamedAttackedByPlayer({
      entityId: 1,
      attackedBySide: 'China',
    })).toBe(true);

    // Environmental/no-source damage overwrites last damage info with no attacker side.
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 1, 'FLAME');
    expect(logic.evaluateScriptNamedAttackedByPlayer({
      entityId: 1,
      attackedBySide: 'China',
    })).toBe(false);
  });

  it('evaluates named-attacked-by-type from persistent last-damage source template', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Target', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
        makeObjectDef('VehicleAttacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Target', 10, 10),          // id 1
        makeMapObject('VehicleAttacker', 20, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptNamedAttackedByType({
      entityId: 1,
      objectType: 'VehicleAttacker',
    })).toBe(false);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(2, privateApi.spawnedEntities.get(1), 10, 'SMALL_ARMS');

    expect(logic.evaluateScriptNamedAttackedByType({
      entityId: 1,
      objectType: 'VehicleAttacker',
    })).toBe(true);
    expect(logic.evaluateScriptNamedAttackedByType({
      entityId: 1,
      objectType: 'UnknownTemplate',
    })).toBe(false);

    // Source parity: source template is retained even after attacker object is gone.
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);
    expect(logic.evaluateScriptNamedAttackedByType({
      entityId: 1,
      objectType: 'VehicleAttacker',
    })).toBe(true);
  });

  it('evaluates building-entered and is-building-empty from contain state', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GarrisonHub', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 900,
            InitialHealth: 900,
          }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_Contain', {
            ContainMax: 2,
          }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GarrisonHub', 12, 12), // id 1
        makeMapObject('Ranger', 14, 12),      // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptBuildingEntered({
      side: 'America',
      entityId: 1,
    })).toBe(false);
    expect(logic.evaluateScriptIsBuildingEmpty({
      entityId: 1,
    })).toBe(true);

    logic.submitCommand({ type: 'garrisonBuilding', entityId: 2, targetBuildingId: 1 });
    logic.update(0);

    expect(logic.evaluateScriptBuildingEntered({
      side: 'America',
      entityId: 1,
    })).toBe(true);
    expect(logic.evaluateScriptBuildingEntered({
      side: 'China',
      entityId: 1,
    })).toBe(false);
    expect(logic.evaluateScriptIsBuildingEmpty({
      entityId: 1,
    })).toBe(false);

    // Source parity: OpenContain::update clears player-entered flag each frame.
    logic.update(0);
    expect(logic.evaluateScriptBuildingEntered({
      side: 'America',
      entityId: 1,
    })).toBe(false);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { garrisonContainerId: number | null }>;
    };
    privateApi.spawnedEntities.get(2)!.garrisonContainerId = null;
    expect(logic.evaluateScriptIsBuildingEmpty({
      entityId: 1,
    })).toBe(true);
  });

  it('evaluates named-has-free-container-slots from contain occupancy', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GarrisonHub', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 900, InitialHealth: 900 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_Contain', { ContainMax: 1 }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GarrisonHub', 12, 12),
        makeMapObject('Ranger', 14, 12),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptNamedHasFreeContainerSlots({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptNamedHasFreeContainerSlots({ entityId: 2 })).toBe(false);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { garrisonContainerId: number | null }>;
    };
    privateApi.spawnedEntities.get(2)!.garrisonContainerId = 1;

    expect(logic.evaluateScriptNamedHasFreeContainerSlots({ entityId: 1 })).toBe(false);
  });

  it('evaluates named-entered-area and named-exited-area using current/previous frame parity', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Scout', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([makeMapObject('Scout', 20, 20)], 128, 128);
    map.triggers = [{
      name: 'CaptureZone',
      id: 1,
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 40, y: 40 },
        { x: 80, y: 40 },
        { x: 80, y: 80 },
        { x: 40, y: 80 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number }>;
    };
    const scout = privateApi.spawnedEntities.get(1)!;

    expect(logic.evaluateScriptNamedInsideArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);
    expect(logic.evaluateScriptNamedOutsideArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    expect(logic.evaluateScriptNamedEnteredArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);
    expect(logic.evaluateScriptNamedExitedArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);

    // Move inside the trigger and verify entered-frame + previous-frame behavior.
    scout.x = 50;
    scout.z = 50;
    logic.update(0);
    expect(logic.evaluateScriptNamedInsideArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    expect(logic.evaluateScriptNamedOutsideArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);
    expect(logic.evaluateScriptNamedEnteredArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    logic.update(0);
    expect(logic.evaluateScriptNamedEnteredArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    logic.update(0);
    expect(logic.evaluateScriptNamedEnteredArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);

    // Move back outside and verify exit detection with same frame window.
    scout.x = 20;
    scout.z = 20;
    logic.update(0);
    expect(logic.evaluateScriptNamedInsideArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);
    expect(logic.evaluateScriptNamedOutsideArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    expect(logic.evaluateScriptNamedExitedArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    logic.update(0);
    expect(logic.evaluateScriptNamedExitedArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(true);
    logic.update(0);
    expect(logic.evaluateScriptNamedExitedArea({ entityId: 1, triggerName: 'CaptureZone' })).toBe(false);
  });

  it('evaluates script-team core conditions from explicit team registry subset', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TeamUnitA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('TeamUnitB', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('EnemyUnitC', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TeamUnitA', 10, 10), // id 1
        makeMapObject('TeamUnitB', 12, 10), // id 2
        makeMapObject('EnemyUnitC', 14, 10), // id 3
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setScriptTeamMembers('AlphaTeam', [1, 2]);
    logic.setScriptTeamCreated('AlphaTeam', true);
    logic.setScriptTeamState('AlphaTeam', 'ASSAULT');
    logic.setScriptTeamControllingSide('AlphaTeam', 'America');

    expect(logic.evaluateScriptTeamCreated({ teamName: 'AlphaTeam' })).toBe(true);
    expect(logic.evaluateScriptTeamStateIs({ teamName: 'AlphaTeam', stateName: 'ASSAULT' })).toBe(true);
    expect(logic.evaluateScriptTeamStateIsNot({ teamName: 'AlphaTeam', stateName: 'RETREAT' })).toBe(true);
    expect(logic.evaluateScriptHasUnits({ teamName: 'AlphaTeam' })).toBe(true);
    expect(logic.evaluateScriptIsDestroyed({ teamName: 'AlphaTeam' })).toBe(false);
    expect(logic.evaluateScriptTeamOwnedByPlayer({ teamName: 'AlphaTeam', side: 'America' })).toBe(true);
    expect(logic.evaluateScriptTeamOwnedByPlayer({ teamName: 'AlphaTeam', side: 'China' })).toBe(false);
    expect(logic.evaluateScriptTeamDiscovered({ teamName: 'AlphaTeam', side: 'America' })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string>; transportContainerId: number | null }>;
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
    };

    privateApi.spawnedEntities.get(1)!.objectStatusFlags.add('VETERAN');
    expect(logic.evaluateScriptTeamHasObjectStatus({
      teamName: 'AlphaTeam',
      objectStatus: 'VETERAN',
      entireTeam: false,
    })).toBe(true);
    expect(logic.evaluateScriptTeamHasObjectStatus({
      teamName: 'AlphaTeam',
      objectStatus: 'VETERAN',
      entireTeam: true,
    })).toBe(false);

    privateApi.applyWeaponDamageAmount(3, privateApi.spawnedEntities.get(1), 15, 'SMALL_ARMS');
    expect(logic.evaluateScriptTeamAttackedByPlayer({
      teamName: 'AlphaTeam',
      attackedBySide: 'China',
    })).toBe(true);
    expect(logic.evaluateScriptTeamAttackedByType({
      teamName: 'AlphaTeam',
      objectType: 'EnemyUnitC',
    })).toBe(true);

    logic.notifyScriptWaypointPathCompleted(1, 'RouteAlpha');
    expect(logic.evaluateScriptTeamReachedWaypointsEnd({
      teamName: 'AlphaTeam',
      waypointPathName: 'RouteAlpha',
    })).toBe(true);

    privateApi.spawnedEntities.get(1)!.transportContainerId = 99;
    expect(logic.evaluateScriptTeamIsContained({
      teamName: 'AlphaTeam',
      allContained: false,
    })).toBe(true);
    expect(logic.evaluateScriptTeamIsContained({
      teamName: 'AlphaTeam',
      allContained: true,
    })).toBe(false);
    privateApi.spawnedEntities.get(2)!.transportContainerId = 99;
    expect(logic.evaluateScriptTeamIsContained({
      teamName: 'AlphaTeam',
      allContained: true,
    })).toBe(true);

    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(2), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptHasUnits({ teamName: 'AlphaTeam' })).toBe(false);
    expect(logic.evaluateScriptIsDestroyed({ teamName: 'AlphaTeam' })).toBe(true);
  });

  it('resolves THIS_TEAM and THIS_OBJECT via script context setters', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ContextUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('ContextUnit', 10, 10)], 128, 128), // id 1
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setScriptTeamMembers('AlphaTeam', [1]);
    logic.setScriptConditionTeamContext('AlphaTeam');
    expect(logic.evaluateScriptCondition({
      conditionType: 'TEAM_HAS_UNITS',
      params: ['<This Team>'],
    })).toBe(true);

    logic.setScriptCallingTeamContext('AlphaTeam');
    expect(logic.executeScriptAction({
      actionType: 'TEAM_SET_STATE',
      params: ['<This Team>', 'PATROL'],
    })).toBe(true);
    expect(logic.evaluateScriptTeamStateIs({ teamName: 'AlphaTeam', stateName: 'PATROL' })).toBe(true);

    logic.setScriptConditionEntityContext(1);
    expect(logic.evaluateScriptCondition({
      conditionType: 'NAMED_NOT_DESTROYED',
      params: ['<This Object>'],
    })).toBe(true);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 9999, 'UNRESISTABLE');
    logic.update(1 / 30);

    expect(logic.evaluateScriptCondition({
      conditionType: 'NAMED_DESTROYED',
      params: ['<This Object>'],
    })).toBe(true);
  });

  it('resolves THIS_PLAYER tokens for player-side script params', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('PlayerUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('EnemyUnit', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PlayerUnit', 10, 10),
        makeMapObject('EnemyUnit', 20, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setSideCredits('America', 1000);
    logic.setSideCredits('China', 500);
    logic.setPlayerRelationship('America', 'China', 0);
    logic.setPlayerRelationship('China', 'America', 0);
    logic.setScriptCurrentPlayerSide('America');

    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_HAS_CREDITS',
      params: [1000, 'EQUAL', '<This Player>'],
    })).toBe(true);
    expect(logic.evaluateScriptCondition({
      conditionType: 'PLAYER_HAS_CREDITS',
      params: [500, 'EQUAL', "<This Player's Enemy>"],
    })).toBe(true);

    expect(logic.executeScriptAction({
      actionType: 'PLAYER_SET_MONEY',
      params: ['<This Player>', 250],
    })).toBe(true);
    expect(logic.getSideCredits('America')).toBe(250);
  });

  it('evaluates script-team area and enter/exit conditions from member trigger transitions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TeamMover', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('TeamMover', 20, 20), // id 1
      makeMapObject('TeamMover', 24, 20), // id 2
    ], 128, 128);
    map.triggers = [{
      name: 'TeamZone',
      id: 1,
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 40, y: 40 },
        { x: 80, y: 40 },
        { x: 80, y: 80 },
        { x: 40, y: 80 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    logic.setScriptTeamMembers('BravoTeam', [1, 2]);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number }>;
    };
    const memberA = privateApi.spawnedEntities.get(1)!;
    const memberB = privateApi.spawnedEntities.get(2)!;

    expect(logic.evaluateScriptTeamInsideAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);
    expect(logic.evaluateScriptTeamInsideAreaPartially({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);
    expect(logic.evaluateScriptTeamOutsideAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);

    // Move one member in.
    memberA.x = 50;
    memberA.z = 50;
    logic.update(0);

    expect(logic.evaluateScriptTeamInsideAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);
    expect(logic.evaluateScriptTeamInsideAreaPartially({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
    expect(logic.evaluateScriptTeamOutsideAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);
    expect(logic.evaluateScriptTeamEnteredAreaPartially({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
    expect(logic.evaluateScriptTeamEnteredAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);
    expect(logic.evaluateScriptTeamExitedAreaPartially({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);
    expect(logic.evaluateScriptTeamExitedAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(false);

    // Move second member in.
    memberB.x = 52;
    memberB.z = 52;
    logic.update(0);

    expect(logic.evaluateScriptTeamInsideAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
    expect(logic.evaluateScriptTeamInsideAreaPartially({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
    expect(logic.evaluateScriptTeamEnteredAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);

    // Move both out.
    memberA.x = 20;
    memberA.z = 20;
    memberB.x = 24;
    memberB.z = 20;
    logic.update(0);

    expect(logic.evaluateScriptTeamExitedAreaPartially({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
    expect(logic.evaluateScriptTeamExitedAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
    expect(logic.evaluateScriptTeamOutsideAreaEntirely({ teamName: 'BravoTeam', triggerName: 'TeamZone' })).toBe(true);
  });

  it('evaluates unit-has-emptied with previous-frame transport count parity', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('Transport', 'America', ['VEHICLE', 'TRANSPORT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
          makeBlock('Behavior', 'TransportContain ModuleTag_Contain', { Slots: 2 }),
        ]),
        makeObjectDef('Passenger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('Transport', 10, 10), // id 1
        makeMapObject('Passenger', 12, 10), // id 2
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { transportContainerId: number | null }>;
    };

    privateApi.spawnedEntities.get(2)!.transportContainerId = 1;
    expect(logic.evaluateScriptUnitHasEmptied({ entityId: 1 })).toBe(false);

    logic.update(0);
    privateApi.spawnedEntities.get(2)!.transportContainerId = null;

    expect(logic.evaluateScriptUnitHasEmptied({ entityId: 1 })).toBe(true);
    expect(logic.evaluateScriptUnitHasEmptied({ entityId: 1 })).toBe(true);

    logic.update(0);
    expect(logic.evaluateScriptUnitHasEmptied({ entityId: 1 })).toBe(false);
  });

  it('evaluates unit-has-object-status with any-bit semantics', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('StatusUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('StatusUnit', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    privateApi.spawnedEntities.get(1)!.objectStatusFlags.add('DISABLED_HACKED');

    expect(logic.evaluateScriptUnitHasObjectStatus({
      entityId: 1,
      objectStatus: 'DISABLED_HACKED',
    })).toBe(true);
    expect(logic.evaluateScriptUnitHasObjectStatus({
      entityId: 1,
      objectStatus: 'DISABLED_EMP DISABLED_HACKED',
    })).toBe(true);
    expect(logic.evaluateScriptUnitHasObjectStatus({
      entityId: 1,
      objectStatus: 'DISABLED_EMP',
    })).toBe(false);
  });

  it('evaluates unit-health from initial health with source-parity rounding', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('DamagedSpawnUnit', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 200,
            InitialHealth: 150,
          }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('DamagedSpawnUnit', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    // Source parity: denominator is InitialHealth, not MaxHealth.
    expect(logic.evaluateScriptUnitHealth({
      entityId: 1,
      comparison: 'EQUAL',
      healthPercent: 100,
    })).toBe(true);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (sourceEntityId: number | null, target: unknown, amount: number, damageType: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(null, privateApi.spawnedEntities.get(1), 52, 'SMALL_ARMS');

    // C++ rounding formula: (health*100 + initial/2) / initial.
    // (98*100 + 150/2) / 150 = 65 (integer).
    expect(logic.evaluateScriptUnitHealth({
      entityId: 1,
      comparison: 'EQUAL',
      healthPercent: 65,
    })).toBe(true);
    expect(logic.evaluateScriptUnitHealth({
      entityId: 1,
      comparison: 'GREATER_EQUAL',
      healthPercent: 66,
    })).toBe(false);
  });

  it('evaluates player power percentage and excess-power comparisons', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef(
          'PowerPlantA',
          'America',
          ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'],
          [makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 })],
          { EnergyBonus: 100 },
        ),
        makeObjectDef(
          'BarracksA',
          'America',
          ['STRUCTURE'],
          [makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 })],
          { EnergyBonus: -80 },
        ),
        makeObjectDef(
          'ConsumerC',
          'China',
          ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'],
          [makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 900, InitialHealth: 900 })],
          { EnergyBonus: -120 },
        ),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlantA', 10, 10),
        makeMapObject('BarracksA', 20, 10),
        makeMapObject('ConsumerC', 30, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.evaluateScriptPlayerHasPower({ side: 'America' })).toBe(true);
    expect(logic.evaluateScriptPlayerHasPower({ side: 'China' })).toBe(false);

    // America power ratio: 100 / 80 = 1.25 (125%).
    expect(logic.evaluateScriptPlayerHasComparisonPercentPower({
      side: 'America',
      comparison: 'GREATER_EQUAL',
      percent: 125,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerHasComparisonPercentPower({
      side: 'America',
      comparison: 'GREATER',
      percent: 130,
    })).toBe(false);

    // America excess power: 100 - 80 = 20.
    expect(logic.evaluateScriptPlayerHasComparisonValueExcessPower({
      side: 'America',
      comparison: 'EQUAL',
      kilowatts: 20,
    })).toBe(true);
    expect(logic.evaluateScriptPlayerHasComparisonValueExcessPower({
      side: 'America',
      comparison: 'LESS_THAN',
      kilowatts: 0,
    })).toBe(false);
  });

  it('evaluates skirmish garrisoned-building and captured-unit comparisons', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('GarrisonBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'GarrisonContain ModuleTag_Contain', { ContainMax: 5 }),
        ]),
        makeObjectDef('Ranger', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('GarrisonBuilding', 10, 10),
        makeMapObject('Ranger', 12, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, {
        garrisonContainerId: number | null;
      }>;
      captureEntity: (entityId: number, newSide: string) => void;
    };

    // Simulate one unit inside one garrison building.
    const ranger = privateApi.spawnedEntities.get(2)!;
    ranger.garrisonContainerId = 1;

    expect(logic.evaluateScriptSkirmishPlayerHasComparisonGarrisoned({
      side: 'America',
      comparison: 'EQUAL',
      count: 1,
    })).toBe(true);

    // Capture unit into China side; source parity Object::isCaptured should become true.
    privateApi.captureEntity(2, 'China');
    expect(logic.evaluateScriptSkirmishPlayerHasComparisonCapturedUnits({
      side: 'China',
      comparison: 'GREATER_EQUAL',
      count: 1,
    })).toBe(true);

    // Recapturing back to the original side clears captured state.
    privateApi.captureEntity(2, 'America');
    expect(logic.evaluateScriptSkirmishPlayerHasComparisonCapturedUnits({
      side: 'America',
      comparison: 'EQUAL',
      count: 0,
    })).toBe(true);
  });

  it('evaluates skirmish player faction and discovery conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('ScoutA', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 40 }),
        makeObjectDef('ScoutC', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { VisionRange: 40 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('ScoutA', 10, 10),
        makeMapObject('ScoutC', 15, 10),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.update(1 / 30);

    expect(logic.evaluateScriptSkirmishPlayerIsFaction({
      side: 'America',
      factionName: 'America',
    })).toBe(true);
    expect(logic.evaluateScriptSkirmishPlayerIsFaction({
      side: 'America',
      factionName: 'China',
    })).toBe(false);

    expect(logic.evaluateScriptSkirmishPlayerHasDiscoveredPlayer({
      side: 'America',
      discoveredBySide: 'China',
    })).toBe(true);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    privateApi.spawnedEntities.get(1)!.objectStatusFlags.add('STEALTHED');

    // Source parity: stealthed and not detected/disguised objects do not count.
    expect(logic.evaluateScriptSkirmishPlayerHasDiscoveredPlayer({
      side: 'America',
      discoveredBySide: 'China',
    })).toBe(false);
  });

  it('evaluates skirmish special power ready condition with cached retry frames', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SuperweaponBuilding', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SuperWeapon', {
            SpecialPowerTemplate: 'SuperweaponParticleCannon',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SuperweaponParticleCannon', { ReloadTime: 6000 }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('SuperweaponBuilding', 100, 100)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    // ReloadTime 6000ms => power is not ready on frame 0.
    expect(logic.evaluateScriptSkirmishSpecialPowerIsReady({
      side: 'America',
      specialPowerName: 'SuperweaponParticleCannon',
      conditionCacheId: 'sp-ready',
    })).toBe(false);

    for (let i = 0; i < 181; i += 1) {
      logic.update(1 / 30);
    }

    expect(logic.evaluateScriptSkirmishSpecialPowerIsReady({
      side: 'America',
      specialPowerName: 'SuperweaponParticleCannon',
      conditionCacheId: 'sp-ready',
    })).toBe(true);
  });

  it('returns false forever for unknown skirmish special power names', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CommandCenter', 50, 50)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    expect(logic.evaluateScriptSkirmishSpecialPowerIsReady({
      side: 'America',
      specialPowerName: 'MissingPower',
      conditionCacheId: 'sp-missing',
    })).toBe(false);

    for (let i = 0; i < 60; i += 1) {
      logic.update(1 / 30);
    }

    expect(logic.evaluateScriptSkirmishSpecialPowerIsReady({
      side: 'America',
      specialPowerName: 'MissingPower',
      conditionCacheId: 'sp-missing',
    })).toBe(false);
  });

  it('evaluates skirmish command-button readiness for special-power buttons', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SuperweaponA', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SuperWeapon', {
            SpecialPowerTemplate: 'SuperweaponParticleCannon',
          }),
        ]),
        makeObjectDef('SuperweaponB', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1000, InitialHealth: 1000 }),
          makeBlock('Behavior', 'SpecialPowerCreate ModuleTag_SPC', {}),
          makeBlock('Behavior', 'OCLSpecialPower ModuleTag_SuperWeapon', {
            SpecialPowerTemplate: 'SuperweaponParticleCannon',
          }),
        ]),
      ],
      specialPowers: [
        makeSpecialPowerDef('SuperweaponParticleCannon', { ReloadTime: 0 }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_ParticleCannon', {
          Command: 'SPECIAL_POWER',
          SpecialPower: 'SuperweaponParticleCannon',
        }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SuperweaponA', 30, 30),
        makeMapObject('SuperweaponB', 40, 30),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string> }>;
    };
    privateApi.spawnedEntities.get(2)!.objectStatusFlags.add('DISABLED_EMP');

    expect(logic.evaluateScriptSkirmishCommandButtonIsReady({
      side: 'America',
      commandButtonName: 'Command_ParticleCannon',
      allReady: true,
    })).toBe(false);
    expect(logic.evaluateScriptSkirmishCommandButtonIsReady({
      side: 'America',
      commandButtonName: 'Command_ParticleCannon',
      allReady: false,
    })).toBe(true);

    privateApi.spawnedEntities.get(2)!.objectStatusFlags.delete('DISABLED_EMP');
    expect(logic.evaluateScriptSkirmishCommandButtonIsReady({
      side: 'America',
      commandButtonName: 'Command_ParticleCannon',
      allReady: true,
    })).toBe(true);
  });

  it('evaluates skirmish command-button readiness for upgrade buttons', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('UpgradeLab', 'America', ['STRUCTURE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 800, InitialHealth: 800 }),
        ], { CommandSet: 'CommandSet_UpgradeLab' }),
      ],
      upgrades: [
        makeUpgradeDef('Upgrade_A', { BuildCost: 500, Type: 'PLAYER' }),
      ],
      commandButtons: [
        makeCommandButtonDef('Command_UpgradeA', {
          Command: 'PLAYER_UPGRADE',
          Upgrade: 'Upgrade_A',
        }),
      ],
      commandSets: [
        makeCommandSetDef('CommandSet_UpgradeLab', { '1': 'Command_UpgradeA' }),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('UpgradeLab', 20, 20)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setSideCredits('America', 0);
    expect(logic.evaluateScriptSkirmishCommandButtonIsReady({
      side: 'America',
      commandButtonName: 'Command_UpgradeA',
      allReady: false,
    })).toBe(false);

    logic.setSideCredits('America', 1000);
    expect(logic.evaluateScriptSkirmishCommandButtonIsReady({
      side: 'America',
      commandButtonName: 'Command_UpgradeA',
      allReady: false,
    })).toBe(true);
  });

  it('evaluates skirmish value-in-area and tech-building distance conditions', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('AmericanTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 300, InitialHealth: 300 }),
        ], { BuildCost: 700 }),
        makeObjectDef('AmericanInfantry', 'America', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ], { BuildCost: 300 }),
        makeObjectDef('AlliedTechBuilding', 'China', ['STRUCTURE', 'TECH_BUILDING'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('AmericanTank', 8, 8),
      makeMapObject('AmericanInfantry', 10, 10),
      makeMapObject('AlliedTechBuilding', 40, 40),
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'StagingArea',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 0, y: 0, z: 0 },
        { x: 20, y: 0, z: 0 },
        { x: 20, y: 20, z: 0 },
        { x: 0, y: 20, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    logic.setTeamRelationship('America', 'China', 2);

    expect(logic.evaluateScriptSkirmishValueInArea({
      side: 'America',
      comparison: 'EQUAL',
      money: 1000,
      triggerName: 'StagingArea',
      conditionCacheId: 'value-area',
    })).toBe(true);

    expect(logic.evaluateScriptSkirmishPlayerTechBuildingWithinDistancePerimeter({
      side: 'America',
      distance: 60,
      triggerName: 'StagingArea',
      conditionCacheId: 'tech-dist',
    })).toBe(true);
  });

  it('evaluates skirmish supplies-within-distance-perimeter against non-enemy warehouses', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('FriendlyWarehouse', 'America', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 5,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 900, InitialHealth: 900 }),
        ]),
        makeObjectDef('NeutralWarehouse', 'Civilian', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 6,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 900, InitialHealth: 900 }),
        ]),
        makeObjectDef('EnemyWarehouse', 'China', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 20,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 900, InitialHealth: 900 }),
        ]),
      ],
    });

    const map = makeMap([
      makeMapObject('FriendlyWarehouse', 10, 10),
      makeMapObject('NeutralWarehouse', 18, 10),
      makeMapObject('EnemyWarehouse', 22, 10),
    ], 128, 128);
    map.triggers = [{
      id: 1,
      name: 'SupplyProbe',
      isWaterArea: false,
      isRiver: false,
      points: [
        { x: 0, y: 0, z: 0 },
        { x: 20, y: 0, z: 0 },
        { x: 20, y: 20, z: 0 },
        { x: 0, y: 20, z: 0 },
      ],
    }];

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(map, makeRegistry(bundle), makeHeightmap(128, 128));
    logic.setTeamRelationship('America', 'China', 0);

    // Friendly/neutral warehouses: max = 6 * 100 = 600.
    expect(logic.evaluateScriptSkirmishSuppliesWithinDistancePerimeter({
      side: 'America',
      distance: 10,
      triggerName: 'SupplyProbe',
      value: 550,
    })).toBe(true);
    // Enemy warehouse (20 * 100 = 2000) must be excluded.
    expect(logic.evaluateScriptSkirmishSuppliesWithinDistancePerimeter({
      side: 'America',
      distance: 10,
      triggerName: 'SupplyProbe',
      value: 1000,
    })).toBe(false);
  });

  it('evaluates skirmish unowned faction unit comparison and prereq-to-build condition', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('WarFactory', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
        makeObjectDef('AdvancedTank', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 400, InitialHealth: 400 }),
        ], { BuildCost: 1200, Prerequisites: 'WarFactory' }),
        makeObjectDef('NeutralHulkA', 'Civilian', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 200, InitialHealth: 200 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('WarFactory', 10, 10),
        makeMapObject('NeutralHulkA', 20, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    logic.setSidePlayerType('America', 'HUMAN');

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { objectStatusFlags: Set<string>; side?: string }>;
      sidePlayerTypes: Map<string, string>;
    };
    privateApi.spawnedEntities.get(2)!.objectStatusFlags.add('DISABLED_UNMANNED');
    privateApi.spawnedEntities.get(2)!.side = 'Civilian';
    // Keep civilian side as neutral by not registering player type.
    privateApi.sidePlayerTypes.delete('civilian');

    expect(logic.evaluateScriptSkirmishUnownedFactionUnitComparison({
      comparison: 'EQUAL',
      count: 1,
    })).toBe(true);

    expect(logic.evaluateScriptSkirmishPlayerHasPrereqsToBuild({
      side: 'America',
      templateName: 'AdvancedTank',
    })).toBe(true);
  });

  it('evaluates skirmish supply-source-attacked with AI scan gating', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyCenter', 'America', ['STRUCTURE', 'CASH_GENERATOR', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
        makeObjectDef('EnemyAttacker', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyCenter', 10, 10),
        makeMapObject('EnemyAttacker', 20, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    logic.update(1 / 30);
    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    privateApi.applyWeaponDamageAmount(2, privateApi.spawnedEntities.get(1), 25, 'SMALL_ARMS');

    expect(logic.evaluateScriptSkirmishSupplySourceAttacked({
      side: 'America',
    })).toBe(true);
    // Source parity: scan rate gate suppresses repeated positive results until next scan window.
    expect(logic.evaluateScriptSkirmishSupplySourceAttacked({
      side: 'America',
    })).toBe(false);

    for (let i = 0; i < 11; i += 1) {
      logic.update(1 / 30);
    }
    // Last attacked frame is no longer within the 10-frame scan window.
    expect(logic.evaluateScriptSkirmishSupplySourceAttacked({
      side: 'America',
    })).toBe(false);
  });

  it('evaluates skirmish supply-source-safe with AI safety scan and cached polling', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SupplyWarehouse', 'America', ['STRUCTURE', 'SUPPLY_SOURCE'], [
          makeBlock('Behavior', 'SupplyWarehouseDockUpdate ModuleTag_Dock', {
            StartingBoxes: 20,
          }),
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 900, InitialHealth: 900 }),
        ]),
        makeObjectDef('EnemyInfantry', 'China', ['INFANTRY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SupplyWarehouse', 20, 20),
        makeMapObject('EnemyInfantry', 24, 20),
      ], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );
    logic.setSidePlayerType('America', 'COMPUTER');
    logic.setTeamRelationship('America', 'China', 0);
    logic.setTeamRelationship('China', 'America', 0);

    expect(logic.evaluateScriptSkirmishSupplySourceSafe({
      side: 'America',
      minSupplyAmount: 1000,
      conditionCacheId: 'safe-ai',
    })).toBe(false);

    const privateApi = logic as unknown as {
      spawnedEntities: Map<number, { x: number; z: number }>;
    };
    const enemy = privateApi.spawnedEntities.get(2)!;
    enemy.x = 500;
    enemy.z = 500;

    // Source parity: condition only refreshes every 2*LOGICFRAMES_PER_SECOND.
    expect(logic.evaluateScriptSkirmishSupplySourceSafe({
      side: 'America',
      minSupplyAmount: 1000,
      conditionCacheId: 'safe-ai',
    })).toBe(false);

    for (let i = 0; i < 61; i += 1) {
      logic.update(1 / 30);
    }

    expect(logic.evaluateScriptSkirmishSupplySourceSafe({
      side: 'America',
      minSupplyAmount: 1000,
      conditionCacheId: 'safe-ai',
    })).toBe(true);

    logic.setSidePlayerType('America', 'HUMAN');
    expect(logic.evaluateScriptSkirmishSupplySourceSafe({
      side: 'America',
      minSupplyAmount: 99999,
      conditionCacheId: 'safe-human',
    })).toBe(true);
  });

  it('evaluates skirmish start-position condition from explicit side start slot', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('CommandCenter', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 1200, InitialHealth: 1200 }),
        ]),
      ],
    });

    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([makeMapObject('CommandCenter', 10, 10)], 128, 128),
      makeRegistry(bundle),
      makeHeightmap(128, 128),
    );

    expect(logic.setSkirmishPlayerStartPosition('America', 2)).toBe(true);
    expect(logic.getSkirmishPlayerStartPosition('America')).toBe(2);

    expect(logic.evaluateScriptSkirmishStartPosition({
      side: 'America',
      startPosition: 2,
    })).toBe(true);
    expect(logic.evaluateScriptSkirmishStartPosition({
      side: 'America',
      startPosition: 1,
    })).toBe(false);
    expect(logic.evaluateScriptSkirmishStartPosition({
      side: 'China',
      startPosition: 2,
    })).toBe(false);
  });
});

describe('SubdualDamageHelper', () => {
  it('accumulates subdual damage instead of reducing health', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SubdualTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
            SubdualDamageCap: 200,
            SubdualDamageHealRate: 1000,
            SubdualDamageHealAmount: 5,
          }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SubdualTarget', 10, 10),
        makeMapObject('Attacker', 20, 20),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { health: number; currentSubdualDamage: number; objectStatusFlags: Set<string> }>;
    };
    const target = privateApi.spawnedEntities.get(1)!;
    expect(target.health).toBe(100);
    expect(target.currentSubdualDamage).toBe(0);

    // Apply subdual damage  health should NOT change, subdual damage should accumulate.
    privateApi.applyWeaponDamageAmount(2, target, 50, 'SUBDUAL_MISSILE');
    expect(target.health).toBe(100);
    expect(target.currentSubdualDamage).toBe(50);

    // Not yet subdued (50 < 100 maxHealth).
    expect(target.objectStatusFlags.has('DISABLED_SUBDUED')).toBe(false);
  });

  it('sets DISABLED_SUBDUED when subdual damage reaches maxHealth', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SubdualTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
            SubdualDamageCap: 200,
            SubdualDamageHealRate: 1000,
            SubdualDamageHealAmount: 5,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SubdualTarget', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { health: number; maxHealth: number; currentSubdualDamage: number; objectStatusFlags: Set<string> }>;
    };
    const target = privateApi.spawnedEntities.get(1)!;

    // Apply enough subdual damage to subdue (>= maxHealth = 100).
    privateApi.applyWeaponDamageAmount(null, target, 100, 'SUBDUAL_VEHICLE');
    expect(target.health).toBe(100);
    expect(target.currentSubdualDamage).toBe(100);
    expect(target.objectStatusFlags.has('DISABLED_SUBDUED')).toBe(true);
  });

  it('caps subdual damage at SubdualDamageCap', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SubdualTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
            SubdualDamageCap: 150,
            SubdualDamageHealRate: 1000,
            SubdualDamageHealAmount: 5,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SubdualTarget', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { currentSubdualDamage: number }>;
    };
    const target = privateApi.spawnedEntities.get(1)!;

    // Apply 300 subdual damage  should cap at 150.
    privateApi.applyWeaponDamageAmount(null, target, 300, 'SUBDUAL_BUILDING');
    expect(target.currentSubdualDamage).toBe(150);
  });

  it('heals subdual damage over time via SubdualDamageHelper', () => {
    // SubdualDamageHealRate = 100ms = 3 frames, SubdualDamageHealAmount = 20.
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SubdualTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
            SubdualDamageCap: 200,
            SubdualDamageHealRate: 100,
            SubdualDamageHealAmount: 20,
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('SubdualTarget', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { health: number; currentSubdualDamage: number; subdualHealingCountdown: number; objectStatusFlags: Set<string> }>;
    };
    const target = privateApi.spawnedEntities.get(1)!;

    // Apply 120 subdual damage (subdued: 120 >= 100 maxHealth).
    privateApi.applyWeaponDamageAmount(null, target, 120, 'SUBDUAL_UNRESISTABLE');
    expect(target.currentSubdualDamage).toBe(120);
    expect(target.objectStatusFlags.has('DISABLED_SUBDUED')).toBe(true);

    // Tick 3 frames (healRate = 100ms = 3 frames). After countdown expires, heals 20.
    for (let i = 0; i < 3; i++) logic.update(1 / 30);
    expect(target.currentSubdualDamage).toBe(100);
    expect(target.objectStatusFlags.has('DISABLED_SUBDUED')).toBe(true);

    // Another 3 frames  heals 20  currentSubdualDamage = 80 (< maxHealth).
    for (let i = 0; i < 3; i++) logic.update(1 / 30);
    expect(target.currentSubdualDamage).toBe(80);
    expect(target.objectStatusFlags.has('DISABLED_SUBDUED')).toBe(false);

    // Health should never have been reduced.
    expect(target.health).toBe(100);
  });

  it('ignores subdual damage on entities with SubdualDamageCap = 0', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('NoSubdual', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
            // No SubdualDamageCap  defaults to 0.
          }),
        ]),
      ],
    });
    const scene = new THREE.Scene();
    const logic = new GameLogicSubsystem(scene);
    logic.loadMapObjects(
      makeMap([makeMapObject('NoSubdual', 10, 10)]),
      makeRegistry(bundle),
      makeHeightmap(),
    );
    logic.update(0);

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { health: number; currentSubdualDamage: number }>;
    };
    const target = privateApi.spawnedEntities.get(1)!;

    // Subdual damage should be silently ignored.
    privateApi.applyWeaponDamageAmount(null, target, 500, 'SUBDUAL_MISSILE');
    expect(target.health).toBe(100);
    expect(target.currentSubdualDamage).toBe(0);
  });

  it('prefers vehicle/infantry/structure attackers for same-frame subdual retaliation source', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('SubdualTarget', 'America', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 100,
            InitialHealth: 100,
            SubdualDamageCap: 200,
          }),
        ]),
        makeObjectDef('LowPriorityAttacker', 'China', ['AIRCRAFT'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
        makeObjectDef('VehicleAttacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('SubdualTarget', 10, 10),
        makeMapObject('LowPriorityAttacker', 20, 10),
        makeMapObject('VehicleAttacker', 30, 10),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, { lastAttackerEntityId: number | null }>;
    };
    const target = privateApi.spawnedEntities.get(1)!;

    privateApi.applyWeaponDamageAmount(2, target, 10, 'SUBDUAL_MISSILE');
    expect(target.lastAttackerEntityId).toBe(2);

    // Same-frame vehicle hit should override low-priority aircraft source.
    privateApi.applyWeaponDamageAmount(3, target, 10, 'SUBDUAL_MISSILE');
    expect(target.lastAttackerEntityId).toBe(3);

    // Same-frame low-priority hit should not override preferred source.
    privateApi.applyWeaponDamageAmount(2, target, 10, 'SUBDUAL_MISSILE');
    expect(target.lastAttackerEntityId).toBe(3);
  });

  it('emits BASE_UNDER_ATTACK EVA for subdual-only damage on victory structures', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('PowerPlant', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 1000,
            InitialHealth: 1000,
            SubdualDamageCap: 2000,
          }),
        ]),
        makeObjectDef('Microwave', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('PowerPlant', 40, 40),
        makeMapObject('Microwave', 50, 40),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const target = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, target, 50, 'SUBDUAL_MISSILE');

    const evaEvents = logic.drainEvaEvents();
    expect(evaEvents.some((event) => event.type === 'BASE_UNDER_ATTACK' && event.entityId === 1)).toBe(true);
  });

  it('records side attacked-by notifications for subdual-only damage', () => {
    const bundle = makeBundle({
      objects: [
        makeObjectDef('TargetStructure', 'America', ['STRUCTURE', 'MP_COUNT_FOR_VICTORY'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', {
            MaxHealth: 1000,
            InitialHealth: 1000,
            SubdualDamageCap: 2000,
          }),
        ]),
        makeObjectDef('Attacker', 'China', ['VEHICLE'], [
          makeBlock('Body', 'ActiveBody ModuleTag_Body', { MaxHealth: 100, InitialHealth: 100 }),
        ]),
      ],
    });
    const logic = new GameLogicSubsystem(new THREE.Scene());
    logic.loadMapObjects(
      makeMap([
        makeMapObject('TargetStructure', 40, 40),
        makeMapObject('Attacker', 50, 40),
      ]),
      makeRegistry(bundle),
      makeHeightmap(),
    );

    const privateApi = logic as unknown as {
      applyWeaponDamageAmount: (id: number | null, target: unknown, amount: number, type: string) => void;
      spawnedEntities: Map<number, unknown>;
    };
    const target = privateApi.spawnedEntities.get(1)!;
    privateApi.applyWeaponDamageAmount(2, target, 50, 'SUBDUAL_MISSILE');

    const attacked = logic.getSideAttackedByState('America');
    expect(attacked.attackedBySides).toEqual(['china']);
    expect(attacked.attackedFrame).toBe(0);
  });
});
