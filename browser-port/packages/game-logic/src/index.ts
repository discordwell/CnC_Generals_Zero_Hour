/**
 * Game Logic & Entity Bootstrap — phase-1 gameplay scaffolding.
 *
 * Consumes converted map objects, resolves INI metadata, creates simple entity
 * representations, and supports a minimal click-to-select + click-to-move loop.
 */

import * as THREE from 'three';
import type {
  DeterministicGameLogicCrcSectionWriters,
  Subsystem,
} from '@generals/engine';
import { GameRandom, type IniBlock, type IniValue } from '@generals/core';
import {
  IniDataRegistry,
  type ArmorDef,
  type LocomotorDef,
  type SpecialPowerDef,
  type ObjectDef,
  type ScienceDef,
  type UpgradeDef,
  type WeaponBonusEntry,
  type WeaponDef,
} from '@generals/ini-data';
import {
  MAP_XY_FACTOR,
  base64ToUint8Array,
  type HeightmapGrid,
  type MapDataJSON,
  type MapObjectJSON,
} from '@generals/terrain';
import type { InputState } from '@generals/input';
import {
  adjustDamageByArmorSet as adjustDamageByArmorSetImpl,
  computeAttackRetreatTarget as computeAttackRetreatTargetImpl,
  entityHasSneakyTargetingOffset as entityHasSneakyTargetingOffsetImpl,
  recordConsecutiveAttackShot as recordConsecutiveAttackShotImpl,
  rebuildEntityScatterTargets as rebuildEntityScatterTargetsImpl,
  refreshEntitySneakyMissWindow as refreshEntitySneakyMissWindowImpl,
  resetEntityWeaponTimingState as resetEntityWeaponTimingStateImpl,
  resolveEntitySneakyTargetingOffset as resolveEntitySneakyTargetingOffsetImpl,
  resolveProjectileScatterRadiusForCategory as resolveProjectileScatterRadiusForCategoryImpl,
  resolveScaledProjectileTravelSpeed as resolveScaledProjectileTravelSpeedImpl,
  resolveWeaponDelayFrames as resolveWeaponDelayFramesImpl,
  resolveWeaponPreAttackDelayFrames as resolveWeaponPreAttackDelayFramesImpl,
  updateWeaponIdleAutoReload as updateWeaponIdleAutoReloadImpl,
} from './combat-helpers.js';
import { isPassengerAllowedToFireFromContainingObject as isPassengerAllowedToFireFromContainingObjectImpl } from './combat-containment.js';
import {
  applyWeaponDamageEvent as applyWeaponDamageEventImpl,
  type CombatDamageEventContext,
  updatePendingWeaponDamage as updatePendingWeaponDamageImpl,
} from './combat-damage-events.js';
import {
  isAirfieldReservedForProjectileVictim as isAirfieldReservedForProjectileVictimImpl,
  resolveProjectileIncidentalVictimForPointImpact as resolveProjectileIncidentalVictimForPointImpactImpl,
  resolveProjectilePointCollisionRadius as resolveProjectilePointCollisionRadiusImpl,
  shouldProjectileCollideWithEntity as shouldProjectileCollideWithEntityImpl,
} from './combat-damage-resolution.js';
import { updateCombat as updateCombatImpl } from './combat-update.js';
import {
  findPath as findPathImpl,
  updatePathfindGoalCellFromPath as updatePathfindGoalCellFromPathImpl,
  updatePathfindPosCell as updatePathfindPosCellImpl,
} from './navigation-pathfinding.js';
import {
  createDeterministicGameLogicCrcSectionWriters as createDeterministicGameLogicCrcSectionWritersImpl,
} from './deterministic-state.js';
import {
  resolveRenderAssetProfile as resolveRenderAssetProfileImpl,
  shouldPathfindObstacle as shouldPathfindObstacleImpl,
} from './render-profile-helpers.js';
import {
  createRailedTransportRuntimeState as createRailedTransportRuntimeStateImpl,
  createRailedTransportWaypointIndex as createRailedTransportWaypointIndexImpl,
  executeRailedTransportCommand as executeRailedTransportCommandImpl,
  extractRailedTransportProfile as extractRailedTransportProfileImpl,
  type RailedTransportProfile,
  type RailedTransportRuntimeState,
  type RailedTransportWaypointData,
  type RailedTransportWaypointIndex,
  updateRailedTransportEntity as updateRailedTransportEntityImpl,
} from './railed-transport.js';
import {
  clamp,
  coerceStringArray,
  nominalHeightForCategory,
  pointInPolygon,
  readBooleanField,
  readCoord3DField,
  readNumericField,
  readNumericList,
  readNumericListField,
  readStringField,
  readStringList,
  toByte,
} from './ini-readers.js';
import {
  extractProductionPrerequisiteGroups as extractProductionPrerequisiteGroupsImpl,
  resolveBuildableStatus as resolveBuildableStatusImpl,
} from './production-prerequisites.js';
import {
  canExitProducedUnitViaParking as canExitProducedUnitViaParkingImpl,
  hasAvailableParkingSpace as hasAvailableParkingSpaceImpl,
  releaseParkingDoorReservationForProduction as releaseParkingDoorReservationForProductionImpl,
  reserveParkingDoorForQueuedUnit as reserveParkingDoorForQueuedUnitImpl,
  reserveParkingSpaceForProducedUnit as reserveParkingSpaceForProducedUnitImpl,
  shouldReserveParkingDoorWhenQueued as shouldReserveParkingDoorWhenQueuedImpl,
} from './production-parking.js';
import {
  resolveQueueProductionExitPath as resolveQueueProductionExitPathImpl,
  resolveQueueSpawnLocation as resolveQueueSpawnLocationImpl,
  tickQueueExitGate as tickQueueExitGateImpl,
} from './production-spawn.js';
import {
  areEquivalentTemplateNames as areEquivalentTemplateNamesImpl,
  doesTemplateMatchMaxSimultaneousType as doesTemplateMatchMaxSimultaneousTypeImpl,
  isStructureObjectDef as isStructureObjectDefImpl,
  resolveMaxSimultaneousOfType as resolveMaxSimultaneousOfTypeImpl,
  resolveProductionQuantity as resolveProductionQuantityImpl,
} from './production-templates.js';
import {
  findArmorDefByName,
  findCommandButtonDefByName,
  findCommandSetDefByName,
  findObjectDefByName,
  findScienceDefByName,
  findUpgradeDefByName,
  findWeaponDefByName,
  iterAllScienceDefs,
  resolveUpgradeBuildCost,
  resolveUpgradeBuildTimeFrames,
  resolveUpgradeType,
} from './registry-lookups.js';
import {
  canAffordSideCredits as canAffordSideCreditsImpl,
  depositSideCredits as depositSideCreditsImpl,
  withdrawSideCredits as withdrawSideCreditsImpl,
} from './side-credits.js';
import {
  routeIssueSpecialPowerCommand as routeIssueSpecialPowerCommandImpl,
  resolveSharedShortcutSpecialPowerReadyFrame as resolveSharedShortcutSpecialPowerReadyFrameImpl,
  resolveShortcutSpecialPowerSourceEntityReadyFrameBySource as
    resolveShortcutSpecialPowerSourceEntityReadyFrameBySourceImpl,
  setSpecialPowerReadyFrame as setSpecialPowerReadyFrameImpl,
} from './special-power-routing.js';
import {
  DEFAULT_SUPPLY_BOX_VALUE,
  SupplyTruckAIState,
  initializeWarehouseState as initializeWarehouseStateImpl,
  updateSupplyTruck as updateSupplyTruckImpl,
  type SupplyChainContext,
  type SupplyTruckProfile,
  type SupplyTruckState,
  type SupplyWarehouseProfile,
  type SupplyWarehouseState,
} from './supply-chain.js';
import {
  addExperiencePoints as addExperiencePointsImpl,
  applyHealthBonusForLevelChange as applyHealthBonusForLevelChangeImpl,
  createExperienceState as createExperienceStateImpl,
  DEFAULT_VETERANCY_CONFIG,
  getExperienceValue as getExperienceValueImpl,
  LEVEL_ELITE,
  LEVEL_HEROIC,
  LEVEL_REGULAR,
  LEVEL_VETERAN,
  resolveArmorSetFlagsForLevel as resolveArmorSetFlagsForLevelImpl,
  type ExperienceProfile,
  type ExperienceState,
  type VeterancyLevel,
} from './experience.js';
import {
  CELL_CLEAR,
  CELL_FOGGED,
  CELL_SHROUDED,
  createEntityVisionState as createEntityVisionStateImpl,
  FogOfWarGrid,
  updateEntityVision as updateEntityVisionImpl,
  type CellVisibility,
  type EntityVisionState,
} from './fog-of-war.js';
import {
  executeAreaDamage as executeAreaDamageImpl,
  executeCashHack as executeCashHackImpl,
  executeDefector as executeDefectorImpl,
  executeSpyVision as executeSpyVisionImpl,
  executeAreaHeal as executeAreaHealImpl,
  executeEmpPulse as executeEmpPulseImpl,
  resolveEffectCategory as resolveEffectCategoryImpl,
  DEFAULT_AREA_DAMAGE_RADIUS,
  DEFAULT_AREA_DAMAGE_AMOUNT,
  DEFAULT_CASH_HACK_AMOUNT,
  DEFAULT_SPY_VISION_RADIUS,
  DEFAULT_AREA_HEAL_AMOUNT,
  DEFAULT_AREA_HEAL_RADIUS,
  DEFAULT_EMP_RADIUS,
  DEFAULT_EMP_DAMAGE,
  type SpecialPowerEffectContext,
} from './special-power-effects.js';
import {
  createSkirmishAIState as createSkirmishAIStateImpl,
  notifyStructureProduced as notifySkirmishAIStructureProducedImpl,
  updateSkirmishAI as updateSkirmishAIImpl,
  type SkirmishAIContext,
  type SkirmishAIState,
} from './skirmish-ai.js';
import {
  applyCostModifierUpgradeToSide as applyCostModifierUpgradeToSideImpl,
  applyKindOfProductionCostModifiers as applyKindOfProductionCostModifiersImpl,
  applyPowerPlantUpgradeToSide as applyPowerPlantUpgradeToSideImpl,
  applyRadarUpgradeToSide as applyRadarUpgradeToSideImpl,
  extractUpgradeModulesFromBlocks as extractUpgradeModulesFromBlocksImpl,
  removeCostModifierUpgradeFromSide as removeCostModifierUpgradeFromSideImpl,
  removePowerPlantUpgradeFromSide as removePowerPlantUpgradeFromSideImpl,
  removeRadarUpgradeFromSide as removeRadarUpgradeFromSideImpl,
} from './upgrade-modules.js';
import {
  type BeaconDeleteCommand,
  type CancelDozerConstructionCommand,
  type CombatDropCommand,
  type ConstructBuildingCommand,
  type EnterObjectCommand,
  type EntityRelationship,
  type ExecuteRailedTransportCommand,
  type GameLogicCommand,
  type GameLogicConfig,
  type GarrisonBuildingCommand,
  type EnterTransportCommand,
  type HackInternetCommand,
  type RepairBuildingCommand,
  type IssueSpecialPowerCommand,
  type LocalScienceAvailability,
  type MapObjectPlacementSummary,
  type PlaceBeaconCommand,
  type RenderAnimationState,
  type RenderAnimationStateClipCandidates,
  type RenderableEntityState,
  type RenderableObjectCategory,
  type SellCommand,
  type SelectedEntityInfo,
  type ToggleOverchargeCommand,
  type DetonateDemoTrapCommand,
  type ToggleDemoTrapModeCommand,
} from './types.js';

export * from './types.js';

const TEST_CRUSH_ONLY = 0;
const TEST_SQUISH_ONLY = 1;
const TEST_CRUSH_OR_SQUISH = 2;
const RELATIONSHIP_ENEMIES = 0;
const RELATIONSHIP_NEUTRAL = 1;
const RELATIONSHIP_ALLIES = 2;
type RelationshipValue = typeof RELATIONSHIP_ENEMIES | typeof RELATIONSHIP_NEUTRAL | typeof RELATIONSHIP_ALLIES;
type SidePlayerType = 'HUMAN' | 'COMPUTER';
type AttackCommandSource = 'PLAYER' | 'AI' | 'SCRIPT';

/** Reusable empty kindOf set for projectile templates with no kindOf. */
const EMPTY_KINDOF_SET = new Set<string>();

type ObjectCategory = RenderableObjectCategory;

interface VectorXZ {
  x: number;
  z: number;
}

interface NavigationGrid {
  width: number;
  height: number;
  terrainType: Uint8Array;
  blocked: Uint8Array;
  pinched: Uint8Array;
  bridge: Uint8Array;
  bridgePassable: Uint8Array;
  bridgeTransitions: Uint8Array;
  bridgeSegmentByCell: Int32Array;
  zonePassable: Uint8Array;
  zoneBlockWidth: number;
  zoneBlockHeight: number;
  logicalMinX: number;
  logicalMinZ: number;
  logicalMaxX: number;
  logicalMaxZ: number;
}

const PATHFIND_CELL_SIZE = MAP_XY_FACTOR;
const CLIFF_HEIGHT_DELTA = 9.8;
const PATHFIND_ZONE_BLOCK_SIZE = 10;
const NO_ATTACK_DISTANCE = 0;
const ATTACK_MOVE_DISTANCE_FUDGE = 3 * MAP_XY_FACTOR;
const ATTACK_RANGE_CELL_EDGE_FUDGE = PATHFIND_CELL_SIZE * 0.25;
const ATTACK_MIN_RANGE_DISTANCE_SQR_FUDGE = 0.5;
const LOGIC_FRAME_RATE = 30;
const LOGIC_FRAME_MS = 1000 / LOGIC_FRAME_RATE;
const SOURCE_FRAMES_TO_ALLOW_SCAFFOLD = LOGIC_FRAME_RATE * 1.5;
const SOURCE_TOTAL_FRAMES_TO_SELL_OBJECT = LOGIC_FRAME_RATE * 3;
const SOURCE_DEFAULT_SELL_PERCENTAGE = 1.0;
/** Source parity: Object.h CONSTRUCTION_COMPLETE sentinel — indicates fully built. */
const CONSTRUCTION_COMPLETE = -1;
const SOURCE_HACK_FALLBACK_CASH_AMOUNT = 1;
const SOURCE_DEFAULT_MAX_BEACONS_PER_PLAYER = 3;

const NAV_CLEAR = 0;
const NAV_WATER = 1;
const NAV_CLIFF = 2;
const NAV_OBSTACLE = 4;
const NAV_IMPASSABLE = 6;
const NAV_BRIDGE_IMPASSABLE = 7;

const OBJECT_FLAG_BRIDGE_POINT1 = 0x010;
const OBJECT_FLAG_BRIDGE_POINT2 = 0x020;
const SOURCE_DISABLED_SHORTCUT_SPECIAL_POWER_READY_FRAME = 0xffffffff - 10;

const LOCOMOTORSET_NORMAL = 'SET_NORMAL';
const LOCOMOTORSET_NORMAL_UPGRADED = 'SET_NORMAL_UPGRADED';
const LOCOMOTORSET_FREEFALL = 'SET_FREEFALL';
const LOCOMOTORSET_WANDER = 'SET_WANDER';
const LOCOMOTORSET_PANIC = 'SET_PANIC';
const LOCOMOTORSET_TAXIING = 'SET_TAXIING';
const LOCOMOTORSET_SUPERSONIC = 'SET_SUPERSONIC';
const LOCOMOTORSET_SLUGGISH = 'SET_SLUGGISH';
const NO_SURFACES = 0;
const SOURCE_LOCOMOTOR_SET_NAMES = new Set<string>([
  LOCOMOTORSET_NORMAL,
  LOCOMOTORSET_NORMAL_UPGRADED,
  LOCOMOTORSET_FREEFALL,
  LOCOMOTORSET_WANDER,
  LOCOMOTORSET_PANIC,
  LOCOMOTORSET_TAXIING,
  LOCOMOTORSET_SUPERSONIC,
  LOCOMOTORSET_SLUGGISH,
]);
const WEAPON_SET_FLAG_VETERAN = 1 << 0;
const WEAPON_SET_FLAG_ELITE = 1 << 1;
const WEAPON_SET_FLAG_HERO = 1 << 2;
const WEAPON_SET_FLAG_PLAYER_UPGRADE = 1 << 3;
const WEAPON_SET_FLAG_CRATEUPGRADE_ONE = 1 << 4;
const WEAPON_SET_FLAG_CRATEUPGRADE_TWO = 1 << 5;
const WEAPON_SET_FLAG_VEHICLE_HIJACK = 1 << 6;
const WEAPON_SET_FLAG_CARBOMB = 1 << 7;
const WEAPON_SET_FLAG_MINE_CLEARING_DETAIL = 1 << 8;
const WEAPON_AFFECTS_SELF = 0x01;
const WEAPON_AFFECTS_ALLIES = 0x02;
const WEAPON_AFFECTS_ENEMIES = 0x04;
const WEAPON_AFFECTS_NEUTRALS = 0x08;
const WEAPON_KILLS_SELF = 0x10;
const WEAPON_DOESNT_AFFECT_SIMILAR = 0x20;
const WEAPON_DOESNT_AFFECT_AIRBORNE = 0x40;
const WEAPON_AFFECTS_DEFAULT_MASK = WEAPON_AFFECTS_ALLIES | WEAPON_AFFECTS_ENEMIES | WEAPON_AFFECTS_NEUTRALS;
const WEAPON_COLLIDE_ALLIES = 0x0001;
const WEAPON_COLLIDE_ENEMIES = 0x0002;
const WEAPON_COLLIDE_STRUCTURES = 0x0004;
const WEAPON_COLLIDE_SHRUBBERY = 0x0008;
const WEAPON_COLLIDE_PROJECTILE = 0x0010;
const WEAPON_COLLIDE_WALLS = 0x0020;
const WEAPON_COLLIDE_SMALL_MISSILES = 0x0040;
const WEAPON_COLLIDE_BALLISTIC_MISSILES = 0x0080;
const WEAPON_COLLIDE_CONTROLLED_STRUCTURES = 0x0100;
const WEAPON_COLLIDE_DEFAULT_MASK = WEAPON_COLLIDE_STRUCTURES;
// Source parity: WeaponAntiMaskType — weapon targeting category bitmask.
const WEAPON_ANTI_AIRBORNE_VEHICLE = 0x01;
const WEAPON_ANTI_GROUND = 0x02;
const WEAPON_ANTI_PROJECTILE = 0x04;
const WEAPON_ANTI_SMALL_MISSILE = 0x08;
const WEAPON_ANTI_MINE = 0x10;
const WEAPON_ANTI_AIRBORNE_INFANTRY = 0x20;
const WEAPON_ANTI_BALLISTIC_MISSILE = 0x40;
const WEAPON_ANTI_PARACHUTE = 0x80;
const HUGE_DAMAGE_AMOUNT = 1_000_000_000;
// Source parity: Thing::isSignificantlyAboveTerrain — -(3*3)*m_gravity with m_gravity=-1.0.
const SIGNIFICANTLY_ABOVE_TERRAIN_THRESHOLD = 9.0;
const ARMOR_SET_FLAG_VETERAN = 1 << 0;
const ARMOR_SET_FLAG_ELITE = 1 << 1;
const ARMOR_SET_FLAG_HERO = 1 << 2;
const ARMOR_SET_FLAG_PLAYER_UPGRADE = 1 << 3;
const ARMOR_SET_FLAG_WEAK_VERSUS_BASEDEFENSES = 1 << 4;
const ARMOR_SET_FLAG_SECOND_LIFE = 1 << 5;
const ARMOR_SET_FLAG_CRATE_UPGRADE_ONE = 1 << 6;
const ARMOR_SET_FLAG_CRATE_UPGRADE_TWO = 1 << 7;

// Source parity: WeaponBonusConditionType — bitmask flags for active weapon bonus conditions.
const WEAPON_BONUS_GARRISONED       = 1 << 0;
const WEAPON_BONUS_HORDE            = 1 << 1;
const WEAPON_BONUS_CONTINUOUS_FIRE_MEAN = 1 << 2;
const WEAPON_BONUS_CONTINUOUS_FIRE_FAST = 1 << 3;
const WEAPON_BONUS_NATIONALISM      = 1 << 4;
const WEAPON_BONUS_PLAYER_UPGRADE   = 1 << 5;
const WEAPON_BONUS_DRONE_SPOTTING   = 1 << 6;
const WEAPON_BONUS_ENTHUSIASTIC     = 1 << 8;
const WEAPON_BONUS_VETERAN          = 1 << 9;
const WEAPON_BONUS_ELITE            = 1 << 10;
const WEAPON_BONUS_HERO             = 1 << 11;
const WEAPON_BONUS_BOMBARDMENT      = 1 << 12;
const WEAPON_BONUS_HOLDTHELINE      = 1 << 13;
const WEAPON_BONUS_SEARCHANDDESTROY = 1 << 14;
const WEAPON_BONUS_SUBLIMINAL       = 1 << 15;
const WEAPON_BONUS_FAERIE_FIRE      = 1 << 22;
const WEAPON_BONUS_FANATICISM       = 1 << 23;
const WEAPON_BONUS_FRENZY_ONE       = 1 << 24;
const WEAPON_BONUS_FRENZY_TWO       = 1 << 25;
const WEAPON_BONUS_FRENZY_THREE     = 1 << 26;

const WEAPON_BONUS_CONDITION_BY_NAME = new Map<string, number>([
  ['GARRISONED', WEAPON_BONUS_GARRISONED],
  ['HORDE', WEAPON_BONUS_HORDE],
  ['CONTINUOUS_FIRE_MEAN', WEAPON_BONUS_CONTINUOUS_FIRE_MEAN],
  ['CONTINUOUS_FIRE_FAST', WEAPON_BONUS_CONTINUOUS_FIRE_FAST],
  ['NATIONALISM', WEAPON_BONUS_NATIONALISM],
  ['PLAYER_UPGRADE', WEAPON_BONUS_PLAYER_UPGRADE],
  ['DRONE_SPOTTING', WEAPON_BONUS_DRONE_SPOTTING],
  ['ENTHUSIASTIC', WEAPON_BONUS_ENTHUSIASTIC],
  ['VETERAN', WEAPON_BONUS_VETERAN],
  ['ELITE', WEAPON_BONUS_ELITE],
  ['HERO', WEAPON_BONUS_HERO],
  ['BATTLEPLAN_BOMBARDMENT', WEAPON_BONUS_BOMBARDMENT],
  ['BATTLEPLAN_HOLDTHELINE', WEAPON_BONUS_HOLDTHELINE],
  ['BATTLEPLAN_SEARCHANDDESTROY', WEAPON_BONUS_SEARCHANDDESTROY],
  ['SUBLIMINAL', WEAPON_BONUS_SUBLIMINAL],
  ['TARGET_FAERIE_FIRE', WEAPON_BONUS_FAERIE_FIRE],
  ['FANATICISM', WEAPON_BONUS_FANATICISM],
  ['FRENZY_ONE', WEAPON_BONUS_FRENZY_ONE],
  ['FRENZY_TWO', WEAPON_BONUS_FRENZY_TWO],
  ['FRENZY_THREE', WEAPON_BONUS_FRENZY_THREE],
]);

// Source parity: WeaponBonus::Field — bonus field types.
const WEAPON_BONUS_FIELD_DAMAGE = 0;
const WEAPON_BONUS_FIELD_RADIUS = 1;
const WEAPON_BONUS_FIELD_RANGE = 2;
const WEAPON_BONUS_FIELD_RATE_OF_FIRE = 3;
const WEAPON_BONUS_FIELD_PRE_ATTACK = 4;

const WEAPON_BONUS_FIELD_BY_NAME = new Map<string, number>([
  ['DAMAGE', WEAPON_BONUS_FIELD_DAMAGE],
  ['RADIUS', WEAPON_BONUS_FIELD_RADIUS],
  ['RANGE', WEAPON_BONUS_FIELD_RANGE],
  ['RATE_OF_FIRE', WEAPON_BONUS_FIELD_RATE_OF_FIRE],
  ['PRE_ATTACK', WEAPON_BONUS_FIELD_PRE_ATTACK],
]);

/**
 * Source parity: WeaponBonusSet — lookup table mapping (conditionBit, fieldIndex) to multiplier.
 * Each entry stores the multiplier for one condition+field combination.
 * Global set comes from GameData.ini; per-weapon overrides come from weapon INI.
 */
interface WeaponBonusTable {
  /** Sparse map: key = `${conditionBit}:${fieldIndex}`, value = multiplier. */
  entries: Map<string, number>;
}

function buildWeaponBonusTable(bonusEntries: readonly WeaponBonusEntry[]): WeaponBonusTable {
  const entries = new Map<string, number>();
  for (const entry of bonusEntries) {
    const conditionBit = WEAPON_BONUS_CONDITION_BY_NAME.get(entry.condition);
    const fieldIndex = WEAPON_BONUS_FIELD_BY_NAME.get(entry.field);
    if (conditionBit === undefined || fieldIndex === undefined) continue;
    entries.set(`${conditionBit}:${fieldIndex}`, entry.multiplier);
  }
  return { entries };
}

/**
 * Source parity: Weapon::computeBonus() + WeaponBonusSet::appendBonuses() — compute
 * the effective weapon bonus multiplier for a given field by accumulating all active
 * condition bonuses. Bonuses are ADDITIVE: result = 1.0 + sum(bonus - 1.0).
 */
function computeWeaponBonusField(
  table: WeaponBonusTable,
  conditionFlags: number,
  fieldIndex: number,
): number {
  if (conditionFlags === 0) return 1.0;
  let result = 1.0;
  for (const [key, multiplier] of table.entries) {
    const colonIdx = key.indexOf(':');
    const bit = Number(key.slice(0, colonIdx));
    const field = Number(key.slice(colonIdx + 1));
    if (field !== fieldIndex) continue;
    if ((conditionFlags & bit) === 0) continue;
    // Source parity: WeaponBonus::appendBonuses — additive accumulation.
    result += multiplier - 1.0;
  }
  return result;
}

const WEAPON_SET_FLAG_MASK_BY_NAME = new Map<string, number>([
  ['VETERAN', WEAPON_SET_FLAG_VETERAN],
  ['ELITE', WEAPON_SET_FLAG_ELITE],
  ['HERO', WEAPON_SET_FLAG_HERO],
  ['PLAYER_UPGRADE', WEAPON_SET_FLAG_PLAYER_UPGRADE],
  ['CRATEUPGRADE_ONE', WEAPON_SET_FLAG_CRATEUPGRADE_ONE],
  ['CRATEUPGRADE_TWO', WEAPON_SET_FLAG_CRATEUPGRADE_TWO],
  ['VEHICLE_HIJACK', WEAPON_SET_FLAG_VEHICLE_HIJACK],
  ['CARBOMB', WEAPON_SET_FLAG_CARBOMB],
  ['MINE_CLEARING_DETAIL', WEAPON_SET_FLAG_MINE_CLEARING_DETAIL],
]);

const WEAPON_AFFECTS_MASK_BY_NAME = new Map<string, number>([
  ['SELF', WEAPON_AFFECTS_SELF],
  ['ALLIES', WEAPON_AFFECTS_ALLIES],
  ['ENEMIES', WEAPON_AFFECTS_ENEMIES],
  ['NEUTRALS', WEAPON_AFFECTS_NEUTRALS],
  ['SUICIDE', WEAPON_KILLS_SELF],
  ['NOT_SIMILAR', WEAPON_DOESNT_AFFECT_SIMILAR],
  ['NOT_AIRBORNE', WEAPON_DOESNT_AFFECT_AIRBORNE],
]);
const WEAPON_COLLIDE_MASK_BY_NAME = new Map<string, number>([
  ['ALLIES', WEAPON_COLLIDE_ALLIES],
  ['ENEMIES', WEAPON_COLLIDE_ENEMIES],
  ['STRUCTURES', WEAPON_COLLIDE_STRUCTURES],
  ['SHRUBBERY', WEAPON_COLLIDE_SHRUBBERY],
  ['PROJECTILES', WEAPON_COLLIDE_PROJECTILE],
  ['WALLS', WEAPON_COLLIDE_WALLS],
  ['SMALL_MISSILES', WEAPON_COLLIDE_SMALL_MISSILES],
  ['BALLISTIC_MISSILES', WEAPON_COLLIDE_BALLISTIC_MISSILES],
  ['CONTROLLED_STRUCTURES', WEAPON_COLLIDE_CONTROLLED_STRUCTURES],
]);

const ARMOR_SET_FLAG_MASK_BY_NAME = new Map<string, number>([
  ['VETERAN', ARMOR_SET_FLAG_VETERAN],
  ['ELITE', ARMOR_SET_FLAG_ELITE],
  ['HERO', ARMOR_SET_FLAG_HERO],
  ['PLAYER_UPGRADE', ARMOR_SET_FLAG_PLAYER_UPGRADE],
  ['WEAK_VERSUS_BASEDEFENSES', ARMOR_SET_FLAG_WEAK_VERSUS_BASEDEFENSES],
  ['SECOND_LIFE', ARMOR_SET_FLAG_SECOND_LIFE],
  ['CRATE_UPGRADE_ONE', ARMOR_SET_FLAG_CRATE_UPGRADE_ONE],
  ['CRATE_UPGRADE_TWO', ARMOR_SET_FLAG_CRATE_UPGRADE_TWO],
]);

const SOURCE_DAMAGE_TYPE_NAMES: readonly string[] = [
  'EXPLOSION',
  'CRUSH',
  'ARMOR_PIERCING',
  'SMALL_ARMS',
  'GATTLING',
  'RADIATION',
  'FLAME',
  'LASER',
  'SNIPER',
  'POISON',
  'HEALING',
  'UNRESISTABLE',
  'WATER',
  'DEPLOY',
  'SURRENDER',
  'HACK',
  'KILL_PILOT',
  'PENALTY',
  'FALLING',
  'MELEE',
  'DISARM',
  'HAZARD_CLEANUP',
  'PARTICLE_BEAM',
  'TOPPLING',
  'INFANTRY_MISSILE',
  'AURORA_BOMB',
  'LAND_MINE',
  'JET_MISSILES',
  'STEALTHJET_MISSILES',
  'MOLOTOV_COCKTAIL',
  'COMANCHE_VULCAN',
  'FLESHY_SNIPER',
];
const SOURCE_DAMAGE_TYPE_NAME_SET = new Set<string>(SOURCE_DAMAGE_TYPE_NAMES);

// ---------------------------------------------------------------------------
// Source parity: BezierSegment — cubic Bezier evaluation and arc length
// approximation for DumbProjectileBehavior flight paths.
// ---------------------------------------------------------------------------

/** Evaluate a cubic Bezier curve at parameter t (0..1). */
function evaluateCubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number {
  const oneMinusT = 1 - t;
  const oneMinusT2 = oneMinusT * oneMinusT;
  const t2 = t * t;
  return (
    oneMinusT2 * oneMinusT * p0 +
    3 * oneMinusT2 * t * p1 +
    3 * oneMinusT * t2 * p2 +
    t2 * t * p3
  );
}

/**
 * Source parity: BezierSegment::getApproximateLength() — recursive subdivision
 * arc length approximation. Compares chord length vs control polygon length;
 * subdivides at midpoint when the difference exceeds tolerance.
 */
function approximateCubicBezierArcLength3D(
  p0x: number, p0y: number, p0z: number,
  p1x: number, p1y: number, p1z: number,
  p2x: number, p2y: number, p2z: number,
  p3x: number, p3y: number, p3z: number,
  tolerance: number,
  depth: number,
): number {
  const chordLength = Math.hypot(p3x - p0x, p3y - p0y, p3z - p0z);
  const polyLength =
    Math.hypot(p1x - p0x, p1y - p0y, p1z - p0z) +
    Math.hypot(p2x - p1x, p2y - p1y, p2z - p1z) +
    Math.hypot(p3x - p2x, p3y - p2y, p3z - p2z);

  if (depth > 10 || (polyLength - chordLength) <= tolerance) {
    return (chordLength + polyLength) / 2;
  }

  // de Casteljau subdivision at t=0.5
  const m01x = (p0x + p1x) * 0.5, m01y = (p0y + p1y) * 0.5, m01z = (p0z + p1z) * 0.5;
  const m12x = (p1x + p2x) * 0.5, m12y = (p1y + p2y) * 0.5, m12z = (p1z + p2z) * 0.5;
  const m23x = (p2x + p3x) * 0.5, m23y = (p2y + p3y) * 0.5, m23z = (p2z + p3z) * 0.5;
  const m012x = (m01x + m12x) * 0.5, m012y = (m01y + m12y) * 0.5, m012z = (m01z + m12z) * 0.5;
  const m123x = (m12x + m23x) * 0.5, m123y = (m12y + m23y) * 0.5, m123z = (m12z + m23z) * 0.5;
  const mx = (m012x + m123x) * 0.5, my = (m012y + m123y) * 0.5, mz = (m012z + m123z) * 0.5;

  return (
    approximateCubicBezierArcLength3D(p0x, p0y, p0z, m01x, m01y, m01z, m012x, m012y, m012z, mx, my, mz, tolerance, depth + 1) +
    approximateCubicBezierArcLength3D(mx, my, mz, m123x, m123y, m123z, m23x, m23y, m23z, p3x, p3y, p3z, tolerance, depth + 1)
  );
}

/**
 * Source parity: PartitionManager::estimateTerrainExtremesAlongLine() — sample
 * terrain height at N points along a line segment to find the highest point.
 */
function estimateHighestTerrainAlongLine(
  heightmap: HeightmapGrid,
  startX: number, startZ: number,
  endX: number, endZ: number,
  numSamples: number,
): number {
  let maxHeight = heightmap.getInterpolatedHeight(startX, startZ);
  maxHeight = Math.max(maxHeight, heightmap.getInterpolatedHeight(endX, endZ));
  for (let i = 1; i < numSamples - 1; i++) {
    const t = i / (numSamples - 1);
    const x = startX + (endX - startX) * t;
    const z = startZ + (endZ - startZ) * t;
    maxHeight = Math.max(maxHeight, heightmap.getInterpolatedHeight(x, z));
  }
  return maxHeight;
}

/** Number of samples used for terrain height estimation along projectile paths. */
const BEZIER_TERRAIN_SAMPLE_COUNT = 10;
/** Tolerance for Bezier arc length approximation. */
const BEZIER_ARC_LENGTH_TOLERANCE = 1.0;

/**
 * Source parity: AIUpdateModuleData::m_moodAttackCheckRate — default interval
 * (in logic frames) between idle auto-target scans. C++ uses 2 seconds (60 frames).
 */
const AUTO_TARGET_SCAN_RATE_FRAMES = LOGIC_FRAME_RATE * 2;

/**
 * Source parity: TAiData guard parameters. Real values come from AIData.ini;
 * these defaults match the typical Zero Hour configuration.
 */
const GUARD_ENEMY_SCAN_RATE_FRAMES = Math.trunc(LOGIC_FRAME_RATE / 2); // 15 frames = 0.5s
const GUARD_ENEMY_RETURN_SCAN_RATE_FRAMES = LOGIC_FRAME_RATE; // 30 frames = 1s
const GUARD_INNER_MODIFIER_HUMAN = 1.0;
const GUARD_OUTER_MODIFIER_HUMAN = 1.5;
const GUARD_INNER_MODIFIER_AI = 1.0;
const GUARD_OUTER_MODIFIER_AI = 2.0;
const GUARD_CHASE_UNIT_FRAMES = LOGIC_FRAME_RATE * 10; // 300 frames = 10s

/**
 * Source parity: AIGuardMachine state IDs.
 * IDLE: sitting at guard point, periodically scanning for enemies.
 * PURSUING: actively chasing/fighting an enemy within the outer range.
 * RETURNING: walking back to the guard point after losing/killing target.
 */
type GuardState = 'NONE' | 'IDLE' | 'PURSUING' | 'RETURNING';

interface LocomotorSetProfile {
  surfaceMask: number;
  downhillOnly: boolean;
  movementSpeed: number;
  /**
   * Source parity: Locomotor::m_minSpeed — minimum speed when unit is moving.
   * Units that have started moving won't go below this speed.
   */
  minSpeed: number;
  /**
   * Source parity: Locomotor::m_acceleration — how quickly the unit reaches top speed.
   * In world-units/second^2. 0 = instant acceleration.
   */
  acceleration: number;
  /**
   * Source parity: Locomotor::m_braking — how quickly the unit decelerates.
   * In world-units/second^2. BIGNUM/0 = instant braking.
   */
  braking: number;
  /**
   * Source parity: Locomotor::m_turnRate — radians/second the unit can turn.
   * 0 = instant rotation (current behavior fallback).
   */
  turnRate: number;
  /**
   * Source parity: Locomotor::m_appearance — affects movement pattern.
   * E.g., 'TREADS', 'FOUR_WHEELS', 'TWO_LEGS', 'HOVER', 'WINGS', 'THRUST'.
   */
  appearance: string;
}

interface BridgeSegmentState {
  passable: boolean;
  cellIndices: number[];
  transitionIndices: number[];
}

type ObstacleGeometryShape = 'box' | 'circle';

interface ObstacleGeometry {
  shape: ObstacleGeometryShape;
  majorRadius: number;
  minorRadius: number;
  /** Source parity: GeometryInfo::m_height — used for bounding sphere radius computation. */
  height: number;
}

interface CliffStateBits {
  data: Uint8Array;
  stride: number;
}

type MaxHealthChangeTypeName = 'SAME_CURRENTHEALTH' | 'PRESERVE_RATIO' | 'ADD_CURRENT_HEALTH_TOO';
type WeaponPrefireTypeName = 'PER_SHOT' | 'PER_ATTACK' | 'PER_CLIP';

interface AttackWeaponProfile {
  name: string;
  primaryDamage: number;
  secondaryDamage: number;
  primaryDamageRadius: number;
  secondaryDamageRadius: number;
  scatterTargetScalar: number;
  scatterTargets: Array<{ x: number; z: number }>;
  scatterRadius: number;
  scatterRadiusVsInfantry: number;
  radiusDamageAngle: number;
  damageType: string;
  /** Source parity: WeaponTemplate::m_deathType — per-weapon death type (default NORMAL). */
  deathType: string;
  damageDealtAtSelfPosition: boolean;
  radiusDamageAffectsMask: number;
  projectileCollideMask: number;
  weaponSpeed: number;
  minWeaponSpeed: number;
  scaleWeaponSpeed: boolean;
  projectileObjectName: string | null;
  attackRange: number;
  unmodifiedAttackRange: number;
  minAttackRange: number;
  continueAttackRange: number;
  clipSize: number;
  clipReloadFrames: number;
  autoReloadWhenIdleFrames: number;
  preAttackDelayFrames: number;
  preAttackType: WeaponPrefireTypeName;
  minDelayFrames: number;
  maxDelayFrames: number;
  antiMask: number;
  /** Source parity: ContinuousFireOne — consecutive shots needed for MEAN state. 0 = disabled. */
  continuousFireOneShotsNeeded: number;
  /** Source parity: ContinuousFireTwo — consecutive shots needed for FAST state. 0 = disabled. */
  continuousFireTwoShotsNeeded: number;
  /** Source parity: ContinuousFireCoast — coast frames after last possible shot before cooldown starts. */
  continuousFireCoastFrames: number;
  /** Source parity: per-weapon RATE_OF_FIRE bonus multiplier for CONTINUOUS_FIRE_MEAN condition. */
  continuousFireMeanRateOfFire: number;
  /** Source parity: per-weapon RATE_OF_FIRE bonus multiplier for CONTINUOUS_FIRE_FAST condition. */
  continuousFireFastRateOfFire: number;
  /** Source parity: LaserName — non-null if this weapon spawns a laser beam. */
  laserName: string | null;
  /**
   * Source parity: DumbProjectileBehavior Bezier arc parameters.
   * Parsed from the projectile object template's DumbProjectileBehavior module.
   */
  projectileArcFirstHeight: number;
  projectileArcSecondHeight: number;
  projectileArcFirstPercentIndent: number;
  projectileArcSecondPercentIndent: number;
  /** Source parity: Weapon::m_leechRangeWeapon — unlimited range after first shot connects. */
  leechRangeWeapon: boolean;
}

interface WeaponTemplateSetProfile {
  conditionsMask: number;
  weaponNamesBySlot: [string | null, string | null, string | null];
}

interface ArmorTemplateSetProfile {
  conditionsMask: number;
  armorName: string | null;
}

interface SpecialPowerModuleProfile {
  specialPowerTemplateName: string;
  moduleType: string;
  updateModuleStartsAttack: boolean;
  startsPaused: boolean;
  /**
   * Source parity: CashHackSpecialPowerModuleData::m_defaultAmountToSteal.
   * INI field: MoneyAmount. Default 0.
   */
  cashHackMoneyAmount: number;
  /**
   * Source parity: CashBountyPowerModuleData::m_defaultBounty.
   * INI field: Bounty (parsed as percent → real). Default 0.
   */
  cashBountyPercent: number;
  /**
   * Source parity: SpyVisionSpecialPowerModuleData::m_baseDurationInFrames.
   * INI field: BaseDuration. Raw value in ms (C++ converts to frames). Default 0.
   */
  spyVisionBaseDurationMs: number;
  /**
   * Source parity: FireWeaponPowerModuleData::m_maxShotsToFire.
   * INI field: MaxShotsToFire. Default 1.
   */
  fireWeaponMaxShots: number;
  /**
   * Source parity: CleanupAreaPowerModuleData::m_cleanupMoveRange.
   * INI field: MaxMoveDistanceFromLocation. Default 0.
   */
  cleanupMoveRange: number;
  /**
   * Source parity: OCLSpecialPowerModuleData::m_defaultOCL.
   * INI field: OCL. The ObjectCreationList to execute when the power fires.
   */
  oclName: string;
  /**
   * Source parity: OCLSpecialPower / area-damage fallback radius.
   * INI field: Radius. Default 0 (use fallback constant).
   */
  areaDamageRadius: number;
  /**
   * Source parity: Area-damage fallback damage amount.
   * INI field: Damage. Default 0 (use fallback constant).
   */
  areaDamageAmount: number;
  /**
   * Source parity: CleanupAreaPower / Emergency Repair heal amount.
   * INI field: HealAmount. Default 0 (use fallback constant).
   */
  areaHealAmount: number;
  /**
   * Source parity: Heal effect radius.
   * INI field: HealRange. Default 0 (use fallback constant).
   */
  areaHealRadius: number;
}

interface SpecialPowerDispatchProfile {
  specialPowerTemplateName: string;
  moduleType: string;
  dispatchType: 'NO_TARGET' | 'POSITION' | 'OBJECT';
  commandOption: number;
  commandButtonId: string;
  targetEntityId: number | null;
  targetX: number | null;
  targetZ: number | null;
}

/**
 * Source parity: SpecialAbilityUpdate — unit-based special abilities that require
 * approach, pack/unpack animations, and preparation before triggering.
 * Used by: Black Lotus, Hackers, Colonel Burton, Jarmen Kell, Infantry capture, etc.
 */
type SpecialAbilityPackingState = 'NONE' | 'PACKING' | 'UNPACKING' | 'PACKED' | 'UNPACKED';

interface SpecialAbilityProfile {
  specialPowerTemplateName: string;
  startAbilityRange: number;
  abilityAbortRange: number;
  preparationFrames: number;
  persistentPrepFrames: number;
  packTimeFrames: number;
  unpackTimeFrames: number;
  packUnpackVariationFactor: number;
  skipPackingWithNoTarget: boolean;
  effectDurationFrames: number;
  fleeRangeAfterCompletion: number;
  flipOwnerAfterPacking: boolean;
  flipOwnerAfterUnpacking: boolean;
  loseStealthOnTrigger: boolean;
  preTriggerUnstealthFrames: number;
  awardXPForTriggering: number;
}

interface SpecialAbilityRuntimeState {
  active: boolean;
  packingState: SpecialAbilityPackingState;
  prepFrames: number;
  animFrames: number;
  targetEntityId: number | null;
  targetX: number | null;
  targetZ: number | null;
  withinStartAbilityRange: boolean;
  noTargetCommand: boolean;
  /** Track persistent trigger count for repeating abilities. */
  persistentTriggerCount: number;
}

interface UpgradeModuleProfile {
  id: string;
  moduleType:
    | 'LOCOMOTORSETUPGRADE'
    | 'MAXHEALTHUPGRADE'
    | 'ARMORUPGRADE'
    | 'WEAPONSETUPGRADE'
    | 'COMMANDSETUPGRADE'
    | 'STATUSBITSUPGRADE'
    | 'STEALTHUPGRADE'
    | 'WEAPONBONUSUPGRADE'
    | 'COSTMODIFIERUPGRADE'
    | 'GRANTSCIENCEUPGRADE'
    | 'POWERPLANTUPGRADE'
    | 'RADARUPGRADE'
    | 'PASSENGERSFIREUPGRADE'
    | 'UNPAUSESPECIALPOWERUPGRADE'
    | 'EXPERIENCESCALARUPGRADE'
    | 'MODELCONDITIONUPGRADE'
    | 'OBJECTCREATIONUPGRADE'
    | 'ACTIVESHROUDUPGRADE'
    | 'REPLACEOBJECTUPGRADE';
  triggeredBy: Set<string>;
  conflictsWith: Set<string>;
  removesUpgrades: Set<string>;
  requiresAllTriggers: boolean;
  addMaxHealth: number;
  maxHealthChangeType: MaxHealthChangeTypeName;
  sourceUpgradeName: string | null;
  statusToSet: Set<string>;
  statusToClear: Set<string>;
  commandSetName: string | null;
  commandSetAltName: string | null;
  commandSetAltTriggerUpgrade: string | null;
  effectKindOf: Set<string>;
  effectPercent: number;
  grantScienceName: string;
  radarIsDisableProof: boolean;
  specialPowerTemplateName: string;
  addXPScalar: number;
  conditionFlag: string;
  upgradeObjectOCLName: string;
  newShroudRange: number;
  replaceObjectName: string;
}

interface KindOfProductionCostModifier {
  kindOf: Set<string>;
  multiplier: number;
  refCount: number;
}

interface SideRadarState {
  radarCount: number;
  disableProofRadarCount: number;
  /** Source parity: Player::m_radarDisabled — set during power brown-out. */
  radarDisabled: boolean;
}

interface SidePowerState {
  powerBonus: number;
  /** Total energy production from all alive buildings (positive energyBonus values). */
  energyProduction: number;
  /** Total energy consumption from all alive buildings (absolute of negative energyBonus values). */
  energyConsumption: number;
  /** Source parity: Player::m_energy — tracks whether side is currently in brown-out. */
  brownedOut: boolean;
  /** Source parity: SabotagePowerPlantCrateCollide — forced brownout until this frame. */
  powerSabotagedUntilFrame: number;
}

/**
 * Source parity: Player.h — rank level progression from kills.
 * Rank thresholds and purchase point grants from Rank.ini.
 */
interface SideRankState {
  /** Current rank level (1-based, starts at 1). */
  rankLevel: number;
  /** Cumulative skill points (from kills). */
  skillPoints: number;
  /** Unspent science purchase (General's) points. */
  sciencePurchasePoints: number;
}

/**
 * Source parity: Rank.ini — defines XP thresholds and purchase point grants per rank.
 * Standard C&C Generals: Zero Hour rank values.
 */
interface RankInfoEntry {
  skillPointsNeeded: number;
  sciencePurchasePointsGranted: number;
}

/** Default Generals/ZH rank table (8 ranks). */
const RANK_TABLE: readonly RankInfoEntry[] = [
  { skillPointsNeeded: 0, sciencePurchasePointsGranted: 1 },     // Rank 1 (start)
  { skillPointsNeeded: 200, sciencePurchasePointsGranted: 0 },   // Rank 2
  { skillPointsNeeded: 500, sciencePurchasePointsGranted: 1 },   // Rank 3
  { skillPointsNeeded: 800, sciencePurchasePointsGranted: 0 },   // Rank 4
  { skillPointsNeeded: 1500, sciencePurchasePointsGranted: 1 },  // Rank 5
  { skillPointsNeeded: 3000, sciencePurchasePointsGranted: 0 },  // Rank 6
  { skillPointsNeeded: 5000, sciencePurchasePointsGranted: 0 },  // Rank 7
  { skillPointsNeeded: 8000, sciencePurchasePointsGranted: 1 },  // Rank 8
];

interface ProductionProfile {
  maxQueueEntries: number;
  quantityModifiers: Array<{
    templateName: string;
    quantity: number;
  }>;
}

interface ProductionPrerequisiteGroup {
  objectAlternatives: string[];
  scienceRequirements: string[];
}

interface QueueProductionExitProfile {
  moduleType: 'QUEUE' | 'SUPPLY_CENTER' | 'SPAWN_POINT';
  unitCreatePoint: { x: number; y: number; z: number };
  naturalRallyPoint: { x: number; y: number; z: number } | null;
  exitDelayFrames: number;
  allowAirborneCreation: boolean;
  initialBurst: number;
  spawnPointBoneName: string | null;
}

interface ParkingPlaceProfile {
  totalSpaces: number;
  occupiedSpaceEntityIds: Set<number>;
  reservedProductionIds: Set<number>;
}

type ContainModuleType = 'OPEN' | 'TRANSPORT' | 'OVERLORD' | 'HELIX' | 'GARRISON' | 'TUNNEL' | 'HEAL' | 'INTERNET_HACK';

interface ContainProfile {
  moduleType: ContainModuleType;
  passengersAllowedToFire: boolean;
  passengersAllowedToFireDefault: boolean;
  portableStructureTemplateNames?: string[];
  /** Maximum number of garrisoned units. 0 = not garrisonable. */
  garrisonCapacity: number;
  /** Source parity: ContainMax — maximum number of transport passengers. 0 = unlimited. */
  transportCapacity: number;
  /** Source parity: TunnelContainModuleData::m_framesForFullHeal — frames for 0→100% heal. 0 = no heal. */
  timeForFullHealFrames: number;
  /** Source parity: OpenContainModuleData::m_damagePercentageToUnits — fraction (0-1) of each passenger's
   *  maxHealth applied as UNRESISTABLE damage when container dies. 0 = no damage. Default: 0. */
  damagePercentToUnits: number;
  /** Source parity: OpenContainModuleData::m_isBurnedDeathToUnits — death type for damage-to-contained.
   *  TRUE = BURNED, FALSE = NORMAL. Default: true (C++ default). */
  burnedDeathToUnits: boolean;
}

/**
 * Source parity: TurretAIData — parsed turret module profile controlling weapon slot availability.
 * (GeneralsMD/Code/GameEngine/Include/GameLogic/TurretAI.h)
 */
interface TurretProfile {
  /** Bitmask of weapon slots controlled by this turret (1 << slotIndex). */
  controlledWeaponSlotsMask: number;
  /** Whether this turret starts disabled (from INI InitiallyDisabled). */
  initiallyDisabled: boolean;
  /** Runtime enabled state. Toggled by deploy actions, mode changes, upgrades. */
  enabled: boolean;
  /**
   * Source parity: TurretAIData::m_turnRate — radians per logic frame.
   * C++ INI field "TurretTurnRate" is parsed as angular velocity (degrees/sec → rad/frame).
   * 0 means instant rotation (fallback).
   */
  turnRate: number;
  /** Source parity: TurretAIData::m_naturalTurretAngle — resting angle in radians. */
  naturalAngle: number;
  /** Source parity: TurretAIData::m_firesWhileTurning — can fire before fully aligned. */
  firesWhileTurning: boolean;
  /**
   * Source parity: TurretAIData::m_recenterTime — frames before returning to natural angle
   * after losing target. Default: 2 * LOGIC_FRAME_RATE (60 frames = 2 seconds).
   */
  recenterTimeFrames: number;
}

/** Source parity: TurretAI runtime state per turret per entity. */
interface TurretRuntimeState {
  /** Current turret angle in radians (relative to owner body rotation). */
  currentAngle: number;
  /** Turret AI state machine state. */
  state: 'IDLE' | 'AIM' | 'RECENTER' | 'HOLD';
  /** Frame at which the turret should begin recentering (hold→recenter transition). */
  holdUntilFrame: number;
}

/**
 * Source parity: JetAIUpdate module data — parsed from INI.
 * (GeneralsMD/Code/GameEngine/Source/GameLogic/AI/AIUpdate/JetAIUpdate.cpp)
 */
interface JetAIProfile {
  sneakyOffsetWhenAttacking: number;
  attackersMissPersistFrames: number;
  needsRunway: boolean;
  keepsParkingSpaceWhenAirborne: boolean;
  outOfAmmoDamagePerSecond: number;
  returnToBaseIdleFrames: number;
  minHeight: number;
  parkingOffset: number;
  takeoffPauseFrames: number;
  takeoffDistForMaxLift: number;
  attackLocomotorSet: string;
  attackLocoPersistFrames: number;
  returnLocomotorSet: string;
}

type JetAIState =
  | 'PARKED'
  | 'TAKING_OFF'
  | 'AIRBORNE'
  | 'RETURNING_FOR_LANDING'
  | 'LANDING'
  | 'RELOAD_AMMO'
  | 'CIRCLING_DEAD_AIRFIELD';

interface JetAIRuntimeState {
  state: JetAIState;
  stateEnteredFrame: number;
  allowAirLoco: boolean;
  pendingCommand: { type: 'moveTo'; x: number; z: number } | { type: 'attackEntity'; targetId: number } | null;
  producerX: number;
  producerZ: number;
  returnToBaseFrame: number;
  attackLocoExpireFrame: number;
  useReturnLoco: boolean;
  reloadDoneFrame: number;
  reloadTotalFrames: number;
  circlingNextCheckFrame: number;
  cruiseHeight: number;
}

type AnimationSteeringTurnAnim =
  'CENTER_TO_RIGHT'
  | 'CENTER_TO_LEFT'
  | 'RIGHT_TO_CENTER'
  | 'LEFT_TO_CENTER';

/**
 * Source parity: AnimationSteeringUpdateModuleData.
 * C++ file: AnimationSteeringUpdate.h/cpp.
 */
interface AnimationSteeringProfile {
  transitionFrames: number;
}

interface TensileFormationProfile {
  enabled: boolean;
  crackSound: string;
}

interface TensileFormationLinkState {
  id: number;
  tensorX: number;
  tensorZ: number;
}

interface TensileFormationRuntimeState {
  enabled: boolean;
  linksInited: boolean;
  links: TensileFormationLinkState[];
  inertiaX: number;
  inertiaZ: number;
  motionlessCounter: number;
  life: number;
  lowestSlideElevation: number;
  nextWakeFrame: number;
  done: boolean;
}

/**
 * Source parity: SpawnBehaviorModuleData — spawner module parsed from INI.
 * (GeneralsMD/Code/GameEngine/Include/GameLogic/Module/SpawnBehavior.h)
 */
interface SpawnBehaviorProfile {
  /** How many slaves the spawner maintains. */
  spawnNumber: number;
  /** Frames to wait before replacing a dead slave. */
  spawnReplaceDelayFrames: number;
  /** Template name(s) of what to spawn. Multiple names for cycling. */
  spawnTemplateNames: string[];
  /** Only spawn once, then go dormant. */
  oneShot: boolean;
  /** Slaves die when spawner dies. */
  spawnedRequireSpawner: boolean;
  /** Spawner's health is the average of all slaves' health. */
  aggregateHealth: boolean;
  /** How many to create immediately, ignoring the replace delay. */
  initialBurst: number;
  /** If true, slaves handle their own targeting (not forwarded from master). */
  slavesHaveFreeWill: boolean;
}

/**
 * Source parity: SpawnBehavior runtime state — tracks live slaves and replacement scheduling.
 */
interface SpawnBehaviorState {
  profile: SpawnBehaviorProfile;
  /** ObjectIDs of all currently alive slaves. */
  slaveIds: number[];
  /** Frames at which each pending replacement should occur. */
  replacementFrames: number[];
  /** Index into spawnTemplateNames for cycling. */
  templateNameIndex: number;
  /** True if one-shot spawner has already spawned. */
  oneShotCompleted: boolean;
  /** Source parity: m_initialBurstTimesInited — prevents burst logic from re-firing. */
  initialBurstApplied: boolean;
}

/**
 * Source parity: AI attack state machine sub-states.
 * Maps to AIAttackState sub-machine (AIStates.cpp):
 *   IDLE → no attack in progress
 *   APPROACHING → AIAttackApproachTargetState / AIAttackPursueTargetState
 *   AIMING → AIAttackAimAtTargetState
 *   FIRING → AIAttackFireWeaponState
 */
type AttackSubState = 'IDLE' | 'APPROACHING' | 'AIMING' | 'FIRING';

interface UnitProductionQueueEntry {
  type: 'UNIT';
  templateName: string;
  productionId: number;
  buildCost: number;
  totalProductionFrames: number;
  framesUnderConstruction: number;
  percentComplete: number;
  productionQuantityTotal: number;
  productionQuantityProduced: number;
}

interface UpgradeProductionQueueEntry {
  type: 'UPGRADE';
  upgradeName: string;
  productionId: number;
  buildCost: number;
  totalProductionFrames: number;
  framesUnderConstruction: number;
  percentComplete: number;
  upgradeType: 'PLAYER' | 'OBJECT';
}

type ProductionQueueEntry = UnitProductionQueueEntry | UpgradeProductionQueueEntry;

interface PendingWeaponDamageEvent {
  sourceEntityId: number;
  primaryVictimEntityId: number | null;
  impactX: number;
  impactZ: number;
  executeFrame: number;
  delivery: 'DIRECT' | 'PROJECTILE' | 'LASER';
  weapon: AttackWeaponProfile;
  /** Frame when the projectile was launched. */
  launchFrame: number;
  /** Launch origin in world coordinates. */
  sourceX: number;
  sourceY: number;
  sourceZ: number;
  /** Unique visual id for renderer tracking. */
  projectileVisualId: number;
  /** Cached visual type classification. */
  cachedVisualType: import('./types.js').ProjectileVisualType;
  /** Target Y height for Bezier arc endpoint. */
  impactY: number;
  /**
   * Source parity: DumbProjectileBehavior cubic Bezier arc control point Y heights.
   * P0=(sourceX,sourceY,sourceZ), P3=(impactX,impactY,impactZ).
   * P1 and P2 are placed along the line at firstPercentIndent/secondPercentIndent.
   */
  bezierP1Y: number;
  bezierP2Y: number;
  bezierFirstPercentIndent: number;
  bezierSecondPercentIndent: number;
  /** Whether this projectile uses a Bezier arc (has DumbProjectileBehavior data). */
  hasBezierArc: boolean;
  // ── Source parity: CountermeasuresBehavior missile diversion ──
  /** Frame when this missile diverts to a countermeasure flare (0 = not diverted). */
  countermeasureDivertFrame: number;
  /** If true, this missile has been diverted and deals no damage on detonation. */
  countermeasureNoDamage: boolean;
  /** If true, impact visual should be suppressed (quiet KILL_SELF teardown). */
  suppressImpactVisual: boolean;
  /** Source parity: MissileAIUpdate module profile on the projectile object template. */
  missileAIProfile: MissileAIProfile | null;
  /** Source parity: MissileAIUpdate runtime state for in-flight homing missiles. */
  missileAIState: MissileAIRuntimeState | null;
}

type MissileAIState = 'PRELAUNCH' | 'LAUNCH' | 'IGNITION' | 'ATTACK_NOTURN' | 'ATTACK' | 'KILL' | 'KILL_SELF';

/**
 * Source parity: MissileAIUpdateModuleData — parsed from projectile object INI Behavior.
 * C++ file: MissileAIUpdate.cpp.
 */
interface MissileAIProfile {
  tryToFollowTarget: boolean;
  fuelLifetimeFrames: number;
  ignitionDelayFrames: number;
  initialVelocity: number;
  distanceToTravelBeforeTurning: number;
  distanceToTargetBeforeDiving: number;
  distanceToTargetForLock: number;
  useWeaponSpeed: boolean;
  detonateOnNoFuel: boolean;
  distanceScatterWhenJammed: number;
  detonateCallsKill: boolean;
  killSelfDelayFrames: number;
  /** Locomotor turn rate converted from radians/second to radians/frame. */
  turnRatePerFrame: number;
}

/**
 * Source parity: MissileAIUpdate runtime state.
 * C++ fields mapped from m_state/m_fuelExpirationDate/m_noTurnDistLeft/etc.
 */
interface MissileAIRuntimeState {
  state: MissileAIState;
  stateEnteredFrame: number;
  currentX: number;
  currentY: number;
  currentZ: number;
  prevX: number;
  prevY: number;
  prevZ: number;
  velocityX: number;
  velocityY: number;
  velocityZ: number;
  speed: number;
  armed: boolean;
  fuelExpirationFrame: number;
  noTurnDistanceLeft: number;
  trackingTarget: boolean;
  targetEntityId: number | null;
  targetX: number;
  targetY: number;
  targetZ: number;
  originalTargetX: number;
  originalTargetY: number;
  originalTargetZ: number;
  travelDistance: number;
  totalDistanceEstimate: number;
}

interface SellingEntityState {
  sellFrame: number;
  constructionPercent: number;
}

/**
 * Source parity: TunnelTracker — per-player shared tunnel state.
 * All tunnels belonging to a player share a single passenger list and capacity.
 */
interface TunnelTrackerState {
  /** IDs of all tunnel buildings for this side. */
  tunnelIds: Set<number>;
  /** IDs of all passengers inside the tunnel network. */
  passengerIds: Set<number>;
  /** Frames for full heal (from the TunnelContain module data). */
  timeForFullHealFrames: number;
}

interface HackInternetProfile {
  unpackTimeFrames: number;
  packTimeFrames: number;
  cashUpdateDelayFrames: number;
  cashUpdateDelayFastFrames: number;
  regularCashAmount: number;
  veteranCashAmount: number;
  eliteCashAmount: number;
  heroicCashAmount: number;
}

interface HackInternetRuntimeState {
  cashUpdateDelayFrames: number;
  cashAmountPerCycle: number;
  nextCashFrame: number;
}

interface HackInternetPendingCommandState {
  command: GameLogicCommand;
  executeFrame: number;
}

// ── Source parity: AssaultTransportAIUpdate — auto-deploy/recall passengers ──

interface AssaultTransportProfile {
  /** Health ratio below which members are recalled for healing. 0 = never recall. */
  membersGetHealedAtLifeRatio: number;
}

interface AssaultTransportMember {
  entityId: number;
  isHealing: boolean;
  isNew: boolean;
}

interface AssaultTransportState {
  members: AssaultTransportMember[];
  designatedTargetId: number | null;
  attackMoveGoalX: number;
  attackMoveGoalZ: number;
  isAttackMove: boolean;
  isAttackObject: boolean;
  newOccupantsAreNewMembers: boolean;
}

/**
 * Source parity: PowerPlantUpdateModuleData — rod extension animation timing.
 * C++ PowerPlantUpdate.h: m_rodsExtendTime.
 */
interface PowerPlantUpdateProfile {
  rodsExtendTimeFrames: number;
}

interface PowerPlantUpdateState {
  extended: boolean;
  /** Frame when the UPGRADING→UPGRADED transition occurs. 0 = not pending. */
  upgradeFinishFrame: number;
}

interface OverchargeBehaviorProfile {
  healthPercentToDrainPerSecond: number;
  notAllowedWhenHealthBelowPercent: number;
}

interface OverchargeRuntimeState extends OverchargeBehaviorProfile {
}

interface SabotageBuildingProfile {
  moduleType: string;
  disableHackedDurationFrames: number;
  disableContainedHackers: boolean;
  stealsCashAmount: number;
  destroysTarget: boolean;
  powerSabotageDurationFrames: number;
  /** Source parity: SabotageCommandCenter/SabotageSuperweapon — resets all special power cooldowns. */
  resetsSpecialPowers: boolean;
}

interface PendingEnterObjectActionState {
  targetObjectId: number;
  action: EnterObjectCommand['action'];
}

interface PendingRepairDockActionState {
  dockObjectId: number;
  /**
   * Source parity: RepairDockUpdate::m_lastRepair per-dock cache.
   * We cache the dock object id that initialized healthToAddPerFrame.
   * 0 = not initialized.
   */
  lastRepairDockObjectId: number;
  /** Source parity: RepairDockUpdate::m_healthToAddPerFrame. */
  healthToAddPerFrame: number;
}

interface PendingCombatDropActionState {
  targetObjectId: number | null;
  targetX: number;
  targetZ: number;
  nextDropFrame: number;
}

interface PendingChinookRappelState {
  sourceEntityId: number;
  targetObjectId: number | null;
  targetX: number;
  targetZ: number;
  descentSpeedPerFrame: number;
}

interface RepairDockProfile {
  /** Source parity: RepairDockUpdateModuleData::m_framesForFullHeal (duration real in frames). */
  timeForFullHealFrames: number;
}

interface DozerAIProfile {
  /** Source parity: DozerAIUpdateModuleData::m_repairHealthPercentPerSecond (0..1 per second). */
  repairHealthPercentPerSecond: number;
  /** Source parity: DozerAIUpdateModuleData::m_boredTime (duration real in frames). */
  boredTimeFrames: number;
  /** Source parity: DozerAIUpdateModuleData::m_boredRange. */
  boredRange: number;
}

/**
 * Source parity subset: ChinookAIUpdate module data used by gameplay systems
 * currently implemented in this port (supply availability + combat-drop timing).
 */
interface ChinookAIProfile {
  numRopes: number;
  perRopeDelayMinFrames: number;
  perRopeDelayMaxFrames: number;
  minDropHeight: number;
  waitForRopesToDrop: boolean;
  rappelSpeed: number;
  ropeDropSpeed: number;
  ropeFinalHeight: number;
}

interface MapEntity {
  id: number;
  templateName: string;
  category: ObjectCategory;
  kindOf: Set<string>;
  side?: string;
  /** Source parity: original controlling side used by Object::isCaptured(). */
  originalOwningSide: string;
  /** Source parity: Object::isCaptured() runtime state. */
  capturedFromOriginalOwner: boolean;
  controllingPlayerToken: string | null;
  resolved: boolean;
  bridgeFlags: number;
  mapCellX: number;
  mapCellZ: number;
  renderAssetCandidates: string[];
  renderAssetPath: string | null;
  renderAssetResolved: boolean;
  renderAnimationStateClips?: RenderAnimationStateClipCandidates;
  x: number;
  y: number;
  z: number;
  rotationY: number;
  animationState: RenderAnimationState;
  baseHeight: number;
  nominalHeight: number;
  selected: boolean;
  canMove: boolean;
  energyBonus: number;
  crusherLevel: number;
  crushableLevel: number;
  canBeSquished: boolean;
  isUnmanned: boolean;
  attackNeedsLineOfSight: boolean;
  isImmobile: boolean;
  noCollisions: boolean;
  isIndestructible: boolean;
  /** Source parity: KeepObjectDie — prevents entity removal on death, keeps as rubble. */
  keepObjectOnDeath: boolean;
  /** Source parity: Body module type determines damage behavior (HighlanderBody caps at 1HP, ImmortalBody never dies). */
  bodyType: BodyModuleType;
  /** Source parity: HiveStructureBody — damage redirection config for tunnel-like structures. */
  hiveStructureProfile: HiveStructureBodyProfile | null;
  canTakeDamage: boolean;
  maxHealth: number;
  /** Source parity: BodyModule::m_initialHealth (used by script unit-health condition). */
  initialHealth: number;
  health: number;
  attackWeapon: AttackWeaponProfile | null;
  weaponTemplateSets: WeaponTemplateSetProfile[];
  weaponSetFlagsMask: number;
  /** Source parity: Object::m_weaponBonusCondition — bitmask of active weapon bonus conditions. */
  weaponBonusConditionFlags: number;
  armorTemplateSets: ArmorTemplateSetProfile[];
  armorSetFlagsMask: number;
  armorDamageCoefficients: Map<string, number> | null;
  attackTargetEntityId: number | null;
  attackTargetPosition: VectorXZ | null;
  attackOriginalVictimPosition: VectorXZ | null;
  attackCommandSource: AttackCommandSource;
  /** Source parity: AI attack state machine sub-state. */
  attackSubState: AttackSubState;
  nextAttackFrame: number;
  attackAmmoInClip: number;
  attackReloadFinishFrame: number;
  attackForceReloadFrame: number;
  forcedWeaponSlot: number | null;
  weaponLockStatus: 'NOT_LOCKED' | 'LOCKED_TEMPORARILY' | 'LOCKED_PERMANENTLY';
  maxShotsRemaining: number;
  /** Source parity: Weapon::m_leechWeaponRangeActive — unlimited range lock after first shot. */
  leechRangeActive: boolean;
  /** Source parity: TurretAI modules controlling weapon slot availability. */
  turretProfiles: TurretProfile[];
  /** Source parity: TurretAI runtime state — one per turret profile. */
  turretStates: TurretRuntimeState[];
  attackScatterTargetsUnused: number[];
  preAttackFinishFrame: number;
  consecutiveShotsTargetEntityId: number | null;
  consecutiveShotsAtTarget: number;
  /** Source parity: FiringTracker continuous-fire tier — NONE, MEAN, or FAST. */
  continuousFireState: 'NONE' | 'MEAN' | 'FAST';
  /** Source parity: FiringTracker — frame when cooldown begins (0 = inactive). */
  continuousFireCooldownFrame: number;
  sneakyOffsetWhenAttacking: number;
  attackersMissPersistFrames: number;
  attackersMissExpireFrame: number;
  productionProfile: ProductionProfile | null;
  productionQueue: ProductionQueueEntry[];
  productionNextId: number;
  queueProductionExitProfile: QueueProductionExitProfile | null;
  rallyPoint: VectorXZ | null;
  parkingPlaceProfile: ParkingPlaceProfile | null;
  containProfile: ContainProfile | null;
  queueProductionExitDelayFramesRemaining: number;
  queueProductionExitBurstRemaining: number;
  parkingSpaceProducerId: number | null;
  helixCarrierId: number | null;
  garrisonContainerId: number | null;
  /** Source parity: OpenContain::m_playerEnteredMask (cleared every frame, set on enter). */
  containPlayerEnteredSide: string | null;
  /** Source parity: m_containedBy for TransportContain/OverlordContain (Humvee, Chinook, etc.). */
  transportContainerId: number | null;
  /** Source parity: TunnelContain — references the tunnel this entity currently resides in. */
  tunnelContainerId: number | null;
  /** Frame at which this entity entered the tunnel (for heal calculation). */
  tunnelEnteredFrame: number;
  /** Source parity: HealContain — frame at which this entity entered the heal container. */
  healContainEnteredFrame: number;
  helixPortableRiderId: number | null;
  /** Source parity: SlavedUpdate — ID of the spawner/slaver that owns this slave. */
  slaverEntityId: number | null;
  /** Source parity: SpawnBehavior — spawner runtime state. Null if not a spawner. */
  spawnBehaviorState: SpawnBehaviorState | null;
  largestWeaponRange: number;
  totalWeaponAntiMask: number;
  locomotorSets: Map<string, LocomotorSetProfile>;
  completedUpgrades: Set<string>;
  locomotorUpgradeTriggers: Set<string>;
  executedUpgradeModules: Set<string>;
  upgradeModules: UpgradeModuleProfile[];
  objectStatusFlags: Set<string>;
  /** Source parity: ModelConditionFlags — visual state flags for drawable/animation system. */
  modelConditionFlags: Set<string>;
  commandSetStringOverride: string | null;
  locomotorUpgradeEnabled: boolean;
  activeLocomotorSet: string;
  locomotorSurfaceMask: number;
  locomotorDownhillOnly: boolean;
  specialPowerModules: Map<string, SpecialPowerModuleProfile>;
  lastSpecialPowerDispatch: SpecialPowerDispatchProfile | null;
  pathDiameter: number;
  pathfindCenterInCell: boolean;
  blocksPath: boolean;
  /** Source parity: Object geometry major radius (world units) used by crush/collision logic. */
  geometryMajorRadius: number;
  obstacleGeometry: ObstacleGeometry | null;
  obstacleFootprint: number;
  ignoredMovementObstacleId: number | null;
  movePath: VectorXZ[];
  pathIndex: number;
  moving: boolean;
  /** Max speed from the active locomotor set (world-units per second). */
  speed: number;
  /**
   * Source parity: Locomotor::m_curSpeed — instantaneous speed along heading.
   * Smoothly accelerates/decelerates toward `speed` or 0.
   */
  currentSpeed: number;
  moveTarget: VectorXZ | null;
  pathfindGoalCell: { x: number; z: number } | null;
  pathfindPosCell: { x: number; z: number } | null;
  supplyWarehouseProfile: SupplyWarehouseProfile | null;
  supplyTruckProfile: SupplyTruckProfile | null;
  chinookAIProfile: ChinookAIProfile | null;
  repairDockProfile: RepairDockProfile | null;
  dozerAIProfile: DozerAIProfile | null;
  /** Source parity: DozerPrimaryIdleState::m_idleTooLongTimestamp. */
  dozerIdleTooLongTimestamp: number;
  isSupplyCenter: boolean;
  experienceProfile: ExperienceProfile | null;
  experienceState: ExperienceState;
  visionRange: number;
  visionState: EntityVisionState;
  /** Source parity: StealthUpdate — parsed stealth module profile. */
  stealthProfile: StealthProfile | null;
  /** Frames remaining before CAN_STEALTH entity re-enters stealth. 0 = ready to stealth. */
  stealthDelayRemaining: number;
  /** Frame at which DETECTED expires. 0 = not detected. */
  detectedUntilFrame: number;
  /** Frame at which entity last took damage (for STEALTH_NOT_WHILE_TAKING_DAMAGE). */
  lastDamageFrame: number;
  /**
   * Source parity: BodyModule::m_lastDamageSourceId / getClearableLastAttacker().
   * Set when damage is received; cleared after retaliation check. Enables
   * immediate retaliation rather than waiting for the 2-second auto-target scan.
   */
  lastAttackerEntityId: number | null;
  /** Source parity: BodyModule::m_lastDamageInfo.in.m_sourceID (persistent for script conditions). */
  scriptLastDamageSourceEntityId: number | null;
  /** Source parity: BodyModule::m_lastDamageInfo.in.m_sourceTemplate (template name snapshot). */
  scriptLastDamageSourceTemplateName: string | null;
  /** Source parity: BodyModule::m_lastDamageInfo.in.m_sourcePlayerMask (resolved to side key). */
  scriptLastDamageSourceSide: string | null;
  /** Source parity: StealthDetectorUpdate — parsed detector module profile. */
  detectorProfile: DetectorProfile | null;
  /** Frame at which next detection scan is allowed (rate throttle). */
  detectorNextScanFrame: number;
  /** Source parity: AutoHealBehavior — self-heal state. */
  autoHealProfile: AutoHealProfile | null;
  autoHealNextFrame: number;
  autoHealDamageDelayUntilFrame: number;
  /** Source parity: BaseRegenerateUpdate — structure regen after damage delay. */
  baseRegenDelayUntilFrame: number;
  /** Source parity: PropagandaTowerBehavior — radius heal/buff aura. */
  propagandaTowerProfile: PropagandaTowerProfile | null;
  propagandaTowerNextScanFrame: number;
  propagandaTowerTrackedIds: number[];
  /** Sole healing benefactor anti-stacking. */
  soleHealingBenefactorId: number | null;
  soleHealingBenefactorExpirationFrame: number;
  /**
   * Source parity: AIUpdateInterface::m_nextMoodCheckTime — frame at which
   * idle auto-target scan is next allowed. Throttles enemy scans to avoid
   * per-frame overhead. C++ default: every 2 seconds (60 logic frames).
   */
  autoTargetScanNextFrame: number;

  // ── Source parity: AIGuardMachine — guard position/object state ──
  /** Current guard state machine phase. 'NONE' = not guarding. */
  guardState: GuardState;
  /** Guard point X (for GUARDTARGET_LOCATION) or last-known guarded object X. */
  guardPositionX: number;
  /** Guard point Z (for GUARDTARGET_LOCATION) or last-known guarded object Z. */
  guardPositionZ: number;
  /** Entity ID being guarded (for GUARDTARGET_OBJECT). 0 = guarding a position. */
  guardObjectId: number;
  /** Guard behavior variant (NORMAL / GUARD_WITHOUT_PURSUIT / GUARD_FLYING_UNITS_ONLY). */
  guardMode: number;
  /** Frame at which next guard-mode enemy scan is allowed. */
  guardNextScanFrame: number;
  /** Frame at which the outer-range chase expires (unit forced to return). */
  guardChaseExpireFrame: number;
  /** Inner guard range (vision * modifier). */
  guardInnerRange: number;
  /** Outer guard range (vision * modifier, pursuit limit). */
  guardOuterRange: number;

  // ── Source parity: PoisonedBehavior — per-entity poison DoT state ──
  /** INI-extracted poison behavior profile (null = entity cannot be poisoned). */
  poisonedBehaviorProfile: PoisonedBehaviorProfile | null;
  /** Damage amount per poison tick (0 = not poisoned). */
  poisonDamageAmount: number;
  /** Frame at which next poison tick fires. */
  poisonNextDamageFrame: number;
  /** Frame at which poison effect expires. */
  poisonExpireFrame: number;

  // ── Source parity: FlammableUpdate — per-entity fire DoT state ──
  /** Flammability status: 'NORMAL' | 'AFLAME' | 'BURNED'. */
  flameStatus: 'NORMAL' | 'AFLAME' | 'BURNED';
  /** Accumulated flame damage toward ignition threshold. */
  flameDamageAccumulated: number;
  /** Frame at which aflame state ends. */
  flameEndFrame: number;
  /** Frame at which entity becomes BURNED (0 = never). Independent of flameEndFrame. */
  flameBurnedEndFrame: number;
  /** Frame at which next fire damage tick fires. */
  flameDamageNextFrame: number;
  /** Last frame flame damage was received. */
  flameLastDamageReceivedFrame: number;
  /** Flammable module profile (null = not flammable). */
  flammableProfile: FlammableProfile | null;
  /** Fire spread module profile (null = no fire spreading). */
  fireSpreadProfile: FireSpreadProfile | null;
  /** Frame at which next fire spread attempt occurs. */
  fireSpreadNextFrame: number;

  // ── Source parity: MinefieldBehavior — mine collision detonation ──
  /** Mine module profile (null = not a mine). */
  minefieldProfile: MinefieldProfile | null;
  /** Virtual mines remaining (charges). */
  mineVirtualMinesRemaining: number;
  /** Immune entities (mine-clearing units). */
  mineImmunes: MineImmuneEntry[];
  /** Detonator tracking for repeat detonation move threshold. */
  mineDetonators: MineDetonatorEntry[];
  /** Frames remaining for scoot animation (0 = inactive). */
  mineScootFramesLeft: number;
  /** Source parity: m_draining — health drain after creator dies. */
  mineDraining: boolean;
  /** Source parity: m_regenerates — can change after creator dies. */
  mineRegenerates: boolean;
  /** Source parity: m_nextDeathCheckFrame — next frame to check if creator is dead. */
  mineNextDeathCheckFrame: number;
  /** Source parity: m_ignoreDamage — suppress onDamage during self-damage. */
  mineIgnoreDamage: boolean;
  /** Source parity: m_producerID — entity that created this mine (for creator death detection). */
  mineCreatorId: number;

  // ── Source parity: EjectPilotDie — pilot eject on death ──
  /** Template name of pilot unit to eject on death. Null = no eject. */
  ejectPilotTemplateName: string | null;
  /** Minimum veterancy level to eject (default 1 = VETERAN). */
  ejectPilotMinVeterancy: number;

  // ── Source parity: ProneUpdate — infantry goes prone when damaged ──
  /** DamageToFramesRatio: damage-to-frames conversion. Null = no prone behavior. */
  proneDamageToFramesRatio: number | null;
  /** Remaining frames of prone state (0 = not prone). */
  proneFramesRemaining: number;

  // ── Source parity: DemoTrapUpdate — proximity/manual detonation trap ──
  demoTrapProfile: DemoTrapProfile | null;
  /** Countdown for next proximity scan. */
  demoTrapNextScanFrame: number;
  /** True once the trap has detonated (prevents double-fire). */
  demoTrapDetonated: boolean;
  /** Whether the trap is currently in proximity (auto-scan) mode. */
  demoTrapProximityMode: boolean;

  // ── Source parity: RebuildHoleExposeDie — creates hole on building death ──
  /** Die module profile (null = no hole on death). Only on buildings. */
  rebuildHoleExposeDieProfile: RebuildHoleExposeDieProfile | null;

  // ── Source parity: RebuildHoleBehavior — hole lifecycle management ──
  /** Behavior module profile (null = not a rebuild hole). Only on hole objects. */
  rebuildHoleProfile: RebuildHoleBehaviorProfile | null;
  /** ID of the worker unit spawned by this hole (0 = none). */
  rebuildHoleWorkerEntityId: number;
  /** ID of the building being reconstructed (0 = none). */
  rebuildHoleReconstructingEntityId: number;
  /** ID of the original building that died and created this hole. */
  rebuildHoleSpawnerEntityId: number;
  /** Countdown frames until worker spawns (0 = not waiting). */
  rebuildHoleWorkerWaitCounter: number;
  /** Template name of the building to reconstruct. Empty = not initialized. */
  rebuildHoleRebuildTemplateName: string;
  /** Whether the hole is currently masked (hidden during active reconstruction). */
  rebuildHoleMasked: boolean;

  // ── Source parity: AutoDepositUpdate — periodic income ──
  /** AutoDeposit profile (null = no periodic income). */
  autoDepositProfile: AutoDepositProfile | null;
  /** Frame when next deposit occurs (C++ m_depositOnFrame). */
  autoDepositNextFrame: number;
  /** C++ m_initialized — set TRUE on first deposit frame to enable capture bonus. */
  autoDepositInitialized: boolean;
  /** C++ m_awardInitialCaptureBonus — TRUE when bonus is pending, cleared after award. */
  autoDepositCaptureBonusPending: boolean;

  // ── Source parity: AutoFindHealingUpdate — AI auto-seek healing ──
  /** Auto-find-healing profile (null = no auto-heal seeking). */
  autoFindHealingProfile: AutoFindHealingProfile | null;
  /** Frame at which next heal pad scan occurs. */
  autoFindHealingNextScanFrame: number;

  // ── Source parity: CreateObjectDie / SlowDeathBehavior — OCL on death ──
  /** OCL entries to execute when entity is destroyed, with DieMuxData filtering. */
  deathOCLEntries: DeathOCLEntry[];

  // ── Source parity: Object::m_constructionPercent — dozer construction progress ──
  /**
   * Construction progress: 0..100 during build, CONSTRUCTION_COMPLETE (-1) when done.
   * Objects are born with -1 (complete) unless placed by a dozer.
   */
  constructionPercent: number;
  /** ID of the dozer currently building this entity. 0 = no active builder. */
  builderId: number;
  /** Total frames to build from INI BuildTime. 0 = instant. */
  buildTotalFrames: number;

  // ── Source parity: DeployStyleAIUpdate — deploy/undeploy state machine ──
  deployStyleProfile: DeployStyleProfile | null;
  deployState: DeployState;
  deployFrameToWait: number;

  // ── Source parity: SpecialAbilityUpdate — unit special abilities ──
  specialAbilityProfile: SpecialAbilityProfile | null;
  specialAbilityState: SpecialAbilityRuntimeState | null;

  destroyed: boolean;

  // ── Source parity: DamageInfo.in.m_deathType — death cause for die module filtering ──
  /** Set before death pipeline runs. Maps from damage type (CRUSH→CRUSHED, POISON→POISONED, etc.). */
  pendingDeathType: string;

  // ── Source parity: LifetimeUpdate — timed self-destruction ──
  /** Frame at which this entity should self-destruct (null = no lifetime limit). */
  lifetimeDieFrame: number | null;

  // ── Source parity: HeightDieUpdate — aircraft height-based death ──
  /** Height die profile (null = no height-based death). */
  heightDieProfile: HeightDieProfile | null;
  /** Frame after which height checks begin (accounts for InitialDelay). */
  heightDieActiveFrame: number;
  /** Source parity: HeightDieUpdate — last-frame Y position for OnlyWhenMovingDown check. */
  heightDieLastY: number;

  // ── Source parity: DeletionUpdate — timed silent removal (no death pipeline) ──
  /** Frame at which this entity should be silently destroyed (null = no deletion timer). */
  deletionDieFrame: number | null;

  // ── Source parity: StickyBombUpdate — bomb attachment and tracking ──
  /** Sticky bomb profile (null = not a sticky bomb). */
  stickyBombProfile: StickyBombUpdateProfile | null;
  /** ID of entity this bomb is attached to (0 = not attached). */
  stickyBombTargetId: number;
  /** Frame at which timed bomb detonates (0 = remote-triggered). */
  stickyBombDieFrame: number;

  // ── Source parity: FireWeaponWhenDamagedBehavior — weapon fired on damage ──
  /** Reaction weapons keyed by body damage state (fired once per damage event). */
  fireWhenDamagedProfiles: FireWhenDamagedProfile[];

  // ── Source parity: FireWeaponUpdate — autonomous weapon fire at own position ──
  /** Parsed FireWeaponUpdate modules from INI (multiple allowed per entity). */
  fireWeaponUpdateProfiles: FireWeaponUpdateProfile[];
  /** Per-profile next-fire-frame tracker (matches fireWeaponUpdateProfiles by index). */
  fireWeaponUpdateNextFireFrames: number[];
  /** Frame when this entity last fired a normal combat weapon (for ExclusiveWeaponDelay). */
  lastShotFiredFrame: number;

  // ── Source parity: OCLUpdate — periodic Object Creation List spawning ──
  /** Parsed OCLUpdate modules from INI (multiple allowed per entity). */
  oclUpdateProfiles: OCLUpdateProfile[];
  /** Per-profile next-creation-frame tracker (matches oclUpdateProfiles by index). */
  oclUpdateNextCreationFrames: number[];
  /** Per-profile flag: true once the initial timer has been set (first shouldCreate skips). */
  oclUpdateTimerStarted: boolean[];

  // ── Source parity: WeaponBonusUpdate — aura-based weapon bonus application ──
  /** Parsed WeaponBonusUpdate modules from INI (aura source). */
  weaponBonusUpdateProfiles: WeaponBonusUpdateProfile[];
  /** Per-profile next-pulse-frame tracker. */
  weaponBonusUpdateNextPulseFrames: number[];

  // ── Source parity: TempWeaponBonusHelper — temporary weapon bonus on this entity ──
  /** Active temp bonus condition flag (0 = none). Only one active at a time per C++. */
  tempWeaponBonusFlag: number;
  /** Frame when the current temp bonus expires. */
  tempWeaponBonusExpiryFrame: number;

  // ── Source parity: InstantDeathBehavior — die modules with filtering ──
  /** Parsed InstantDeathBehavior modules from INI (all matching profiles fire on death). */
  instantDeathProfiles: InstantDeathProfile[];
  /** Parsed FireWeaponWhenDeadBehavior modules from INI (fire weapon on death with upgrade control). */
  fireWeaponWhenDeadProfiles: FireWeaponWhenDeadProfile[];

  // ── Source parity: SlowDeathBehavior — phased death sequences ──
  /** Parsed SlowDeathBehavior modules from INI (multiple per entity, one selected on death). */
  slowDeathProfiles: SlowDeathProfile[];
  /** Active slow death state when entity is in a phased death sequence (null = not dying slowly). */
  slowDeathState: SlowDeathRuntimeState | null;

  // ── Source parity: StructureCollapseUpdate — building collapse die module ──
  structureCollapseProfile: StructureCollapseProfile | null;
  /** Active collapse state (null = not collapsing). Entity persists during collapse. */
  structureCollapseState: StructureCollapseRuntimeState | null;

  // ── Source parity: EMPUpdate — EMP pulse field that disables nearby entities ──
  empUpdateProfile: EMPUpdateProfile | null;
  empUpdateState: EMPUpdateRuntimeState | null;

  // ── Source parity: HijackerUpdate — hijacker hides in vehicle, ejects on death ──
  hijackerUpdateProfile: HijackerUpdateProfile | null;
  hijackerState: HijackerRuntimeState | null;

  // ── Source parity: LeafletDropBehavior — delayed radius disable for infantry+vehicles ──
  leafletDropProfile: LeafletDropProfile | null;
  leafletDropState: LeafletDropRuntimeState | null;

  // ── Source parity: SmartBombTargetHomingUpdate — course correction for falling projectiles ──
  smartBombProfile: SmartBombTargetHomingProfile | null;
  smartBombState: SmartBombTargetHomingState | null;

  // ── Source parity: DynamicGeometryInfoUpdate — geometry morphing over time ──
  dynamicGeometryProfile: DynamicGeometryInfoUpdateProfile | null;
  dynamicGeometryState: DynamicGeometryInfoUpdateState | null;

  // ── Source parity: FireOCLAfterWeaponCooldownUpdate — fire OCL after weapon stops ──
  fireOCLAfterCooldownProfiles: FireOCLAfterWeaponCooldownProfile[];
  fireOCLAfterCooldownStates: FireOCLAfterWeaponCooldownState[];

  // ── Source parity: NeutronBlastBehavior — death-triggered radius neutron blast ──
  neutronBlastProfile: NeutronBlastProfile | null;

  // ── Source parity: BunkerBusterBehavior — kills garrisoned units on bomb death ──
  bunkerBusterProfile: BunkerBusterProfile | null;
  bunkerBusterVictimId: number | null;

  // ── Source parity: GrantStealthBehavior — expanding radius stealth grant ──
  grantStealthProfile: GrantStealthProfile | null;
  grantStealthCurrentRadius: number;

  // ── Source parity: NeutronMissileSlowDeathBehavior — timed blast wave sequence ──
  neutronMissileSlowDeathProfile: NeutronMissileSlowDeathProfile | null;
  neutronMissileSlowDeathState: NeutronMissileSlowDeathState | null;

  // ── Source parity: HelicopterSlowDeathBehavior — spiral crash death for helicopters ──
  helicopterSlowDeathProfiles: HelicopterSlowDeathProfile[];
  helicopterSlowDeathState: HelicopterSlowDeathState | null;

  // ── Source parity: JetSlowDeathBehavior — jet crash death with roll and FX timeline ──
  jetSlowDeathProfiles: JetSlowDeathProfile[];
  jetSlowDeathState: JetSlowDeathState | null;

  // ── Source parity: CleanupHazardUpdate — passive hazard cleanup scanning ──
  cleanupHazardProfile: CleanupHazardProfile | null;
  cleanupHazardState: CleanupHazardState | null;

  // ── Source parity: AssistedTargetingUpdate — laser designation assisted attacks ──
  assistedTargetingProfile: AssistedTargetingProfile | null;

  // ── Source parity: TechBuildingBehavior — neutral buildings that revert on death ──
  techBuildingProfile: TechBuildingBehaviorProfile | null;

  // ── Source parity: SupplyWarehouseCripplingBehavior — self-heal + dock disable ──
  supplyWarehouseCripplingProfile: SupplyWarehouseCripplingProfile | null;
  /** Frame after which healing is allowed (suppression timer). */
  swCripplingHealSuppressedUntilFrame: number;
  /** Frame of next heal tick. */
  swCripplingNextHealFrame: number;
  /** Whether the dock is currently crippled (REALLYDAMAGED state). */
  swCripplingDockDisabled: boolean;

  // ── Source parity: GenerateMinefieldBehavior — spawns mines on death ──
  generateMinefieldProfile: GenerateMinefieldProfile | null;
  generateMinefieldDone: boolean;

  // ── Source parity: CreateCrateDie — crate spawning on death ──
  createCrateDieProfile: CreateCrateDieProfile | null;

  // ── Source parity: SalvageCrateCollide — crate collection ──
  salvageCrateProfile: SalvageCrateProfile | null;
  // ── Source parity: CrateCollide hierarchy — general crate collection ──
  crateCollideProfile: CrateCollideProfile | null;

  // ── Source parity: BattlePlanUpdate — Strategy Center plan system ──
  battlePlanProfile: BattlePlanProfile | null;
  battlePlanState: BattlePlanRuntimeState | null;
  /** Applied damage scalar from battle plan bonuses (1.0 = no change). */
  battlePlanDamageScalar: number;
  /** Base vision range before battle plan modifiers. */
  baseVisionRange: number;

  // ── Source parity: PointDefenseLaserUpdate — anti-projectile defense ──
  pointDefenseLaserProfile: PointDefenseLaserProfile | null;
  /** Frame when next expensive target scan should run. */
  pdlNextScanFrame: number;
  /** Visual ID of the currently tracked projectile event (0 = no target). */
  pdlTargetProjectileVisualId: number;
  /** Frame when the PDL weapon can fire again. */
  pdlNextShotFrame: number;

  // ── Source parity: HordeUpdate — formation bonus system ──
  hordeProfile: HordeUpdateProfile | null;
  /** Frame when next horde membership scan should run. */
  hordeNextCheckFrame: number;
  /** Currently has horde bonus active. */
  isInHorde: boolean;
  /** Counted enough nearby units to be a true horde member (vs rub-off inheritance). */
  isTrueHordeMember: boolean;

  // ── Source parity: EnemyNearUpdate — model condition flag when enemy in range ──
  enemyNearScanDelayFrames: number;
  /** Countdown frames until next enemy scan. */
  enemyNearNextScanCountdown: number;
  /** Whether an enemy is currently detected nearby. */
  enemyNearDetected: boolean;

  // ── Source parity: SlavedUpdate — slave following/guard behavior ──
  slavedUpdateProfile: SlavedUpdateProfile | null;
  /** Guard point offset from master position (randomized on enslave). */
  slaveGuardOffsetX: number;
  slaveGuardOffsetZ: number;
  /** Frame countdown until next slaved update tick. */
  slavedNextUpdateFrame: number;
  // ── Source parity: CountermeasuresBehavior (aircraft flare defense) ──
  countermeasuresProfile: CountermeasuresProfile | null;
  countermeasuresState: CountermeasuresState | null;

  // ── Source parity: PilotFindVehicleUpdate — ejected pilot seeks vehicle ──
  pilotFindVehicleProfile: PilotFindVehicleProfile | null;
  pilotFindVehicleNextScanFrame: number;
  pilotFindVehicleDidMoveToBase: boolean;
  /** Target vehicle entity ID the pilot is navigating toward. */
  pilotFindVehicleTargetId: number | null;

  // ── Source parity: ToppleUpdate — trees/poles fall when damaged/crushed ──
  toppleProfile: ToppleProfile | null;
  toppleState: ToppleState;
  /** Topple direction in XZ (normalized). */
  toppleDirX: number;
  toppleDirZ: number;
  /** Current angular velocity (radians/frame). */
  toppleAngularVelocity: number;
  /** Accumulated angular rotation (0..PI/2). */
  toppleAngularAccumulation: number;
  /** Topple speed used to compute acceleration. */
  toppleSpeed: number;

  // ── Source parity: RadarUpdate — radar dish extension animation ──
  radarUpdateProfile: RadarUpdateProfile | null;
  /** Frame at which the radar extension animation completes. */
  radarExtendDoneFrame: number;
  /** Whether the radar extension animation has completed. */
  radarExtendComplete: boolean;
  /** Whether this radar is actively providing radar to the player. */
  radarActive: boolean;

  // ── Source parity: FloatUpdate — water surface snapping ──
  floatUpdateProfile: FloatUpdateProfile | null;

  // ── Source parity: WanderAIUpdate — random movement when idle ──
  hasWanderAI: boolean;
  // ── Source parity: VeterancyGainCreate — sets veterancy level on creation if science owned ──
  veterancyGainCreateProfiles: VeterancyGainCreateProfile[];
  // ── Source parity: FXListDie — death FX lists with DieMuxData filtering ──
  fxListDieProfiles: FXListDieProfile[];
  // ── Source parity: CrushDie — sets FRONTCRUSHED/BACKCRUSHED model conditions on crush death ──
  crushDieProfiles: CrushDieProfile[];
  // ── Source parity: DestroyDie — DieMuxData-filtered forced removal on death ──
  destroyDieProfiles: DestroyDieProfile[];
  // ── Source parity: DamDie — enables WAVEGUIDE objects when dam dies ──
  damDieProfiles: DamDieProfile[];
  // ── Source parity: SpecialPowerCompletionDie — script callback on death ──
  specialPowerCompletionDieProfiles: SpecialPowerCompletionDieProfile[];
  /** Source parity: SpecialPowerCompletionDie::m_creatorID. */
  specialPowerCompletionCreatorId: number;
  /** Source parity: SpecialPowerCompletionDie::m_creatorSet (creator can only be assigned once). */
  specialPowerCompletionCreatorSet: boolean;
  /** Source parity: BodyModule::m_frontCrushed — front end was crushed. */
  frontCrushed: boolean;
  /** Source parity: BodyModule::m_backCrushed — back end was crushed. */
  backCrushed: boolean;
  // ── Source parity: GrantUpgradeCreate — grants upgrade on creation/build complete ──
  grantUpgradeCreateProfiles: GrantUpgradeCreateProfile[];

  // ── Source parity: UpgradeDie — removes upgrade from producer on death ──
  upgradeDieProfiles: UpgradeDieProfile[];
  /** Source parity: Object::m_producerID — entity that created this one (factory/producer). */
  producerEntityId: number;

  // ── Source parity: CheckpointUpdate — gate opens for allies, closes for enemies ──
  checkpointProfile: CheckpointProfile | null;
  checkpointAllyNear: boolean;
  checkpointEnemyNear: boolean;
  checkpointMaxMinorRadius: number;
  checkpointScanCountdown: number;

  // ── Source parity: DynamicShroudClearingRangeUpdate — animated vision range ──
  dynamicShroudProfile: DynamicShroudProfile | null;
  dynamicShroudState: DynamicShroudState;
  dynamicShroudStateCountdown: number;
  dynamicShroudTotalFrames: number;
  dynamicShroudShrinkStartDeadline: number;
  dynamicShroudSustainDeadline: number;
  dynamicShroudGrowStartDeadline: number;
  dynamicShroudDoneForeverFrame: number;
  dynamicShroudChangeIntervalCountdown: number;
  dynamicShroudNativeClearingRange: number;
  dynamicShroudCurrentClearingRange: number;

  // ── Source parity: JetAIUpdate — aircraft flight state machine ──
  /** JetAI profile (null = not an aircraft with JetAIUpdate). */
  jetAIProfile: JetAIProfile | null;
  /** JetAI runtime state (null = not an aircraft with JetAIUpdate). */
  jetAIState: JetAIRuntimeState | null;

  // ── Source parity: AnimationSteeringUpdate — turn animation model conditions ──
  animationSteeringProfile: AnimationSteeringProfile | null;
  animationSteeringCurrentTurnAnim: AnimationSteeringTurnAnim | null;
  animationSteeringNextTransitionFrame: number;
  animationSteeringLastRotationY: number;

  // ── Source parity: TensileFormationUpdate — avalanche-style group collapse physics ──
  tensileFormationProfile: TensileFormationProfile | null;
  tensileFormationState: TensileFormationRuntimeState | null;

  // ── Source parity: AssaultTransportAIUpdate — auto-deploy/recall passengers ──
  /** AssaultTransport profile (null = not an assault transport). */
  assaultTransportProfile: AssaultTransportProfile | null;

  // ── Source parity: PowerPlantUpdate — rod extension animation state machine ──
  powerPlantUpdateProfile: PowerPlantUpdateProfile | null;
  powerPlantUpdateState: PowerPlantUpdateState | null;

  // ── Source parity: SpecialPowerCreate — starts special power timers on build complete ──
  hasSpecialPowerCreate: boolean;
  /**
   * Source parity: Object::m_shroudRange — distance this entity actively shrouds enemy vision.
   * Different from visionRange (sight distance) — this is the GPS Scrambler-style active shrouding.
   */
  shroudRange: number;

  // ── Source parity: SubdualDamageHelper + ActiveBody subdual fields ──
  /** INI: SubdualDamageCap — max subdual damage. 0 = entity cannot be subdued. */
  subdualDamageCap: number;
  /** INI: SubdualDamageHealRate — frames between heal ticks (parseDurationUnsignedInt). */
  subdualDamageHealRate: number;
  /** INI: SubdualDamageHealAmount — HP healed per tick. */
  subdualDamageHealAmount: number;
  /** Runtime: accumulated subdual damage, capped at subdualDamageCap. */
  currentSubdualDamage: number;
  /** Runtime: SubdualDamageHelper countdown timer. 0 = time to heal. */
  subdualHealingCountdown: number;
}

/**
 * Source parity: AutoHealBehavior module parsed from INI.
 */
interface AutoHealProfile {
  healingAmount: number;
  healingDelayFrames: number;
  startHealingDelayFrames: number;
  radius: number;
  affectsWholePlayer: boolean;
  initiallyActive: boolean;
}

/**
 * Source parity: PropagandaTowerBehavior module parsed from INI.
 */
interface PropagandaTowerProfile {
  radius: number;
  scanDelayFrames: number;
  healPercentPerSecond: number;
  upgradedHealPercentPerSecond: number;
  upgradeRequired: string | null;
}

/**
 * Source parity: FlammableUpdate module parsed from INI.
 */
interface FlammableProfile {
  /** Cumulative damage threshold to ignite. */
  flameDamageLimit: number;
  /** Frames before threshold resets after no fire damage. */
  flameDamageExpirationDelayFrames: number;
  /** Duration in frames that entity stays AFLAME. */
  aflameDurationFrames: number;
  /** Frames between fire damage ticks while AFLAME (0 = no periodic damage). */
  aflameDamageDelayFrames: number;
  /** Damage per fire tick. */
  aflameDamageAmount: number;
  /** Frames before BURNED status is set (0 = never burns out). Independent of AFLAME duration. */
  burnedDelayFrames: number;
}

/**
 * Source parity: FireSpreadUpdate module parsed from INI.
 * C++ file: FireSpreadUpdate.cpp — spreads fire from burning entities to nearby flammable ones.
 */
interface FireSpreadProfile {
  /** Minimum frames between fire spread attempts. */
  minSpreadDelayFrames: number;
  /** Maximum frames between fire spread attempts. */
  maxSpreadDelayFrames: number;
  /** Radius within which to search for flammable targets. */
  spreadTryRange: number;
}

/**
 * Source parity: AutoFindHealingUpdate module parsed from INI.
 * C++ file: AutoFindHealingUpdate.cpp — AI units auto-seek nearby heal pads when damaged.
 */
interface AutoFindHealingProfile {
  /** Frames between scans for heal pads. */
  scanRateFrames: number;
  /** Radius to search for HEAL_PAD entities. */
  scanRange: number;
  /** Health ratio above which unit never seeks healing (default 0.95). */
  neverHeal: number;
  /** Health ratio below which unit always seeks healing even if busy (default 0.25). */
  alwaysHeal: number;
}

/**
 * Source parity: PoisonedBehavior module parsed from INI.
 * C++ file: PoisonedBehavior.cpp — per-entity poison DoT configuration.
 */
interface PoisonedBehaviorProfile {
  /** Frames between poison damage ticks. C++ field: m_poisonDamageIntervalData. */
  poisonDamageIntervalFrames: number;
  /** Total poison duration in frames after last dose. C++ field: m_poisonDurationData. */
  poisonDurationFrames: number;
}

/**
 * Source parity: HeightDieUpdate module parsed from INI.
 * C++ file: HeightDieUpdate.cpp — kills entities that fall below a target height above terrain.
 * Used for aircraft death when disabled/out of fuel, projectile cleanup, etc.
 */
interface HeightDieProfile {
  /** Height above terrain below which entity dies (C++ m_targetHeightAboveTerrain). */
  targetHeight: number;
  /** Only trigger death when entity is moving downward (C++ m_onlyWhenMovingDown). */
  onlyWhenMovingDown: boolean;
  /** Whether to include structure heights in target height calculation. */
  targetHeightIncludesStructures: boolean;
  /** Snap entity to ground on death. */
  snapToGroundOnDeath: boolean;
  /** Initial delay frames before height checks begin. */
  initialDelayFrames: number;
}

/**
 * Source parity: GrantUpgradeCreate — grants an upgrade when entity is created or build completes.
 * C++ file: GrantUpgradeCreate.cpp — used by units that auto-grant upgrades on creation.
 */
interface GrantUpgradeCreateProfile {
  /** Name of upgrade to grant (normalized to uppercase). */
  upgradeName: string;
  /** If true, the upgrade is a PLAYER-scoped upgrade (granted to side, not object). */
  isPlayerUpgrade: boolean;
  /** If UNDER_CONSTRUCTION is in ExemptStatus, grant on create when not under construction. */
  exemptUnderConstruction: boolean;
}

/**
 * Source parity: VeterancyGainCreate — on creation, sets entity veterancy level if player has
 * the required science. C++ file: VeterancyGainCreate.cpp.
 */
interface VeterancyGainCreateProfile {
  /** Veterancy level to set (0=REGULAR, 1=VETERAN, 2=ELITE, 3=HEROIC). */
  startingLevel: VeterancyLevel;
  /** Science name required (normalized to uppercase). Null = no science check (always applies). */
  scienceRequired: string | null;
}

/**
 * Source parity: FXListDie — on death, triggers a named FX list if isDieApplicable passes.
 * C++ file: FXListDie.cpp — used for death particle effects, explosion FX, etc.
 */
interface FXListDieProfile {
  /** Name of the FX list to trigger on death. */
  deathFXName: string;
  /** If true, orient the FX toward the damage source. */
  orientToObject: boolean;
  /** DieMuxData filtering. */
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
}

/**
 * Source parity: CrushDie — sets FRONTCRUSHED/BACKCRUSHED model conditions when entity dies from crush.
 * C++ file: CrushDie.cpp — determines which end of the victim was crushed based on crusher position.
 */
interface CrushDieProfile {
  /** DieMuxData filtering. */
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
}

/**
 * Source parity: DestroyDie — default die module with DieMuxData filters.
 * C++ file: DestroyDie.cpp.
 */
interface DestroyDieProfile {
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
}

/**
 * Source parity: DamDie — on applicable death, enables all WAVEGUIDE objects.
 * C++ file: DamDie.cpp.
 */
interface DamDieProfile {
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
}

/**
 * Source parity: SpecialPowerCompletionDie — notifies ScriptEngine when configured object dies.
 * C++ file: SpecialPowerCompletionDie.cpp.
 */
interface SpecialPowerCompletionDieProfile {
  specialPowerTemplateName: string;
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
}

/**
 * Source parity: UpgradeDie — when entity dies, removes specified upgrade from its producer.
 * C++ file: UpgradeDie.cpp — used by scout drones etc. that remove upgrade on death.
 */
interface UpgradeDieProfile {
  /** Name of upgrade to remove from producer on death (normalized to uppercase). */
  upgradeName: string;
  /** Die filtering: DeathTypes, ExemptStatus, RequiredStatus, VeterancyLevels. */
  deathTypes: Set<string> | null;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
}

/**
 * Source parity: CheckpointUpdate — autonomous gate that opens for allies, closes for enemies.
 * C++ file: CheckpointUpdate.cpp — used by GLA checkpoints and similar neutral structures.
 */
interface CheckpointProfile {
  /** Delay between enemy scans in logic frames. */
  scanDelayFrames: number;
}

/**
 * Source parity: DynamicShroudClearingRangeUpdate — animates vision range changes.
 * C++ file: DynamicShroudClearingRangeUpdate.cpp — used by Spy Satellite and similar abilities.
 * Timeline: growDelay → growing → sustaining → shrinkDelay → shrinking → done(finalVision).
 */
interface DynamicShroudProfile {
  shrinkDelay: number;
  shrinkTime: number;
  growDelay: number;
  growTime: number;
  /** Vision range once fully shrunk (C++ m_finalVision). */
  finalVision: number;
  /** How often to actually apply the vision range change (C++ m_changeInterval). */
  changeInterval: number;
  /** Separate change interval during growing phase (C++ m_growInterval). */
  growInterval: number;
}

type DynamicShroudState = 'NOT_STARTED' | 'GROWING' | 'SUSTAINING' | 'SHRINKING' | 'DONE' | 'SLEEPING';

/**
 * Source parity: HiveStructureBody — damage redirection to spawn slaves.
 * C++ file: HiveStructureBody.h — GLA Tunnel Networks redirect damage to units inside.
 */
interface HiveStructureBodyProfile {
  /** Damage type names that get redirected to closest slave when slaves exist. */
  propagateDamageTypes: Set<string>;
  /** Subset of propagate types that are silently ignored when no slaves exist. */
  swallowDamageTypes: Set<string>;
}

/**
 * Source parity: StickyBombUpdate module parsed from INI.
 * C++ file: StickyBombUpdate.h — bomb attachment and tracking behavior.
 * Used for Colonel Burton demo charges, Jarmen Kell booby traps.
 */
interface StickyBombUpdateProfile {
  /** Vertical offset above target for mobile targets. C++ default: 10.0. */
  offsetZ: number;
  /** Weapon template name for geometry-scaled detonation damage (null = use death weapons). */
  geometryBasedDamageWeaponName: string | null;
}

/**
 * Source parity: StealthUpdate module parsed from INI.
 * Controls when entities can enter/exit stealth.
 */
interface StealthProfile {
  /** Frames to wait before entering stealth (and re-stealth delay after break). */
  stealthDelayFrames: number;
  /** Entity has innate stealth ability — sets CAN_STEALTH on creation. */
  innateStealth: boolean;
  /** Bitmask: conditions that break/prevent stealth. */
  forbiddenConditions: number;
  /** Speed threshold — stealth breaks when velocity > this. 0 = any movement breaks stealth. */
  moveThresholdSpeed: number;
}

/** StealthForbiddenConditions bitmask values — matches C++ TheStealthLevelNames array ordering. */
const STEALTH_FORBIDDEN_ATTACKING        = 1 << 0; // ATTACKING
const STEALTH_FORBIDDEN_MOVING           = 1 << 1; // MOVING
const STEALTH_FORBIDDEN_USING_ABILITY    = 1 << 2; // USING_ABILITY
const STEALTH_FORBIDDEN_FIRING_PRIMARY   = 1 << 3; // FIRING_PRIMARY
const STEALTH_FORBIDDEN_FIRING_SECONDARY = 1 << 4; // FIRING_SECONDARY
const STEALTH_FORBIDDEN_FIRING_TERTIARY  = 1 << 5; // FIRING_TERTIARY
const STEALTH_FORBIDDEN_NO_BLACK_MARKET  = 1 << 6; // NO_BLACK_MARKET
const STEALTH_FORBIDDEN_TAKING_DAMAGE    = 1 << 7; // TAKING_DAMAGE
const STEALTH_FORBIDDEN_RIDERS_ATTACKING = 1 << 8; // RIDERS_ATTACKING

/** Source parity: default forbidden conditions — attacking and any movement. */
const STEALTH_FORBIDDEN_DEFAULT = STEALTH_FORBIDDEN_ATTACKING | STEALTH_FORBIDDEN_MOVING;

/**
 * Source parity: StealthDetectorUpdate module parsed from INI.
 * Range-based detection of stealthed enemy entities.
 */
interface DetectorProfile {
  /** Detection range override. 0 = use entity's visionRange. */
  detectionRange: number;
  /** Frames between detection scans (throttle). */
  detectionRate: number;
  /** Can detect while garrisoned inside a building. */
  canDetectWhileGarrisoned: boolean;
  /** Can detect while contained in a transport. */
  canDetectWhileContained: boolean;
  /** Only detect entities with these KindOf flags. Empty = all. */
  extraRequiredKindOf: Set<string>;
  /** Don't detect entities with these KindOf flags. Empty = no filter. */
  extraForbiddenKindOf: Set<string>;
}

/**
 * Source parity: CreateCrateDie — spawns a crate object on unit death.
 * C++ uses CrateSystem templates, but we simplify to a direct template name.
 */
interface CreateCrateDieProfile {
  /** Object template name of the crate to spawn. */
  crateTemplateName: string;
}

/**
 * Source parity: SalvageCrateCollide — collide handler that grants weapon upgrades,
 * veterancy, or money when a KINDOF_SALVAGER unit collects the crate.
 */
interface SalvageCrateProfile {
  /** Probability weapon upgrade succeeds (default 1.0). */
  weaponChance: number;
  /** Probability level gain succeeds if weapon fails (default 0.25). */
  levelChance: number;
  /** Minimum money if both weapon and level fail (default 25). */
  minMoney: number;
  /** Maximum money if both weapon and level fail (default 75). */
  maxMoney: number;
}

/**
 * Source parity: CrateCollide hierarchy — general crate collection profiles.
 * Parsed from Behavior blocks on crate object templates.
 *   HealCrateCollide — heals all units of collector's side
 *   MoneyCrateCollide — deposits credits to collector's side
 *   VeterancyCrateCollide — grants veterancy levels
 *   ShroudCrateCollide — reveals entire map for collector's player
 *   UnitCrateCollide — spawns N units nearby
 */
type CrateCollideType = 'HEAL' | 'MONEY' | 'VETERANCY' | 'SHROUD' | 'UNIT';

interface CrateCollideProfile {
  crateType: CrateCollideType;
  /** KindOf requirements for collector (empty = any unit). */
  requiredKindOf: string[];
  /** KindOf exclusions (collector must NOT have any of these). */
  forbiddenKindOf: string[];
  /** Dead unit's team cannot collect this crate. */
  forbidOwnerPlayer: boolean;
  /** Buildings can collect this crate (bypasses movement requirement). */
  buildingPickup: boolean;
  /** Only human players can collect. */
  humanOnly: boolean;
  // Crate-specific parameters:
  /** MoneyCrateCollide: amount to deposit. */
  moneyProvided: number;
  /** UnitCrateCollide: template name. */
  unitType: string;
  /** UnitCrateCollide: number of units to spawn. */
  unitCount: number;
  /** VeterancyCrateCollide: area of effect radius (0 = single unit). */
  veterancyRange: number;
  /** VeterancyCrateCollide: if true, gain levels = crate's vet level; else always 1. */
  addsOwnerVeterancy: boolean;
  /** VeterancyCrateCollide: pilot mode restrictions. */
  isPilot: boolean;
}

/**
 * Source parity: MinefieldBehavior module parsed from INI.
 * Mines detonate on collision with enemy objects.
 */
interface MinefieldProfile {
  /** Weapon fired at detonation point. */
  detonationWeaponName: string | null;
  /** Relationship bitmask: who triggers the mine. Default: ENEMIES | NEUTRAL. */
  detonatedByMask: number;
  /** Number of virtual mines (charges) before the mine object is destroyed. */
  numVirtualMines: number;
  /** Whether mines regenerate after detonation (health-proportional). */
  regenerates: boolean;
  /** Workers (infantry+dozer) don't detonate mines by default. */
  workersDetonate: boolean;
  /** Minimum distance a repeat detonator must move before triggering again. */
  repeatDetonateMoveThresh: number;
  /** Whether regen stops when the creator building dies. */
  stopsRegenAfterCreatorDies: boolean;
  /** Health drain percent per second after creator dies (0 = no drain). */
  degenPercentPerSecondAfterCreatorDies: number;
  /** Scoot animation time in frames (0 = instant placement). */
  scootFromStartingPointTimeFrames: number;
}

// Relationship bitmask constants for MinefieldBehavior DetonatedBy.
const MINE_DETONATED_BY_ALLIES = 1 << 0;
const MINE_DETONATED_BY_ENEMIES = 1 << 1;
const MINE_DETONATED_BY_NEUTRAL = 1 << 2;
const MINE_DEFAULT_DETONATED_BY = MINE_DETONATED_BY_ENEMIES | MINE_DETONATED_BY_NEUTRAL;

/** Maximum immune entries per mine (matches C++ MAX_IMMUNITY = 3). */
const MINE_MAX_IMMUNITY = 3;

interface MineImmuneEntry {
  entityId: number;
  collideFrame: number;
}

interface MineDetonatorEntry {
  entityId: number;
  x: number;
  z: number;
}

/**
 * Source parity: DeployStyleAIUpdate — deploy/undeploy state machine for units that must
 * deploy to attack and pack to move (artillery, mortars, gatling cannons).
 */
type DeployState = 'READY_TO_MOVE' | 'DEPLOY' | 'READY_TO_ATTACK' | 'UNDEPLOY';

interface DeployStyleProfile {
  unpackTimeFrames: number;
  packTimeFrames: number;
  turretsFunctionOnlyWhenDeployed: boolean;
}

/**
 * Source parity: BattlePlanUpdate — USA Strategy Center battle plan system.
 * Three plans (Bombardment, Hold the Line, Search and Destroy) provide
 * faction-wide weapon bonus flags, armor scaling, and sight range bonuses.
 */
interface BattlePlanProfile {
  bombardmentAnimationFrames: number;
  holdTheLineAnimationFrames: number;
  searchAndDestroyAnimationFrames: number;
  transitionIdleFrames: number;
  battlePlanParalyzeFrames: number;
  holdTheLineArmorDamageScalar: number;
  searchAndDestroySightRangeScalar: number;
  strategyCenterSearchAndDestroySightRangeScalar: number;
  strategyCenterSearchAndDestroyDetectsStealth: boolean;
  strategyCenterHoldTheLineMaxHealthScalar: number;
  validMemberKindOf: Set<string>;
  invalidMemberKindOf: Set<string>;
}

type BattlePlanType = 'NONE' | 'BOMBARDMENT' | 'HOLDTHELINE' | 'SEARCHANDDESTROY';
type BattlePlanTransitionStatus = 'IDLE' | 'UNPACKING' | 'ACTIVE' | 'PACKING';

interface BattlePlanRuntimeState {
  desiredPlan: BattlePlanType;
  activePlan: BattlePlanType;
  transitionStatus: BattlePlanTransitionStatus;
  transitionFinishFrame: number;
  idleCooldownFinishFrame: number;
}

/**
 * Per-side battle plan bonus tracking for multiplicative stacking.
 */
interface SideBattlePlanBonuses {
  bombardmentCount: number;
  holdTheLineCount: number;
  searchAndDestroyCount: number;
}

/**
 * Source parity: GenerateMinefieldBehavior — spawns mine entities around an object.
 */
interface GenerateMinefieldProfile {
  mineName: string;
  distanceAroundObject: number;
  borderOnly: boolean;
  alwaysCircular: boolean;
  generateOnlyOnDeath: boolean;
}

/**
 * Source parity: FireWeaponWhenDamagedBehavior — fires weapons when entity takes damage.
 * Reaction weapons fire once per damage event; continuous weapons fire every frame.
 */
interface FireWhenDamagedProfile {
  reactionWeapons: [string | null, string | null, string | null, string | null];
  continuousWeapons: [string | null, string | null, string | null, string | null];
  damageAmount: number;
  // Source parity: per-weapon cooldown — each Weapon instance tracks m_whenWeCanFireAgain.
  reactionNextFireFrame: [number, number, number, number];
  continuousNextFireFrame: [number, number, number, number];
}

/**
 * Source parity: FireWeaponUpdate — autonomous weapon that fires at own position every frame.
 * Used for things like poison fields, area denial weapons, persistent effects.
 */
interface FireWeaponUpdateProfile {
  /** Weapon template name to fire. */
  weaponName: string;
  /** Delay in logic frames before first fire after entity creation. */
  initialDelayFrames: number;
  /** If > 0, suppress this module for this many frames after entity fires a normal weapon. */
  exclusiveWeaponDelayFrames: number;
}

/**
 * Source parity: OCLUpdate module parsed from INI.
 * Periodically spawns objects via ObjectCreationList on a timer.
 * Used for supply drops, reinforcement spawns, beacon effects, etc.
 */
interface OCLUpdateProfile {
  /** OCL name to execute (non-faction-triggered mode). */
  oclName: string;
  /** Minimum delay in logic frames between OCL spawns. */
  minDelayFrames: number;
  /** Maximum delay in logic frames between OCL spawns. */
  maxDelayFrames: number;
}

/**
 * Source parity: WeaponBonusUpdate module parsed from INI.
 * Periodically applies a temporary weapon bonus condition to nearby allied units.
 * Used by Propaganda Towers, Frenzy generals ability, etc.
 */
interface WeaponBonusUpdateProfile {
  /** KindOf flags that must be present on target. Empty = match all. */
  requiredKindOf: Set<string>;
  /** KindOf flags that must NOT be present on target. Empty = no exclusion. */
  forbiddenKindOf: Set<string>;
  /** How long the bonus lasts on each target (logic frames). */
  bonusDurationFrames: number;
  /** How often to pulse/scan (logic frames). */
  bonusDelayFrames: number;
  /** Range to scan for allied targets (world units). */
  bonusRange: number;
  /** Bitmask flag to apply (from WEAPON_BONUS_CONDITION_BY_NAME). */
  bonusConditionFlag: number;
}

/**
 * Source parity: PointDefenseLaserUpdate module parsed from INI.
 * Autonomous anti-projectile defense that scans for incoming missiles/aircraft
 * and fires a defensive weapon to intercept them.
 */
interface PointDefenseLaserProfile {
  /** Weapon template name to fire at targets. */
  weaponName: string;
  /** Primary target kindOf set (e.g. SMALL_MISSILE). */
  primaryTargetKindOf: Set<string>;
  /** Secondary target kindOf set (fallback targets). */
  secondaryTargetKindOf: Set<string>;
  /** Frames between expensive target scans. */
  scanRate: number;
  /** Scan search radius (world units). */
  scanRange: number;
  /** Velocity prediction factor for out-of-range targets. */
  predictTargetVelocityFactor: number;
}

/**
 * Source parity: HordeUpdate module — passive formation bonus for grouped units.
 * When enough nearby units match the kindOf filter, the HORDE weapon bonus
 * condition is set, granting damage/rate bonuses from the global weapon bonus table.
 */
interface HordeUpdateProfile {
  /** Frames between expensive spatial scans. */
  updateRate: number;
  /** KindOf flags that count toward horde membership. */
  kindOf: Set<string>;
  /** Minimum count of nearby matching units (including self) for horde status. */
  minCount: number;
  /** Scan radius for counting nearby units (world units). */
  minDist: number;
  /** Source parity: RubOffRadius — inherit horde status from a nearby true horde member. */
  rubOffRadius: number;
  /** Only allied units count toward horde membership. */
  alliesOnly: boolean;
  /** Only exact-match template types count. */
  exactMatch: boolean;
  /** Allow NATIONALISM weapon bonus when in horde. */
  allowedNationalism: boolean;
}

/**
 * Source parity: DemoTrapUpdateModuleData — demo trap detonation profile.
 */
interface DemoTrapProfile {
  /** Whether the trap starts in proximity (auto-scan) mode vs manual-only. */
  defaultsToProximityMode: boolean;
  /** Proximity detection radius (world units, 2D center-to-center). */
  triggerDetonationRange: number;
  /** KindOf flags for objects to skip during scanning. */
  ignoreKindOf: Set<string>;
  /** Frames between proximity scans. */
  scanFrames: number;
  /** If true, detonates even with friendly units nearby. */
  friendlyDetonation: boolean;
  /** Weapon template name fired at own position on detonation. */
  detonationWeaponName: string | null;
  /** Whether the trap detonates when killed. */
  detonateWhenKilled: boolean;
}

/**
 * Source parity: RebuildHoleExposeDieModuleData — die module on buildings that
 * creates a rebuild hole when the building is destroyed.
 */
interface RebuildHoleExposeDieProfile {
  /** Template name of the hole object to create on building death. */
  holeName: string;
  /** Max health for the created hole object. */
  holeMaxHealth: number;
  /** Whether to redirect attackers from dead building to hole. */
  transferAttackers: boolean;
}

/**
 * Source parity: RebuildHoleBehaviorModuleData — update module on hole objects
 * that manages the worker-spawn → reconstruct → complete lifecycle.
 */
interface RebuildHoleBehaviorProfile {
  /** Template name of the worker unit that performs reconstruction. */
  workerObjectName: string;
  /** Delay frames before worker respawns after death. */
  workerRespawnDelay: number;
  /** Hole health regeneration as fraction of maxHealth per second (e.g. 0.1 = 10%). */
  holeHealthRegenPercentPerSecond: number;
}

/**
 * Source parity: AutoDepositUpdateModuleData — periodic income module on buildings.
 * Deposits money at fixed intervals. Used by supply centers, oil derricks, etc.
 */
interface AutoDepositProfile {
  /** Frames between deposits. Source parity: DepositTiming (parsed as duration ms → frames). */
  depositFrames: number;
  /** Cash amount per deposit. Source parity: DepositAmount. */
  depositAmount: number;
  /** One-time bonus deposited when a neutral building is captured. Source parity: InitialCaptureBonus. */
  initialCaptureBonus: number;
}

/**
 * Source parity: SlavedUpdateModuleData — slave side behavior for following master.
 */
interface SlavedUpdateProfile {
  /** Max distance from master when idle (guard radius). */
  guardMaxRange: number;
  /** Random wander radius while guarding. */
  guardWanderRange: number;
  /** Max distance from master when master is attacking. */
  attackRange: number;
  /** Random wander radius around attack position. */
  attackWanderRange: number;
  /** Max distance ahead of master when scouting. */
  scoutRange: number;
  /** Random wander radius around scout position. */
  scoutWanderRange: number;
  /** Distance to target to grant DRONE_SPOTTING bonus. */
  distToTargetToGrantRangeBonus: number;
  /** HP per second the slave heals its master (0 = no repair). */
  repairRatePerSecond: number;
  /** Master health % threshold for emergency repair priority. */
  repairWhenBelowHealthPercent: number;
  /** If true, slave is forced to same pathfinding layer as master. */
  stayOnSameLayerAsMaster: boolean;
}

/**
 * Source parity: CountermeasuresBehavior — aircraft flare/countermeasure defense.
 * (GeneralsMD/Code/GameEngine/Include/GameLogic/Module/CountermeasuresBehavior.h)
 */
interface CountermeasuresProfile {
  /** ThingTemplate name of the flare object. */
  flareTemplateName: string;
  /** Number of flares per volley. */
  volleySize: number;
  /** Half-angle spread in radians for distributing flares. */
  volleyArcAngle: number;
  /** Velocity multiplier for flare launch speed. */
  volleyVelocityFactor: number;
  /** Frames between successive volleys. */
  framesBetweenVolleys: number;
  /** Total number of volleys before reload needed. */
  numberOfVolleys: number;
  /** Frames for auto-reload (0 = must reload at airfield). */
  reloadFrames: number;
  /** Probability [0..1] that incoming missile is diverted. */
  evasionRate: number;
  /** Frames before missile diverts to flare (must > reactionFrames). */
  missileDecoyFrames: number;
  /** Frames of delay before first volley after detecting missile. */
  reactionFrames: number;
}

/** Source parity: CountermeasuresBehavior runtime state per entity. */
interface CountermeasuresState {
  /** Total countermeasures available to launch. */
  availableCountermeasures: number;
  /** Number of active flare objects in world. */
  activeCountermeasures: number;
  /** Active flare IDs. */
  flareIds: number[];
  /** Frame when first volley will launch (0 = not waiting). */
  reactionFrame: number;
  /** Frame when next volley fires (0 = not scheduled). */
  nextVolleyFrame: number;
  /** Frame when auto-reload completes (0 = not reloading). */
  reloadFrame: number;
  /** Source parity: lifetime count of all missiles fired at this entity. */
  incomingMissiles: number;
  /** Source parity: lifetime count of missiles marked for diversion. */
  divertedMissiles: number;
}

/**
 * Source parity: ToppleUpdateModuleData — tree/pole toppling on damage/crush.
 * (Generals/Code/GameEngine/Include/GameLogic/Module/ToppleUpdate.h)
 */
interface ToppleProfile {
  /** Initial angular velocity multiplier (fraction of topple speed). */
  initialVelocityPercent: number;
  /** Angular acceleration multiplier (fraction of topple speed). */
  initialAccelPercent: number;
  /** Velocity retained after bounce (fraction). */
  bounceVelocityPercent: number;
  /** Kill entity when topple completes (default true). */
  killWhenFinishedToppling: boolean;
  /** Kill entity instantly when topple starts. */
  killWhenStartToppling: boolean;
  /** Constrain topple to left/right only (fences). */
  toppleLeftOrRightOnly: boolean;
}

type ToppleState = 'NONE' | 'TOPPLING' | 'BOUNCING' | 'DONE';

/**
 * Source parity: PilotFindVehicleUpdateModuleData — AI pilot auto-enter vehicle behavior.
 * (Generals/Code/GameEngine/Include/GameLogic/Module/PilotFindVehicleUpdate.h)
 */
interface PilotFindVehicleProfile {
  /** Frames between scan attempts. */
  scanFrames: number;
  /** Search radius around the pilot. */
  scanRange: number;
  /** Min health ratio (0..1) — vehicles below this ratio are rejected as too damaged. */
  minHealth: number;
}

/** Source parity: SlavedUpdate constants. */
const SLAVED_UPDATE_RATE = 8; // LOGICFRAMES_PER_SECOND / 4 ≈ 7.5, round to 8
const STRAY_MULTIPLIER = 2.0;
const SLAVE_CLOSE_ENOUGH = 15.0;

// Body damage state thresholds (source parity: GlobalData defaults).
const UNIT_DAMAGED_THRESH = 0.5;
const UNIT_REALLY_DAMAGED_THRESH = 0.1;

type BodyDamageState = 0 | 1 | 2 | 3; // PRISTINE=0, DAMAGED=1, REALLYDAMAGED=2, RUBBLE=3

/**
 * Source parity: Body module types from C++ hierarchy.
 *   ActiveBody — standard health system (default)
 *   StructureBody — extends ActiveBody for buildings (functionally same for damage)
 *   HighlanderBody — caps damage at health-1 for non-UNRESISTABLE damage (can only die from UNRESISTABLE)
 *   ImmortalBody — health never drops below 1 (cannot die from any damage)
 *   InactiveBody — no health, ignores all damage (except UNRESISTABLE triggers death)
 *   HiveStructureBody — redirects specified damage types to spawn slaves when they exist
 *   UndeadBody — first fatal hit caps damage to 1HP, triggers second life with reduced max health
 */
type BodyModuleType = 'ACTIVE' | 'STRUCTURE' | 'HIGHLANDER' | 'IMMORTAL' | 'INACTIVE' | 'HIVE_STRUCTURE' | 'UNDEAD';

function calcBodyDamageState(health: number, maxHealth: number): BodyDamageState {
  if (maxHealth <= 0) return 0;
  const ratio = health / maxHealth;
  if (ratio > UNIT_DAMAGED_THRESH) return 0;
  if (ratio > UNIT_REALLY_DAMAGED_THRESH) return 1;
  if (ratio > 0) return 2;
  return 3;
}

/**
 * Source parity: IsSubdualDamage — does this damage type deal subdual (stun) damage?
 * C++ file: Damage.h:119-131. These damage types accumulate subdual damage on the
 * target body instead of reducing health.
 */
function isSubdualDamage(damageType: string): boolean {
  switch (damageType.toUpperCase()) {
    case 'SUBDUAL_MISSILE':
    case 'SUBDUAL_VEHICLE':
    case 'SUBDUAL_BUILDING':
    case 'SUBDUAL_UNRESISTABLE':
      return true;
    default:
      return false;
  }
}

/**
 * Source parity: IsHealthDamagingDamage — does this damage type affect health?
 * C++ file: Damage.h:134-151. Returns false for non-health damage types
 * (STATUS, SUBDUAL_*, KILLPILOT, KILL_GARRISONED) which cause special effects
 * instead of reducing health.
 */
function isHealthDamagingDamage(damageType: string): boolean {
  switch (damageType.toUpperCase()) {
    case 'STATUS':
    case 'SUBDUAL_MISSILE':
    case 'SUBDUAL_VEHICLE':
    case 'SUBDUAL_BUILDING':
    case 'SUBDUAL_UNRESISTABLE':
    case 'KILLPILOT':
    case 'KILL_GARRISONED':
      return false;
    default:
      return true;
  }
}

/**
 * Source parity: DamageInfo.in.m_deathType — fallback mapping from damage type.
 * C++ weapons carry their own DeathType field (Weapon.h m_deathType, default DEATH_NORMAL).
 * This function is used as a fallback for non-weapon damage sources (crush, topple, etc.).
 * When a weapon fires, prefer the weapon's explicit DeathType over this mapping.
 */
function damageTypeToDeathType(damageType: string): string {
  switch (damageType.toUpperCase()) {
    case 'CRUSH': return 'CRUSHED';
    case 'POISON': return 'POISONED';
    case 'POISON_BETA': return 'POISONED_BETA';
    case 'FLAME': case 'PARTICLE_BEAM': return 'BURNED';
    case 'EXPLOSION': return 'EXPLODED';
    case 'LASER': return 'LASERED';
    case 'TOPPLING': return 'TOPPLED';
    case 'WATER': return 'FLOODED';
    case 'SUICIDE': return 'SUICIDED';
    case 'DETONATION': return 'DETONATED';
    case 'FALLING': return 'SPLATTED';
    default: return 'NORMAL';
  }
}

/**
 * Source parity: SlowDeathBehavior module parsed from INI.
 * Controls phased death sequences with configurable timing, effects, and sinking.
 */
interface SlowDeathProfile {
  /** Weighting for this death behavior when multiple are applicable. */
  probabilityModifier: number;
  /** Extra probability per % overkill damage. */
  modifierBonusPerOverkillPercent: number;
  /** Frames before sinking begins. */
  sinkDelay: number;
  /** Random variance in sink delay. */
  sinkDelayVariance: number;
  /** Units per frame to sink (0 = no sinking). */
  sinkRate: number;
  /** Frames until final destruction. */
  destructionDelay: number;
  /** Random variance in destruction delay. */
  destructionDelayVariance: number;
  /** Z-coordinate threshold for destruction (default: -10). */
  destructionAltitude: number;
  /** Which death types trigger this behavior (empty = ALL). */
  deathTypes: Set<string>;
  /** Which veterancy levels allow this (empty = ALL). */
  veterancyLevels: Set<string>;
  /** Status flags that exempt this behavior. */
  exemptStatus: Set<string>;
  /** Status flags required for this behavior. */
  requiredStatus: Set<string>;
  /** OCL names to execute at each phase (INITIAL=0, MIDPOINT=1, FINAL=2). */
  phaseOCLs: [string[], string[], string[]];
  /** Weapon names to fire at each phase. */
  phaseWeapons: [string[], string[], string[]];
}

/**
 * Source parity: CreateObjectDie / SlowDeathBehavior — death OCL entry with DieMuxData
 * filtering. C++ DieModule base class provides isDieApplicable checks.
 */
interface DeathOCLEntry {
  oclName: string;
  /** DieMuxData: which death types trigger this (empty = ALL). */
  deathTypes: Set<string>;
  /** DieMuxData: which veterancy levels allow this (empty = ALL). */
  veterancyLevels: Set<string>;
  /** DieMuxData: status flags that exempt this behavior. */
  exemptStatus: Set<string>;
  /** DieMuxData: status flags required for this behavior. */
  requiredStatus: Set<string>;
}

/**
 * Source parity: InstantDeathBehavior — die module that fires effects and instantly
 * destroys the entity. Multiple can exist per entity; each has DieMuxData filtering.
 * C++ file: InstantDeathBehavior.h / InstantDeathBehavior.cpp
 */
interface InstantDeathProfile {
  /** Which death types trigger this (empty = ALL). */
  deathTypes: Set<string>;
  /** Which veterancy levels allow this (empty = ALL). */
  veterancyLevels: Set<string>;
  /** Status flags that exempt this behavior. */
  exemptStatus: Set<string>;
  /** Status flags required for this behavior. */
  requiredStatus: Set<string>;
  /** Weapon template names to fire (one chosen randomly). */
  weaponNames: string[];
  /** OCL names to execute (one chosen randomly). */
  oclNames: string[];
}

/**
 * Source parity: FireWeaponWhenDeadBehavior — fires a weapon on death with
 * DieMuxData filtering and upgrade activation control.
 * C++ file: FireWeaponWhenDeadBehavior.cpp / FireWeaponWhenDeadBehavior.h.
 */
interface FireWeaponWhenDeadProfile {
  /** DieMuxData: which death types trigger this (empty = ALL). */
  deathTypes: Set<string>;
  /** DieMuxData: which veterancy levels allow this (empty = ALL). */
  veterancyLevels: Set<string>;
  /** DieMuxData: status flags that exempt this behavior. */
  exemptStatus: Set<string>;
  /** DieMuxData: status flags required for this behavior. */
  requiredStatus: Set<string>;
  /** Weapon template name to fire on death. */
  deathWeaponName: string;
  /** Source parity: StartsActive — if true, active without upgrade. */
  startsActive: boolean;
  /** Source parity: TriggeredBy — upgrade name(s) that activate this module. */
  triggeredBy: string[];
  /** Source parity: ConflictsWithTriggeredBy — upgrade name(s) that disable this module. */
  conflictsWith: string[];
}

/**
 * Source parity: RadarUpdate module parsed from INI.
 * Manages the radar dish extension animation timer.
 * Actual radar functionality is tracked via player-level radarCount.
 */
interface RadarUpdateProfile {
  /** Frames for the radar dish extension animation to complete. */
  radarExtendTimeFrames: number;
}

/**
 * Source parity: FloatUpdate module parsed from INI.
 * Snaps object Z to water surface each frame when enabled.
 */
interface FloatUpdateProfile {
  /** Whether water-surface snapping is enabled. */
  enabled: boolean;
}

interface SlowDeathRuntimeState {
  /** Index into the entity's slowDeathProfiles array. */
  profileIndex: number;
  /** Frame when sinking begins. */
  sinkFrame: number;
  /** Frame when midpoint phase triggers. */
  midpointFrame: number;
  /** Frame when final destruction occurs. */
  destructionFrame: number;
  /** Whether the midpoint phase has been executed. */
  midpointExecuted: boolean;
}

/**
 * Source parity: HelicopterSlowDeathBehavior — extended slow death for helicopters.
 * Adds spiral orbit, self-spin, gravity descent, blade fly-off, and ground impact.
 * C++ file: HelicopterSlowDeathUpdate.cpp (extends SlowDeathBehavior).
 */
interface HelicopterSlowDeathProfile {
  /** DieMuxData filtering. */
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
  /** Radians/frame to turn the spiral orbit circle. */
  spiralOrbitTurnRate: number;
  /** Initial forward speed in the spiral (units/frame). */
  spiralOrbitForwardSpeed: number;
  /** Forward speed multiplier per frame (0-1, 1 = no damping). */
  spiralOrbitForwardSpeedDamping: number;
  /** Minimum self-spin rate (rad/frame). */
  minSelfSpin: number;
  /** Maximum self-spin rate (rad/frame). */
  maxSelfSpin: number;
  /** Frames between self-spin rate updates. */
  selfSpinUpdateDelay: number;
  /** Amount to change self-spin rate per update (rad/s → rad/frame internally). */
  selfSpinUpdateAmount: number;
  /** Fraction of gravity applied for fall (0 = float, 1 = full gravity). */
  fallHowFast: number;
  /** Frames after ground hit before final explosion. */
  delayFromGroundToFinalDeath: number;
  /** OCL names to execute on ground hit. */
  oclHitGround: string[];
  /** OCL names to execute on final explosion. */
  oclFinalBlowUp: string[];
  /** Final rubble object template name. */
  finalRubbleObject: string;
}

interface HelicopterSlowDeathState {
  /** Forward angle of the spiral orbit (not the body heading). */
  forwardAngle: number;
  /** Current forward speed in the spiral. */
  forwardSpeed: number;
  /** Current vertical velocity (negative = falling). */
  verticalVelocity: number;
  /** Current self-spin rate (rad/frame). */
  selfSpin: number;
  /** Whether self-spin is increasing toward max (true) or decreasing toward min (false). */
  selfSpinTowardsMax: boolean;
  /** Frame when self-spin rate was last updated. */
  lastSelfSpinUpdateFrame: number;
  /** Orbit direction: 1 = left, -1 = right. */
  orbitDirection: number;
  /** Frame when the helicopter hit the ground (0 = still airborne). */
  hitGroundFrame: number;
  /** Index into helicopterSlowDeathProfiles for the applicable profile. */
  profileIndex: number;
}

/**
 * Source parity: JetSlowDeathBehavior — jet-specific death animation with roll, forward
 * motion, multi-stage FX timeline. C++ file: JetSlowDeathBehavior.cpp.
 * Extends SlowDeathBehavior: if jet dies on ground, instant destroy. If airborne,
 * keeps flying straight with roll decay, descends via gravity, hits ground, final explosion.
 */
interface JetSlowDeathProfile {
  /** DieMuxData filtering. */
  deathTypes: Set<string>;
  veterancyLevels: Set<string>;
  exemptStatus: Set<string>;
  requiredStatus: Set<string>;
  /** OCL names to execute if jet dies on ground (instant destroy). */
  oclOnGroundDeath: string[];
  /** OCL names to execute at start of airborne death. */
  oclInitialDeath: string[];
  /** Frames after initial death before secondary OCL fires. */
  delaySecondaryFromInitialDeath: number;
  /** OCL names for secondary effect (mid-descent). */
  oclSecondary: string[];
  /** OCL names when jet hits the ground. */
  oclHitGround: string[];
  /** Frames after ground impact before final explosion. */
  delayFinalBlowUpFromHitGround: number;
  /** OCL names for final explosion. */
  oclFinalBlowUp: string[];
  /** Initial roll rate (rad/frame). */
  rollRate: number;
  /** Multiplier applied to roll rate each frame (1.0 = constant, <1 = damping). */
  rollRateDelta: number;
  /** Pitch rate applied after hitting ground (rad/frame). */
  pitchRate: number;
  /** Fall speed fraction: 0 = slow fall (full lift), 1 = fast fall (no lift). */
  fallHowFast: number;
}

interface JetSlowDeathState {
  /** Frame when death sequence began. */
  deathFrame: number;
  /** Frame when jet hit ground (0 = still airborne). */
  groundFrame: number;
  /** Current roll rate (decays each frame by rollRateDelta). */
  rollRate: number;
  /** Accumulated roll angle for visual rendering. */
  rollAngle: number;
  /** Accumulated pitch angle (after ground impact). */
  pitchAngle: number;
  /** Forward speed at time of death (units/frame). */
  forwardSpeed: number;
  /** Heading at time of death (radians). */
  forwardAngle: number;
  /** Current vertical velocity (negative = falling). */
  verticalVelocity: number;
  /** Whether secondary OCL has been executed. */
  secondaryExecuted: boolean;
  /** Index into jetSlowDeathProfiles. */
  profileIndex: number;
}

/**
 * Source parity: CleanupHazardUpdate — workers passively scan for nearby CLEANUP_HAZARD
 * entities and auto-attack them. C++ file: CleanupHazardUpdate.cpp.
 */
interface CleanupHazardProfile {
  /** Weapon slot used for cleanup (e.g., PRIMARY, SECONDARY). */
  weaponSlot: string;
  /** Frames between scans for hazard targets. */
  scanFrames: number;
  /** Range to scan for hazard targets (units). */
  scanRange: number;
}

interface CleanupHazardState {
  /** Entity ID of the current cleanup target (0 = none). */
  bestTargetId: number;
  /** Countdown frames until next scan. */
  nextScanFrame: number;
  /** Whether target was in firing range last check. */
  inRange: boolean;
  /** C++ parity: m_nextShotAvailableInFrames — per-shot cooldown counter. */
  nextShotAvailableFrame: number;
}

/**
 * Source parity: AssistedTargetingUpdate — laser designation system.
 * Allows a unit to be told to assist-attack a target by another unit.
 * C++ file: AssistedTargetingUpdate.cpp.
 */
interface AssistedTargetingProfile {
  /** Clip size for assisted attacks. */
  clipSize: number;
  /** Weapon slot to lock when assisting. */
  weaponSlot: string;
  /** Laser template for line from assister to self. */
  laserFromAssisted: string;
  /** Laser template for line from self to target. */
  laserToTarget: string;
}

/** Source parity: SlowDeathBehavior midpoint is randomly placed between 35-65% of destruction time. */
const SLOW_DEATH_BEGIN_MIDPOINT_RATIO = 0.35;
const SLOW_DEATH_END_MIDPOINT_RATIO = 0.65;

/**
 * Source parity: StructureCollapseUpdate — building collapse die module with gravity-based
 * sinking and phased OCL/FX spawning. C++ file: StructureCollapseUpdate.h/cpp.
 * 4 phases: INITIAL (on die), DELAY (small bursts), BURST (big bursts), FINAL (collapse done).
 */
interface StructureCollapseProfile {
  /** DieMuxData: which death types trigger this (empty = ALL). */
  deathTypes: Set<string>;
  /** DieMuxData: which veterancy levels allow this (empty = ALL). */
  veterancyLevels: Set<string>;
  /** DieMuxData: status flags that exempt this behavior. */
  exemptStatus: Set<string>;
  /** DieMuxData: status flags required for this behavior. */
  requiredStatus: Set<string>;
  /** Min frames of dramatic pause before collapse starts. */
  minCollapseDelay: number;
  /** Max frames of dramatic pause before collapse starts. */
  maxCollapseDelay: number;
  /** Min frames between burst OCL events during collapse. */
  minBurstDelay: number;
  /** Max frames between burst OCL events during collapse. */
  maxBurstDelay: number;
  /** Gravity damping factor (0.0 = full gravity, 1.0 = no gravity). */
  collapseDamping: number;
  /** 1 in N chance that a burst is "big" (BURST phase) vs "small" (DELAY phase). */
  bigBurstFrequency: number;
  /** OCL names per phase: [INITIAL, DELAY, BURST, FINAL]. */
  phaseOCLs: [string[], string[], string[], string[]];
}

type StructureCollapseState = 'WAITING' | 'COLLAPSING' | 'DONE';

interface StructureCollapseRuntimeState {
  state: StructureCollapseState;
  /** Frame when collapse transition from WAITING to COLLAPSING happens. */
  collapseFrame: number;
  /** Frame when next burst OCL fires during COLLAPSING state. */
  burstFrame: number;
  /** Current downward displacement (negative = below original position). */
  currentHeight: number;
  /** Current downward velocity (increases each frame due to gravity). */
  collapseVelocity: number;
}

/** Source parity: GlobalData::m_gravity = -1.0f */
const SOURCE_DEFAULT_GRAVITY = -1.0;

/** Source parity: GlobalData::m_gravity = -1.0f */
const STRUCTURE_COLLAPSE_GRAVITY = SOURCE_DEFAULT_GRAVITY;

/** Source parity: gravity for helicopter slow death fall. */
const HELICOPTER_GRAVITY = SOURCE_DEFAULT_GRAVITY;

/** Source parity: ChinookAIUpdateModuleData constructor default for m_rappelSpeed. */
const DEFAULT_CHINOOK_RAPPEL_SPEED = Math.abs(SOURCE_DEFAULT_GRAVITY) * LOGIC_FRAME_RATE * 0.5;

/**
 * Source parity: EMPUpdate — electromagnetic pulse field that grows, disables nearby entities,
 * and fades. C++ file: EMPUpdate.h/cpp. Attached to the EMP pulse object spawned by OCL/special power.
 */
interface EMPUpdateProfile {
  /** Lifetime in logic frames — entity self-destructs at this frame offset from creation. */
  lifetimeFrames: number;
  /** Frame offset from creation when the fade begins and the disable attack fires. */
  startFadeFrame: number;
  /** Duration in frames that affected objects remain DISABLED_EMP. */
  disabledDurationFrames: number;
  /** Radius in which objects are disabled. */
  effectRadius: number;
  /** If true, the EMP does not affect the owner's own STRUCTURE entities. */
  doesNotAffectMyOwnBuildings: boolean;
  /** Required kindOf flags for targets (empty = all). */
  victimRequiredKindOf: Set<string>;
  /** Forbidden kindOf flags for targets. */
  victimForbiddenKindOf: Set<string>;
}

interface EMPUpdateRuntimeState {
  /** Frame at which the EMP pulse self-destructs. */
  dieFrame: number;
  /** Frame at which the disable attack fires (= creation + startFadeFrame). */
  fadeFrame: number;
  /** Whether the disable attack has already fired. */
  disableAttackFired: boolean;
}

/**
 * Source parity: LeafletDropBehavior — delayed radius-based disable that only affects enemy
 * infantry and vehicles. C++ file: EMPUpdate.h/cpp (same file as EMPUpdate).
 */
interface LeafletDropProfile {
  /** Delay in frames before the disable attack fires. */
  delayFrames: number;
  /** Duration in frames that affected objects remain DISABLED_EMP. */
  disabledDurationFrames: number;
  /** Radius for scanning victims. */
  affectRadius: number;
}

interface LeafletDropRuntimeState {
  /** Frame when the disable attack fires. */
  startFrame: number;
  /** Whether the disable attack has already fired. */
  fired: boolean;
}

/**
 * Source parity: HijackerUpdate — allows a hijacker unit to hide inside a hijacked vehicle,
 * sync position+veterancy, and eject when the vehicle is destroyed.
 * C++ file: HijackerUpdate.h/cpp.
 */
interface HijackerUpdateProfile {
  /** Template name for the parachute container to create when ejecting while airborne. */
  parachuteName: string | null;
}

interface HijackerRuntimeState {
  /** Entity ID of the hijacked vehicle. */
  targetId: number;
  /** Whether the hijacker is currently hidden inside the vehicle. */
  isInVehicle: boolean;
  /** Whether the vehicle was airborne at last check (for parachute eject). */
  wasTargetAirborne: boolean;
  /** Eject position (vehicle's position when last seen alive). */
  ejectX: number;
  ejectY: number;
  ejectZ: number;
}

/**
 * Source parity: SmartBombTargetHomingUpdate — gently adjusts a falling object's XZ position
 * toward its designated target coordinate each frame while airborne.
 * C++ file: SmartBombTargetHomingUpdate.h/cpp.
 */
interface SmartBombTargetHomingProfile {
  /** Blend factor: 0 = snap to target, 1 = no correction, default 0.99. */
  courseCorrectionScalar: number;
}

interface SmartBombTargetHomingState {
  /** Whether a target has been received via SetTargetPosition. */
  targetReceived: boolean;
  /** Target X world coordinate (horizontal). */
  targetX: number;
  /** Target Z world coordinate (horizontal depth). */
  targetZ: number;
}

/**
 * Source parity: DynamicGeometryInfoUpdate — morphs collision geometry over time.
 * C++ file: DynamicGeometryInfoUpdate.cpp.
 */
interface DynamicGeometryInfoUpdateProfile {
  initialDelayFrames: number;
  initialHeight: number;
  initialMajorRadius: number;
  initialMinorRadius: number;
  finalHeight: number;
  finalMajorRadius: number;
  finalMinorRadius: number;
  transitionTimeFrames: number;
  reverseAtTransitionTime: boolean;
}

interface DynamicGeometryInfoUpdateState {
  delayCountdown: number;
  started: boolean;
  finished: boolean;
  timeActive: number;
  /** Current initial values (may be swapped on reverse). */
  initialHeight: number;
  initialMajorRadius: number;
  initialMinorRadius: number;
  finalHeight: number;
  finalMajorRadius: number;
  finalMinorRadius: number;
  /** Whether reverse has been triggered (only once). */
  reverseAtTransitionTime: boolean;
}

/**
 * Source parity: FireOCLAfterWeaponCooldownUpdate — fires an OCL when a tracked weapon
 * stops shooting after enough consecutive shots. C++ file: FireOCLAfterWeaponCooldownUpdate.cpp.
 */
interface FireOCLAfterWeaponCooldownProfile {
  /** Which weapon slot to track (0 = PRIMARY, 1 = SECONDARY, 2 = TERTIARY). */
  weaponSlot: number;
  /** OCL template name to create. */
  oclName: string;
  /** Minimum consecutive shots required before OCL creation. */
  minShotsRequired: number;
  /** Lifetime scaling factor (ms of OCL lifetime per second of firing). */
  oclLifetimePerSecond: number;
  /** Maximum OCL lifetime in frames. */
  oclMaxFrames: number;
}

interface FireOCLAfterWeaponCooldownState {
  valid: boolean;
  consecutiveShots: number;
  startFrame: number;
}

/**
 * Source parity: NeutronBlastBehavior — death-triggered radius effect that kills infantry,
 * kills all contained units, and makes vehicles unmanned. Used by Neutron Mines/Shells.
 * C++ file: NeutronBlastBehavior.h/cpp.
 */
interface NeutronBlastProfile {
  /** Blast radius for scanning victims. Default 10. */
  blastRadius: number;
  /** Whether airborne aircraft are affected. Default true. */
  affectAirborne: boolean;
  /** Whether allied units are affected. Default true. */
  affectAllies: boolean;
}

/**
 * Source parity: BunkerBusterBehavior — death-triggered behavior that kills garrisoned
 * units inside a targeted building. The bomb tracks its victim (attackTarget) during flight,
 * then on death force-exits and damages all contained units in bustable containers.
 * C++ file: BunkerBusterBehavior.h/cpp.
 */
interface BunkerBusterProfile {
  /** Upgrade that must be completed by the owning player for the effect to trigger. Empty = no gate. */
  upgradeRequired: string;
  /** Weapon providing damageType/deathType for occupant damage. Empty = kill outright. */
  occupantDamageWeaponName: string;
  /** Weapon fired at detonation point for shockwave effect. Empty = none. */
  shockwaveWeaponName: string;
}

/**
 * Source parity: NeutronMissileSlowDeathBehavior — extends SlowDeathBehavior with
 * sequential timed blast waves for the China Nuke superweapon missile object.
 * Up to 9 blast rings with configurable delay, radius, damage falloff, and topple.
 * Also fires "scorch blasts" at separate delays (visual BURNED model condition).
 * C++ file: NeutronMissileSlowDeathUpdate.h/cpp.
 */
interface NeutronMissileBlastInfo {
  enabled: boolean;
  /** Frames after activation before this blast fires. */
  delay: number;
  /** Frames after activation before this scorch blast fires. */
  scorchDelay: number;
  innerRadius: number;
  outerRadius: number;
  maxDamage: number;
  minDamage: number;
  toppleSpeed: number;
}

interface NeutronMissileSlowDeathProfile {
  blasts: NeutronMissileBlastInfo[];
}

interface NeutronMissileSlowDeathState {
  activationFrame: number;
  completedBlasts: boolean[];
  completedScorchBlasts: boolean[];
}

/**
 * Source parity: GrantStealthBehavior — expanding radius stealth grant.
 * Created by GPS Scrambler OCL. Each frame grows scan radius, grants stealth
 * to allied units with matching KindOf, then self-destructs at finalRadius.
 * C++ file: GrantStealthBehavior.cpp.
 */
interface GrantStealthProfile {
  startRadius: number;
  finalRadius: number;
  radiusGrowRate: number;
  /** KindOf filter for targets. null = all types. */
  kindOf: Set<string> | null;
}

/**
 * Source parity: TechBuildingBehavior — neutral buildings (oil derricks, hospitals, etc.)
 * that revert to neutral team on death so they can be recaptured.
 * C++ file: TechBuildingBehavior.cpp.
 */
interface TechBuildingBehaviorProfile {
  /** Source parity: PulseFXRate — visual-only (timer interval for FX pulse). */
  pulseFXRateFrames: number;
}

/**
 * Source parity: SupplyWarehouseCripplingBehavior — disables dock on REALLYDAMAGED,
 * self-heals after suppression delay. C++ file: SupplyWarehouseCripplingBehavior.cpp.
 */
interface SupplyWarehouseCripplingProfile {
  /** Frames after damage before healing can start. */
  selfHealSuppressionFrames: number;
  /** Frames between each heal tick. */
  selfHealDelayFrames: number;
  /** HP healed per tick. */
  selfHealAmount: number;
}

/** Source parity: PoisonedBehavior default INI values. */
const DEFAULT_POISON_DAMAGE_INTERVAL_FRAMES = 10; // ~0.33s at 30fps
const DEFAULT_POISON_DURATION_FRAMES = 90; // ~3s at 30fps

/** Source parity: FlammableUpdate default INI values. */
const DEFAULT_FLAME_DAMAGE_LIMIT = 20.0;
const DEFAULT_AFLAME_DAMAGE_AMOUNT = 5;

/** Global base regen config from GlobalData.ini. */
const BASE_REGEN_HEALTH_PERCENT_PER_SECOND = 0.02; // 2% per second default
const BASE_REGEN_DELAY_FRAMES = 60; // ~2s delay after damage before regen starts

const DEFAULT_GAME_LOGIC_CONFIG: Readonly<GameLogicConfig> = {
  renderUnknownObjects: true,
  defaultMoveSpeed: 18,
  terrainSnapSpeed: 6,
  attackUsesLineOfSight: true,
  sellPercentage: SOURCE_DEFAULT_SELL_PERCENTAGE,
  superweaponRestriction: 0,
  maxTunnelCapacity: 10,
};

const OBJECT_DONT_RENDER_FLAG = 0x100;

interface SideScoreState {
  structuresBuilt: number;
  moneySpent: number;
}

type ScriptComparisonType =
  | 'LESS_THAN'
  | 'LESS_EQUAL'
  | 'EQUAL'
  | 'GREATER_EQUAL'
  | 'GREATER'
  | 'NOT_EQUAL';

type ScriptComparisonInput = ScriptComparisonType | number;

type ScriptRelationshipInput =
  | EntityRelationship
  | 'REL_ENEMY'
  | 'REL_NEUTRAL'
  | 'REL_FRIEND'
  | 'ENEMY'
  | 'NEUTRAL'
  | 'FRIEND'
  | 'ALLY'
  | 'ALLIES'
  | number;

interface ScriptConditionCacheState {
  /** Source parity: Condition::m_customData (-1=false, 0=unknown, 1=true). */
  customData: -1 | 0 | 1;
  /** Source parity: Condition::m_customFrame. */
  customFrame: number;
}

interface ScriptNamedEvent {
  name: string;
  sourceEntityId: number;
}

interface ScriptMusicCompletedEvent {
  name: string;
  index: number;
}

interface ScriptTeamRecord {
  nameUpper: string;
  memberEntityIds: Set<number>;
  created: boolean;
  stateName: string;
  controllingSide: string | null;
}

interface ScriptCounterState {
  value: number;
  isCountdownTimer: boolean;
}

/**
 * Source parity: Condition::ConditionType enum order from Scripts.h.
 * Used to resolve numeric condition ids to canonical enum names.
 */
const SCRIPT_CONDITION_TYPE_NAMES_BY_INDEX = [
  'CONDITION_FALSE',
  'COUNTER',
  'FLAG',
  'CONDITION_TRUE',
  'TIMER_EXPIRED',
  'PLAYER_ALL_DESTROYED',
  'PLAYER_ALL_BUILDFACILITIES_DESTROYED',
  'TEAM_INSIDE_AREA_PARTIALLY',
  'TEAM_DESTROYED',
  'CAMERA_MOVEMENT_FINISHED',
  'TEAM_HAS_UNITS',
  'TEAM_STATE_IS',
  'TEAM_STATE_IS_NOT',
  'NAMED_INSIDE_AREA',
  'NAMED_OUTSIDE_AREA',
  'NAMED_DESTROYED',
  'NAMED_NOT_DESTROYED',
  'TEAM_INSIDE_AREA_ENTIRELY',
  'TEAM_OUTSIDE_AREA_ENTIRELY',
  'NAMED_ATTACKED_BY_OBJECTTYPE',
  'TEAM_ATTACKED_BY_OBJECTTYPE',
  'NAMED_ATTACKED_BY_PLAYER',
  'TEAM_ATTACKED_BY_PLAYER',
  'BUILT_BY_PLAYER',
  'NAMED_CREATED',
  'TEAM_CREATED',
  'PLAYER_HAS_CREDITS',
  'NAMED_DISCOVERED',
  'TEAM_DISCOVERED',
  'MISSION_ATTEMPTS',
  'NAMED_OWNED_BY_PLAYER',
  'TEAM_OWNED_BY_PLAYER',
  'PLAYER_HAS_N_OR_FEWER_BUILDINGS',
  'PLAYER_HAS_POWER',
  'NAMED_REACHED_WAYPOINTS_END',
  'TEAM_REACHED_WAYPOINTS_END',
  'NAMED_SELECTED',
  'NAMED_ENTERED_AREA',
  'NAMED_EXITED_AREA',
  'TEAM_ENTERED_AREA_ENTIRELY',
  'TEAM_ENTERED_AREA_PARTIALLY',
  'TEAM_EXITED_AREA_ENTIRELY',
  'TEAM_EXITED_AREA_PARTIALLY',
  'MULTIPLAYER_ALLIED_VICTORY',
  'MULTIPLAYER_ALLIED_DEFEAT',
  'MULTIPLAYER_PLAYER_DEFEAT',
  'PLAYER_HAS_NO_POWER',
  'HAS_FINISHED_VIDEO',
  'HAS_FINISHED_SPEECH',
  'HAS_FINISHED_AUDIO',
  'BUILDING_ENTERED_BY_PLAYER',
  'ENEMY_SIGHTED',
  'UNIT_HEALTH',
  'BRIDGE_REPAIRED',
  'BRIDGE_BROKEN',
  'NAMED_DYING',
  'NAMED_TOTALLY_DEAD',
  'PLAYER_HAS_OBJECT_COMPARISON',
  'OBSOLETE_SCRIPT_1',
  'OBSOLETE_SCRIPT_2',
  'PLAYER_TRIGGERED_SPECIAL_POWER',
  'PLAYER_COMPLETED_SPECIAL_POWER',
  'PLAYER_MIDWAY_SPECIAL_POWER',
  'PLAYER_TRIGGERED_SPECIAL_POWER_FROM_NAMED',
  'PLAYER_COMPLETED_SPECIAL_POWER_FROM_NAMED',
  'PLAYER_MIDWAY_SPECIAL_POWER_FROM_NAMED',
  'DEFUNCT_PLAYER_SELECTED_GENERAL',
  'DEFUNCT_PLAYER_SELECTED_GENERAL_FROM_NAMED',
  'PLAYER_BUILT_UPGRADE',
  'PLAYER_BUILT_UPGRADE_FROM_NAMED',
  'PLAYER_DESTROYED_N_BUILDINGS_PLAYER',
  'UNIT_COMPLETED_SEQUENTIAL_EXECUTION',
  'TEAM_COMPLETED_SEQUENTIAL_EXECUTION',
  'PLAYER_HAS_COMPARISON_UNIT_TYPE_IN_TRIGGER_AREA',
  'PLAYER_HAS_COMPARISON_UNIT_KIND_IN_TRIGGER_AREA',
  'UNIT_EMPTIED',
  'TYPE_SIGHTED',
  'NAMED_BUILDING_IS_EMPTY',
  'PLAYER_HAS_N_OR_FEWER_FACTION_BUILDINGS',
  'UNIT_HAS_OBJECT_STATUS',
  'TEAM_ALL_HAS_OBJECT_STATUS',
  'TEAM_SOME_HAVE_OBJECT_STATUS',
  'PLAYER_POWER_COMPARE_PERCENT',
  'PLAYER_EXCESS_POWER_COMPARE_VALUE',
  'SKIRMISH_SPECIAL_POWER_READY',
  'SKIRMISH_VALUE_IN_AREA',
  'SKIRMISH_PLAYER_FACTION',
  'SKIRMISH_SUPPLIES_VALUE_WITHIN_DISTANCE',
  'SKIRMISH_TECH_BUILDING_WITHIN_DISTANCE',
  'SKIRMISH_COMMAND_BUTTON_READY_ALL',
  'SKIRMISH_COMMAND_BUTTON_READY_PARTIAL',
  'SKIRMISH_UNOWNED_FACTION_UNIT_EXISTS',
  'SKIRMISH_PLAYER_HAS_PREREQUISITE_TO_BUILD',
  'SKIRMISH_PLAYER_HAS_COMPARISON_GARRISONED',
  'SKIRMISH_PLAYER_HAS_COMPARISON_CAPTURED_UNITS',
  'SKIRMISH_NAMED_AREA_EXIST',
  'SKIRMISH_PLAYER_HAS_UNITS_IN_AREA',
  'SKIRMISH_PLAYER_HAS_BEEN_ATTACKED_BY_PLAYER',
  'SKIRMISH_PLAYER_IS_OUTSIDE_AREA',
  'SKIRMISH_PLAYER_HAS_DISCOVERED_PLAYER',
  'PLAYER_ACQUIRED_SCIENCE',
  'PLAYER_HAS_SCIENCEPURCHASEPOINTS',
  'PLAYER_CAN_PURCHASE_SCIENCE',
  'MUSIC_TRACK_HAS_COMPLETED',
  'PLAYER_LOST_OBJECT_TYPE',
  'SUPPLY_SOURCE_SAFE',
  'SUPPLY_SOURCE_ATTACKED',
  'START_POSITION_IS',
  'NAMED_HAS_FREE_CONTAINER_SLOTS',
  'NUM_ITEMS',
] as const;

const SCRIPT_CONDITION_TYPE_NAME_SET = new Set<string>(SCRIPT_CONDITION_TYPE_NAMES_BY_INDEX);

/**
 * Compatibility aliases for callers using port-facing names instead of C++ enum names.
 */
const SCRIPT_CONDITION_TYPE_ALIASES = new Map<string, string>([
  ['ALL_DESTROYED', 'PLAYER_ALL_DESTROYED'],
  ['ALL_BUILD_FACILITIES_DESTROYED', 'PLAYER_ALL_BUILDFACILITIES_DESTROYED'],
  ['PLAYER_ALL_BUILD_FACILITIES_DESTROYED', 'PLAYER_ALL_BUILDFACILITIES_DESTROYED'],
  ['SKIRMISH_NAMED_AREA_EXISTS', 'SKIRMISH_NAMED_AREA_EXIST'],
]);

/**
 * Source parity subset: ScriptAction::ScriptActionType identifiers used by current script-action
 * dispatch support. Numeric ids are from Scripts.h enum order.
 */
const SCRIPT_ACTION_TYPE_NUMERIC_TO_NAME = new Map<number, string>([
  [1, 'SET_FLAG'],
  [2, 'SET_COUNTER'],
  [6, 'SET_TIMER'],
  [15, 'INCREMENT_COUNTER'],
  [16, 'DECREMENT_COUNTER'],
  [20, 'SET_MILLISECOND_TIMER'],
  [37, 'TEAM_SET_STATE'],
  [147, 'SET_RANDOM_TIMER'],
  [148, 'SET_RANDOM_MSEC_TIMER'],
  [149, 'STOP_TIMER'],
  [150, 'RESTART_TIMER'],
  [151, 'ADD_TO_MSEC_TIMER'],
  [152, 'SUB_FROM_MSEC_TIMER'],
  [153, 'TEAM_TRANSFER_TO_PLAYER'],
  [154, 'PLAYER_SET_MONEY'],
  [155, 'PLAYER_GIVE_MONEY'],
  [272, 'PLAYER_ADD_SKILLPOINTS'],
  [273, 'PLAYER_ADD_RANKLEVEL'],
  [274, 'PLAYER_SET_RANKLEVEL'],
  [275, 'PLAYER_SET_RANKLEVELLIMIT'],
  [276, 'PLAYER_GRANT_SCIENCE'],
  [277, 'PLAYER_PURCHASE_SCIENCE'],
  [298, 'PLAYER_SCIENCE_AVAILABILITY'],
]);

const SCRIPT_ACTION_TYPE_NAME_SET = new Set<string>(SCRIPT_ACTION_TYPE_NUMERIC_TO_NAME.values());

const SCRIPT_ACTION_TYPE_ALIASES = new Map<string, string>([
  ['ADD_TO_TIMER', 'ADD_TO_MSEC_TIMER'],
  ['SUB_FROM_TIMER', 'SUB_FROM_MSEC_TIMER'],
]);

export class GameLogicSubsystem implements Subsystem {
  readonly name = 'GameLogic';

  private readonly config: GameLogicConfig;
  private readonly spawnedEntities = new Map<number, MapEntity>();
  private readonly raycaster = new THREE.Raycaster();
  private readonly groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  private readonly gameRandom = new GameRandom(1);

  private nextId = 1;
  private nextProjectileVisualId = 1;
  private animationTime = 0;
  private selectedEntityId: number | null = null;
  private selectedEntityIds: readonly number[] = [];
  private loadedMapData: MapDataJSON | null = null;
  private mapHeightmap: HeightmapGrid | null = null;
  private navigationGrid: NavigationGrid | null = null;
  private iniDataRegistry: IniDataRegistry | null = null;
  /** Source parity: TheGlobalData->m_weaponBonusSet — global weapon bonus table from GameData.ini. */
  private globalWeaponBonusTable: WeaponBonusTable = { entries: new Map() };
  private readonly commandQueue: GameLogicCommand[] = [];
  private frameCounter = 0;
  private readonly bridgeSegments = new Map<number, BridgeSegmentState>();
  private readonly bridgeSegmentByControlEntity = new Map<number, number>();
  /** Source parity: TerrainLogic::m_bridgeDamageStatesChanged frame gate. */
  private bridgeDamageStatesChangedFrame = -1;
  /** Source parity: BridgeInfo::damageStateChanged + curDamageState snapshot for this frame. */
  private readonly bridgeDamageStateByControlEntity = new Map<number, boolean>();
  private readonly teamRelationshipOverrides = new Map<string, number>();
  private readonly playerRelationshipOverrides = new Map<string, number>();
  private readonly sideCredits = new Map<string, number>();
  private readonly sidePlayerTypes = new Map<string, SidePlayerType>();
  /** Source parity: Player::m_cashBountyPercent — percentage of enemy kill cost awarded as credits. */
  private readonly sideCashBountyPercent = new Map<string, number>();
  private readonly sideUpgradesInProduction = new Map<string, Set<string>>();
  private readonly sideCompletedUpgrades = new Map<string, Set<string>>();
  private readonly sideKindOfProductionCostModifiers = new Map<string, KindOfProductionCostModifier[]>();
  private readonly sideSciences = new Map<string, Set<string>>();
  /** Source parity: ScriptEngine::m_acquiredSciences (consumed by evaluateScienceAcquired). */
  private readonly sideScriptAcquiredSciences = new Map<string, Set<string>>();
  /** Source parity: ScriptEngine::m_triggeredSpecialPowers script event list. */
  private readonly sideScriptTriggeredSpecialPowerEvents = new Map<string, ScriptNamedEvent[]>();
  /** Source parity: ScriptEngine::m_midwaySpecialPowers script event list. */
  private readonly sideScriptMidwaySpecialPowerEvents = new Map<string, ScriptNamedEvent[]>();
  /** Source parity: ScriptEngine::m_finishedSpecialPowers script event list. */
  private readonly sideScriptCompletedSpecialPowerEvents = new Map<string, ScriptNamedEvent[]>();
  /** Source parity: ScriptEngine::m_completedUpgrades script event list. */
  private readonly sideScriptCompletedUpgradeEvents = new Map<string, ScriptNamedEvent[]>();
  /** Source parity: Player::m_sciencesDisabled + m_sciencesHidden, keyed by side then science. */
  private readonly sideScienceAvailability = new Map<string, Map<string, LocalScienceAvailability>>();
  /** Source parity: ScriptEngine::m_completedVideo consumed by evaluateVideoHasCompleted. */
  private readonly scriptCompletedVideos: string[] = [];
  /**
   * Source parity subset: ScriptEngine::isSpeechComplete.
   * TODO(source-parity): query audio lengths and frame deadlines like C++ m_testingSpeech.
   */
  private readonly scriptCompletedSpeech: string[] = [];
  /**
   * Source parity subset: ScriptEngine::isAudioComplete.
   * TODO(source-parity): query audio lengths and frame deadlines like C++ m_testingAudio.
   */
  private readonly scriptCompletedAudio: string[] = [];
  /** Source parity: Audio::hasMusicTrackCompleted consumed by evaluateMusicHasCompleted. */
  private readonly scriptCompletedMusic: ScriptMusicCompletedEvent[] = [];
  /** Source parity subset: ScriptEngine team registry keyed by uppercase team name. */
  private readonly scriptTeamsByName = new Map<string, ScriptTeamRecord>();
  private readonly sidePowerBonus = new Map<string, SidePowerState>();
  private readonly sideRadarState = new Map<string, SideRadarState>();
  private readonly sideRankState = new Map<string, SideRankState>();
  /** Source parity: GameLogic::m_rankLevelLimit consumed by Player rank/skill progression. */
  private rankLevelLimit = RANK_TABLE.length;
  private readonly sideScoreState = new Map<string, SideScoreState>();
  /** Source parity: Player::m_attackedBy + m_attackedFrame. */
  private readonly sideAttackedBy = new Map<string, Set<string>>();
  private readonly sideAttackedFrame = new Map<string, number>();
  /** Source parity: AIPlayer::m_supplySourceAttackCheckFrame (per-side scan gate). */
  private readonly sideSupplySourceAttackCheckFrame = new Map<string, number>();
  /** Source parity: AIPlayer::m_attackedSupplyCenter (last attacked economy object ID). */
  private readonly sideAttackedSupplySource = new Map<string, number>();
  private readonly sideBattlePlanBonuses = new Map<string, SideBattlePlanBonuses>();
  private readonly battlePlanParalyzedUntilFrame = new Map<number, number>();
  private readonly playerSideByIndex = new Map<number, string>();
  private readonly localPlayerScienceAvailability = new Map<string, LocalScienceAvailability>();
  private readonly shortcutSpecialPowerSourceByName = new Map<string, Map<number, number>>();
  private readonly shortcutSpecialPowerNamesByEntityId = new Map<number, Set<string>>();
  private readonly sharedShortcutSpecialPowerReadyFrames = new Map<string, number>();
  /** Source parity: ScriptEngine::notifyOfObjectCreationOrDestruction dirty version. */
  private scriptObjectTopologyVersion = 0;
  private scriptObjectCountChangedFrame = 0;
  /** Source parity: Condition::m_customData/m_customFrame cache keyed by scripted condition id. */
  private readonly scriptConditionCacheById = new Map<string, ScriptConditionCacheState>();
  /** Source parity: ScriptEngine::m_counters indexed by counter name in this port. */
  private readonly scriptCountersByName = new Map<string, ScriptCounterState>();
  /** Source parity: ScriptEngine::m_flags indexed by flag name in this port. */
  private readonly scriptFlagsByName = new Map<string, boolean>();
  /** Source parity: ScriptEngine::m_uiInteractions one-frame signal names. */
  private readonly scriptUIInteractions = new Set<string>();
  /** Source parity: ScriptEngine::m_objectCount map used by evaluatePlayerLostObjectType(). */
  private readonly scriptObjectCountBySideAndType = new Map<string, number>();
  /** Source parity: ScriptEngine::didUnitExist history keyed by object id in this port. */
  private readonly scriptExistedEntityIds = new Set<number>();
  /** Source parity: Object::m_triggerInfo isInside snapshots keyed by entity id. */
  private readonly scriptTriggerMembershipByEntityId = new Map<number, Set<number>>();
  /** Source parity: Object::m_triggerInfo entered flags keyed by entity id. */
  private readonly scriptTriggerEnteredByEntityId = new Map<number, Set<number>>();
  /** Source parity: Object::m_triggerInfo exited flags keyed by entity id. */
  private readonly scriptTriggerExitedByEntityId = new Map<number, Set<number>>();
  /** Source parity: Object::m_enteredOrExitedFrame keyed by entity id. */
  private readonly scriptTriggerEnterExitFrameByEntityId = new Map<number, number>();
  /**
   * Source parity subset: AIUpdateInterface::getCompletedWaypoint path labels by entity.
   * TODO(source-parity): feed this from script waypoint-path movement actions.
   */
  private readonly scriptCompletedWaypointPathsByEntityId = new Map<number, Set<string>>();
  /** Source parity: evaluateUnitHasEmptied transport-status cache keyed by entity id. */
  private readonly scriptTransportStatusByEntityId = new Map<number, { frameNumber: number; unitCount: number }>();
  private readonly pendingWeaponDamageEvents: PendingWeaponDamageEvent[] = [];
  private readonly missileAIProfileByProjectileTemplate = new Map<string, MissileAIProfile | null>();
  private readonly visualEventBuffer: import('./types.js').VisualEvent[] = [];
  private readonly evaEventBuffer: import('./types.js').EvaEvent[] = [];
  /** Cooldown tracker: EvaEventType → next frame this event can fire again. */
  private readonly evaCooldowns = new Map<string, number>();
  private readonly pendingDyingRenderableStates = new Map<number, {
    state: RenderableEntityState;
    expireFrame: number;
  }>();
  /** Source parity: Object::m_hasDiedAlready — prevents re-entrant death pipeline. */
  private readonly dyingEntityIds = new Set<number>();
  private readonly sellingEntities = new Map<number, SellingEntityState>();
  private readonly hackInternetStateByEntityId = new Map<number, HackInternetRuntimeState>();
  private readonly hackInternetPendingCommandByEntityId = new Map<number, HackInternetPendingCommandState>();
  private readonly assaultTransportStateByEntityId = new Map<number, AssaultTransportState>();
  private readonly overchargeStateByEntityId = new Map<number, OverchargeRuntimeState>();
  private readonly disabledHackedStatusByEntityId = new Map<number, number>();
  private readonly disabledEmpStatusByEntityId = new Map<number, number>();
  /** Source parity: ThingTemplate::m_isBuildFacility derived set from production prerequisites. */
  private buildFacilityTemplateNamesCache: Set<string> | null = null;
  private buildFacilityTemplateNamesRegistry: IniDataRegistry | null = null;
  private readonly pendingEnterObjectActions = new Map<number, PendingEnterObjectActionState>();
  private readonly pendingRepairDockActions = new Map<number, PendingRepairDockActionState>();
  private readonly pendingGarrisonActions = new Map<number, number>();
  /** Source parity: TransportContain — passenger ID → transport ID for deferred enter. */
  private readonly pendingTransportActions = new Map<number, number>();
  /** Source parity: TunnelContain — passenger ID → tunnel entity ID for deferred enter. */
  private readonly pendingTunnelActions = new Map<number, number>();
  /** Source parity: TunnelTracker — per-side shared tunnel network state. */
  private readonly tunnelTrackers = new Map<string, TunnelTrackerState>();
  private readonly pendingCombatDropActions = new Map<number, PendingCombatDropActionState>();
  /** Source parity: ChinookCombatDropState — rappellers actively descending. */
  private readonly pendingChinookRappels = new Map<number, PendingChinookRappelState>();
  /** Source parity: ChinookAIUpdate::m_pendingCommand while in takeoff/landing/rappel states. */
  private readonly pendingChinookCommandByEntityId = new Map<number, GameLogicCommand>();
  /** Source parity: BuildAssistant repair — dozer ID → target building ID. */
  private readonly pendingRepairActions = new Map<number, number>();
  /** Source parity: DozerAIUpdate — dozer ID → building ID being constructed. */
  private readonly pendingConstructionActions = new Map<number, number>();
  private readonly supplyWarehouseStates = new Map<number, SupplyWarehouseState>();
  private readonly supplyTruckStates = new Map<number, SupplyTruckState>();
  private fogOfWarGrid: FogOfWarGrid | null = null;
  /** Source parity: Cached water polygon trigger data for FloatUpdate water height queries. */
  private waterPolygonData: Array<{
    points: Array<{ x: number; y: number; z: number }>;
    minX: number; maxX: number; minZ: number; maxZ: number;
    /** Water surface height (original engine Z → game-logic Y). */
    waterHeight: number;
  }> = [];
  /** Source parity groundwork: map polygon triggers (named regions for scripting conditions). */
  private mapTriggerRegions: Array<{
    id: number;
    name: string;
    nameUpper: string;
    points: Array<{ x: number; y: number; z: number }>;
    minX: number;
    maxX: number;
    minZ: number;
    maxZ: number;
  }> = [];
  /** Source parity: SpyVisionSpecialPower — temporary fog reveals with expiration timers. */
  private readonly temporaryVisionReveals: {
    playerIndex: number;
    worldX: number;
    worldZ: number;
    radius: number;
    expiryFrame: number;
  }[] = [];
  private readonly sidePlayerIndex = new Map<string, number>();
  private nextPlayerIndex = 0;
  private readonly skirmishAIStates = new Map<string, SkirmishAIState>();
  /** Source parity: Player::m_mpStartIndex (0-based start slot per side). */
  private readonly sideSkirmishStartIndex = new Map<string, number>();
  private readonly railedTransportStateByEntityId = new Map<number, RailedTransportRuntimeState>();
  private railedTransportWaypointIndex: RailedTransportWaypointIndex = createRailedTransportWaypointIndexImpl(null);
  // localPlayerSciencePurchasePoints removed — now lives in sideRankState.
  private localPlayerIndex = 0;

  private isAttackMoveToMode = false;
  private previousAttackMoveToggleDown = false;

  private placementSummary: MapObjectPlacementSummary = {
    totalObjects: 0,
    spawnedObjects: 0,
    skippedObjects: 0,
    resolvedObjects: 0,
    unresolvedObjects: 0,
  };

  private readonly defeatedSides = new Set<string>();
  private gameEndFrame: number | null = null;

  constructor(_scene: THREE.Scene, config?: Partial<GameLogicConfig>) {
    void _scene;
    this.config = { ...DEFAULT_GAME_LOGIC_CONFIG, ...config };
  }

  init(): void {
    // No async startup required for the bootstrap stage.
  }

  /**
   * Resolve map objects against INI definitions and create simulation entities.
   * Returns a compact summary for debug overlays and future HUD wiring.
   */
  loadMapObjects(
    mapData: MapDataJSON,
    iniDataRegistry: IniDataRegistry,
    heightmap: HeightmapGrid | null,
  ): MapObjectPlacementSummary {
    this.clearSpawnedObjects();
    this.loadedMapData = mapData;
    this.mapHeightmap = heightmap;
    this.iniDataRegistry = iniDataRegistry;

    // Source parity: TheGlobalData->m_weaponBonusSet — build from GameData.ini entries.
    const gameDataConfig = iniDataRegistry.getGameData();
    if (gameDataConfig) {
      this.globalWeaponBonusTable = buildWeaponBonusTable(gameDataConfig.weaponBonusEntries);
    }

    this.railedTransportWaypointIndex = createRailedTransportWaypointIndexImpl(
      this.resolveRailedTransportWaypointData(mapData),
    );

    this.placementSummary = {
      totalObjects: mapData.objects.length,
      spawnedObjects: 0,
      skippedObjects: 0,
      resolvedObjects: 0,
      unresolvedObjects: 0,
    };

    for (const mapObject of mapData.objects) {
      if ((mapObject.flags & OBJECT_DONT_RENDER_FLAG) !== 0) {
        this.placementSummary.skippedObjects++;
        continue;
      }

      const objectDef = iniDataRegistry.getObject(mapObject.templateName);
      const resolved = objectDef !== undefined;

      if (!resolved && !this.config.renderUnknownObjects) {
        this.placementSummary.skippedObjects++;
        continue;
      }

      const mapEntity = this.createMapEntity(mapObject, objectDef, iniDataRegistry, heightmap);
      this.addEntityToWorld(mapEntity);
      this.registerEntityEnergy(mapEntity);
      this.initializeMinefieldState(mapEntity);
      this.registerTunnelEntity(mapEntity);

      // Initialize supply warehouse state from profile if applicable.
      if (mapEntity.supplyWarehouseProfile) {
        this.supplyWarehouseStates.set(
          mapEntity.id,
          initializeWarehouseStateImpl(mapEntity.supplyWarehouseProfile),
        );
      }

      // Source parity: SpecialPowerCreate::onBuildComplete — start special power timers.
      // Map-placed buildings are born complete, so fire immediately after entity creation.
      // Dozer-built buildings fire from completeConstruction() when construction finishes.
      if (mapEntity.hasSpecialPowerCreate && !mapEntity.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
        this.onBuildCompleteSpecialPowerCreate(mapEntity);
      }

      this.placementSummary.spawnedObjects++;
      if (resolved) {
        this.placementSummary.resolvedObjects++;
      } else {
        this.placementSummary.unresolvedObjects++;
      }
    }

    this.navigationGrid = this.buildNavigationGrid(mapData, heightmap);

    // Source parity: Cache water polygon data for FloatUpdate water height queries.
    // C++ TerrainLogic::isUnderwater uses polygon triggers to resolve water surface height.
    // MapPoint uses original engine coordinates: x=horizontal X, y=horizontal Z, z=height.
    this.waterPolygonData = mapData.triggers
      .filter((trigger) => trigger.isWaterArea || trigger.isRiver)
      .map((trigger) => ({
        points: trigger.points,
        minX: Math.min(...trigger.points.map((p) => p.x)),
        maxX: Math.max(...trigger.points.map((p) => p.x)),
        minZ: Math.min(...trigger.points.map((p) => p.y)),
        maxZ: Math.max(...trigger.points.map((p) => p.y)),
        // Source parity: C++ getWaterHeight returns pTrig->getPoint(0)->z (original engine Z = height).
        waterHeight: trigger.points[0]?.z ?? 0,
      }));

    this.mapTriggerRegions = mapData.triggers.map((trigger) => ({
      id: trigger.id,
      name: trigger.name,
      nameUpper: trigger.name.trim().toUpperCase(),
      points: trigger.points,
      minX: Math.min(...trigger.points.map((p) => p.x)),
      maxX: Math.max(...trigger.points.map((p) => p.x)),
      minZ: Math.min(...trigger.points.map((p) => p.y)),
      maxZ: Math.max(...trigger.points.map((p) => p.y)),
    }));
    this.initializeScriptTriggerMembershipBaselines();

    // Initialize fog of war grid based on map dimensions.
    if (heightmap) {
      this.fogOfWarGrid = new FogOfWarGrid(heightmap.worldWidth, heightmap.worldDepth, MAP_XY_FACTOR);
    }

    // Source parity: script condition caches begin from the post-load baseline.
    this.scriptObjectTopologyVersion = 0;
    this.scriptObjectCountChangedFrame = 0;

    return this.placementSummary;
  }

  private resolveRailedTransportWaypointData(mapData: MapDataJSON): RailedTransportWaypointData | null {
    if (!mapData.waypoints) {
      return null;
    }

    return {
      nodes: mapData.waypoints.nodes.map((node) => ({
        id: node.id,
        name: node.name,
        x: node.position.x,
        z: node.position.y,
        biDirectional: node.biDirectional ?? false,
      })),
      links: mapData.waypoints.links.map((link) => ({
        waypoint1: link.waypoint1,
        waypoint2: link.waypoint2,
      })),
    };
  }

  getPlacementSummary(): MapObjectPlacementSummary {
    return { ...this.placementSummary };
  }

  getRenderableEntityStates(): RenderableEntityState[] {
    const renderableStates = Array.from(this.spawnedEntities.values()).map((entity) =>
      this.makeRenderableEntityState(entity),
    );
    const pendingDyingStates = Array.from(this.pendingDyingRenderableStates.values())
      .map((pending) => pending.state);

    return [...renderableStates, ...pendingDyingStates];
  }

  private makeRenderableEntityState(entity: MapEntity): RenderableEntityState {
    return {
      id: entity.id,
      templateName: entity.templateName,
      resolved: entity.resolved,
      renderAssetCandidates: entity.renderAssetCandidates,
      renderAssetPath: entity.renderAssetPath,
      renderAssetResolved: entity.renderAssetResolved,
      renderAnimationStateClips: entity.renderAnimationStateClips,
      category: entity.category,
      x: entity.x,
      y: entity.y,
      z: entity.z,
      rotationY: entity.rotationY,
      animationState: entity.animationState,
      health: entity.health,
      maxHealth: entity.maxHealth,
      isSelected: entity.selected,
      side: entity.side,
      veterancyLevel: entity.experienceState.currentLevel,
      isStealthed: entity.objectStatusFlags.has('STEALTHED'),
      isDetected: entity.objectStatusFlags.has('DETECTED'),
      shroudStatus: this.resolveEntityShroudStatusForLocalPlayer(entity),
      constructionPercent: entity.constructionPercent,
      toppleAngle: entity.toppleAngularAccumulation,
      toppleDirX: entity.toppleDirX,
      toppleDirZ: entity.toppleDirZ,
      /** Turret rotation angles (one per turret module), in radians relative to body. */
      turretAngles: entity.turretStates.map(ts => ts.currentAngle),
    };
  }

  /**
   * Source parity references:
   * - Generals/Code/GameEngine/Source/GameLogic/System/GameLogic.cpp (GameLogic::getCRC)
   *
   * TODO(source parity): replace the section serializers below with direct
   * ownership from object/partition/player/AI runtime ports as those systems
   * are promoted from scaffolding to source-complete subsystems.
   */
  createDeterministicGameLogicCrcSectionWriters():
    DeterministicGameLogicCrcSectionWriters<unknown> {
    return createDeterministicGameLogicCrcSectionWritersImpl({
      spawnedEntities: this.spawnedEntities,
      navigationGrid: this.navigationGrid,
      bridgeSegments: this.bridgeSegments,
      bridgeSegmentByControlEntity: this.bridgeSegmentByControlEntity,
      selectedEntityId: this.selectedEntityId,
      teamRelationshipOverrides: this.teamRelationshipOverrides,
      playerRelationshipOverrides: this.playerRelationshipOverrides,
      placementSummary: this.placementSummary,
      sideKindOfProductionCostModifiers: this.sideKindOfProductionCostModifiers,
      sidePowerBonus: this.sidePowerBonus,
      sideRadarState: this.sideRadarState,
      frameCounter: this.frameCounter,
      nextId: this.nextId,
      animationTime: this.animationTime,
      isAttackMoveToMode: this.isAttackMoveToMode,
      previousAttackMoveToggleDown: this.previousAttackMoveToggleDown,
      config: this.config,
      commandQueue: this.commandQueue,
    });
  }

  /**
   * Minimal RTS interaction:
   * - Left click: select a spawned entity.
   * - Right click: issue move/attack-move based on attack-move mode.
   * - Press A (edge-triggered) to toggle one-shot attack-move mode.
   */
  handlePointerInput(
    input: InputState,
    camera: THREE.Camera,
  ): void {
    const attackMoveToggleDown = input.keysDown.has('a');
    if (attackMoveToggleDown && !this.previousAttackMoveToggleDown) {
      this.isAttackMoveToMode = !this.isAttackMoveToMode;
    }
    this.previousAttackMoveToggleDown = attackMoveToggleDown;

    if (input.leftMouseClick) {
      const pickedEntityId = this.pickObjectByInput(input, camera);
      if (pickedEntityId === null) {
        this.submitCommand({ type: 'clearSelection' });
      } else {
        this.submitCommand({ type: 'select', entityId: pickedEntityId });
      }
    }
    if (input.rightMouseClick && this.selectedEntityIds.length > 0) {
      const pickedEntityId = this.pickObjectByInput(input, camera);
      const moveTarget = this.getMoveTargetFromMouse(input, camera);

      // Compute group centroid for formation offsets.
      const movableEntities: MapEntity[] = [];
      let centerX = 0;
      let centerZ = 0;
      for (const selEntityId of this.selectedEntityIds) {
        const selEntity = this.spawnedEntities.get(selEntityId);
        if (!selEntity || selEntity.destroyed || !selEntity.canMove) continue;
        movableEntities.push(selEntity);
        centerX += selEntity.x;
        centerZ += selEntity.z;
      }
      const groupSize = movableEntities.length;
      if (groupSize > 0) {
        centerX /= groupSize;
        centerZ /= groupSize;
      }
      const useFormation = groupSize > 1;

      // Issue commands to all selected entities.
      for (const selEntity of movableEntities) {
        // Try garrison if infantry right-clicks on a garrisonable building.
        if (
          pickedEntityId !== null
          && pickedEntityId !== selEntity.id
          && selEntity.category === 'infantry'
        ) {
          const targetEntity = this.spawnedEntities.get(pickedEntityId);
          if (
            targetEntity
            && !targetEntity.destroyed
            && targetEntity.containProfile?.moduleType === 'GARRISON'
            && this.getTeamRelationship(selEntity, targetEntity) !== RELATIONSHIP_ENEMIES
          ) {
            this.submitCommand({
              type: 'garrisonBuilding',
              entityId: selEntity.id,
              targetBuildingId: pickedEntityId,
            });
            continue;
          }
        }

        // Try repair if dozer right-clicks on a damaged friendly building.
        if (
          pickedEntityId !== null
          && pickedEntityId !== selEntity.id
          && selEntity.kindOf.has('DOZER')
        ) {
          const targetEntity = this.spawnedEntities.get(pickedEntityId);
          if (
            targetEntity
            && !targetEntity.destroyed
            && targetEntity.kindOf.has('STRUCTURE')
            && targetEntity.health < targetEntity.maxHealth
            && this.getTeamRelationship(selEntity, targetEntity) !== RELATIONSHIP_ENEMIES
          ) {
            this.submitCommand({
              type: 'repairBuilding',
              entityId: selEntity.id,
              targetBuildingId: pickedEntityId,
            });
            continue;
          }
        }

        // Try attack if we clicked on an enemy.
        if (
          selEntity.attackWeapon
          && pickedEntityId !== null
          && pickedEntityId !== selEntity.id
        ) {
          const targetEntity = this.spawnedEntities.get(pickedEntityId);
          if (
            targetEntity
            && !targetEntity.destroyed
            && this.getTeamRelationship(selEntity, targetEntity) === RELATIONSHIP_ENEMIES
          ) {
            this.submitCommand({
              type: 'attackEntity',
              entityId: selEntity.id,
              targetEntityId: pickedEntityId,
            });
            continue;
          }
        }

        // Otherwise move / attack-move with formation offsets.
        if (moveTarget !== null) {
          let destX = moveTarget.x;
          let destZ = moveTarget.z;

          if (useFormation) {
            // Compute relative offset from group center, clamped per C++ source.
            let offX = selEntity.x - centerX;
            let offZ = selEntity.z - centerZ;
            const offLen = Math.sqrt(offX * offX + offZ * offZ);
            const maxSpread = 30; // ~6x typical unit bounding radius (5)
            if (offLen > maxSpread) {
              const scale = maxSpread / offLen;
              offX *= scale;
              offZ *= scale;
            }
            destX += offX;
            destZ += offZ;
          }

          const attackDistance = this.resolveAttackMoveDistance(selEntity);
          if (this.isAttackMoveToMode) {
            this.submitCommand({
              type: 'attackMoveTo',
              entityId: selEntity.id,
              targetX: destX,
              targetZ: destZ,
              attackDistance,
            });
          } else {
            this.submitCommand({
              type: 'moveTo',
              entityId: selEntity.id,
              targetX: destX,
              targetZ: destZ,
            });
          }
        }
      }

      this.isAttackMoveToMode = false;
    }
  }

  /**
   * Update movement and placeholder animation.
   */
  update(dt: number): void {
    this.animationTime += dt;
    this.frameCounter++;
    this.updateScriptCountdownTimers();
    this.resetBridgeDamageStateChanges();
    this.resetContainPlayerEnteredSides();
    this.flushCommands();
    this.updateDisabledHackedStatuses();
    this.updateDisabledEmpStatuses();
    this.updatePowerBrownOut();
    this.updateProduction();
    this.updateSpawnBehaviors();
    this.updateSlavedEntities();
    this.updateDeployStyleEntities();
    this.updateTurretAI();
    this.updateCombat();
    this.updateIdleAutoTargeting();
    this.updateGuardBehavior();
    this.updateJetAI();
    this.updateEntityMovement(dt);
    this.updateAnimationSteering();
    this.updateUnitCollisionSeparation();
    this.updateCrushCollisions();
    this.updateRailedTransport();
    this.updatePendingEnterObjectActions();
    this.updatePendingRepairDockActions();
    this.updatePendingGarrisonActions();
    this.updatePendingTransportActions();
    this.updatePendingTunnelActions();
    this.updatePendingRepairActions();
    this.updatePendingConstructionActions();
    this.updateDozerIdleBehavior();
    this.updatePendingChinookRappels();
    this.updatePendingCombatDropActions();
    this.updateHackInternet();
    this.updatePendingHackInternetCommands();
    this.updateAssaultTransports();
    this.updateOvercharge();
    this.updateGrantStealth();
    this.updateStealth();
    this.updateDetection();
    this.updateBattlePlan();
    this.updateBattlePlanParalysis();
    this.updateSpecialAbility();
    this.updatePoisonedEntities();
    this.updateSubdualDamageHelpers();
    this.updateFlammableEntities();
    this.updateFireSpread();
    this.updateHealing();
    this.updateMineBehavior();
    this.updateMineCollisions();
    this.updateDemoTraps();
    this.updateCrateCollisions();
    this.updateTunnelHealing();
    this.updateHealContainHealing();
    this.updateAutoFindHealing();
    this.updateFogOfWar();
    this.updateSupplyChain();
    this.updateSkirmishAI();
    this.updateEva();
    this.updateHorde();
    this.updateEnemyNear();
    this.updateCheckpoints();
    this.updateProneEntities();
    this.updateFireWhenDamagedContinuous();
    this.updateFireWeaponUpdate();
    this.updateOCLUpdate();
    this.updateWeaponBonusUpdate();
    this.updateTempWeaponBonusExpiry();
    this.updateSellingEntities();
    this.updateRebuildHoles();
    this.updateWanderAI();
    this.updateHijackerEntities();
    this.updateFloatEntities();
    this.updateAutoDeposit();
    this.updateDynamicShroud();
    this.updatePilotFindVehicle();
    this.updateToppleEntities();
    this.updateTensileFormation();
    this.updateSupplyWarehouseCrippling();
    this.updateRadarExtension();
    this.updatePowerPlantUpdate();
    this.updateTemporaryVisionReveals();
    this.updateRenderStates();
    this.updateLifetimeEntities();
    this.updateDeletionEntities();
    this.updateHeightDieEntities();
    this.updateStickyBombs();
    this.updateSlowDeathEntities();
    this.updateHelicopterSlowDeath();
    this.updateJetSlowDeath();
    this.updateStructureCollapseEntities();
    this.updateSmartBombHoming();
    this.updateBunkerBusterTracking();
    this.updateDynamicGeometry();
    this.updateFireOCLAfterCooldown();
    this.updateEmpEntities();
    this.updateLeafletDropEntities();
    this.updateCleanupHazard();
    this.updateWeaponIdleAutoReload();
    this.updatePointDefenseLaser();
    this.updateCountermeasures();
    this.updateMissileAIEvents();
    this.updateProjectileFlightCollisions();
    this.processCountermeasureDiversions();
    this.updatePendingWeaponDamage();
    this.updateScriptTriggerTransitions();
    this.finalizeDestroyedEntities();
    this.cleanupDyingRenderableStates();
    this.checkVictoryConditions();
    this.clearScriptUIInteractions();
  }

  private updateScriptCountdownTimers(): void {
    for (const counter of this.scriptCountersByName.values()) {
      if (!counter.isCountdownTimer) {
        continue;
      }
      // Source parity: countdown timers decrement to -1 and then stop.
      if (counter.value >= 0) {
        counter.value -= 1;
      }
    }
  }

  private clearScriptUIInteractions(): void {
    this.scriptUIInteractions.clear();
  }

  private resetContainPlayerEnteredSides(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (!entity.containProfile) continue;
      entity.containPlayerEnteredSide = null;
    }
  }

  submitCommand(command: GameLogicCommand): void {
    if (command.type === 'purchaseScience') {
      this.applyCommand(command);
      return;
    }

    this.commandQueue.push(command);
  }

  getSelectedEntityId(): number | null {
    return this.selectedEntityId;
  }

  getSelectedEntityInfo(): SelectedEntityInfo | null {
    return this.getSelectedEntityInfoById(this.selectedEntityId);
  }

  getSelectedEntityInfoById(entityId: number | null): SelectedEntityInfo | null {
    if (entityId === null) {
      return null;
    }

    const selected = this.spawnedEntities.get(entityId);
    if (!selected) {
      return null;
    }

    const registry = this.iniDataRegistry;
    const objectDef = registry
      ? findObjectDefByName(registry, selected.templateName)
      : undefined;
    const normalizedKindOf = this.normalizeKindOf(objectDef?.kindOf);
    return {
      id: selected.id,
      templateName: selected.templateName,
      category: selected.category,
      side: selected.side,
      resolved: selected.resolved,
      canMove: selected.canMove,
      hasAutoRallyPoint: selected.queueProductionExitProfile !== null,
      isUnmanned: selected.isUnmanned,
      isDozer: normalizedKindOf.has('DOZER'),
      isMoving: selected.moving,
      appliedUpgradeNames: Array.from(selected.completedUpgrades.values()).sort(),
      objectStatusFlags: Array.from(selected.objectStatusFlags.values()).sort(),
      modelConditionFlags: Array.from(selected.modelConditionFlags.values()).sort(),
    };
  }

  getEntityWorldPosition(entityId: number): readonly [number, number, number] | null {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return null;
    }
    return [
      entity.x,
      entity.y,
      entity.z,
    ];
  }

  getEntityRelationship(sourceEntityId: number, targetEntityId: number): EntityRelationship | null {
    const source = this.spawnedEntities.get(sourceEntityId);
    const target = this.spawnedEntities.get(targetEntityId);
    if (!source || !target) {
      return null;
    }
    return this.relationshipValueToLabel(this.getTeamRelationship(source, target));
  }

  setPlayerSide(playerIndex: number, side: string | null | undefined): void {
    const normalizedPlayerIndex = this.normalizePlayerIndex(playerIndex);
    if (normalizedPlayerIndex === null) {
      return;
    }
    const normalizedSide = this.normalizeSide(side ?? '');
    if (!normalizedSide) {
      this.playerSideByIndex.delete(normalizedPlayerIndex);
      return;
    }
    this.playerSideByIndex.set(normalizedPlayerIndex, normalizedSide);
  }

  getPlayerSide(playerIndex: number): string | null {
    const normalizedPlayerIndex = this.normalizePlayerIndex(playerIndex);
    if (normalizedPlayerIndex === null) {
      return null;
    }
    return this.playerSideByIndex.get(normalizedPlayerIndex) ?? null;
  }

  setSkirmishPlayerStartPosition(side: string, startPositionOneBased: number): boolean {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return false;
    }

    const normalizedStartPosition = Number.isFinite(startPositionOneBased)
      ? Math.trunc(startPositionOneBased)
      : 0;
    if (normalizedStartPosition <= 0) {
      return false;
    }

    // Source parity: Player::getMpStartIndex is 0-based internally.
    this.sideSkirmishStartIndex.set(normalizedSide, normalizedStartPosition - 1);
    return true;
  }

  getSkirmishPlayerStartPosition(side: string): number | null {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return null;
    }
    const startIndex = this.sideSkirmishStartIndex.get(normalizedSide);
    if (startIndex === undefined) {
      return null;
    }
    return startIndex + 1;
  }

  getPlayerRelationshipByIndex(
    sourcePlayerIndex: number,
    targetPlayerIndex: number,
  ): EntityRelationship {
    const normalizedSource = this.normalizePlayerIndex(sourcePlayerIndex);
    const normalizedTarget = this.normalizePlayerIndex(targetPlayerIndex);
    if (normalizedSource === null || normalizedTarget === null) {
      return 'neutral';
    }
    if (normalizedSource === normalizedTarget) {
      return 'allies';
    }

    const sourceSide = this.playerSideByIndex.get(normalizedSource);
    const targetSide = this.playerSideByIndex.get(normalizedTarget);
    if (!sourceSide || !targetSide) {
      return 'neutral';
    }
    return this.relationshipValueToLabel(this.getTeamRelationshipBySides(sourceSide, targetSide));
  }

  getAttackMoveDistanceForEntity(entityId: number): number {
    return this.resolveAttackMoveDistance(this.spawnedEntities.get(entityId));
  }

  getLocalPlayerUpgradeNames(): string[] {
    const side = this.resolveLocalPlayerSide();
    if (!side) {
      return [];
    }
    return Array.from(this.getSideUpgradeSet(this.sideCompletedUpgrades, side)).sort();
  }

  getLocalPlayerScienceNames(): string[] {
    const side = this.resolveLocalPlayerSide();
    if (!side) {
      return [];
    }
    return Array.from(this.getSideScienceSet(side)).sort();
  }

  resolveCommandCenterEntityId(localPlayerIndex?: number | null): number | null {
    const normalizedPlayerIndex = this.normalizePlayerIndex(
      localPlayerIndex === undefined || localPlayerIndex === null
        ? this.localPlayerIndex
        : localPlayerIndex,
    );
    if (normalizedPlayerIndex === null) {
      return null;
    }
    const localSide = this.playerSideByIndex.get(normalizedPlayerIndex) ?? this.resolveLocalPlayerSide();
    if (!localSide) {
      return null;
    }

    for (const [entityId, entity] of this.spawnedEntities) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== localSide) {
        continue;
      }
      if (this.resolveEntityKindOfSet(entity).has('COMMANDCENTER')) {
        return entityId;
      }
    }
    return null;
  }

  getLocalPlayerSciencePurchasePoints(): number {
    const side = this.resolveLocalPlayerSide();
    if (!side) return 0;
    return this.getSideRankStateMap(this.normalizeSide(side)!).sciencePurchasePoints;
  }

  getLocalPlayerRankLevel(): number {
    const side = this.resolveLocalPlayerSide();
    if (!side) return 1;
    return this.getSideRankStateMap(this.normalizeSide(side)!).rankLevel;
  }

  getLocalPlayerSkillPoints(): number {
    const side = this.resolveLocalPlayerSide();
    if (!side) return 0;
    return this.getSideRankStateMap(this.normalizeSide(side)!).skillPoints;
  }

  getLocalPlayerNextRankThreshold(): number {
    const level = this.getLocalPlayerRankLevel();
    if (level >= RANK_TABLE.length) return RANK_TABLE[RANK_TABLE.length - 1]?.skillPointsNeeded ?? 0;
    return RANK_TABLE[level]?.skillPointsNeeded ?? 0;
  }

  private resolveLocalPlayerSide(): string | null {
    const configuredLocalSide = this.playerSideByIndex.get(this.localPlayerIndex);
    if (configuredLocalSide) {
      return configuredLocalSide;
    }

    const observedSides = new Set<string>();
    for (const entity of this.spawnedEntities.values()) {
      const normalizedSide = this.normalizeSide(entity.side);
      if (!normalizedSide) {
        continue;
      }
      observedSides.add(normalizedSide);
      if (observedSides.size > 1) {
        return null;
      }
    }

    if (observedSides.size !== 1) {
      return null;
    }

    for (const observedSide of observedSides) {
      return observedSide;
    }
    return null;
  }

  /**
   * Source parity: Object::isNeutralControlled() — entity has no controlling player side.
   * In C++, neutral entities are controlled by ThePlayerList->getNeutralPlayer().
   */
  private isEntityNeutralControlled(entity: MapEntity): boolean {
    const normalizedSide = this.normalizeSide(entity.side);
    if (!normalizedSide) return true;
    // A side with no player type is considered neutral (e.g. unclaimed tech buildings).
    return !this.sidePlayerTypes.has(normalizedSide);
  }

  private resolveEntityOwnerSide(entity: MapEntity): string | null {
    const directSide = this.normalizeSide(entity.side);
    if (directSide) {
      return directSide;
    }

    const ownerToken = this.normalizeControllingPlayerToken(entity.controllingPlayerToken ?? undefined);
    if (!ownerToken) {
      return null;
    }

    let resolvedSide: string | null = null;
    for (const candidate of this.spawnedEntities.values()) {
      if (candidate.destroyed) {
        continue;
      }
      if (this.normalizeControllingPlayerToken(candidate.controllingPlayerToken ?? undefined) !== ownerToken) {
        continue;
      }

      const candidateSide = this.normalizeSide(candidate.side);
      if (!candidateSide) {
        continue;
      }
      if (resolvedSide === null) {
        resolvedSide = candidateSide;
        continue;
      }
      if (resolvedSide !== candidateSide) {
        return null;
      }
    }

    return resolvedSide;
  }

  getLocalPlayerDisabledScienceNames(): string[] {
    const disabled: string[] = [];
    for (const [scienceName, availability] of this.localPlayerScienceAvailability.entries()) {
      if (availability === 'disabled') {
        disabled.push(scienceName);
      }
    }
    return disabled.sort();
  }

  getLocalPlayerHiddenScienceNames(): string[] {
    const hidden: string[] = [];
    for (const [scienceName, availability] of this.localPlayerScienceAvailability.entries()) {
      if (availability === 'hidden') {
        hidden.push(scienceName);
      }
    }
    return hidden.sort();
  }

  trackShortcutSpecialPowerSourceEntity(
    specialPowerName: string,
    sourceEntityId: number,
    readyFrame: number,
  ): boolean {
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(specialPowerName);
    if (!normalizedSpecialPowerName || !Number.isFinite(sourceEntityId)) {
      return false;
    }

    const normalizedSourceEntityId = Math.trunc(sourceEntityId);
    const normalizedReadyFrame = Number.isFinite(readyFrame)
      ? Math.max(0, Math.trunc(readyFrame))
      : SOURCE_DISABLED_SHORTCUT_SPECIAL_POWER_READY_FRAME;

    let sourcesForPower = this.shortcutSpecialPowerSourceByName.get(normalizedSpecialPowerName);
    if (!sourcesForPower) {
      sourcesForPower = new Map<number, number>();
      this.shortcutSpecialPowerSourceByName.set(normalizedSpecialPowerName, sourcesForPower);
    }
    sourcesForPower.set(normalizedSourceEntityId, normalizedReadyFrame);

    let powersForEntity = this.shortcutSpecialPowerNamesByEntityId.get(normalizedSourceEntityId);
    if (!powersForEntity) {
      powersForEntity = new Set<string>();
      this.shortcutSpecialPowerNamesByEntityId.set(normalizedSourceEntityId, powersForEntity);
    }
    powersForEntity.add(normalizedSpecialPowerName);
    return true;
  }

  setShortcutSpecialPowerSourceEntity(
    specialPowerName: string,
    sourceEntityId: number | null,
  ): boolean {
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(specialPowerName);
    if (!normalizedSpecialPowerName) {
      return false;
    }
    if (sourceEntityId === null) {
      this.clearTrackedShortcutSpecialPowerName(normalizedSpecialPowerName);
      return true;
    }
    if (!Number.isFinite(sourceEntityId)) {
      return false;
    }
    this.clearTrackedShortcutSpecialPowerName(normalizedSpecialPowerName);
    return this.trackShortcutSpecialPowerSourceEntity(
      normalizedSpecialPowerName,
      Math.trunc(sourceEntityId),
      0,
    );
  }

  clearTrackedShortcutSpecialPowerSourceEntity(sourceEntityId: number): void {
    if (!Number.isFinite(sourceEntityId)) {
      return;
    }
    const normalizedSourceEntityId = Math.trunc(sourceEntityId);
    const powersForEntity = this.shortcutSpecialPowerNamesByEntityId.get(normalizedSourceEntityId);
    if (!powersForEntity) {
      return;
    }

    for (const specialPowerName of powersForEntity) {
      const sourcesForPower = this.shortcutSpecialPowerSourceByName.get(specialPowerName);
      if (!sourcesForPower) {
        continue;
      }
      sourcesForPower.delete(normalizedSourceEntityId);
      if (sourcesForPower.size === 0) {
        this.shortcutSpecialPowerSourceByName.delete(specialPowerName);
      }
    }
    this.shortcutSpecialPowerNamesByEntityId.delete(normalizedSourceEntityId);
  }

  resolveShortcutSpecialPowerSourceEntityId(specialPowerName: string): number | null {
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(specialPowerName);
    if (!normalizedSpecialPowerName) {
      return null;
    }
    const sourcesForPower = this.shortcutSpecialPowerSourceByName.get(normalizedSpecialPowerName);
    if (!sourcesForPower || sourcesForPower.size === 0) {
      return null;
    }

    const staleEntityIds: number[] = [];
    let bestEntityId: number | null = null;
    let bestReadyFrame = Number.POSITIVE_INFINITY;
    for (const [entityId, readyFrame] of sourcesForPower.entries()) {
      if (!this.spawnedEntities.has(entityId)) {
        staleEntityIds.push(entityId);
        continue;
      }
      if (readyFrame < bestReadyFrame) {
        bestEntityId = entityId;
        bestReadyFrame = readyFrame;
      }
    }

    for (const staleEntityId of staleEntityIds) {
      this.clearTrackedShortcutSpecialPowerSourceEntity(staleEntityId);
    }
    return bestEntityId;
  }

  resolveShortcutSpecialPowerSourceEntityReadyFrame(specialPowerName: string): number | null {
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(specialPowerName);
    if (!normalizedSpecialPowerName) {
      return null;
    }
    const sourcesForPower = this.shortcutSpecialPowerSourceByName.get(normalizedSpecialPowerName);
    if (!sourcesForPower || sourcesForPower.size === 0) {
      return null;
    }

    const staleEntityIds: number[] = [];
    let bestReadyFrame: number | null = null;
    for (const [entityId, readyFrame] of sourcesForPower.entries()) {
      if (!this.spawnedEntities.has(entityId)) {
        staleEntityIds.push(entityId);
        continue;
      }
      if (bestReadyFrame === null || readyFrame < bestReadyFrame) {
        bestReadyFrame = readyFrame;
      }
    }

    for (const staleEntityId of staleEntityIds) {
      this.clearTrackedShortcutSpecialPowerSourceEntity(staleEntityId);
    }

    return bestReadyFrame;
  }

  resolveMoveTargetFromInput(input: InputState, camera: THREE.Camera): { x: number; z: number } | null {
    return this.getMoveTargetFromMouse(input, camera);
  }

  resolveObjectTargetFromInput(input: InputState, camera: THREE.Camera): number | null {
    return this.pickObjectByInput(input, camera);
  }

  getEntityState(entityId: number): {
    id: number;
    templateName: string;
    resolved: boolean;
    renderAssetCandidates: string[];
    renderAssetPath: string | null;
    renderAssetResolved: boolean;
    renderAnimationStateClips?: RenderAnimationStateClipCandidates;
    health: number;
    maxHealth: number;
    lastSpecialPowerDispatch: SpecialPowerDispatchProfile | null;
    canTakeDamage: boolean;
    attackTargetEntityId: number | null;
    alive: boolean;
    activeLocomotorSet: string;
    speed: number;
    statusFlags: string[];
    x: number;
    y: number;
    animationState: RenderAnimationState;
    z: number;
    veterancyLevel: number;
    currentExperience: number;
    rallyPoint: { x: number; z: number } | null;
    constructionPercent: number;
    side: string;
    weaponBonusConditionFlags: number;
    visionRange: number;
    shroudRange: number;
    battlePlanDamageScalar: number;
  } | null {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return null;
    }

    return {
      id: entity.id,
      templateName: entity.templateName,
      resolved: entity.resolved,
      renderAssetCandidates: entity.renderAssetCandidates,
      renderAssetPath: entity.renderAssetPath,
      renderAssetResolved: entity.renderAssetResolved,
      renderAnimationStateClips: entity.renderAnimationStateClips,
      health: entity.health,
      maxHealth: entity.maxHealth,
      lastSpecialPowerDispatch: entity.lastSpecialPowerDispatch ? {
        specialPowerTemplateName: entity.lastSpecialPowerDispatch.specialPowerTemplateName,
        moduleType: entity.lastSpecialPowerDispatch.moduleType,
        dispatchType: entity.lastSpecialPowerDispatch.dispatchType,
        commandOption: entity.lastSpecialPowerDispatch.commandOption,
        commandButtonId: entity.lastSpecialPowerDispatch.commandButtonId,
        targetEntityId: entity.lastSpecialPowerDispatch.targetEntityId,
        targetX: entity.lastSpecialPowerDispatch.targetX,
        targetZ: entity.lastSpecialPowerDispatch.targetZ,
      } : null,
      canTakeDamage: entity.canTakeDamage,
      attackTargetEntityId: entity.attackTargetEntityId,
      alive: !entity.destroyed,
      activeLocomotorSet: entity.activeLocomotorSet,
      speed: entity.speed,
      statusFlags: Array.from(entity.objectStatusFlags.values()).sort(),
      x: entity.x,
      y: entity.y,
      animationState: entity.animationState,
      z: entity.z,
      veterancyLevel: entity.experienceState.currentLevel,
      currentExperience: entity.experienceState.currentExperience,
      rallyPoint: entity.rallyPoint ? { x: entity.rallyPoint.x, z: entity.rallyPoint.z } : null,
      constructionPercent: entity.constructionPercent,
      side: entity.side ?? '',
      weaponBonusConditionFlags: entity.weaponBonusConditionFlags,
      visionRange: entity.visionRange,
      shroudRange: entity.shroudRange,
      battlePlanDamageScalar: entity.battlePlanDamageScalar,
    };
  }

  getEntityIdsByTemplate(templateName: string): number[] {
    const normalizedTemplateName = templateName.trim().toUpperCase();
    if (!normalizedTemplateName) {
      return [];
    }
    return Array.from(this.spawnedEntities.values())
      .filter((entity) => entity.templateName.toUpperCase() === normalizedTemplateName)
      .map((entity) => entity.id)
      .sort((left, right) => left - right);
  }

  getEntityIdsByTemplateAndSide(templateName: string, side: string): number[] {
    const normalizedTemplateName = templateName.trim().toUpperCase();
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedTemplateName || !normalizedSide) {
      return [];
    }
    return Array.from(this.spawnedEntities.values())
      .filter(
        (entity) =>
          this.normalizeSide(entity.side) === normalizedSide
          && entity.templateName.toUpperCase() === normalizedTemplateName,
      )
      .map((entity) => entity.id)
      .sort((left, right) => left - right);
  }

  getLocalPlayerSelectionIds(): readonly number[] {
    return [...this.selectedEntityIds];
  }

  /**
   * Source parity: VictoryConditions.cpp — hasSinglePlayerBeenDefeated / hasAchievedVictory.
   * Returns the game end state for the local player (player index 0).
   */
  getGameEndState(): import('./types.js').GameEndState | null {
    if (this.gameEndFrame === null) {
      return null;
    }

    const localSide = this.resolveLocalPlayerSide();
    if (!localSide) {
      return null;
    }

    const status = this.defeatedSides.has(localSide) ? 'DEFEAT' as const : 'VICTORY' as const;
    const victorSides: string[] = [];
    const defeatedSides = Array.from(this.defeatedSides);

    for (const [, side] of this.playerSideByIndex) {
      if (!this.defeatedSides.has(side) && !victorSides.includes(side)) {
        victorSides.push(side);
      }
    }

    return {
      status,
      endFrame: this.gameEndFrame,
      victorSides,
      defeatedSides,
    };
  }

  /**
   * Check if a side has been defeated (no buildings and no combat units remaining).
   */
  isSideDefeated(side: string): boolean {
    return this.defeatedSides.has(this.normalizeSide(side));
  }

  /**
   * Drain the visual events buffer. Returns all events since the last drain.
   * The caller should consume these for particle effects, sounds, etc.
   */
  drainVisualEvents(): import('./types.js').VisualEvent[] {
    if (this.visualEventBuffer.length === 0) return [];
    const events = this.visualEventBuffer.slice();
    this.visualEventBuffer.length = 0;
    return events;
  }

  /**
   * Drain the EVA announcer events buffer. Returns all events since the last drain.
   * The caller should consume these for audio playback (voice lines).
   */
  drainEvaEvents(): import('./types.js').EvaEvent[] {
    if (this.evaEventBuffer.length === 0) return [];
    const events = this.evaEventBuffer.slice();
    this.evaEventBuffer.length = 0;
    return events;
  }

  /**
   * Return in-flight projectile data for renderer visualization.
   * Each projectile has an interpolated position based on launch/impact timing.
   */
  getActiveProjectiles(): import('./types.js').ActiveProjectile[] {
    const projectiles: import('./types.js').ActiveProjectile[] = [];
    const heightmap = this.mapHeightmap;

    for (const event of this.pendingWeaponDamageEvents) {
      if (event.delivery !== 'PROJECTILE') continue;
      const missileState = event.missileAIState;
      let x: number, y: number, z: number;
      let progress: number;
      let heading: number;

      if (missileState) {
        x = missileState.currentX;
        y = missileState.currentY;
        z = missileState.currentZ;
        progress = Math.min(1, Math.max(0, missileState.travelDistance / Math.max(1, missileState.totalDistanceEstimate)));
        heading = Math.atan2(missileState.velocityX, missileState.velocityZ);
      } else {
        const totalFrames = event.executeFrame - event.launchFrame;
        if (totalFrames <= 0) continue;

        const elapsed = this.frameCounter - event.launchFrame;
        progress = Math.min(1, Math.max(0, elapsed / totalFrames));

        if (event.hasBezierArc) {
          // Source parity: DumbProjectileBehavior cubic Bezier flight path evaluation.
          // P0 = (sourceX, sourceY, sourceZ), P3 = (impactX, impactY, impactZ).
          // P1 and P2 placed along the 3D line at firstPercentIndent/secondPercentIndent.
          const p0x = event.sourceX, p0y = event.sourceY, p0z = event.sourceZ;
          const p3x = event.impactX, p3y = event.impactY, p3z = event.impactZ;
          const dx = p3x - p0x, dy = p3y - p0y, dz = p3z - p0z;
          const dist = Math.hypot(dx, dy, dz);
          const nx = dist > 0 ? dx / dist : 0;
          const nz = dist > 0 ? dz / dist : 0;
          const p1x = p0x + nx * dist * event.bezierFirstPercentIndent;
          const p1z = p0z + nz * dist * event.bezierFirstPercentIndent;
          const p2x = p0x + nx * dist * event.bezierSecondPercentIndent;
          const p2z = p0z + nz * dist * event.bezierSecondPercentIndent;

          x = evaluateCubicBezier(progress, p0x, p1x, p2x, p3x);
          y = evaluateCubicBezier(progress, p0y, event.bezierP1Y, event.bezierP2Y, p3y);
          z = evaluateCubicBezier(progress, p0z, p1z, p2z, p3z);
        } else {
          // Fallback: linear XZ + parabolic Y arc for projectiles without Bezier data.
          x = event.sourceX + (event.impactX - event.sourceX) * progress;
          z = event.sourceZ + (event.impactZ - event.sourceZ) * progress;
          const baseY = event.sourceY;
          const arcHeight = Math.max(5, Math.hypot(event.impactX - event.sourceX, event.impactZ - event.sourceZ) * 0.15);
          const arcY = baseY + arcHeight * 4 * progress * (1 - progress);
          const terrainY = heightmap ? heightmap.getInterpolatedHeight(x, z) : 0;
          y = Math.max(terrainY + 1, arcY);
        }

        // Heading from source to target.
        heading = Math.atan2(event.impactX - event.sourceX, event.impactZ - event.sourceZ);
      }

      projectiles.push({
        id: event.projectileVisualId,
        sourceEntityId: event.sourceEntityId,
        visualType: event.cachedVisualType,
        x, y, z,
        targetX: event.impactX,
        targetZ: event.impactZ,
        progress,
        heading,
      });
    }

    return projectiles;
  }

  getSelectedEntityInfos(entityIds: readonly number[]): SelectedEntityInfo[] {
    const infos: SelectedEntityInfo[] = [];
    const seen = new Set<number>();
    for (const entityId of entityIds) {
      if (seen.has(entityId)) {
        continue;
      }
      seen.add(entityId);
      const info = this.getSelectedEntityInfoById(entityId);
      if (info !== null) {
        infos.push(info);
      }
    }
    return infos;
  }

  getProductionState(entityId: number): {
    queueEntryCount: number;
    maxQueueEntries?: number;
    queue: Array<{
      type: 'UNIT';
      templateName: string;
      productionId: number;
      buildCost: number;
      totalProductionFrames: number;
      framesUnderConstruction: number;
      percentComplete: number;
      productionQuantityTotal: number;
      productionQuantityProduced: number;
    } | {
      type: 'UPGRADE';
      upgradeName: string;
      productionId: number;
      buildCost: number;
      totalProductionFrames: number;
      framesUnderConstruction: number;
      percentComplete: number;
      upgradeType: 'PLAYER' | 'OBJECT';
    }>;
  } | null {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return null;
    }

    return {
      queueEntryCount: entity.productionQueue.length,
      maxQueueEntries: entity.productionProfile?.maxQueueEntries,
      queue: entity.productionQueue.map((entry) => {
        if (entry.type === 'UPGRADE') {
          return {
            type: entry.type,
            upgradeName: entry.upgradeName,
            productionId: entry.productionId,
            buildCost: entry.buildCost,
            totalProductionFrames: entry.totalProductionFrames,
            framesUnderConstruction: entry.framesUnderConstruction,
            percentComplete: entry.percentComplete,
            upgradeType: entry.upgradeType,
          };
        }

        return {
          type: entry.type,
          templateName: entry.templateName,
          productionId: entry.productionId,
          buildCost: entry.buildCost,
          totalProductionFrames: entry.totalProductionFrames,
          framesUnderConstruction: entry.framesUnderConstruction,
          percentComplete: entry.percentComplete,
          productionQuantityTotal: entry.productionQuantityTotal,
          productionQuantityProduced: entry.productionQuantityProduced,
        };
      }),
    };
  }

  getSideCredits(side: string): number {
    return this.sideCredits.get(this.normalizeSide(side)) ?? 0;
  }

  setSideCredits(side: string, amount: number): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }
    const normalizedAmount = Number.isFinite(amount) ? Math.max(0, Math.trunc(amount)) : 0;
    this.sideCredits.set(normalizedSide, normalizedAmount);
  }

  addSideCredits(side: string, amount: number): number {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return 0;
    }
    const delta = Number.isFinite(amount) ? Math.trunc(amount) : 0;
    const current = this.sideCredits.get(normalizedSide) ?? 0;
    const next = Math.max(0, current + delta);
    this.sideCredits.set(normalizedSide, next);
    return next;
  }

  getSidePlayerType(side: string | undefined): SidePlayerType {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return 'HUMAN';
    }
    return this.sidePlayerTypes.get(normalizedSide) ?? 'HUMAN';
  }

  setSidePlayerType(side: string, playerType: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    const normalizedType = playerType.trim().toUpperCase();
    if (!normalizedSide) {
      return false;
    }
    if (normalizedType !== 'HUMAN' && normalizedType !== 'COMPUTER') {
      return false;
    }

    this.sidePlayerTypes.set(normalizedSide, normalizedType);
    return true;
  }

  getSideScoreState(side: string): {
    structuresBuilt: number;
    moneySpent: number;
  } {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return { structuresBuilt: 0, moneySpent: 0 };
    }
    const score = this.sideScoreState.get(normalizedSide);
    if (!score) {
      return { structuresBuilt: 0, moneySpent: 0 };
    }
    return {
      structuresBuilt: score.structuresBuilt,
      moneySpent: score.moneySpent,
    };
  }

  getScriptObjectTopologyVersion(): number {
    return this.scriptObjectTopologyVersion;
  }

  getScriptObjectCountChangedFrame(): number {
    return this.scriptObjectCountChangedFrame;
  }

  /**
   * Source parity groundwork: ScriptEngine object-count cache invalidation check.
   * Returns true when object topology changed after the supplied frame.
   */
  didScriptObjectCountChangeSince(frame: number): boolean {
    return this.scriptObjectCountChangedFrame > frame;
  }

  /**
   * Source parity groundwork: named map trigger regions used by scripting.
   */
  getMapTriggerNames(): string[] {
    const names = new Set<string>();
    for (const trigger of this.mapTriggerRegions) {
      if (trigger.nameUpper.length === 0) continue;
      names.add(trigger.name);
    }
    return Array.from(names.values()).sort((left, right) => left.localeCompare(right));
  }

  /**
   * Source parity groundwork: test whether a world point lies inside a named trigger polygon.
   */
  isPointInsideMapTrigger(triggerName: string, worldX: number, worldZ: number): boolean {
    const normalizedName = triggerName.trim().toUpperCase();
    if (!normalizedName) return false;
    for (const trigger of this.mapTriggerRegions) {
      if (trigger.nameUpper !== normalizedName) continue;
      if (this.isPointInsideTriggerRegion(trigger, worldX, worldZ)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity groundwork: script object-count query for trigger/side/template conditions.
   */
  getScriptObjectCount(filter: {
    side?: string;
    templateName?: string;
    kindOfAll?: string[];
    triggerName?: string;
  } = {}): number {
    const normalizedSide = filter.side ? this.normalizeSide(filter.side) : null;
    const normalizedTemplate = filter.templateName
      ? filter.templateName.trim().toUpperCase()
      : '';
    const requiredKinds = (filter.kindOfAll ?? [])
      .map((kind) => kind.trim().toUpperCase())
      .filter((kind) => kind.length > 0);

    let regionCandidates: typeof this.mapTriggerRegions | null = null;
    if (filter.triggerName) {
      const triggerName = filter.triggerName.trim().toUpperCase();
      if (!triggerName) return 0;
      regionCandidates = this.mapTriggerRegions.filter((region) => region.nameUpper === triggerName);
      if (regionCandidates.length === 0) return 0;
    }

    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (normalizedSide && this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (normalizedTemplate && entity.templateName.toUpperCase() !== normalizedTemplate) continue;
      if (requiredKinds.length > 0 && !requiredKinds.every((kind) => entity.kindOf.has(kind))) continue;

      if (regionCandidates) {
        let inAnyRegion = false;
        for (const region of regionCandidates) {
          if (this.isPointInsideTriggerRegion(region, entity.x, entity.z)) {
            inAnyRegion = true;
            break;
          }
        }
        if (!inAnyRegion) continue;
      }

      count += 1;
    }

    return count;
  }

  /**
   * Source parity subset: ScriptEngine counter state mutation for script integration.
   */
  setScriptCounter(counterName: string, value: number): boolean {
    const counter = this.getOrCreateScriptCounter(counterName);
    if (!counter) {
      return false;
    }
    counter.value = Number.isFinite(value) ? Math.trunc(value) : 0;
    counter.isCountdownTimer = false;
    return true;
  }

  /**
   * Source parity subset: ScriptEngine counter increment/decrement helpers.
   */
  addScriptCounter(counterName: string, delta: number): boolean {
    const counter = this.getOrCreateScriptCounter(counterName);
    if (!counter) {
      return false;
    }
    const normalizedDelta = Number.isFinite(delta) ? Math.trunc(delta) : 0;
    counter.value += normalizedDelta;
    return true;
  }

  /**
   * Source parity subset: ScriptEngine::setTimer frame countdown semantics.
   */
  startScriptTimer(counterName: string, frames: number): boolean {
    const counter = this.getOrCreateScriptCounter(counterName);
    if (!counter) {
      return false;
    }
    counter.value = Number.isFinite(frames) ? Math.trunc(frames) : 0;
    counter.isCountdownTimer = true;
    return true;
  }

  /**
   * Source parity subset: ScriptEngine::pauseTimer.
   */
  pauseScriptTimer(counterName: string): boolean {
    const counter = this.getOrCreateScriptCounter(counterName);
    if (!counter) {
      return false;
    }
    counter.isCountdownTimer = false;
    return true;
  }

  /**
   * Source parity subset: ScriptEngine::restartTimer.
   */
  resumeScriptTimer(counterName: string): boolean {
    const counter = this.getOrCreateScriptCounter(counterName);
    if (!counter) {
      return false;
    }
    if (counter.value > 0) {
      counter.isCountdownTimer = true;
    }
    return true;
  }

  /**
   * Source parity subset: ScriptEngine::setFlag.
   */
  setScriptFlag(flagName: string, value: boolean): boolean {
    const normalizedName = this.normalizeScriptVariableName(flagName);
    if (!normalizedName) {
      return false;
    }
    this.scriptFlagsByName.set(normalizedName, value);
    return true;
  }

  /**
   * Source parity subset: ScriptEngine::signalUIInteract one-frame flag signal.
   */
  notifyScriptUIInteraction(flagName: string): boolean {
    const normalizedName = this.normalizeScriptVariableName(flagName);
    if (!normalizedName) {
      return false;
    }
    this.scriptUIInteractions.add(normalizedName);
    return true;
  }

  /**
   * Source parity subset: ScriptEngine action execution for counter/flag/timer/team/money actions.
   * C++ reference: ScriptEngine::executeActions switch + setCounter/addCounter/subCounter/setFlag/setTimer.
   */
  executeScriptAction(action: unknown): boolean {
    if (!action || typeof action !== 'object') {
      return false;
    }

    const actionRecord = action as Record<string, unknown>;
    const actionType = this.resolveScriptActionTypeName(actionRecord.actionType ?? actionRecord.type);
    if (!actionType) {
      return false;
    }

    const { paramsObject, paramsArray } = this.resolveScriptConditionParams(actionRecord);
    const readValue = (index: number, keyNames: readonly string[] = []): unknown =>
      this.resolveScriptConditionParamValue(actionRecord, paramsObject, paramsArray, index, keyNames);
    const readString = (index: number, keyNames: readonly string[] = []): string =>
      this.coerceScriptConditionString(readValue(index, keyNames));
    const readNumber = (index: number, keyNames: readonly string[] = []): number =>
      this.coerceScriptConditionNumber(readValue(index, keyNames)) ?? 0;
    const readInteger = (index: number, keyNames: readonly string[] = []): number =>
      Math.trunc(readNumber(index, keyNames));
    const readBoolean = (index: number, keyNames: readonly string[] = []): boolean =>
      this.coerceScriptConditionBoolean(readValue(index, keyNames), false);

    switch (actionType) {
      case 'SET_FLAG':
        return this.setScriptFlag(
          readString(0, ['flagName', 'flag']),
          readBoolean(1, ['value', 'enabled']),
        );
      case 'SET_COUNTER':
        return this.setScriptCounter(
          readString(0, ['counterName', 'counter']),
          readInteger(1, ['value']),
        );
      case 'TEAM_SET_STATE':
        return this.setScriptTeamState(
          readString(0, ['teamName', 'team']),
          readString(1, ['stateName', 'state']),
        );
      case 'INCREMENT_COUNTER':
        return this.addScriptCounter(
          readString(1, ['counterName', 'counter']),
          readInteger(0, ['value']),
        );
      case 'DECREMENT_COUNTER':
        return this.addScriptCounter(
          readString(1, ['counterName', 'counter']),
          -readInteger(0, ['value']),
        );
      case 'SET_TIMER':
        return this.startScriptTimer(
          readString(0, ['counterName', 'counter']),
          readInteger(1, ['value', 'frames']),
        );
      case 'SET_RANDOM_TIMER': {
        const minFrames = readInteger(1, ['value', 'minFrames']);
        const maxFrames = readInteger(2, ['randomValue', 'maxFrames']);
        return this.startScriptTimer(
          readString(0, ['counterName', 'counter']),
          this.resolveScriptRandomInt(minFrames, maxFrames),
        );
      }
      case 'STOP_TIMER':
        return this.pauseScriptTimer(readString(0, ['counterName', 'counter']));
      case 'RESTART_TIMER':
        return this.resumeScriptTimer(readString(0, ['counterName', 'counter']));
      case 'SET_MILLISECOND_TIMER': {
        const seconds = readNumber(1, ['value', 'seconds']);
        return this.startScriptTimer(
          readString(0, ['counterName', 'counter']),
          this.secondsToScriptTimerFrames(seconds),
        );
      }
      case 'SET_RANDOM_MSEC_TIMER': {
        const minSeconds = readNumber(1, ['value', 'minSeconds']);
        const maxSeconds = readNumber(2, ['randomValue', 'maxSeconds']);
        const seconds = this.resolveScriptRandomReal(minSeconds, maxSeconds);
        return this.startScriptTimer(
          readString(0, ['counterName', 'counter']),
          this.secondsToScriptTimerFrames(seconds),
        );
      }
      case 'ADD_TO_MSEC_TIMER': {
        const seconds = readNumber(0, ['value', 'seconds']);
        return this.addScriptCounter(
          readString(1, ['counterName', 'counter']),
          this.secondsToScriptTimerFrames(seconds),
        );
      }
      case 'SUB_FROM_MSEC_TIMER': {
        const seconds = readNumber(0, ['value', 'seconds']);
        return this.addScriptCounter(
          readString(1, ['counterName', 'counter']),
          this.secondsToScriptTimerFrames(-seconds),
        );
      }
      case 'TEAM_TRANSFER_TO_PLAYER':
        return this.setScriptTeamControllingSide(
          readString(0, ['teamName', 'team']),
          readString(1, ['side', 'playerName', 'player']),
        );
      case 'PLAYER_SET_MONEY': {
        const side = readString(0, ['side', 'playerName', 'player']);
        if (!this.normalizeSide(side)) {
          return false;
        }
        this.setSideCredits(side, readInteger(1, ['value', 'amount', 'money']));
        return true;
      }
      case 'PLAYER_GIVE_MONEY': {
        const side = readString(0, ['side', 'playerName', 'player']);
        if (!this.normalizeSide(side)) {
          return false;
        }
        this.addSideCredits(side, readInteger(1, ['value', 'amount', 'money']));
        return true;
      }
      case 'PLAYER_ADD_SKILLPOINTS': {
        const side = readString(0, ['side', 'playerName', 'player']);
        if (!this.normalizeSide(side)) {
          return false;
        }
        this.adjustSideSkillPoints(side, readInteger(1, ['value', 'amount', 'skillPoints']));
        return true;
      }
      case 'PLAYER_ADD_RANKLEVEL': {
        const side = readString(0, ['side', 'playerName', 'player']);
        const normalizedSide = this.normalizeSide(side);
        if (!normalizedSide) {
          return false;
        }
        const rankState = this.getSideRankStateMap(normalizedSide);
        this.setSideRankLevelByNormalizedSide(
          normalizedSide,
          rankState.rankLevel + readInteger(1, ['value', 'amount', 'rankLevels']),
        );
        return true;
      }
      case 'PLAYER_SET_RANKLEVEL': {
        const side = readString(0, ['side', 'playerName', 'player']);
        if (!this.normalizeSide(side)) {
          return false;
        }
        this.setSideRankLevel(side, readInteger(1, ['value', 'rankLevel']));
        return true;
      }
      case 'PLAYER_SET_RANKLEVELLIMIT':
        this.rankLevelLimit = Math.max(
          1,
          Math.min(RANK_TABLE.length, readInteger(0, ['value', 'rankLevelLimit'])),
        );
        return true;
      case 'PLAYER_GRANT_SCIENCE':
        return this.grantSideScience(
          readString(0, ['side', 'playerName', 'player']),
          readString(1, ['scienceName', 'science']),
        );
      case 'PLAYER_PURCHASE_SCIENCE': {
        const side = readString(0, ['side', 'playerName', 'player']);
        const normalizedSide = this.normalizeSide(side);
        if (!normalizedSide) {
          return false;
        }

        const science = this.resolveScienceInternalName(readString(1, ['scienceName', 'science']));
        if (!science) {
          return false;
        }

        if (!this.canSidePurchaseScience(normalizedSide, science)) {
          return false;
        }

        const registry = this.iniDataRegistry;
        if (!registry) {
          return false;
        }
        const scienceDef = findScienceDefByName(registry, science);
        if (!scienceDef) {
          return false;
        }
        const scienceCost = this.getSciencePurchaseCost(scienceDef);
        if (scienceCost <= 0) {
          return false;
        }

        if (!this.addScienceToSide(normalizedSide, science)) {
          return false;
        }

        const rankState = this.getSideRankStateMap(normalizedSide);
        rankState.sciencePurchasePoints = Math.max(0, rankState.sciencePurchasePoints - scienceCost);
        return true;
      }
      case 'PLAYER_SCIENCE_AVAILABILITY':
        return this.setSideScienceAvailability(
          readString(0, ['side', 'playerName', 'player']),
          readString(1, ['scienceName', 'science']),
          readString(2, ['availability', 'scienceAvailability', 'value']),
        );
      default:
        return false;
    }
  }

  /**
   * Source parity: ScriptConditions::evaluateCondition dispatcher.
   * Accepts either positional parameter arrays (`params` / `parameters`) or named parameter objects.
   */
  evaluateScriptCondition(condition: unknown): boolean {
    if (!condition || typeof condition !== 'object') {
      return false;
    }

    const conditionRecord = condition as Record<string, unknown>;
    const conditionType = this.resolveScriptConditionTypeName(
      conditionRecord.conditionType ?? conditionRecord.type,
    );
    if (!conditionType) {
      return false;
    }

    const { paramsObject, paramsArray } = this.resolveScriptConditionParams(conditionRecord);
    const conditionCacheId = this.resolveScriptConditionCacheId(conditionRecord, paramsObject);

    const readValue = (index: number, keyNames: readonly string[] = []): unknown =>
      this.resolveScriptConditionParamValue(conditionRecord, paramsObject, paramsArray, index, keyNames);
    const readString = (index: number, keyNames: readonly string[] = []): string =>
      this.coerceScriptConditionString(readValue(index, keyNames));
    const readNumber = (index: number, keyNames: readonly string[] = []): number =>
      this.coerceScriptConditionNumber(readValue(index, keyNames)) ?? 0;
    const readInteger = (index: number, keyNames: readonly string[] = []): number =>
      Math.trunc(readNumber(index, keyNames));
    const readBoolean = (
      index: number,
      keyNames: readonly string[] = [],
      defaultValue = false,
    ): boolean => this.coerceScriptConditionBoolean(readValue(index, keyNames), defaultValue);
    const readOptionalInteger = (
      index: number,
      keyNames: readonly string[] = [],
    ): number | undefined => {
      const value = this.coerceScriptConditionNumber(readValue(index, keyNames));
      return value === null ? undefined : Math.trunc(value);
    };
    const readComparison = (
      index: number,
      keyNames: readonly string[] = [],
    ): ScriptComparisonInput => {
      const value = readValue(index, keyNames);
      if (typeof value === 'number' && Number.isFinite(value)) {
        return Math.trunc(value);
      }
      return this.coerceScriptConditionString(value) as ScriptComparisonType;
    };
    const readRelationship = (
      index: number,
      keyNames: readonly string[] = [],
    ): ScriptRelationshipInput => {
      const value = readValue(index, keyNames);
      if (typeof value === 'number' && Number.isFinite(value)) {
        return Math.trunc(value);
      }
      return this.coerceScriptConditionString(value) as ScriptRelationshipInput;
    };

    switch (conditionType) {
      case 'CONDITION_FALSE':
        return false;
      case 'CONDITION_TRUE':
        return true;
      case 'COUNTER':
        return this.evaluateScriptCounterCondition({
          counterName: readString(0, ['counterName', 'counter']),
          comparison: readComparison(1, ['comparison']),
          value: readInteger(2, ['value']),
        });
      case 'FLAG':
        return this.evaluateScriptFlagCondition({
          flagName: readString(0, ['flagName', 'flag']),
          value: readBoolean(1, ['value']),
        });
      case 'TIMER_EXPIRED':
        return this.evaluateScriptTimerExpired({
          counterName: readString(0, ['counterName', 'counter']),
        });

      case 'PLAYER_ALL_DESTROYED':
        return this.evaluateScriptAllDestroyed({
          side: readString(0, ['side']),
        });
      case 'PLAYER_ALL_BUILDFACILITIES_DESTROYED':
        return this.evaluateScriptAllBuildFacilitiesDestroyed({
          side: readString(0, ['side']),
        });
      case 'TEAM_INSIDE_AREA_PARTIALLY':
        return this.evaluateScriptTeamInsideAreaPartially({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'TEAM_DESTROYED':
        return this.evaluateScriptIsDestroyed({
          teamName: readString(0, ['teamName', 'team']),
        });
      case 'CAMERA_MOVEMENT_FINISHED':
        // TODO(source-parity): route to TacticalView::isCameraMovementFinished once view scripting is wired.
        return true;
      case 'TEAM_HAS_UNITS':
        return this.evaluateScriptHasUnits({
          teamName: readString(0, ['teamName', 'team']),
        });
      case 'TEAM_STATE_IS':
        return this.evaluateScriptTeamStateIs({
          teamName: readString(0, ['teamName', 'team']),
          stateName: readString(1, ['stateName', 'state']),
        });
      case 'TEAM_STATE_IS_NOT':
        return this.evaluateScriptTeamStateIsNot({
          teamName: readString(0, ['teamName', 'team']),
          stateName: readString(1, ['stateName', 'state']),
        });
      case 'NAMED_INSIDE_AREA':
        return this.evaluateScriptNamedInsideArea({
          entityId: readInteger(0, ['entityId']),
          triggerName: readString(1, ['triggerName', 'trigger']),
        });
      case 'NAMED_OUTSIDE_AREA':
        return this.evaluateScriptNamedOutsideArea({
          entityId: readInteger(0, ['entityId']),
          triggerName: readString(1, ['triggerName', 'trigger']),
        });
      case 'NAMED_DESTROYED':
        return this.evaluateScriptNamedUnitDestroyed({
          entityId: readInteger(0, ['entityId']),
        });
      case 'NAMED_NOT_DESTROYED':
        return this.evaluateScriptNamedUnitExists({
          entityId: readInteger(0, ['entityId']),
        });
      case 'TEAM_INSIDE_AREA_ENTIRELY':
        return this.evaluateScriptTeamInsideAreaEntirely({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'TEAM_OUTSIDE_AREA_ENTIRELY':
        return this.evaluateScriptTeamOutsideAreaEntirely({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'NAMED_ATTACKED_BY_OBJECTTYPE':
        return this.evaluateScriptNamedAttackedByType({
          entityId: readInteger(0, ['entityId']),
          objectType: readString(1, ['objectType', 'templateName', 'unitType']),
        });
      case 'TEAM_ATTACKED_BY_OBJECTTYPE':
        return this.evaluateScriptTeamAttackedByType({
          teamName: readString(0, ['teamName', 'team']),
          objectType: readString(1, ['objectType', 'templateName', 'unitType']),
        });
      case 'NAMED_ATTACKED_BY_PLAYER':
        return this.evaluateScriptNamedAttackedByPlayer({
          entityId: readInteger(0, ['entityId']),
          attackedBySide: readString(1, ['attackedBySide', 'side']),
        });
      case 'TEAM_ATTACKED_BY_PLAYER':
        return this.evaluateScriptTeamAttackedByPlayer({
          teamName: readString(0, ['teamName', 'team']),
          attackedBySide: readString(1, ['attackedBySide', 'side']),
        });
      case 'BUILT_BY_PLAYER':
        return this.evaluateScriptBuiltByPlayer({
          templateName: readString(0, ['templateName', 'objectType', 'unitType']),
          side: readString(1, ['side']),
          conditionCacheId,
        });
      case 'NAMED_CREATED':
        return this.evaluateScriptNamedCreated({
          entityId: readInteger(0, ['entityId']),
        });
      case 'TEAM_CREATED':
        return this.evaluateScriptTeamCreated({
          teamName: readString(0, ['teamName', 'team']),
        });
      case 'PLAYER_HAS_CREDITS':
        return this.evaluateScriptPlayerHasCredits({
          credits: readNumber(0, ['credits']),
          comparison: readComparison(1, ['comparison']),
          side: readString(2, ['side']),
        });
      case 'NAMED_DISCOVERED':
        return this.evaluateScriptNamedDiscovered({
          entityId: readInteger(0, ['entityId']),
          side: readString(1, ['side']),
        });
      case 'TEAM_DISCOVERED':
        return this.evaluateScriptTeamDiscovered({
          teamName: readString(0, ['teamName', 'team']),
          side: readString(1, ['side']),
        });
      case 'MISSION_ATTEMPTS':
        return this.evaluateScriptMissionAttempts({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          attempts: readInteger(2, ['attempts']),
        });
      case 'NAMED_OWNED_BY_PLAYER':
        return this.evaluateScriptNamedOwnedByPlayer({
          entityId: readInteger(0, ['entityId']),
          side: readString(1, ['side']),
        });
      case 'TEAM_OWNED_BY_PLAYER':
        return this.evaluateScriptTeamOwnedByPlayer({
          teamName: readString(0, ['teamName', 'team']),
          side: readString(1, ['side']),
        });
      case 'PLAYER_HAS_N_OR_FEWER_BUILDINGS':
        return this.evaluateScriptPlayerHasNOrFewerBuildings({
          side: readString(0, ['side']),
          buildingCount: readInteger(1, ['buildingCount', 'count']),
        });
      case 'PLAYER_HAS_POWER':
        return this.evaluateScriptPlayerHasPower({
          side: readString(0, ['side']),
        });
      case 'PLAYER_HAS_NO_POWER':
        return !this.evaluateScriptPlayerHasPower({
          side: readString(0, ['side']),
        });
      case 'NAMED_REACHED_WAYPOINTS_END':
        return this.evaluateScriptNamedReachedWaypointsEnd({
          entityId: readInteger(0, ['entityId']),
          waypointPathName: readString(1, ['waypointPathName', 'waypointPath']),
        });
      case 'TEAM_REACHED_WAYPOINTS_END':
        return this.evaluateScriptTeamReachedWaypointsEnd({
          teamName: readString(0, ['teamName', 'team']),
          waypointPathName: readString(1, ['waypointPathName', 'waypointPath']),
        });
      case 'NAMED_SELECTED':
        return this.evaluateScriptNamedSelected({
          entityId: readInteger(0, ['entityId']),
        });
      case 'NAMED_ENTERED_AREA':
        return this.evaluateScriptNamedEnteredArea({
          entityId: readInteger(0, ['entityId']),
          triggerName: readString(1, ['triggerName', 'trigger']),
        });
      case 'NAMED_EXITED_AREA':
        return this.evaluateScriptNamedExitedArea({
          entityId: readInteger(0, ['entityId']),
          triggerName: readString(1, ['triggerName', 'trigger']),
        });
      case 'TEAM_ENTERED_AREA_ENTIRELY':
        return this.evaluateScriptTeamEnteredAreaEntirely({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'TEAM_ENTERED_AREA_PARTIALLY':
        return this.evaluateScriptTeamEnteredAreaPartially({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'TEAM_EXITED_AREA_ENTIRELY':
        return this.evaluateScriptTeamExitedAreaEntirely({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'TEAM_EXITED_AREA_PARTIALLY':
        return this.evaluateScriptTeamExitedAreaPartially({
          teamName: readString(0, ['teamName', 'team']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          surfacesAllowed: readOptionalInteger(2, ['surfacesAllowed']),
        });
      case 'MULTIPLAYER_ALLIED_VICTORY':
        return this.evaluateScriptMultiplayerAlliedVictory();
      case 'MULTIPLAYER_ALLIED_DEFEAT':
        return this.evaluateScriptMultiplayerAlliedDefeat();
      case 'MULTIPLAYER_PLAYER_DEFEAT':
        return this.evaluateScriptMultiplayerPlayerDefeat();
      case 'HAS_FINISHED_VIDEO':
        return this.evaluateScriptVideoHasCompleted({
          videoName: readString(0, ['videoName']),
        });
      case 'HAS_FINISHED_SPEECH':
        return this.evaluateScriptSpeechHasCompleted({
          speechName: readString(0, ['speechName']),
        });
      case 'HAS_FINISHED_AUDIO':
        return this.evaluateScriptAudioHasCompleted({
          audioName: readString(0, ['audioName']),
        });
      case 'BUILDING_ENTERED_BY_PLAYER':
        return this.evaluateScriptBuildingEntered({
          entityId: readInteger(0, ['entityId']),
          side: readString(1, ['side']),
        });
      case 'ENEMY_SIGHTED':
        return this.evaluateScriptEnemySighted({
          entityId: readInteger(0, ['entityId']),
          alliance: readRelationship(1, ['alliance']),
          side: readString(2, ['side']),
        });
      case 'TYPE_SIGHTED':
        return this.evaluateScriptTypeSighted({
          entityId: readInteger(0, ['entityId']),
          objectType: readString(1, ['objectType', 'templateName', 'unitType']),
          side: readString(2, ['side']),
        });
      case 'UNIT_HEALTH':
        return this.evaluateScriptUnitHealth({
          entityId: readInteger(0, ['entityId']),
          comparison: readComparison(1, ['comparison']),
          healthPercent: readNumber(2, ['healthPercent']),
        });
      case 'BRIDGE_REPAIRED':
        return this.evaluateScriptBridgeRepaired({
          entityId: readInteger(0, ['entityId']),
        });
      case 'BRIDGE_BROKEN':
        return this.evaluateScriptBridgeBroken({
          entityId: readInteger(0, ['entityId']),
        });
      case 'NAMED_DYING':
        return this.evaluateScriptNamedUnitDying({
          entityId: readInteger(0, ['entityId']),
        });
      case 'NAMED_TOTALLY_DEAD':
        return this.evaluateScriptNamedUnitTotallyDead({
          entityId: readInteger(0, ['entityId']),
        });
      case 'PLAYER_HAS_OBJECT_COMPARISON':
        return this.evaluateScriptPlayerUnitCondition({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          count: readInteger(2, ['count']),
          unitType: readString(3, ['unitType', 'objectType', 'templateName']),
          conditionCacheId,
        });
      case 'PLAYER_TRIGGERED_SPECIAL_POWER':
        return this.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
        });
      case 'PLAYER_TRIGGERED_SPECIAL_POWER_FROM_NAMED':
        return this.evaluateScriptPlayerSpecialPowerFromUnitTriggered({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
          sourceEntityId: readOptionalInteger(2, ['sourceEntityId', 'entityId']),
        });
      case 'PLAYER_MIDWAY_SPECIAL_POWER':
        return this.evaluateScriptPlayerSpecialPowerFromUnitMidway({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
        });
      case 'PLAYER_MIDWAY_SPECIAL_POWER_FROM_NAMED':
        return this.evaluateScriptPlayerSpecialPowerFromUnitMidway({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
          sourceEntityId: readOptionalInteger(2, ['sourceEntityId', 'entityId']),
        });
      case 'PLAYER_COMPLETED_SPECIAL_POWER':
        return this.evaluateScriptPlayerSpecialPowerFromUnitComplete({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
        });
      case 'PLAYER_COMPLETED_SPECIAL_POWER_FROM_NAMED':
        return this.evaluateScriptPlayerSpecialPowerFromUnitComplete({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
          sourceEntityId: readOptionalInteger(2, ['sourceEntityId', 'entityId']),
        });
      case 'PLAYER_ACQUIRED_SCIENCE':
        return this.evaluateScriptScienceAcquired({
          side: readString(0, ['side']),
          scienceName: readString(1, ['scienceName']),
        });
      case 'PLAYER_CAN_PURCHASE_SCIENCE':
        return this.evaluateScriptCanPurchaseScience({
          side: readString(0, ['side']),
          scienceName: readString(1, ['scienceName']),
        });
      case 'PLAYER_HAS_SCIENCEPURCHASEPOINTS':
        return this.evaluateScriptSciencePurchasePoints({
          side: readString(0, ['side']),
          pointsNeeded: readNumber(1, ['pointsNeeded', 'sciencePurchasePoints']),
        });
      case 'NAMED_HAS_FREE_CONTAINER_SLOTS':
        return this.evaluateScriptNamedHasFreeContainerSlots({
          entityId: readInteger(0, ['entityId']),
        });
      case 'PLAYER_BUILT_UPGRADE':
        return this.evaluateScriptUpgradeFromUnitComplete({
          side: readString(0, ['side']),
          upgradeName: readString(1, ['upgradeName', 'upgrade']),
        });
      case 'PLAYER_BUILT_UPGRADE_FROM_NAMED':
        return this.evaluateScriptUpgradeFromUnitComplete({
          side: readString(0, ['side']),
          upgradeName: readString(1, ['upgradeName', 'upgrade']),
          sourceEntityId: readOptionalInteger(2, ['sourceEntityId', 'entityId']),
        });
      case 'DEFUNCT_PLAYER_SELECTED_GENERAL':
      case 'DEFUNCT_PLAYER_SELECTED_GENERAL_FROM_NAMED':
        return false;
      case 'PLAYER_DESTROYED_N_BUILDINGS_PLAYER':
        return this.evaluateScriptPlayerDestroyedNOrMoreBuildings({
          side: readString(0, ['side']),
          count: readInteger(1, ['count']),
          opponentSide: readString(2, ['opponentSide']),
        });
      case 'PLAYER_HAS_COMPARISON_UNIT_TYPE_IN_TRIGGER_AREA':
        return this.evaluateScriptPlayerHasUnitTypeInArea({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          count: readInteger(2, ['count']),
          templateName: readString(3, ['templateName', 'objectType', 'unitType']),
          triggerName: readString(4, ['triggerName', 'trigger']),
          conditionCacheId,
        });
      case 'PLAYER_HAS_COMPARISON_UNIT_KIND_IN_TRIGGER_AREA':
        return this.evaluateScriptPlayerHasUnitKindInArea({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          count: readInteger(2, ['count']),
          kindOf: readString(3, ['kindOf']),
          triggerName: readString(4, ['triggerName', 'trigger']),
          conditionCacheId,
        });
      case 'UNIT_EMPTIED':
        return this.evaluateScriptUnitHasEmptied({
          entityId: readInteger(0, ['entityId']),
        });
      case 'NAMED_BUILDING_IS_EMPTY':
        return this.evaluateScriptIsBuildingEmpty({
          entityId: readInteger(0, ['entityId']),
        });
      case 'PLAYER_HAS_N_OR_FEWER_FACTION_BUILDINGS':
        return this.evaluateScriptPlayerHasNOrFewerFactionBuildings({
          side: readString(0, ['side']),
          buildingCount: readInteger(1, ['buildingCount', 'count']),
        });
      case 'UNIT_HAS_OBJECT_STATUS':
        return this.evaluateScriptUnitHasObjectStatus({
          entityId: readInteger(0, ['entityId']),
          objectStatus: readString(1, ['objectStatus']),
        });
      case 'TEAM_ALL_HAS_OBJECT_STATUS':
        return this.evaluateScriptTeamHasObjectStatus({
          teamName: readString(0, ['teamName', 'team']),
          objectStatus: readString(1, ['objectStatus']),
          entireTeam: true,
        });
      case 'TEAM_SOME_HAVE_OBJECT_STATUS':
        return this.evaluateScriptTeamHasObjectStatus({
          teamName: readString(0, ['teamName', 'team']),
          objectStatus: readString(1, ['objectStatus']),
          entireTeam: false,
        });
      case 'PLAYER_POWER_COMPARE_PERCENT':
        return this.evaluateScriptPlayerHasComparisonPercentPower({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          percent: readNumber(2, ['percent']),
        });
      case 'PLAYER_EXCESS_POWER_COMPARE_VALUE':
        return this.evaluateScriptPlayerHasComparisonValueExcessPower({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          kilowatts: readNumber(2, ['kilowatts']),
        });
      case 'SKIRMISH_SPECIAL_POWER_READY':
        return this.evaluateScriptSkirmishSpecialPowerIsReady({
          side: readString(0, ['side']),
          specialPowerName: readString(1, ['specialPowerName', 'specialPower']),
          conditionCacheId,
        });
      case 'SKIRMISH_VALUE_IN_AREA':
        return this.evaluateScriptSkirmishValueInArea({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          money: readInteger(2, ['money', 'value']),
          triggerName: readString(3, ['triggerName', 'trigger']),
          conditionCacheId,
        });
      case 'SKIRMISH_PLAYER_FACTION':
        return this.evaluateScriptSkirmishPlayerIsFaction({
          side: readString(0, ['side']),
          factionName: readString(1, ['factionName', 'faction']),
        });
      case 'SKIRMISH_SUPPLIES_VALUE_WITHIN_DISTANCE':
        return this.evaluateScriptSkirmishSuppliesWithinDistancePerimeter({
          side: readString(0, ['side']),
          distance: readNumber(1, ['distance']),
          triggerName: readString(2, ['triggerName', 'trigger']),
          value: readInteger(3, ['value']),
        });
      case 'SKIRMISH_TECH_BUILDING_WITHIN_DISTANCE':
        return this.evaluateScriptSkirmishPlayerTechBuildingWithinDistancePerimeter({
          side: readString(0, ['side']),
          distance: readNumber(1, ['distance']),
          triggerName: readString(2, ['triggerName', 'trigger']),
          conditionCacheId,
        });
      case 'SKIRMISH_COMMAND_BUTTON_READY_ALL':
        return this.evaluateScriptSkirmishCommandButtonIsReady({
          side: readString(0, ['side']),
          commandButtonName: readString(2, ['commandButtonName', 'commandButton']),
          allReady: true,
        });
      case 'SKIRMISH_COMMAND_BUTTON_READY_PARTIAL':
        return this.evaluateScriptSkirmishCommandButtonIsReady({
          side: readString(0, ['side']),
          commandButtonName: readString(2, ['commandButtonName', 'commandButton']),
          allReady: false,
        });
      case 'SKIRMISH_UNOWNED_FACTION_UNIT_EXISTS':
        return this.evaluateScriptSkirmishUnownedFactionUnitComparison({
          comparison: readComparison(1, ['comparison']),
          count: readInteger(2, ['count']),
        });
      case 'SKIRMISH_PLAYER_HAS_PREREQUISITE_TO_BUILD':
        return this.evaluateScriptSkirmishPlayerHasPrereqsToBuild({
          side: readString(0, ['side']),
          templateName: readString(1, ['templateName', 'objectType', 'unitType']),
        });
      case 'SKIRMISH_PLAYER_HAS_COMPARISON_GARRISONED':
        return this.evaluateScriptSkirmishPlayerHasComparisonGarrisoned({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          count: readInteger(2, ['count']),
        });
      case 'SKIRMISH_PLAYER_HAS_COMPARISON_CAPTURED_UNITS':
        return this.evaluateScriptSkirmishPlayerHasComparisonCapturedUnits({
          side: readString(0, ['side']),
          comparison: readComparison(1, ['comparison']),
          count: readInteger(2, ['count']),
        });
      case 'SKIRMISH_NAMED_AREA_EXIST':
        return this.evaluateScriptSkirmishNamedAreaExists(
          readString(1, ['triggerName', 'trigger']),
        );
      case 'SKIRMISH_PLAYER_HAS_UNITS_IN_AREA':
        return this.evaluateScriptSkirmishPlayerHasUnitsInArea({
          side: readString(0, ['side']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          conditionCacheId,
        });
      case 'SKIRMISH_PLAYER_HAS_BEEN_ATTACKED_BY_PLAYER':
        return this.evaluateScriptSkirmishPlayerHasBeenAttackedByPlayer({
          side: readString(0, ['side']),
          attackedBySide: readString(1, ['attackedBySide', 'side']),
        });
      case 'SKIRMISH_PLAYER_IS_OUTSIDE_AREA':
        return this.evaluateScriptSkirmishPlayerIsOutsideArea({
          side: readString(0, ['side']),
          triggerName: readString(1, ['triggerName', 'trigger']),
          conditionCacheId,
        });
      case 'SKIRMISH_PLAYER_HAS_DISCOVERED_PLAYER':
        return this.evaluateScriptSkirmishPlayerHasDiscoveredPlayer({
          side: readString(0, ['side']),
          discoveredBySide: readString(1, ['discoveredBySide', 'side']),
        });
      case 'MUSIC_TRACK_HAS_COMPLETED':
        return this.evaluateScriptMusicHasCompleted({
          musicName: readString(0, ['musicName']),
          index: readInteger(1, ['index']),
        });
      case 'PLAYER_LOST_OBJECT_TYPE':
        return this.evaluateScriptPlayerLostObjectType({
          side: readString(0, ['side']),
          templateName: readString(1, ['templateName', 'objectType', 'unitType']),
        });
      case 'SUPPLY_SOURCE_SAFE':
        return this.evaluateScriptSkirmishSupplySourceSafe({
          side: readString(0, ['side']),
          minSupplyAmount: readNumber(1, ['minSupplyAmount', 'supplyAmount']),
          conditionCacheId,
        });
      case 'SUPPLY_SOURCE_ATTACKED':
        return this.evaluateScriptSkirmishSupplySourceAttacked({
          side: readString(0, ['side']),
        });
      case 'START_POSITION_IS':
        return this.evaluateScriptSkirmishStartPosition({
          side: readString(0, ['side']),
          startPosition: readInteger(1, ['startPosition']),
        });

      default:
        // TODO(source-parity): script-sequential and camera/view conditions.
        return false;
    }
  }

  /**
   * Source parity subset: explicit script-team membership assignment.
   * TODO(source-parity): support TeamPrototype instance resolution and THIS_TEAM semantics.
   */
  setScriptTeamMembers(teamName: string, entityIds: readonly number[]): boolean {
    const team = this.getOrCreateScriptTeamRecord(teamName);
    if (!team) {
      return false;
    }

    const nextMembers = new Set<number>();
    for (const entityIdRaw of entityIds) {
      if (!Number.isFinite(entityIdRaw)) {
        continue;
      }
      const entityId = Math.trunc(entityIdRaw);
      if (!this.spawnedEntities.has(entityId)) {
        continue;
      }
      nextMembers.add(entityId);
    }
    team.memberEntityIds = nextMembers;
    team.created = true;
    return true;
  }

  /**
   * Source parity subset: Team::getState storage.
   * TODO(source-parity): tie this to Team state machine updates.
   */
  setScriptTeamState(teamName: string, stateName: string): boolean {
    const team = this.getOrCreateScriptTeamRecord(teamName);
    if (!team) {
      return false;
    }
    team.stateName = stateName.trim();
    return true;
  }

  /**
   * Source parity subset: Team::isCreated toggle.
   */
  setScriptTeamCreated(teamName: string, created: boolean): boolean {
    const team = this.getOrCreateScriptTeamRecord(teamName);
    if (!team) {
      return false;
    }
    team.created = created;
    return true;
  }

  /**
   * Source parity subset: Team controlling player side override.
   */
  setScriptTeamControllingSide(teamName: string, side: string | null): boolean {
    const team = this.getOrCreateScriptTeamRecord(teamName);
    if (!team) {
      return false;
    }
    if (side === null) {
      team.controllingSide = null;
      return true;
    }
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return false;
    }
    team.controllingSide = normalizedSide;
    return true;
  }

  clearScriptTeam(teamName: string): boolean {
    const teamNameUpper = this.normalizeScriptTeamName(teamName);
    if (!teamNameUpper) {
      return false;
    }
    return this.scriptTeamsByName.delete(teamNameUpper);
  }

  /**
   * Source parity: ScriptEngine::notifyOfCompletedVideo.
   */
  notifyScriptVideoCompleted(videoName: string): void {
    const normalizedName = this.normalizeScriptCompletionName(videoName);
    if (!normalizedName) {
      return;
    }
    this.scriptCompletedVideos.push(normalizedName);
  }

  /**
   * Source parity subset: ScriptEngine speech completion notifications.
   * TODO(source-parity): speech completion should be computed from audio length.
   */
  notifyScriptSpeechCompleted(speechName: string): void {
    const normalizedName = this.normalizeScriptCompletionName(speechName);
    if (!normalizedName) {
      return;
    }
    this.scriptCompletedSpeech.push(normalizedName);
  }

  /**
   * Source parity subset: ScriptEngine audio completion notifications.
   * TODO(source-parity): audio completion should be computed from audio length.
   */
  notifyScriptAudioCompleted(audioName: string): void {
    const normalizedName = this.normalizeScriptCompletionName(audioName);
    if (!normalizedName) {
      return;
    }
    this.scriptCompletedAudio.push(normalizedName);
  }

  /**
   * Source parity: Audio::hasMusicTrackCompleted completion hook.
   */
  notifyScriptMusicCompleted(trackName: string, index: number): void {
    const normalizedName = this.normalizeScriptCompletionName(trackName);
    if (!normalizedName || !Number.isFinite(index)) {
      return;
    }
    this.scriptCompletedMusic.push({
      name: normalizedName,
      index: Math.trunc(index),
    });
  }

  /**
   * Source parity subset: AIUpdateInterface::getCompletedWaypoint() notification.
   * TODO(source-parity): drive this from script waypoint-path movement actions.
   */
  notifyScriptWaypointPathCompleted(entityId: number, waypointPathName: string): void {
    if (!Number.isFinite(entityId)) {
      return;
    }
    const normalizedPathName = this.normalizeScriptCompletionName(waypointPathName);
    if (!normalizedPathName) {
      return;
    }
    const normalizedEntityId = Math.trunc(entityId);
    if (!this.spawnedEntities.has(normalizedEntityId)) {
      return;
    }
    let completedPaths = this.scriptCompletedWaypointPathsByEntityId.get(normalizedEntityId);
    if (!completedPaths) {
      completedPaths = new Set<string>();
      this.scriptCompletedWaypointPathsByEntityId.set(normalizedEntityId, completedPaths);
    }
    completedPaths.add(normalizedPathName);
  }

  /**
   * Source parity subset: ScriptConditions::evaluateNamedReachedWaypointsEnd.
   * TODO(source-parity): populate completion labels from waypoint path follower AI.
   */
  evaluateScriptNamedReachedWaypointsEnd(filter: {
    entityId: number;
    waypointPathName: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const pathName = this.normalizeScriptCompletionName(filter.waypointPathName);
    if (!pathName) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    if (!this.spawnedEntities.has(entityId)) {
      return false;
    }
    const completedPaths = this.scriptCompletedWaypointPathsByEntityId.get(entityId);
    if (!completedPaths) {
      return false;
    }
    return completedPaths.has(pathName);
  }

  /**
   * Source parity: ScriptConditions::evaluateVideoHasCompleted.
   */
  evaluateScriptVideoHasCompleted(filter: {
    videoName: string;
  }): boolean {
    const normalizedName = this.normalizeScriptCompletionName(filter.videoName);
    if (!normalizedName) {
      return false;
    }
    return this.consumeScriptCompletedName(this.scriptCompletedVideos, normalizedName);
  }

  /**
   * Source parity subset: ScriptConditions::evaluateSpeechHasCompleted.
   * TODO(source-parity): compute completion deadlines from audio metadata.
   */
  evaluateScriptSpeechHasCompleted(filter: {
    speechName: string;
  }): boolean {
    const normalizedName = this.normalizeScriptCompletionName(filter.speechName);
    if (!normalizedName) {
      return false;
    }
    return this.consumeScriptCompletedName(this.scriptCompletedSpeech, normalizedName);
  }

  /**
   * Source parity subset: ScriptConditions::evaluateAudioHasCompleted.
   * TODO(source-parity): compute completion deadlines from audio metadata.
   */
  evaluateScriptAudioHasCompleted(filter: {
    audioName: string;
  }): boolean {
    const normalizedName = this.normalizeScriptCompletionName(filter.audioName);
    if (!normalizedName) {
      return false;
    }
    return this.consumeScriptCompletedName(this.scriptCompletedAudio, normalizedName);
  }

  /**
   * Source parity: ScriptConditions::evaluateMusicHasCompleted.
   */
  evaluateScriptMusicHasCompleted(filter: {
    musicName: string;
    index: number;
  }): boolean {
    const normalizedName = this.normalizeScriptCompletionName(filter.musicName);
    if (!normalizedName || !Number.isFinite(filter.index)) {
      return false;
    }
    const index = Math.trunc(filter.index);
    for (let eventIndex = 0; eventIndex < this.scriptCompletedMusic.length; eventIndex += 1) {
      const event = this.scriptCompletedMusic[eventIndex]!;
      if (event.name !== normalizedName || event.index !== index) {
        continue;
      }
      this.scriptCompletedMusic.splice(eventIndex, 1);
      return true;
    }
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateAllDestroyed.
   * Non-existent side/player resolves to true.
   */
  evaluateScriptAllDestroyed(filter: {
    side: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return true;
    }

    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (this.isScriptEntityEffectivelyDead(entity) || entity.health <= 0) continue;
      if (entity.kindOf.has('PROJECTILE') || entity.kindOf.has('INERT') || entity.kindOf.has('MINE')) {
        continue;
      }
      return false;
    }

    return true;
  }

  /**
   * Source parity: ScriptConditions::evaluateAllBuildFacilitiesDestroyed.
   * Non-existent side/player resolves to true.
   */
  evaluateScriptAllBuildFacilitiesDestroyed(filter: {
    side: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return true;
    }

    const buildFacilityNames = this.getBuildFacilityTemplateNames();
    if (buildFacilityNames.size === 0) {
      return true;
    }

    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (!buildFacilityNames.has(entity.templateName.trim().toUpperCase())) continue;
      return false;
    }

    return true;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateIsDestroyed.
   * TODO(source-parity): support full ScriptEngine team instance resolution.
   */
  evaluateScriptIsDestroyed(filter: {
    teamName: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptTeamMemberAliveForObjects(entity)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateHasUnits.
   * TODO(source-parity): support full ScriptEngine team instance resolution.
   */
  evaluateScriptHasUnits(filter: {
    teamName: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptTeamMemberAliveForUnits(entity)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamStateIs.
   */
  evaluateScriptTeamStateIs(filter: {
    teamName: string;
    stateName: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    return team.stateName === filter.stateName.trim();
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamStateIsNot.
   */
  evaluateScriptTeamStateIsNot(filter: {
    teamName: string;
    stateName: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    return team.stateName !== filter.stateName.trim();
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamAttackedByType.
   * TODO(source-parity): support ScriptEngine object-type groups (getObjectTypes()).
   */
  evaluateScriptTeamAttackedByType(filter: {
    teamName: string;
    objectType: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.evaluateScriptNamedAttackedByType({
        entityId: entity.id,
        objectType: filter.objectType,
      })) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamAttackedByPlayer.
   * TODO(source-parity): support full ScriptEngine team instance resolution.
   */
  evaluateScriptTeamAttackedByPlayer(filter: {
    teamName: string;
    attackedBySide: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.evaluateScriptNamedAttackedByPlayer({
        entityId: entity.id,
        attackedBySide: filter.attackedBySide,
      })) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamCreated.
   * TODO(source-parity): wire team creation lifecycle from TeamFactory.
   */
  evaluateScriptTeamCreated(filter: {
    teamName: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    return team.created;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamDiscovered.
   * TODO(source-parity): support full ScriptEngine team instance resolution.
   */
  evaluateScriptTeamDiscovered(filter: {
    teamName: string;
    side: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.evaluateScriptNamedDiscovered({ entityId: entity.id, side: filter.side })) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamOwnedByPlayer.
   * TODO(source-parity): bind to Team::getControllingPlayer().
   */
  evaluateScriptTeamOwnedByPlayer(filter: {
    teamName: string;
    side: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const controllingSide = this.resolveScriptTeamControllingSide(team);
    if (!controllingSide) {
      return false;
    }
    return controllingSide === normalizedSide;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamReachedWaypointsEnd.
   * TODO(source-parity): support TeamPrototype instance expansion.
   */
  evaluateScriptTeamReachedWaypointsEnd(filter: {
    teamName: string;
    waypointPathName: string;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.evaluateScriptNamedReachedWaypointsEnd({
        entityId: entity.id,
        waypointPathName: filter.waypointPathName,
      })) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamIsContained.
   * TODO(source-parity): include AI_EXIT transitional containment state.
   */
  evaluateScriptTeamIsContained(filter: {
    teamName: string;
    allContained: boolean;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    let anyConsidered = false;
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      const isContained = this.isEntityContained(entity);
      if (isContained) {
        if (!filter.allContained) {
          return true;
        }
      } else if (filter.allContained) {
        return false;
      }
      anyConsidered = true;
    }

    if (!anyConsidered) {
      return false;
    }
    return filter.allContained;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamHasObjectStatus.
   * TODO(source-parity): support full ScriptEngine team instance resolution.
   */
  evaluateScriptTeamHasObjectStatus(filter: {
    teamName: string;
    objectStatus: string;
    entireTeam: boolean;
  }): boolean {
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    const normalizedStatus = filter.objectStatus.trim().toUpperCase();
    if (!normalizedStatus) {
      return false;
    }

    for (const entity of this.getScriptTeamMemberEntities(team)) {
      const hasStatus = entity.objectStatusFlags.has(normalizedStatus);
      if (filter.entireTeam && !hasStatus) {
        return false;
      }
      if (!filter.entireTeam && hasStatus) {
        return true;
      }
    }

    return filter.entireTeam;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamInsideAreaEntirely.
   * TODO(source-parity): apply locomotor surface filtering (whichToConsider mask).
   */
  evaluateScriptTeamInsideAreaEntirely(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    void filter.surfacesAllowed;
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    const triggerNameUpper = filter.triggerName.trim().toUpperCase();
    if (!triggerNameUpper) {
      return false;
    }
    const triggerIndex = this.mapTriggerRegions.findIndex((region) => region.nameUpper === triggerNameUpper);
    if (triggerIndex < 0) {
      return false;
    }

    // Source parity: empty teams are not inside.
    if (this.evaluateScriptIsDestroyed({ teamName: filter.teamName })) {
      return false;
    }

    let anyConsidered = false;
    let anyOutside = false;
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptEntityEffectivelyDead(entity)) {
        continue;
      }
      if (entity.kindOf.has('INERT')) {
        continue;
      }

      if (!this.isScriptTeamMemberInsideTrigger(entity.id, triggerIndex)) {
        anyOutside = true;
      }
      anyConsidered = true;
    }

    return anyConsidered && !anyOutside;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamInsideAreaPartially.
   * TODO(source-parity): apply locomotor surface filtering (whichToConsider mask).
   */
  evaluateScriptTeamInsideAreaPartially(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    void filter.surfacesAllowed;
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    const triggerNameUpper = filter.triggerName.trim().toUpperCase();
    if (!triggerNameUpper) {
      return false;
    }
    const triggerIndex = this.mapTriggerRegions.findIndex((region) => region.nameUpper === triggerNameUpper);
    if (triggerIndex < 0) {
      return false;
    }

    let anyConsidered = false;
    let anyInside = false;
    let anyOutside = false;
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptEntityEffectivelyDead(entity)) {
        continue;
      }
      if (entity.kindOf.has('INERT')) {
        continue;
      }

      if (this.isScriptTeamMemberInsideTrigger(entity.id, triggerIndex)) {
        anyInside = true;
      } else {
        anyOutside = true;
      }
      anyConsidered = true;
    }

    const someInsideSomeOutside = anyConsidered && anyInside && anyOutside;
    const allInside = anyConsidered && !anyOutside;
    return someInsideSomeOutside || allInside;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamOutsideAreaEntirely.
   */
  evaluateScriptTeamOutsideAreaEntirely(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    return !(this.evaluateScriptTeamInsideAreaEntirely(filter) || this.evaluateScriptTeamInsideAreaPartially(filter));
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamEnteredAreaEntirely.
   * TODO(source-parity): apply locomotor surface filtering (whichToConsider mask).
   */
  evaluateScriptTeamEnteredAreaEntirely(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    void filter.surfacesAllowed;
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    if (!this.didScriptTeamMemberEnterOrExitThisFrame(team)) {
      return false;
    }

    const triggerNameUpper = filter.triggerName.trim().toUpperCase();
    if (!triggerNameUpper) {
      return false;
    }
    const triggerIndex = this.mapTriggerRegions.findIndex((region) => region.nameUpper === triggerNameUpper);
    if (triggerIndex < 0) {
      return false;
    }

    let entered = false;
    let outside = false;
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptEntityEffectivelyDead(entity)) {
        continue;
      }
      if (entity.kindOf.has('INERT')) {
        continue;
      }

      if (this.didScriptTeamMemberEnterTrigger(entity.id, triggerIndex)) {
        entered = true;
      } else if (!this.isScriptTeamMemberInsideTrigger(entity.id, triggerIndex)) {
        outside = true;
      }
    }

    return entered && !outside;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamEnteredAreaPartially.
   * TODO(source-parity): apply locomotor surface filtering (whichToConsider mask).
   */
  evaluateScriptTeamEnteredAreaPartially(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    void filter.surfacesAllowed;
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    if (!this.didScriptTeamMemberEnterOrExitThisFrame(team)) {
      return false;
    }

    const triggerNameUpper = filter.triggerName.trim().toUpperCase();
    if (!triggerNameUpper) {
      return false;
    }
    const triggerIndex = this.mapTriggerRegions.findIndex((region) => region.nameUpper === triggerNameUpper);
    if (triggerIndex < 0) {
      return false;
    }

    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptEntityEffectivelyDead(entity)) {
        continue;
      }
      if (entity.kindOf.has('INERT')) {
        continue;
      }
      if (this.didScriptTeamMemberEnterTrigger(entity.id, triggerIndex)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamExitedAreaEntirely.
   * TODO(source-parity): apply locomotor surface filtering (whichToConsider mask).
   */
  evaluateScriptTeamExitedAreaEntirely(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    void filter.surfacesAllowed;
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    if (!this.didScriptTeamMemberEnterOrExitThisFrame(team)) {
      return false;
    }

    const triggerNameUpper = filter.triggerName.trim().toUpperCase();
    if (!triggerNameUpper) {
      return false;
    }
    const triggerIndex = this.mapTriggerRegions.findIndex((region) => region.nameUpper === triggerNameUpper);
    if (triggerIndex < 0) {
      return false;
    }

    let anyConsidered = false;
    let exited = false;
    let inside = false;
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptEntityEffectivelyDead(entity)) {
        continue;
      }
      if (entity.kindOf.has('INERT')) {
        continue;
      }

      if (this.didScriptTeamMemberExitTrigger(entity.id, triggerIndex)) {
        exited = true;
      } else if (this.isScriptTeamMemberInsideTrigger(entity.id, triggerIndex)) {
        inside = true;
      }
      anyConsidered = true;
    }

    return anyConsidered && exited && !inside;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTeamExitedAreaPartially.
   * TODO(source-parity): apply locomotor surface filtering (whichToConsider mask).
   */
  evaluateScriptTeamExitedAreaPartially(filter: {
    teamName: string;
    triggerName: string;
    surfacesAllowed?: number;
  }): boolean {
    void filter.surfacesAllowed;
    const team = this.getScriptTeamRecord(filter.teamName);
    if (!team) {
      return false;
    }

    if (!this.didScriptTeamMemberEnterOrExitThisFrame(team)) {
      return false;
    }

    const triggerNameUpper = filter.triggerName.trim().toUpperCase();
    if (!triggerNameUpper) {
      return false;
    }
    const triggerIndex = this.mapTriggerRegions.findIndex((region) => region.nameUpper === triggerNameUpper);
    if (triggerIndex < 0) {
      return false;
    }

    for (const entity of this.getScriptTeamMemberEntities(team)) {
      if (this.isScriptEntityEffectivelyDead(entity)) {
        continue;
      }
      if (entity.kindOf.has('INERT')) {
        continue;
      }
      if (this.didScriptTeamMemberExitTrigger(entity.id, triggerIndex)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedOwnedByPlayer.
   */
  evaluateScriptNamedOwnedByPlayer(filter: {
    entityId: number;
    side: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }

    return this.normalizeSide(entity.side) === normalizedSide;
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedDiscovered.
   */
  evaluateScriptNamedDiscovered(filter: {
    entityId: number;
    side: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }

    // Source parity: held objects are not visible.
    if (entity.objectStatusFlags.has('DISABLED_HELD')) {
      return false;
    }
    // Source parity: stealthed + not detected/disguised objects are not visible.
    if (entity.objectStatusFlags.has('STEALTHED')
      && !entity.objectStatusFlags.has('DETECTED')
      && !entity.objectStatusFlags.has('DISGUISED')) {
      return false;
    }

    const shroudStatus = this.resolveEntityShroudStatusForSide(entity, normalizedSide);
    return shroudStatus === 'CLEAR' || shroudStatus === 'FOGGED';
  }

  /**
   * Source parity subset: ScriptConditions::evaluateNamedSelected.
   * TODO(source-parity): condition cache invalidation by UI selection-change frame.
   */
  evaluateScriptNamedSelected(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }
    return entity.selected;
  }

  /**
   * Source parity: ScriptConditions::evaluateBridgeBroken.
   */
  evaluateScriptBridgeBroken(filter: {
    entityId: number;
  }): boolean {
    if (this.bridgeDamageStatesChangedFrame !== this.frameCounter) {
      return false;
    }
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    if (!this.spawnedEntities.has(entityId)) {
      return false;
    }
    return this.bridgeDamageStateByControlEntity.get(entityId) === false;
  }

  /**
   * Source parity: ScriptConditions::evaluateBridgeRepaired.
   */
  evaluateScriptBridgeRepaired(filter: {
    entityId: number;
  }): boolean {
    if (this.bridgeDamageStatesChangedFrame !== this.frameCounter) {
      return false;
    }
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    if (!this.spawnedEntities.has(entityId)) {
      return false;
    }
    return this.bridgeDamageStateByControlEntity.get(entityId) === true;
  }

  /**
   * Source parity: ScriptConditions::evaluateMultiplayerAlliedVictory.
   */
  evaluateScriptMultiplayerAlliedVictory(): boolean {
    const localSide = this.resolveLocalPlayerSide();
    if (!localSide) {
      return false;
    }
    return this.gameEndFrame !== null && !this.defeatedSides.has(localSide);
  }

  /**
   * Source parity: ScriptConditions::evaluateMultiplayerAlliedDefeat.
   */
  evaluateScriptMultiplayerAlliedDefeat(): boolean {
    const localSide = this.resolveLocalPlayerSide();
    if (!localSide) {
      // Source parity: observers treat "single alliance remaining" as allied defeat.
      return this.gameEndFrame !== null;
    }
    return this.gameEndFrame !== null && this.defeatedSides.has(localSide);
  }

  /**
   * Source parity: ScriptConditions::evaluateMultiplayerPlayerDefeat.
   */
  evaluateScriptMultiplayerPlayerDefeat(): boolean {
    const localSide = this.resolveLocalPlayerSide();
    if (!localSide) {
      return false;
    }
    return this.defeatedSides.has(localSide) && !this.evaluateScriptMultiplayerAlliedDefeat();
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishNamedAreaExists.
   */
  evaluateScriptSkirmishNamedAreaExists(triggerName: string): boolean {
    return this.findMapTriggerRegionsByName(triggerName).length > 0;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerHasUnitsInArea.
   */
  evaluateScriptSkirmishPlayerHasUnitsInArea(filter: {
    side: string;
    triggerName: string;
    conditionCacheId?: string;
  }): boolean {
    const triggerRegions = this.findMapTriggerRegionsByName(filter.triggerName);
    if (triggerRegions.length === 0) {
      return false;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    let anyChanges = cache === null || cache.customData === 0;
    // TODO(source-parity): include Team::didEnterOrExit once script team tracking exists.
    if (cache && this.scriptObjectCountChangedFrame > cache.customFrame) {
      anyChanges = true;
    }
    // Until team enter/exit notifications are available, area membership can change without
    // topology changes, so conservatively recompute every call.
    anyChanges = true;
    if (!anyChanges && cache) {
      return cache.customData === 1;
    }

    let objectCount = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (!this.isInsideAnyTriggerRegion(entity, triggerRegions)) continue;
      if (entity.destroyed || entity.kindOf.has('INERT') || entity.kindOf.has('PROJECTILE')) continue;
      objectCount += 1;
    }

    const hasUnits = objectCount > 0;
    if (cache) {
      cache.customData = hasUnits ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return hasUnits;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerIsOutsideArea.
   */
  evaluateScriptSkirmishPlayerIsOutsideArea(filter: {
    side: string;
    triggerName: string;
    conditionCacheId?: string;
  }): boolean {
    return !this.evaluateScriptSkirmishPlayerHasUnitsInArea(filter);
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerHasBeenAttackedByPlayer.
   */
  evaluateScriptSkirmishPlayerHasBeenAttackedByPlayer(filter: {
    side: string;
    attackedBySide: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedAttacker = this.normalizeSide(filter.attackedBySide);
    if (!normalizedSide || !normalizedAttacker) {
      return false;
    }
    return this.sideAttackedBy.get(normalizedSide)?.has(normalizedAttacker) ?? false;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerIsFaction.
   */
  evaluateScriptSkirmishPlayerIsFaction(filter: {
    side: string;
    factionName: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedFaction = this.normalizeSide(filter.factionName);
    if (!normalizedSide || !normalizedFaction) {
      return false;
    }
    return normalizedSide === normalizedFaction;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerHasDiscoveredPlayer.
   */
  evaluateScriptSkirmishPlayerHasDiscoveredPlayer(filter: {
    side: string;
    discoveredBySide: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedDiscoveredBySide = this.normalizeSide(filter.discoveredBySide);
    if (!normalizedSide || !normalizedDiscoveredBySide) {
      return false;
    }

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      // Source parity: held objects do not count as discovered.
      if (entity.objectStatusFlags.has('DISABLED_HELD')) continue;
      // Source parity: stealthed + not detected/disguised objects are not visible.
      if (entity.objectStatusFlags.has('STEALTHED')
        && !entity.objectStatusFlags.has('DETECTED')
        && !entity.objectStatusFlags.has('DISGUISED')) {
        continue;
      }

      const shroudStatus = this.resolveEntityShroudStatusForSide(entity, normalizedDiscoveredBySide);
      if (shroudStatus === 'CLEAR' || shroudStatus === 'FOGGED') {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishSpecialPowerIsReady.
   * Uses condition cache id to mirror Parameter::friend_setInt(nextFrame) short-circuiting.
   */
  evaluateScriptSkirmishSpecialPowerIsReady(filter: {
    side: string;
    specialPowerName: string;
    conditionCacheId?: string;
  }): boolean {
    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    if (cache && cache.customData === -1 && this.frameCounter < cache.customFrame) {
      return false;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(filter.specialPowerName);
    if (!normalizedSide || !normalizedSpecialPowerName) {
      if (cache) {
        cache.customData = -1;
        cache.customFrame = this.frameCounter;
      }
      return false;
    }

    const specialPowerDef = this.resolveSpecialPowerDefByName(normalizedSpecialPowerName);
    if (!specialPowerDef) {
      // Source parity: friend_setInt(-1) marks as never true.
      if (cache) {
        cache.customData = -1;
        cache.customFrame = Number.MAX_SAFE_INTEGER;
      }
      return false;
    }

    let nextFrame = this.frameCounter + this.msToLogicFrames(10000);
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) continue;
      if (this.isEntityScriptSpecialPowerDisabled(entity)) continue;

      const module = entity.specialPowerModules.get(normalizedSpecialPowerName);
      if (!module) continue;

      const readyFrame = this.resolveSpecialPowerReadyFrameForSourceEntity(
        normalizedSpecialPowerName,
        entity.id,
      );
      if (readyFrame <= this.frameCounter) {
        if (cache) {
          cache.customData = 1;
          cache.customFrame = this.frameCounter;
        }
        return true;
      }
      if (readyFrame < nextFrame) {
        nextFrame = readyFrame;
      }
    }

    if (cache) {
      cache.customData = -1;
      cache.customFrame = nextFrame;
    }
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishValueInArea.
   * Sums BuildCost of alive, non-inert side-owned objects inside trigger.
   */
  evaluateScriptSkirmishValueInArea(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    money: number;
    triggerName: string;
    conditionCacheId?: string;
  }): boolean {
    const triggerRegions = this.findMapTriggerRegionsByName(filter.triggerName);
    if (triggerRegions.length === 0) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    let anyChanges = cache === null || cache.customData === 0;
    // TODO(source-parity): include Team::didEnterOrExit once script team tracking exists.
    if (cache && this.scriptObjectCountChangedFrame !== cache.customFrame) {
      anyChanges = true;
    }
    // Movement in/out can happen without topology changes; recompute conservatively.
    anyChanges = true;
    if (!anyChanges && cache) {
      return cache.customData === 1;
    }

    let totalCost = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (entity.destroyed) continue;
      if (entity.kindOf.has('INERT')) continue;
      if (!this.isInsideAnyTriggerRegion(entity, triggerRegions)) continue;
      totalCost += this.resolveEntityBuildCostRaw(entity);
    }

    const comparison = this.compareScriptCount(filter.comparison, totalCost, filter.money);
    if (cache) {
      cache.customData = comparison ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return comparison;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishSuppliesWithinDistancePerimeter.
   * Finds max supply value among non-enemy supply warehouses in trigger radius+distance.
   */
  evaluateScriptSkirmishSuppliesWithinDistancePerimeter(filter: {
    side: string;
    distance: number;
    triggerName: string;
    value: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const triggerRegion = this.findMapTriggerRegionsByName(filter.triggerName)[0];
    if (!triggerRegion) {
      return false;
    }

    const { centerX, centerZ, radius } = this.computeTriggerRegionCenterAndRadius(triggerRegion);
    const searchRadius = radius + (Number.isFinite(filter.distance) ? filter.distance : 0);
    const searchRadiusSq = searchRadius * searchRadius;
    const compareToValue = Number.isFinite(filter.value) ? filter.value : 0;

    let maxValue = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (!entity.kindOf.has('STRUCTURE')) continue;
      if (!entity.supplyWarehouseProfile) continue;

      const entitySide = this.normalizeSide(entity.side);
      if (entitySide && this.getTeamRelationshipBySides(normalizedSide, entitySide) === RELATIONSHIP_ENEMIES) {
        continue;
      }

      const dx = entity.x - centerX;
      const dz = entity.z - centerZ;
      if (dx * dx + dz * dz > searchRadiusSq) continue;

      const warehouseState = this.supplyWarehouseStates.get(entity.id);
      if (!warehouseState) continue;

      const value = DEFAULT_SUPPLY_BOX_VALUE * warehouseState.currentBoxes;
      if (value > maxValue) {
        maxValue = value;
      }
    }

    return maxValue > compareToValue;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerTechBuildingWithinDistancePerimeter.
   */
  evaluateScriptSkirmishPlayerTechBuildingWithinDistancePerimeter(filter: {
    side: string;
    distance: number;
    triggerName: string;
    conditionCacheId?: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const triggerRegion = this.findMapTriggerRegionsByName(filter.triggerName)[0];
    if (!triggerRegion) {
      return false;
    }

    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    // Source parity: this condition is effectively static and cached permanently once evaluated.
    if (cache && cache.customData !== 0) {
      return cache.customData === 1;
    }

    const { centerX, centerZ, radius } = this.computeTriggerRegionCenterAndRadius(triggerRegion);
    const searchRadius = radius + (Number.isFinite(filter.distance) ? filter.distance : 0);
    const searchRadiusSq = searchRadius * searchRadius;

    let found = false;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (!entity.kindOf.has('TECH_BUILDING')) continue;

      const candidateSide = this.normalizeSide(entity.side);
      if (!candidateSide || candidateSide === normalizedSide) continue;
      if (this.getTeamRelationshipBySides(normalizedSide, candidateSide) !== RELATIONSHIP_ALLIES) continue;

      const dx = entity.x - centerX;
      const dz = entity.z - centerZ;
      if (dx * dx + dz * dz > searchRadiusSq) continue;
      found = true;
      break;
    }

    if (cache) {
      cache.customData = found ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return found;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishCommandButtonIsReady.
   * TODO(source-parity): team-level iteration is pending ScriptEngine team tracking; this
   * currently scans side-owned entities.
   */
  evaluateScriptSkirmishCommandButtonIsReady(filter: {
    side: string;
    commandButtonName: string;
    allReady: boolean;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }
    const commandButtonDef = findCommandButtonDefByName(registry, filter.commandButtonName);
    if (!commandButtonDef) {
      return false;
    }

    const specialPowerName = this.normalizeShortcutSpecialPowerName(
      readStringField(commandButtonDef.fields, ['SpecialPower'])
      ?? readStringField(commandButtonDef.fields, ['SpecialPowerTemplate'])
      ?? '',
    );
    const upgradeName = readStringField(commandButtonDef.fields, ['Upgrade'])?.trim().toUpperCase() ?? '';
    const upgradeDef = upgradeName ? findUpgradeDefByName(registry, upgradeName) ?? null : null;

    if (!specialPowerName && !upgradeDef) {
      return false;
    }

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }

      let ready: boolean | null = null;
      if (specialPowerName) {
        ready = this.evaluateScriptCommandButtonSpecialPowerReady(entity, specialPowerName);
      } else if (upgradeDef) {
        ready = this.evaluateScriptCommandButtonUpgradeReady(entity, upgradeDef);
      }

      if (ready === null) {
        continue;
      }

      if (ready) {
        if (!filter.allReady) {
          return true;
        }
      } else if (filter.allReady) {
        return false;
      }
    }

    return filter.allReady;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishUnownedFactionUnitComparison.
   * Counts neutral-controlled unmanned faction units.
   */
  evaluateScriptSkirmishUnownedFactionUnitComparison(filter: {
    comparison: ScriptComparisonInput;
    count: number;
  }): boolean {
    let factionUnitCount = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (!entity.objectStatusFlags.has('DISABLED_UNMANNED')) continue;
      if (!this.isEntityNeutralControlled(entity)) continue;
      factionUnitCount += 1;
    }
    return this.compareScriptCount(filter.comparison, factionUnitCount, filter.count);
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishSupplySourceAttacked.
   * Mirrors AIPlayer::isSupplySourceAttacked polling on economy unit damage.
   */
  evaluateScriptSkirmishSupplySourceAttacked(filter: {
    side: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const scanRateFrames = 10;
    if (this.frameCounter === 0) {
      this.sideSupplySourceAttackCheckFrame.set(normalizedSide, this.frameCounter + scanRateFrames);
      return false;
    }

    this.sideAttackedSupplySource.delete(normalizedSide);

    const nextCheckFrame = this.sideSupplySourceAttackCheckFrame.get(normalizedSide) ?? 0;
    if (this.frameCounter < nextCheckFrame) {
      return false;
    }

    const attackedFrame = this.sideAttackedFrame.get(normalizedSide);
    if (attackedFrame === undefined || attackedFrame + scanRateFrames < this.frameCounter) {
      return false;
    }

    this.sideSupplySourceAttackCheckFrame.set(normalizedSide, this.frameCounter + scanRateFrames);

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      if (
        !entity.kindOf.has('CASH_GENERATOR')
        && !entity.kindOf.has('DOZER')
        && !entity.kindOf.has('HARVESTER')
      ) {
        continue;
      }

      // TODO(source-parity): C++ also checks Body::getLastDamageInfo()->out.m_noEffect.
      if (entity.lastDamageFrame > 0 && entity.lastDamageFrame + scanRateFrames > this.frameCounter) {
        this.sideAttackedSupplySource.set(normalizedSide, entity.id);
        return true;
      }
    }

    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishSupplySourceSafe.
   * Polls every 2 seconds and caches the prior result via condition cache state.
   */
  evaluateScriptSkirmishSupplySourceSafe(filter: {
    side: string;
    minSupplyAmount: number;
    conditionCacheId?: string;
  }): boolean {
    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    const anyChanges = cache === null || this.frameCounter > cache.customFrame;
    if (!anyChanges && cache) {
      if (cache.customData === -1) return false;
      if (cache.customData === 1) return true;
    }

    if (cache) {
      cache.customFrame = this.frameCounter + 2 * LOGIC_FRAME_RATE;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      if (cache) {
        cache.customData = -1;
      }
      return false;
    }

    const minSupplyAmount = Number.isFinite(filter.minSupplyAmount)
      ? Math.max(0, Math.trunc(filter.minSupplyAmount))
      : 0;
    const isSafe = this.isScriptSupplySourceSafe(normalizedSide, minSupplyAmount);
    if (cache) {
      cache.customData = isSafe ? 1 : -1;
    }
    return isSafe;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishStartPosition.
   */
  evaluateScriptSkirmishStartPosition(filter: {
    side: string;
    startPosition: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const expectedStartIndex = Number.isFinite(filter.startPosition)
      ? Math.trunc(filter.startPosition) - 1
      : -1;
    if (expectedStartIndex < 0) {
      return false;
    }

    const actualStartIndex = this.sideSkirmishStartIndex.get(normalizedSide);
    if (actualStartIndex === undefined) {
      return false;
    }

    return actualStartIndex === expectedStartIndex;
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerHasPrereqsToBuild.
   */
  evaluateScriptSkirmishPlayerHasPrereqsToBuild(filter: {
    side: string;
    templateName: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const objectDef = this.resolveObjectDefByTemplateName(filter.templateName);
    if (!objectDef) {
      return false;
    }
    return this.canSideBuildUnitTemplate(normalizedSide, objectDef);
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasCredits.
   * Note: source compares (requestedCredits [cmp] currentMoney), not the reverse.
   */
  evaluateScriptPlayerHasCredits(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    credits: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const requestedCredits = Number.isFinite(filter.credits) ? Math.trunc(filter.credits) : 0;
    const currentCredits = this.getSideCredits(normalizedSide);
    return this.compareScriptCount(filter.comparison, requestedCredits, currentCredits);
  }

  /**
   * Source parity: ScriptConditions::evaluateMissionAttempts.
   * C++ currently returns false (unimplemented TODO).
   */
  evaluateScriptMissionAttempts(_filter: {
    side: string;
    comparison: ScriptComparisonInput;
    attempts: number;
  }): boolean {
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerDestroyedNOrMoreBuildings.
   * C++ currently returns false (unimplemented TODO).
   */
  evaluateScriptPlayerDestroyedNOrMoreBuildings(_filter: {
    side: string;
    count: number;
    opponentSide: string;
  }): boolean {
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerSpecialPowerFromUnitTriggered.
   * Consumes the triggered-special-power script event when a match is found.
   */
  evaluateScriptPlayerSpecialPowerFromUnitTriggered(filter: {
    side: string;
    specialPowerName: string;
    sourceEntityId?: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(filter.specialPowerName);
    if (!normalizedSide || !normalizedSpecialPowerName) {
      return false;
    }

    let sourceEntityId: number | null = null;
    if (filter.sourceEntityId !== undefined) {
      if (!Number.isFinite(filter.sourceEntityId)) {
        return false;
      }
      sourceEntityId = Math.trunc(filter.sourceEntityId);
      const sourceEntity = this.spawnedEntities.get(sourceEntityId);
      if (!sourceEntity || sourceEntity.destroyed) {
        return false;
      }
    }

    const events = this.sideScriptTriggeredSpecialPowerEvents.get(normalizedSide);
    if (!events || events.length === 0) {
      return false;
    }

    for (let index = 0; index < events.length; index += 1) {
      const event = events[index]!;
      if (event.name !== normalizedSpecialPowerName) {
        continue;
      }
      if (sourceEntityId !== null && event.sourceEntityId !== sourceEntityId) {
        continue;
      }

      events.splice(index, 1);
      return true;
    }

    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerSpecialPowerFromUnitMidway.
   * Consumes the midway-special-power script event when a match is found.
   */
  evaluateScriptPlayerSpecialPowerFromUnitMidway(filter: {
    side: string;
    specialPowerName: string;
    sourceEntityId?: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(filter.specialPowerName);
    if (!normalizedSide || !normalizedSpecialPowerName) {
      return false;
    }

    let sourceEntityId: number | null = null;
    if (filter.sourceEntityId !== undefined) {
      if (!Number.isFinite(filter.sourceEntityId)) {
        return false;
      }
      sourceEntityId = Math.trunc(filter.sourceEntityId);
      const sourceEntity = this.spawnedEntities.get(sourceEntityId);
      if (!sourceEntity || sourceEntity.destroyed) {
        return false;
      }
    }

    const events = this.sideScriptMidwaySpecialPowerEvents.get(normalizedSide);
    if (!events || events.length === 0) {
      return false;
    }

    for (let index = 0; index < events.length; index += 1) {
      const event = events[index]!;
      if (event.name !== normalizedSpecialPowerName) {
        continue;
      }
      if (sourceEntityId !== null && event.sourceEntityId !== sourceEntityId) {
        continue;
      }

      events.splice(index, 1);
      return true;
    }

    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerSpecialPowerFromUnitComplete.
   * Consumes the completed-special-power script event when a match is found.
   */
  evaluateScriptPlayerSpecialPowerFromUnitComplete(filter: {
    side: string;
    specialPowerName: string;
    sourceEntityId?: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(filter.specialPowerName);
    if (!normalizedSide || !normalizedSpecialPowerName) {
      return false;
    }

    let sourceEntityId: number | null = null;
    if (filter.sourceEntityId !== undefined) {
      if (!Number.isFinite(filter.sourceEntityId)) {
        return false;
      }
      sourceEntityId = Math.trunc(filter.sourceEntityId);
      const sourceEntity = this.spawnedEntities.get(sourceEntityId);
      if (!sourceEntity || sourceEntity.destroyed) {
        return false;
      }
    }

    const events = this.sideScriptCompletedSpecialPowerEvents.get(normalizedSide);
    if (!events || events.length === 0) {
      return false;
    }

    for (let index = 0; index < events.length; index += 1) {
      const event = events[index]!;
      if (event.name !== normalizedSpecialPowerName) {
        continue;
      }
      if (sourceEntityId !== null && event.sourceEntityId !== sourceEntityId) {
        continue;
      }

      events.splice(index, 1);
      return true;
    }

    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateScienceAcquired.
   * Consumes the acquired-science script event when the condition is true.
   */
  evaluateScriptScienceAcquired(filter: {
    side: string;
    scienceName: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedScience = this.resolveScienceInternalName(filter.scienceName);
    if (!normalizedSide || !normalizedScience) {
      return false;
    }

    const acquiredSciences = this.sideScriptAcquiredSciences.get(normalizedSide);
    if (!acquiredSciences || !acquiredSciences.has(normalizedScience)) {
      return false;
    }

    acquiredSciences.delete(normalizedScience);
    return true;
  }

  /**
   * Source parity: ScriptConditions::evaluateCanPurchaseScience.
   */
  evaluateScriptCanPurchaseScience(filter: {
    side: string;
    scienceName: string;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedScience = this.resolveScienceInternalName(filter.scienceName);
    if (!normalizedSide || !normalizedScience) {
      return false;
    }

    return this.canSidePurchaseScience(normalizedSide, normalizedScience);
  }

  /**
   * Source parity: ScriptConditions::evaluateSciencePurchasePoints.
   */
  evaluateScriptSciencePurchasePoints(filter: {
    side: string;
    pointsNeeded: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const pointsNeeded = Number.isFinite(filter.pointsNeeded) ? Math.trunc(filter.pointsNeeded) : 0;
    return this.getSideRankStateMap(normalizedSide).sciencePurchasePoints >= pointsNeeded;
  }

  /**
   * Source parity: ScriptConditions::evaluateUpgradeFromUnitComplete.
   * Consumes the completed-upgrade script event when a match is found.
   */
  evaluateScriptUpgradeFromUnitComplete(filter: {
    side: string;
    upgradeName: string;
    sourceEntityId?: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const normalizedUpgradeName = filter.upgradeName.trim().toUpperCase();
    if (!normalizedUpgradeName || normalizedUpgradeName === 'NONE') {
      return false;
    }

    let sourceEntityId: number | null = null;
    if (filter.sourceEntityId !== undefined) {
      if (!Number.isFinite(filter.sourceEntityId)) {
        return false;
      }
      sourceEntityId = Math.trunc(filter.sourceEntityId);
      const sourceEntity = this.spawnedEntities.get(sourceEntityId);
      if (!sourceEntity || sourceEntity.destroyed) {
        return false;
      }
    }

    const events = this.sideScriptCompletedUpgradeEvents.get(normalizedSide);
    if (!events || events.length === 0) {
      return false;
    }

    for (let index = 0; index < events.length; index += 1) {
      const event = events[index]!;
      if (event.name !== normalizedUpgradeName) {
        continue;
      }
      if (sourceEntityId !== null && event.sourceEntityId !== sourceEntityId) {
        continue;
      }

      events.splice(index, 1);
      return true;
    }

    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedCreated.
   * C++ note: this is effectively evaluateNamedExists (alive or dead, as long as object still exists).
   */
  evaluateScriptNamedCreated(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    return this.spawnedEntities.has(entityId);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedUnitExists.
   * Returns true only when object exists and is not effectively dead.
   */
  evaluateScriptNamedUnitExists(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }
    return !this.isScriptEntityEffectivelyDead(entity);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedUnitDestroyed.
   * True if object is effectively dead, or if it existed previously and is now gone.
   */
  evaluateScriptNamedUnitDestroyed(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (entity) {
      return this.isScriptEntityEffectivelyDead(entity);
    }
    return this.scriptExistedEntityIds.has(entityId);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedUnitDying.
   * True only while object exists and is effectively dead (not after final removal).
   */
  evaluateScriptNamedUnitDying(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }
    return this.isScriptEntityEffectivelyDead(entity);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedUnitTotallyDead.
   * True only if object existed before and no longer exists.
   */
  evaluateScriptNamedUnitTotallyDead(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    if (this.spawnedEntities.has(entityId)) {
      return false;
    }
    return this.scriptExistedEntityIds.has(entityId);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedAttackedByPlayer.
   * Checks persistent last-damage source player for a named unit.
   */
  evaluateScriptNamedAttackedByPlayer(filter: {
    entityId: number;
    attackedBySide: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedAttackerSide = this.normalizeSide(filter.attackedBySide);
    if (!normalizedAttackerSide) {
      return false;
    }

    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }

    return entity.scriptLastDamageSourceSide === normalizedAttackerSide;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateNamedAttackedByType.
   * Current subset matches direct template names from last damage source template.
   * TODO(source-parity): support ScriptEngine object-type groups (getObjectTypes()).
   */
  evaluateScriptNamedAttackedByType(filter: {
    entityId: number;
    objectType: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedObjectType = filter.objectType.trim().toUpperCase();
    if (!normalizedObjectType) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }
    const lastSourceTemplate = entity.scriptLastDamageSourceTemplateName;
    if (!lastSourceTemplate) {
      return false;
    }
    return this.areEquivalentTemplateNames(lastSourceTemplate, normalizedObjectType);
  }

  /**
   * Source parity: ScriptConditions::evaluateBuildingEntered.
   * True only on frames where contain module recorded an entering player side.
   */
  evaluateScriptBuildingEntered(filter: {
    side: string;
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || !entity.containProfile) {
      return false;
    }
    return entity.containPlayerEnteredSide === normalizedSide;
  }

  /**
   * Source parity: ScriptConditions::evaluateIsBuildingEmpty.
   */
  evaluateScriptIsBuildingEmpty(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || !entity.containProfile) {
      return false;
    }
    return this.collectContainedEntityIds(entityId).length === 0;
  }

  /**
   * Source parity: ScriptConditions::evaluateEnemySighted.
   */
  evaluateScriptEnemySighted(filter: {
    entityId: number;
    alliance: ScriptRelationshipInput;
    side: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const relation = this.resolveScriptRelationshipInput(filter.alliance);
    if (relation === null) {
      return false;
    }

    const entityId = Math.trunc(filter.entityId);
    const source = this.spawnedEntities.get(entityId);
    if (!source) {
      return false;
    }

    const visionRange = Math.max(0, source.visionRange);
    const visionRangeSq = visionRange * visionRange;
    const sourceOffMap = this.isEntityOffMap(source);
    for (const candidate of this.spawnedEntities.values()) {
      if (this.normalizeSide(candidate.side) !== normalizedSide) {
        continue;
      }
      if (this.isScriptEntityEffectivelyDead(candidate)) {
        continue;
      }
      if (this.isEntityStealthedAndUndetected(candidate)) {
        continue;
      }
      if (this.isEntityOffMap(candidate) !== sourceOffMap) {
        continue;
      }
      if (this.getTeamRelationship(source, candidate) !== relation) {
        continue;
      }

      const dx = candidate.x - source.x;
      const dz = candidate.z - source.z;
      if (dx * dx + dz * dz > visionRangeSq) {
        continue;
      }

      return true;
    }

    return false;
  }

  /**
   * Source parity subset: ScriptConditions::evaluateTypeSighted.
   * TODO(source-parity): support ScriptEngine object-type groups (getObjectTypes()).
   */
  evaluateScriptTypeSighted(filter: {
    entityId: number;
    objectType: string;
    side: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const normalizedObjectType = filter.objectType.trim().toUpperCase();
    if (!normalizedObjectType) {
      return false;
    }

    const entityId = Math.trunc(filter.entityId);
    const source = this.spawnedEntities.get(entityId);
    if (!source) {
      return false;
    }

    const visionRange = Math.max(0, source.visionRange);
    const visionRangeSq = visionRange * visionRange;
    const sourceOffMap = this.isEntityOffMap(source);
    for (const candidate of this.spawnedEntities.values()) {
      if (this.normalizeSide(candidate.side) !== normalizedSide) {
        continue;
      }
      if (this.isScriptEntityEffectivelyDead(candidate)) {
        continue;
      }
      if (this.isEntityStealthedAndUndetected(candidate)) {
        continue;
      }
      if (this.isEntityOffMap(candidate) !== sourceOffMap) {
        continue;
      }
      if (!this.areEquivalentTemplateNames(candidate.templateName, normalizedObjectType)) {
        continue;
      }

      const dx = candidate.x - source.x;
      const dz = candidate.z - source.z;
      if (dx * dx + dz * dz > visionRangeSq) {
        continue;
      }

      return true;
    }

    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedHasFreeContainerSlots.
   */
  evaluateScriptNamedHasFreeContainerSlots(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }

    const contain = entity.containProfile;
    if (!contain) {
      return false;
    }

    let maxSlots = 0;
    switch (contain.moduleType) {
      case 'GARRISON':
        maxSlots = contain.garrisonCapacity;
        break;
      case 'TUNNEL':
        // TODO(source-parity): tunnel capacity comes from TunnelTracker shared state.
        maxSlots = this.config.maxTunnelCapacity;
        break;
      default:
        maxSlots = contain.transportCapacity;
        break;
    }

    if (maxSlots <= 0) {
      return true;
    }

    return this.collectContainedEntityIds(entityId).length < maxSlots;
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedInsideArea.
   */
  evaluateScriptNamedInsideArea(filter: {
    entityId: number;
    triggerName: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }

    const triggerRegion = this.findMapTriggerRegionsByName(filter.triggerName)[0];
    if (!triggerRegion) {
      return false;
    }
    return this.isPointInsideTriggerRegion(triggerRegion, entity.x, entity.z);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedOutsideArea.
   */
  evaluateScriptNamedOutsideArea(filter: {
    entityId: number;
    triggerName: string;
  }): boolean {
    return !this.evaluateScriptNamedInsideArea(filter);
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedEnteredArea.
   * Mirrors Object::didEnter(trigger): true when entered this frame or previous frame.
   */
  evaluateScriptNamedEnteredArea(filter: {
    entityId: number;
    triggerName: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }
    if (entity.kindOf.has('INERT')) {
      return false;
    }

    const normalizedTriggerName = filter.triggerName.trim().toUpperCase();
    if (!normalizedTriggerName) {
      return false;
    }

    let triggerIndex = -1;
    for (let index = 0; index < this.mapTriggerRegions.length; index += 1) {
      if (this.mapTriggerRegions[index]!.nameUpper === normalizedTriggerName) {
        triggerIndex = index;
        break;
      }
    }
    if (triggerIndex < 0) {
      return false;
    }

    const enteredOrExitedFrame = this.scriptTriggerEnterExitFrameByEntityId.get(entityId);
    if (enteredOrExitedFrame === undefined) {
      return false;
    }
    if (enteredOrExitedFrame !== this.frameCounter && enteredOrExitedFrame !== this.frameCounter - 1) {
      return false;
    }

    return this.scriptTriggerEnteredByEntityId.get(entityId)?.has(triggerIndex) ?? false;
  }

  /**
   * Source parity: ScriptConditions::evaluateNamedExitedArea.
   * Mirrors Object::didExit(trigger): true when exited this frame or previous frame.
   */
  evaluateScriptNamedExitedArea(filter: {
    entityId: number;
    triggerName: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }
    if (entity.kindOf.has('INERT')) {
      return false;
    }

    const normalizedTriggerName = filter.triggerName.trim().toUpperCase();
    if (!normalizedTriggerName) {
      return false;
    }

    let triggerIndex = -1;
    for (let index = 0; index < this.mapTriggerRegions.length; index += 1) {
      if (this.mapTriggerRegions[index]!.nameUpper === normalizedTriggerName) {
        triggerIndex = index;
        break;
      }
    }
    if (triggerIndex < 0) {
      return false;
    }

    const enteredOrExitedFrame = this.scriptTriggerEnterExitFrameByEntityId.get(entityId);
    if (enteredOrExitedFrame === undefined) {
      return false;
    }
    if (enteredOrExitedFrame !== this.frameCounter && enteredOrExitedFrame !== this.frameCounter - 1) {
      return false;
    }

    return this.scriptTriggerExitedByEntityId.get(entityId)?.has(triggerIndex) ?? false;
  }

  /**
   * Source parity: ScriptConditions::evaluateUnitHealth.
   * Uses body initial health as denominator and rounds to nearest integer percent.
   */
  evaluateScriptUnitHealth(filter: {
    entityId: number;
    comparison: ScriptComparisonInput;
    healthPercent: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }

    const initialHealth = entity.initialHealth;
    if (!Number.isFinite(initialHealth) || initialHealth <= 0) {
      return false;
    }

    // C++: Int curPercent = (curHealth*100 + initialHealth/2)/initialHealth;
    const curPercent = Math.trunc((entity.health * 100 + initialHealth / 2) / initialHealth);
    const targetPercent = Number.isFinite(filter.healthPercent) ? Math.trunc(filter.healthPercent) : 0;
    return this.compareScriptNumeric(filter.comparison, curPercent, targetPercent);
  }

  /**
   * Source parity: ScriptConditions::evaluateUnitHasEmptied.
   * True when contain count transitions from >0 to 0 between previous frame and current frame.
   */
  evaluateScriptUnitHasEmptied(filter: {
    entityId: number;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }

    const currentContainedCount = entity.containProfile
      ? this.collectContainedEntityIds(entityId).length
      : 0;

    const previous = this.scriptTransportStatusByEntityId.get(entityId);
    if (!previous) {
      this.scriptTransportStatusByEntityId.set(entityId, {
        frameNumber: this.frameCounter,
        unitCount: currentContainedCount,
      });
      return false;
    }

    if (
      previous.frameNumber === this.frameCounter - 1
      && previous.unitCount > 0
      && currentContainedCount === 0
    ) {
      // Source parity: do not update status here so repeated checks this frame remain true.
      return true;
    }

    previous.frameNumber = this.frameCounter;
    previous.unitCount = currentContainedCount;
    return false;
  }

  /**
   * Source parity: ScriptConditions::evaluateUnitHasObjectStatus.
   * Returns true when the object has any requested status bit.
   */
  evaluateScriptUnitHasObjectStatus(filter: {
    entityId: number;
    objectStatus: string;
  }): boolean {
    if (!Number.isFinite(filter.entityId)) {
      return false;
    }
    const entityId = Math.trunc(filter.entityId);
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }

    const requestedStatuses = filter.objectStatus
      .trim()
      .split(/\s+/)
      .filter((status) => status.length > 0);
    if (requestedStatuses.length === 0) {
      return false;
    }

    return requestedStatuses.some((status) => this.entityHasObjectStatus(entity, status));
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasNOrFewerBuildings.
   */
  evaluateScriptPlayerHasNOrFewerBuildings(filter: {
    side: string;
    buildingCount: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const desiredMax = Number.isFinite(filter.buildingCount) ? Math.trunc(filter.buildingCount) : 0;
    return desiredMax >= this.countScriptStructuresForSide(normalizedSide, false);
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasNOrFewerFactionBuildings.
   * Counts only STRUCTURE + MP_COUNT_FOR_VICTORY objects.
   */
  evaluateScriptPlayerHasNOrFewerFactionBuildings(filter: {
    side: string;
    buildingCount: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    const desiredMax = Number.isFinite(filter.buildingCount) ? Math.trunc(filter.buildingCount) : 0;
    return desiredMax >= this.countScriptStructuresForSide(normalizedSide, true);
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasPower.
   */
  evaluateScriptPlayerHasPower(filter: { side: string }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }
    return this.hasSufficientPower(normalizedSide);
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasComparisonPercentPower.
   */
  evaluateScriptPlayerHasComparisonPercentPower(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    percent: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const powerState = this.getSidePowerState(normalizedSide);
    const totalProduction = powerState.energyProduction + powerState.powerBonus;
    const supplyRatio = powerState.energyConsumption > 0
      ? totalProduction / powerState.energyConsumption
      : 1.0;
    const testRatio = (Number.isFinite(filter.percent) ? filter.percent : 0) / 100.0;
    return this.compareScriptNumeric(filter.comparison, supplyRatio, testRatio);
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasComparisonValueExcessPower.
   */
  evaluateScriptPlayerHasComparisonValueExcessPower(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    kilowatts: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    const powerState = this.getSidePowerState(normalizedSide);
    const actualExcessKilowatts =
      powerState.energyProduction + powerState.powerBonus - powerState.energyConsumption;
    const desiredExcessKilowatts = Number.isFinite(filter.kilowatts) ? Math.trunc(filter.kilowatts) : 0;
    return this.compareScriptNumeric(filter.comparison, actualExcessKilowatts, desiredExcessKilowatts);
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerHasComparisonGarrisoned.
   */
  evaluateScriptSkirmishPlayerHasComparisonGarrisoned(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    count: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    let garrisonedBuildingCount = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (entity.containProfile?.moduleType !== 'GARRISON') continue;
      if (this.collectContainedEntityIds(entity.id).length <= 0) continue;
      garrisonedBuildingCount += 1;
    }

    return this.compareScriptCount(filter.comparison, garrisonedBuildingCount, filter.count);
  }

  /**
   * Source parity: ScriptConditions::evaluateSkirmishPlayerHasComparisonCapturedUnits.
   */
  evaluateScriptSkirmishPlayerHasComparisonCapturedUnits(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    count: number;
  }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    if (!normalizedSide) {
      return false;
    }

    let capturedUnitCount = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (!entity.capturedFromOriginalOwner) continue;
      capturedUnitCount += 1;
    }

    return this.compareScriptCount(filter.comparison, capturedUnitCount, filter.count);
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerUnitCondition
   * (Condition::PLAYER_HAS_OBJECT_COMPARISON).
   */
  evaluateScriptPlayerHasObjectComparison(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    count: number;
    templateName: string;
    conditionCacheId?: string;
  }): boolean {
    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    if (cache && cache.customData !== 0 && this.scriptObjectCountChangedFrame === cache.customFrame) {
      return cache.customData === 1;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedTemplateName = filter.templateName.trim().toUpperCase();
    if (!normalizedSide || !normalizedTemplateName) {
      if (cache) {
        cache.customData = -1;
        cache.customFrame = this.scriptObjectCountChangedFrame;
      }
      return false;
    }

    const objectCount = this.countScriptObjectsByTemplateForSide(normalizedSide, normalizedTemplateName);
    const comparison = this.compareScriptCount(filter.comparison, objectCount, filter.count);
    if (cache) {
      cache.customData = comparison ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return comparison;
  }

  /**
   * Source parity subset: ScriptConditions::evaluatePlayerUnitCondition.
   * TODO(source-parity): support ScriptEngine object-type groups (getObjectTypes()).
   */
  evaluateScriptPlayerUnitCondition(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    count: number;
    unitType: string;
    conditionCacheId?: string;
  }): boolean {
    return this.evaluateScriptPlayerHasObjectComparison({
      side: filter.side,
      comparison: filter.comparison,
      count: filter.count,
      templateName: filter.unitType,
      conditionCacheId: filter.conditionCacheId,
    });
  }

  /**
   * Source parity: ScriptConditions::evaluateBuiltByPlayer.
   */
  evaluateScriptBuiltByPlayer(filter: {
    side: string;
    templateName: string;
    conditionCacheId?: string;
  }): boolean {
    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    if (cache && cache.customData !== 0 && this.scriptObjectCountChangedFrame === cache.customFrame) {
      return cache.customData === 1;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedTemplateName = filter.templateName.trim().toUpperCase();
    if (!normalizedSide || !normalizedTemplateName) {
      if (cache) {
        cache.customData = -1;
        cache.customFrame = this.scriptObjectCountChangedFrame;
      }
      return false;
    }

    const objectCount = this.countScriptObjectsByTemplateForSide(normalizedSide, normalizedTemplateName);
    const built = objectCount !== 0;
    if (cache) {
      cache.customData = built ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return built;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasUnitTypeInArea.
   */
  evaluateScriptPlayerHasUnitTypeInArea(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    count: number;
    templateName: string;
    triggerName: string;
    conditionCacheId?: string;
  }): boolean {
    const triggerRegions = this.findMapTriggerRegionsByName(filter.triggerName);
    if (triggerRegions.length === 0) {
      return false;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedTemplateName = filter.templateName.trim().toUpperCase();
    if (!normalizedSide || !normalizedTemplateName) {
      return false;
    }

    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    let anyChanges = cache === null || cache.customData === 0;
    // TODO(source-parity): include Team::didEnterOrExit once script team tracking exists.
    if (cache && this.scriptObjectCountChangedFrame > cache.customFrame) {
      anyChanges = true;
    }
    // Until team enter/exit notifications are available, area membership can change without
    // topology changes, so conservatively recompute every call.
    anyChanges = true;
    if (!anyChanges && cache) {
      return cache.customData === 1;
    }

    let objectCount = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (!this.areEquivalentTemplateNames(entity.templateName, normalizedTemplateName)) continue;
      if (!this.isInsideAnyTriggerRegion(entity, triggerRegions)) continue;

      // Source parity: count dead/inert objects only when the object is a crate.
      const isDeadOrInert = entity.destroyed || entity.kindOf.has('INERT');
      if (isDeadOrInert && !entity.kindOf.has('CRATE')) continue;

      objectCount += 1;
    }

    const comparison = this.compareScriptCount(filter.comparison, objectCount, filter.count);
    if (cache) {
      cache.customData = comparison ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return comparison;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerHasUnitKindInArea.
   */
  evaluateScriptPlayerHasUnitKindInArea(filter: {
    side: string;
    comparison: ScriptComparisonInput;
    count: number;
    kindOf: string;
    triggerName: string;
    conditionCacheId?: string;
  }): boolean {
    const triggerRegions = this.findMapTriggerRegionsByName(filter.triggerName);
    if (triggerRegions.length === 0) {
      return false;
    }

    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedKindOf = filter.kindOf.trim().toUpperCase();
    if (!normalizedSide || !normalizedKindOf) {
      return false;
    }

    const cache = this.getOrCreateScriptConditionCache(filter.conditionCacheId);
    let anyChanges = cache === null || cache.customData === 0;
    // TODO(source-parity): include Team::didEnterOrExit once script team tracking exists.
    if (cache && this.scriptObjectCountChangedFrame > cache.customFrame) {
      anyChanges = true;
    }
    // Until team enter/exit notifications are available, area membership can change without
    // topology changes, so conservatively recompute every call.
    anyChanges = true;
    if (!anyChanges && cache) {
      return cache.customData === 1;
    }

    let objectCount = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) continue;
      if (!entity.kindOf.has(normalizedKindOf)) continue;
      if (!this.isInsideAnyTriggerRegion(entity, triggerRegions)) continue;
      if (entity.destroyed || entity.kindOf.has('INERT')) continue;
      objectCount += 1;
    }

    const comparison = this.compareScriptCount(filter.comparison, objectCount, filter.count);
    if (cache) {
      cache.customData = comparison ? 1 : -1;
      cache.customFrame = this.scriptObjectCountChangedFrame;
    }
    return comparison;
  }

  /**
   * Source parity: ScriptConditions::evaluatePlayerLostObjectType.
   */
  evaluateScriptPlayerLostObjectType(filter: { side: string; templateName: string }): boolean {
    const normalizedSide = this.normalizeSide(filter.side);
    const normalizedTemplateName = filter.templateName.trim().toUpperCase();
    if (!normalizedSide || !normalizedTemplateName) {
      return false;
    }

    const objectCount = this.countScriptObjectsByTemplateForSide(normalizedSide, normalizedTemplateName);
    const key = `${normalizedSide}:${normalizedTemplateName}`;
    const previousCount = this.scriptObjectCountBySideAndType.get(key);
    if (previousCount === undefined) {
      this.scriptObjectCountBySideAndType.set(key, objectCount);
      return false;
    }

    if (objectCount !== previousCount) {
      this.scriptObjectCountBySideAndType.set(key, objectCount);
    }
    return objectCount < previousCount;
  }

  getSideAttackedByState(side: string): {
    attackedBySides: string[];
    attackedFrame: number | null;
  } {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return { attackedBySides: [], attackedFrame: null };
    }
    const attackedBy = this.sideAttackedBy.get(normalizedSide);
    return {
      attackedBySides: attackedBy ? Array.from(attackedBy.values()).sort() : [],
      attackedFrame: this.sideAttackedFrame.get(normalizedSide) ?? null,
    };
  }

  getSideUpgradeState(side: string): {
    inProduction: string[];
    completed: string[];
  } {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return { inProduction: [], completed: [] };
    }

    const inProduction = Array.from(this.getSideUpgradeSet(this.sideUpgradesInProduction, normalizedSide));
    const completed = Array.from(this.getSideUpgradeSet(this.sideCompletedUpgrades, normalizedSide));
    inProduction.sort((left, right) => left.localeCompare(right));
    completed.sort((left, right) => left.localeCompare(right));

    return { inProduction, completed };
  }

  getSideScienceState(side: string): {
    acquired: string[];
  } {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return { acquired: [] };
    }

    const acquired = Array.from(this.getSideScienceSet(normalizedSide));
    acquired.sort((left, right) => left.localeCompare(right));
    return { acquired };
  }

  getSidePowerState(side: string): SidePowerState {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return { powerBonus: 0, energyProduction: 0, energyConsumption: 0, brownedOut: false, powerSabotagedUntilFrame: 0 };
    }
    const state = this.getSidePowerStateMap(normalizedSide);
    return {
      powerBonus: state.powerBonus,
      energyProduction: state.energyProduction,
      energyConsumption: state.energyConsumption,
      brownedOut: state.brownedOut,
      powerSabotagedUntilFrame: state.powerSabotagedUntilFrame,
    };
  }

  /**
   * Returns true if the side has sufficient power (production >= consumption).
   * Source parity: Energy::hasSufficientPower().
   */
  hasSufficientPower(side: string): boolean {
    const state = this.getSidePowerState(side);
    const totalProduction = state.energyProduction + state.powerBonus;
    return totalProduction >= state.energyConsumption;
  }

  getSideRadarState(side: string): SideRadarState {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return { radarCount: 0, disableProofRadarCount: 0, radarDisabled: false };
    }
    const state = this.getSideRadarStateMap(normalizedSide);
    return { radarCount: state.radarCount, disableProofRadarCount: state.disableProofRadarCount, radarDisabled: state.radarDisabled };
  }

  /**
   * Source parity: Player::hasRadar — returns true when radarCount > 0
   * and radar is not disabled (or has disable-proof radar).
   * C++ Player.cpp:3239-3246.
   */
  hasRadar(side: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return false;
    }
    const state = this.getSideRadarStateMap(normalizedSide);
    if (state.radarDisabled && state.disableProofRadarCount === 0) {
      return false;
    }
    return state.radarCount > 0;
  }

  grantSideScience(side: string, scienceName: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    const normalizedScienceName = scienceName.trim().toUpperCase();
    if (!normalizedSide || !normalizedScienceName || normalizedScienceName === 'NONE') {
      return false;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }
    const scienceDef = findScienceDefByName(registry, normalizedScienceName);
    if (!scienceDef) {
      return false;
    }

    // Source parity: Player::grantScience() rejects non-grantable sciences.
    const isGrantable = readBooleanField(scienceDef.fields, ['IsGrantable']);
    if (isGrantable === false) {
      return false;
    }

    const normalizedScience = scienceDef.name.trim().toUpperCase();
    if (!normalizedScience || normalizedScience === 'NONE') {
      return false;
    }

    return this.addScienceToSide(normalizedSide, normalizedScience);
  }

  private resolveScienceInternalName(scienceName: string): string | null {
    const normalizedScienceName = scienceName.trim().toUpperCase();
    if (!normalizedScienceName || normalizedScienceName === 'NONE') {
      return null;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return null;
    }
    const scienceDef = findScienceDefByName(registry, normalizedScienceName);
    if (!scienceDef) {
      return null;
    }

    const normalizedScience = scienceDef.name.trim().toUpperCase();
    if (!normalizedScience || normalizedScience === 'NONE') {
      return null;
    }
    return normalizedScience;
  }

  private addScienceToSide(normalizedSide: string, normalizedScience: string): boolean {
    const sideSciences = this.getSideScienceSet(normalizedSide);
    if (sideSciences.has(normalizedScience)) {
      return false;
    }

    sideSciences.add(normalizedScience);
    this.getScriptScienceAcquiredSet(normalizedSide).add(normalizedScience);
    return true;
  }

  private recordScriptTriggeredSpecialPowerEvent(
    normalizedSide: string,
    specialPowerName: string,
    sourceEntityId: number,
  ): void {
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(specialPowerName);
    if (!normalizedSpecialPowerName || !Number.isFinite(sourceEntityId)) {
      return;
    }

    const normalizedSourceEntityId = Math.trunc(sourceEntityId);
    if (normalizedSourceEntityId <= 0) {
      return;
    }

    this.getScriptTriggeredSpecialPowerEvents(normalizedSide).push({
      name: normalizedSpecialPowerName,
      sourceEntityId: normalizedSourceEntityId,
    });
  }

  private recordScriptCompletedSpecialPowerEvent(
    normalizedSide: string,
    specialPowerName: string,
    sourceEntityId: number,
  ): void {
    const normalizedSpecialPowerName = this.normalizeShortcutSpecialPowerName(specialPowerName);
    if (!normalizedSpecialPowerName || !Number.isFinite(sourceEntityId)) {
      return;
    }

    const normalizedSourceEntityId = Math.trunc(sourceEntityId);
    if (normalizedSourceEntityId <= 0) {
      return;
    }

    this.getScriptCompletedSpecialPowerEvents(normalizedSide).push({
      name: normalizedSpecialPowerName,
      sourceEntityId: normalizedSourceEntityId,
    });
  }

  private recordScriptCompletedUpgradeEvent(
    normalizedSide: string,
    upgradeName: string,
    sourceEntityId: number,
  ): void {
    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedUpgradeName || normalizedUpgradeName === 'NONE') {
      return;
    }
    if (!Number.isFinite(sourceEntityId)) {
      return;
    }
    const normalizedSourceEntityId = Math.trunc(sourceEntityId);
    if (normalizedSourceEntityId <= 0) {
      return;
    }

    this.getScriptCompletedUpgradeEvents(normalizedSide).push({
      name: normalizedUpgradeName,
      sourceEntityId: normalizedSourceEntityId,
    });
  }

  private getSciencePurchaseCost(scienceDef: ScienceDef): number {
    const costRaw = readNumericField(scienceDef.fields, ['SciencePurchasePointCost']);
    if (costRaw === null || !Number.isFinite(costRaw)) {
      return 0;
    }
    return Math.max(0, Math.trunc(costRaw));
  }

  private getSciencePrerequisites(scienceDef: ScienceDef): string[] {
    const prerequisites = new Set<string>();
    for (const tokens of this.extractIniValueTokens(scienceDef.fields['PrerequisiteSciences'])) {
      for (const token of tokens) {
        const normalized = token.trim().toUpperCase();
        if (normalized && normalized !== 'NONE') {
          prerequisites.add(normalized);
        }
      }
    }
    return [...prerequisites];
  }

  private isScienceAvailableForLocalPlayer(scienceName: string): boolean {
    const availability = this.localPlayerScienceAvailability.get(scienceName);
    return availability !== 'disabled' && availability !== 'hidden';
  }

  private normalizeScienceAvailability(value: string): LocalScienceAvailability | null {
    const normalized = value.trim().toUpperCase();
    if (!normalized) {
      return null;
    }
    if (normalized === 'DISABLED') {
      return 'disabled';
    }
    if (normalized === 'HIDDEN') {
      return 'hidden';
    }
    if (normalized === 'AVAILABLE' || normalized === 'ENABLED') {
      return 'enabled';
    }
    return null;
  }

  private setSideScienceAvailability(side: string, scienceName: string, availability: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return false;
    }

    const normalizedScience = this.resolveScienceInternalName(scienceName);
    if (!normalizedScience) {
      return false;
    }

    const normalizedAvailability = this.normalizeScienceAvailability(availability);
    if (!normalizedAvailability) {
      return false;
    }

    let sideAvailability = this.sideScienceAvailability.get(normalizedSide);
    if (!sideAvailability) {
      sideAvailability = new Map<string, LocalScienceAvailability>();
      this.sideScienceAvailability.set(normalizedSide, sideAvailability);
    }

    if (normalizedAvailability === 'enabled') {
      sideAvailability.delete(normalizedScience);
    } else {
      sideAvailability.set(normalizedScience, normalizedAvailability);
    }

    const localSide = this.resolveLocalPlayerSide();
    if (localSide === normalizedSide) {
      if (normalizedAvailability === 'enabled') {
        this.localPlayerScienceAvailability.delete(normalizedScience);
      } else {
        this.localPlayerScienceAvailability.set(normalizedScience, normalizedAvailability);
      }
    }

    return true;
  }

  private canSidePurchaseScience(normalizedSide: string, normalizedScience: string): boolean {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }

    const scienceDef = findScienceDefByName(registry, normalizedScience);
    if (!scienceDef) {
      return false;
    }

    const canonicalScience = scienceDef.name.trim().toUpperCase();
    if (!canonicalScience || canonicalScience === 'NONE') {
      return false;
    }

    if (this.hasSideScience(normalizedSide, canonicalScience)) {
      return false;
    }

    const sideAvailability = this.sideScienceAvailability.get(normalizedSide)?.get(canonicalScience);
    if (sideAvailability === 'disabled' || sideAvailability === 'hidden') {
      return false;
    }

    for (const prerequisite of this.getSciencePrerequisites(scienceDef)) {
      if (!this.hasSideScience(normalizedSide, prerequisite)) {
        return false;
      }
    }

    const scienceCost = this.getSciencePurchaseCost(scienceDef);
    return scienceCost > 0 && scienceCost <= this.getSideRankStateMap(normalizedSide).sciencePurchasePoints;
  }

  private getPurchasableScienceCost(side: string, scienceName: string): number {
    const normalizedScienceName = scienceName.trim().toUpperCase();
    if (!normalizedScienceName || normalizedScienceName === 'NONE') {
      return 0;
    }

    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return 0;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return 0;
    }

    const scienceDef = findScienceDefByName(registry, normalizedScienceName);
    if (!scienceDef) {
      return 0;
    }

    const normalizedScience = scienceDef.name.trim().toUpperCase();
    if (!normalizedScience || normalizedScience === 'NONE') {
      return 0;
    }

    if (!this.canSidePurchaseScience(normalizedSide, normalizedScience)) {
      return 0;
    }

    if (!this.isScienceAvailableForLocalPlayer(normalizedScience)) {
      return 0;
    }
    return this.getSciencePurchaseCost(scienceDef);
  }

  private getSideUpgradeSet(map: Map<string, Set<string>>, normalizedSide: string): Set<string> {
    const existing = map.get(normalizedSide);
    if (existing) {
      return existing;
    }
    const created = new Set<string>();
    map.set(normalizedSide, created);
    return created;
  }

  private getSideScienceSet(normalizedSide: string): Set<string> {
    const existing = this.sideSciences.get(normalizedSide);
    if (existing) {
      return existing;
    }
    const created = new Set<string>();
    this.sideSciences.set(normalizedSide, created);
    return created;
  }

  private getScriptScienceAcquiredSet(normalizedSide: string): Set<string> {
    const existing = this.sideScriptAcquiredSciences.get(normalizedSide);
    if (existing) {
      return existing;
    }
    const created = new Set<string>();
    this.sideScriptAcquiredSciences.set(normalizedSide, created);
    return created;
  }

  private getScriptTriggeredSpecialPowerEvents(normalizedSide: string): ScriptNamedEvent[] {
    const existing = this.sideScriptTriggeredSpecialPowerEvents.get(normalizedSide);
    if (existing) {
      return existing;
    }
    const created: ScriptNamedEvent[] = [];
    this.sideScriptTriggeredSpecialPowerEvents.set(normalizedSide, created);
    return created;
  }

  private getScriptCompletedSpecialPowerEvents(normalizedSide: string): ScriptNamedEvent[] {
    const existing = this.sideScriptCompletedSpecialPowerEvents.get(normalizedSide);
    if (existing) {
      return existing;
    }
    const created: ScriptNamedEvent[] = [];
    this.sideScriptCompletedSpecialPowerEvents.set(normalizedSide, created);
    return created;
  }

  private getScriptCompletedUpgradeEvents(normalizedSide: string): ScriptNamedEvent[] {
    const existing = this.sideScriptCompletedUpgradeEvents.get(normalizedSide);
    if (existing) {
      return existing;
    }
    const created: ScriptNamedEvent[] = [];
    this.sideScriptCompletedUpgradeEvents.set(normalizedSide, created);
    return created;
  }

  private getSideKindOfProductionCostModifiers(normalizedSide: string): KindOfProductionCostModifier[] {
    const existing = this.sideKindOfProductionCostModifiers.get(normalizedSide);
    if (existing) {
      return existing;
    }

    const created: KindOfProductionCostModifier[] = [];
    this.sideKindOfProductionCostModifiers.set(normalizedSide, created);
    return created;
  }

  private getSidePowerStateMap(normalizedSide: string): SidePowerState {
    const existing = this.sidePowerBonus.get(normalizedSide);
    if (existing) {
      return existing;
    }

    const created: SidePowerState = { powerBonus: 0, energyProduction: 0, energyConsumption: 0, brownedOut: false, powerSabotagedUntilFrame: 0 };
    this.sidePowerBonus.set(normalizedSide, created);
    return created;
  }

  private getSideRadarStateMap(normalizedSide: string): SideRadarState {
    const existing = this.sideRadarState.get(normalizedSide);
    if (existing) {
      return existing;
    }

    const created: SideRadarState = {
      radarCount: 0,
      disableProofRadarCount: 0,
      radarDisabled: false,
    };
    this.sideRadarState.set(normalizedSide, created);
    return created;
  }

  private getSideRankStateMap(normalizedSide: string): SideRankState {
    const existing = this.sideRankState.get(normalizedSide);
    if (existing) {
      return existing;
    }
    // Source parity: Player::resetRank — start at rank 1, with rank 1's purchase points.
    const created: SideRankState = {
      rankLevel: 1,
      skillPoints: 0,
      sciencePurchasePoints: RANK_TABLE[0]?.sciencePurchasePointsGranted ?? 0,
    };
    this.sideRankState.set(normalizedSide, created);
    return created;
  }

  private getRankLevelCap(): number {
    if (RANK_TABLE.length < 1) {
      return 1;
    }
    const normalizedLimit = Number.isFinite(this.rankLevelLimit) ? Math.trunc(this.rankLevelLimit) : RANK_TABLE.length;
    return Math.max(1, Math.min(RANK_TABLE.length, normalizedLimit));
  }

  private setSideRankLevel(side: string, newLevel: number): boolean {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return false;
    }
    return this.setSideRankLevelByNormalizedSide(normalizedSide, newLevel);
  }

  /**
   * Source parity subset: Player::setRankLevel — rank clamp + reset-on-downgrade behavior.
   */
  private setSideRankLevelByNormalizedSide(normalizedSide: string, newLevel: number): boolean {
    const rankState = this.getSideRankStateMap(normalizedSide);
    const rankCap = this.getRankLevelCap();
    const targetLevel = Math.max(1, Math.min(rankCap, Math.trunc(newLevel)));
    if (targetLevel === rankState.rankLevel) {
      return false;
    }

    if (targetLevel < rankState.rankLevel) {
      rankState.rankLevel = 1;
      rankState.skillPoints = 0;
      rankState.sciencePurchasePoints = RANK_TABLE[0]?.sciencePurchasePointsGranted ?? 0;
    }

    for (let level = rankState.rankLevel + 1; level <= targetLevel; level++) {
      const rankInfo = RANK_TABLE[level - 1];
      if (!rankInfo) {
        continue;
      }
      rankState.sciencePurchasePoints = Math.max(
        0,
        rankState.sciencePurchasePoints + rankInfo.sciencePurchasePointsGranted,
      );
      if (rankState.skillPoints < rankInfo.skillPointsNeeded) {
        rankState.skillPoints = rankInfo.skillPointsNeeded;
      }
    }

    rankState.rankLevel = targetLevel;
    return true;
  }

  /**
   * Source parity subset: Player::addSkillPoints (used by script action and kill XP).
   * Returns true if rank increased.
   */
  private adjustSideSkillPoints(side: string, delta: number): boolean {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return false;
    }

    const rankState = this.getSideRankStateMap(normalizedSide);
    const normalizedDelta = Number.isFinite(delta) ? Math.trunc(delta) : 0;
    if (normalizedDelta === 0) {
      return false;
    }

    const rankCap = this.getRankLevelCap();
    const pointCap = RANK_TABLE[rankCap - 1]?.skillPointsNeeded ?? Infinity;
    rankState.skillPoints = Math.min(pointCap, rankState.skillPoints + normalizedDelta);

    let didLevelUp = false;
    while (rankState.rankLevel < rankCap) {
      const nextRank = RANK_TABLE[rankState.rankLevel];
      if (!nextRank || rankState.skillPoints < nextRank.skillPointsNeeded) {
        break;
      }
      this.setSideRankLevelByNormalizedSide(normalizedSide, rankState.rankLevel + 1);
      didLevelUp = true;
    }

    return didLevelUp;
  }

  /**
   * Source parity: Player::addSkillPoints — award player-level skill points from kills.
   * Returns true if a rank level-up occurred.
   */
  private addPlayerSkillPoints(side: string, delta: number): boolean {
    if (delta <= 0) {
      return false;
    }
    return this.adjustSideSkillPoints(side, delta);
  }

  private hasSideScience(side: string, scienceName: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    const normalizedScienceName = scienceName.trim().toUpperCase();
    if (!normalizedSide || !normalizedScienceName || normalizedScienceName === 'NONE') {
      return false;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }
    const scienceDef = findScienceDefByName(registry, normalizedScienceName);
    if (!scienceDef) {
      return false;
    }

    const normalizedScience = scienceDef.name.trim().toUpperCase();
    if (!normalizedScience || normalizedScience === 'NONE') {
      return false;
    }

    return this.getSideScienceSet(normalizedSide).has(normalizedScience);
  }

  private setSideUpgradeInProduction(side: string, upgradeName: string, enabled: boolean): void {
    const normalizedSide = this.normalizeSide(side);
    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedSide || !normalizedUpgradeName) {
      return;
    }

    const set = this.getSideUpgradeSet(this.sideUpgradesInProduction, normalizedSide);
    if (enabled) {
      set.add(normalizedUpgradeName);
      return;
    }
    set.delete(normalizedUpgradeName);
  }

  private setSideUpgradeCompleted(side: string, upgradeName: string, enabled: boolean): void {
    const normalizedSide = this.normalizeSide(side);
    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedSide || !normalizedUpgradeName) {
      return;
    }

    const set = this.getSideUpgradeSet(this.sideCompletedUpgrades, normalizedSide);
    if (enabled) {
      set.add(normalizedUpgradeName);
      return;
    }
    set.delete(normalizedUpgradeName);
  }

  private hasSideUpgradeInProduction(side: string, upgradeName: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedSide || !normalizedUpgradeName) {
      return false;
    }
    return this.getSideUpgradeSet(this.sideUpgradesInProduction, normalizedSide).has(normalizedUpgradeName);
  }

  private hasSideUpgradeCompleted(side: string, upgradeName: string): boolean {
    const normalizedSide = this.normalizeSide(side);
    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedSide || !normalizedUpgradeName) {
      return false;
    }
    return this.getSideUpgradeSet(this.sideCompletedUpgrades, normalizedSide).has(normalizedUpgradeName);
  }

  setBridgeSegmentPassable(segmentId: number, passable: boolean): boolean {
    const grid = this.navigationGrid;
    if (!grid) {
      return false;
    }

    const segment = this.bridgeSegments.get(segmentId);
    if (!segment) {
      return false;
    }
    if (segment.passable === passable) {
      return true;
    }

    segment.passable = passable;
    const passableByte = passable ? 1 : 0;
    for (const index of segment.cellIndices) {
      grid.bridgePassable[index] = passableByte;
    }
    for (const index of segment.transitionIndices) {
      grid.bridgeTransitions[index] = passableByte;
    }

    this.noteBridgeDamageStateChange(segmentId, passable);

    return true;
  }

  setBridgePassableAt(worldX: number, worldZ: number, passable: boolean): boolean {
    const grid = this.navigationGrid;
    if (!grid) {
      return false;
    }

    const [cellX, cellZ] = this.worldToGrid(worldX, worldZ);
    if (cellX === null || cellZ === null) {
      return false;
    }

    const index = cellZ * grid.width + cellX;
    if (index < 0 || index >= grid.bridgeSegmentByCell.length) {
      return false;
    }
    const segmentId = grid.bridgeSegmentByCell[index];
    if (segmentId === undefined || segmentId < 0) {
      return false;
    }

    return this.setBridgeSegmentPassable(segmentId, passable);
  }

  getBridgeSegmentStates(): Array<{ segmentId: number; passable: boolean }> {
    return Array.from(this.bridgeSegments.entries())
      .map(([segmentId, segment]) => ({ segmentId, passable: segment.passable }))
      .sort((a, b) => a.segmentId - b.segmentId);
  }

  private resetBridgeDamageStateChanges(): void {
    this.bridgeDamageStatesChangedFrame = -1;
    this.bridgeDamageStateByControlEntity.clear();
  }

  private noteBridgeDamageStateChange(segmentId: number, passable: boolean): void {
    this.bridgeDamageStatesChangedFrame = this.frameCounter;
    for (const [entityId, mappedSegmentId] of this.bridgeSegmentByControlEntity.entries()) {
      if (mappedSegmentId !== segmentId) {
        continue;
      }
      this.bridgeDamageStateByControlEntity.set(entityId, passable);
    }
  }

  onObjectDestroyed(entityId: number): boolean {
    const segmentId = this.bridgeSegmentByControlEntity.get(entityId);
    if (segmentId === undefined) {
      return false;
    }
    return this.setBridgeSegmentPassable(segmentId, false);
  }

  onObjectRepaired(entityId: number): boolean {
    const segmentId = this.bridgeSegmentByControlEntity.get(entityId);
    if (segmentId === undefined) {
      return false;
    }
    return this.setBridgeSegmentPassable(segmentId, true);
  }

  setEntityLocomotorSet(entityId: number, setName: string): boolean {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }
    const normalizedSet = setName.trim().toUpperCase();
    if (!SOURCE_LOCOMOTOR_SET_NAMES.has(normalizedSet)) {
      return false;
    }
    if (normalizedSet === LOCOMOTORSET_NORMAL_UPGRADED) {
      return false;
    }
    let resolvedSet = normalizedSet;
    if (
      normalizedSet === LOCOMOTORSET_NORMAL
      && entity.locomotorUpgradeEnabled
      && entity.locomotorSets.has(LOCOMOTORSET_NORMAL_UPGRADED)
    ) {
      resolvedSet = LOCOMOTORSET_NORMAL_UPGRADED;
    }
    const profile = entity.locomotorSets.get(resolvedSet);
    if (!profile) {
      return false;
    }
    entity.activeLocomotorSet = resolvedSet;
    entity.locomotorSurfaceMask = profile.surfaceMask;
    entity.locomotorDownhillOnly = profile.downhillOnly;
    entity.speed = profile.movementSpeed > 0 ? profile.movementSpeed : this.config.defaultMoveSpeed;
    return true;
  }

  setEntityLocomotorUpgrade(entityId: number, enabled: boolean): boolean {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }
    entity.locomotorUpgradeEnabled = enabled;
    if (
      entity.activeLocomotorSet === LOCOMOTORSET_NORMAL
      || entity.activeLocomotorSet === LOCOMOTORSET_NORMAL_UPGRADED
    ) {
      this.setEntityLocomotorSet(entityId, LOCOMOTORSET_NORMAL);
    }
    return true;
  }

  applyUpgradeToEntity(entityId: number, upgradeName: string): boolean {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return false;
    }

    if (entity.destroyed) {
      return false;
    }

    const normalizedUpgrade = upgradeName.trim().toUpperCase();
    if (!normalizedUpgrade || normalizedUpgrade === 'NONE') {
      return false;
    }

    entity.completedUpgrades.add(normalizedUpgrade);

    if (this.iniDataRegistry) {
      const upgradeDef = findUpgradeDefByName(this.iniDataRegistry, normalizedUpgrade);
      if (upgradeDef) {
        const existingModuleIds = new Set(entity.upgradeModules.map((module) => module.id));
        const modulesFromUpgrade = this.extractUpgradeModulesFromBlocks(
          upgradeDef.blocks ?? [],
          normalizedUpgrade,
        );
        for (const module of modulesFromUpgrade) {
          if (!existingModuleIds.has(module.id)) {
            entity.upgradeModules.push(module);
            existingModuleIds.add(module.id);
          }
        }
      }
    }

    return this.executePendingUpgradeModules(entityId, entity);
  }

  private captureEntity(entityId: number, newSide: string): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return;
    }

    const normalizedNewSide = this.normalizeSide(newSide);
    if (!normalizedNewSide) {
      return;
    }

    const normalizedOldSide = this.normalizeSide(entity.side ?? '');
    // Transfer base energy between sides on capture.
    this.unregisterEntityEnergy(entity);
    entity.side = normalizedNewSide;
    entity.capturedFromOriginalOwner =
      entity.originalOwningSide.length > 0 && normalizedNewSide !== entity.originalOwningSide;
    entity.controllingPlayerToken = this.normalizeControllingPlayerToken(normalizedNewSide);
    this.registerEntityEnergy(entity);
    this.transferCostModifierUpgradesBetweenSides(entity, normalizedOldSide, normalizedNewSide);
    this.transferPowerPlantUpgradesBetweenSides(entity, normalizedOldSide, normalizedNewSide);
    this.transferOverchargeBetweenSides(entity, normalizedOldSide, normalizedNewSide);
    this.transferRadarUpgradesBetweenSides(entity, normalizedOldSide, normalizedNewSide);
    // Source parity: Player.cpp line 1038 — award AutoDeposit capture bonus on non-neutral capture.
    if (!this.isEntityNeutralControlled(entity)) {
      this.awardAutoDepositCaptureBonus(entity);
    }
  }

  private executePendingUpgradeModules(
    entityId: number,
    entity: MapEntity,
    skipGlobalPlayerUpgradeModules = false,
  ): boolean {
    let appliedAny = false;
    const upgradeMaskToCheck = this.buildEntityUpgradeMask(entity);
    for (const module of entity.upgradeModules) {
      if (
        skipGlobalPlayerUpgradeModules
        && (module.moduleType === 'COSTMODIFIERUPGRADE' || module.moduleType === 'GRANTSCIENCEUPGRADE')
      ) {
        continue;
      }
      if (!this.canExecuteUpgradeModule(entity, module, upgradeMaskToCheck)) {
        continue;
      }

      // Source parity: UpgradeMux::giveSelfUpgrade() processes removals before module implementation.
      this.processUpgradeModuleRemovals(entity, module);

      let appliedThisModule = false;
      if (module.moduleType === 'LOCOMOTORSETUPGRADE') {
        appliedThisModule = this.setEntityLocomotorUpgrade(entityId, true);
      } else if (module.moduleType === 'MAXHEALTHUPGRADE') {
        appliedThisModule = this.applyMaxHealthUpgrade(entity, module.addMaxHealth, module.maxHealthChangeType);
      } else if (module.moduleType === 'ARMORUPGRADE') {
        appliedThisModule = this.applyArmorUpgrade(entity);
      } else if (module.moduleType === 'WEAPONSETUPGRADE') {
        appliedThisModule = this.applyWeaponSetUpgrade(entity);
      } else if (module.moduleType === 'COMMANDSETUPGRADE') {
        appliedThisModule = this.applyCommandSetUpgrade(entity, module);
      } else if (module.moduleType === 'STATUSBITSUPGRADE') {
        appliedThisModule = this.applyStatusBitsUpgrade(entity, module);
      } else if (module.moduleType === 'STEALTHUPGRADE') {
        appliedThisModule = this.applyStealthUpgrade(entity);
      } else if (module.moduleType === 'WEAPONBONUSUPGRADE') {
        appliedThisModule = this.applyWeaponBonusUpgrade(entity);
      } else if (module.moduleType === 'COSTMODIFIERUPGRADE') {
        appliedThisModule = this.applyCostModifierUpgradeModule(entity, module);
      } else if (module.moduleType === 'GRANTSCIENCEUPGRADE') {
        appliedThisModule = this.applyGrantScienceUpgradeModule(entity, module);
      } else if (module.moduleType === 'POWERPLANTUPGRADE') {
        appliedThisModule = this.applyPowerPlantUpgradeModule(entity, module);
      } else if (module.moduleType === 'RADARUPGRADE') {
        appliedThisModule = this.applyRadarUpgradeModule(entity, module);
      } else if (module.moduleType === 'PASSENGERSFIREUPGRADE') {
        // Source parity: PassengersFireUpgrade sets contain->setPassengerAllowedToFire(TRUE).
        if (entity.containProfile) {
          entity.containProfile.passengersAllowedToFire = true;
          appliedThisModule = true;
        }
      } else if (module.moduleType === 'UNPAUSESPECIALPOWERUPGRADE') {
        // Source parity: UnpauseSpecialPowerUpgrade clears the associated special power pause.
        appliedThisModule = this.applyUnpauseSpecialPowerUpgradeModule(entity, module);
      } else if (module.moduleType === 'EXPERIENCESCALARUPGRADE') {
        // Source parity: ExperienceScalarUpgrade.cpp line 85 — adds scalar to XP tracker.
        appliedThisModule = this.applyExperienceScalarUpgrade(entity, module);
      } else if (module.moduleType === 'MODELCONDITIONUPGRADE') {
        // Source parity: ModelConditionUpgrade.cpp line 78 — sets model condition flag.
        appliedThisModule = this.applyModelConditionUpgrade(entity, module);
      } else if (module.moduleType === 'OBJECTCREATIONUPGRADE') {
        // Source parity: ObjectCreationUpgrade.cpp line 97 — spawns OCL on upgrade.
        appliedThisModule = this.applyObjectCreationUpgrade(entity, module);
      } else if (module.moduleType === 'ACTIVESHROUDUPGRADE') {
        // Source parity: ActiveShroudUpgrade.cpp line 87 — sets entity's shroud range.
        appliedThisModule = this.applyActiveShroudUpgrade(entity, module);
      } else if (module.moduleType === 'REPLACEOBJECTUPGRADE') {
        // Source parity: ReplaceObjectUpgrade.cpp line 70 — destroy old, create replacement at same position.
        appliedThisModule = this.applyReplaceObjectUpgrade(entity, module);
        if (appliedThisModule) {
          // Entity was destroyed and replaced — stop processing further modules on this entity.
          entity.executedUpgradeModules.add(module.id);
          return true;
        }
      }

      if (!appliedThisModule) {
        continue;
      }

      entity.executedUpgradeModules.add(module.id);
      appliedAny = true;
    }

    return appliedAny;
  }

  reset(): void {
    this.clearSpawnedObjects();
    this.bridgeSegments.clear();
    this.bridgeSegmentByControlEntity.clear();
    this.resetBridgeDamageStateChanges();
    this.selectedEntityId = null;
    this.nextId = 1;
    this.animationTime = 0;
    this.loadedMapData = null;
    this.mapHeightmap = null;
    this.navigationGrid = null;
    this.iniDataRegistry = null;
    this.sideCredits.clear();
    this.sidePlayerTypes.clear();
    this.sideCashBountyPercent.clear();
    this.sideBattlePlanBonuses.clear();
    this.battlePlanParalyzedUntilFrame.clear();
    this.sideUpgradesInProduction.clear();
    this.sideCompletedUpgrades.clear();
    this.sideKindOfProductionCostModifiers.clear();
    this.sideSciences.clear();
    this.sideScienceAvailability.clear();
    this.sideScriptAcquiredSciences.clear();
    this.sideScriptTriggeredSpecialPowerEvents.clear();
    this.sideScriptMidwaySpecialPowerEvents.clear();
    this.sideScriptCompletedSpecialPowerEvents.clear();
    this.sideScriptCompletedUpgradeEvents.clear();
    this.localPlayerScienceAvailability.clear();
    this.sidePowerBonus.clear();
    this.sideRadarState.clear();
    this.temporaryVisionReveals.length = 0;
    this.sideRankState.clear();
    this.rankLevelLimit = RANK_TABLE.length;
    this.frameCounter = 0;
    this.gameRandom.setSeed(1);
    this.isAttackMoveToMode = false;
    this.previousAttackMoveToggleDown = false;
    this.placementSummary = {
      totalObjects: 0,
      spawnedObjects: 0,
      skippedObjects: 0,
      resolvedObjects: 0,
      unresolvedObjects: 0,
    };
  }

  dispose(): void {
    this.clearSpawnedObjects();
  }

  private createMapEntity(
    mapObject: MapObjectJSON,
    objectDef: ObjectDef | undefined,
    iniDataRegistry: IniDataRegistry,
    heightmap: HeightmapGrid | null,
  ): MapEntity {
    const kindOf = objectDef?.kindOf;
    const category = this.inferCategory(kindOf, objectDef?.fields.KindOf);
    const normalizedKindOf = this.normalizeKindOf(kindOf);
    const isResolved = objectDef !== undefined;
    const objectId = this.nextId++;
    const controllingPlayerToken = this.resolveMapObjectControllingPlayerToken(mapObject);
    const renderAssetProfile = this.resolveRenderAssetProfile(objectDef);

    const nominalHeight = nominalHeightForCategory(category);

    const locomotorSetProfiles = this.resolveLocomotorProfiles(objectDef, iniDataRegistry);
    const upgradeModules = this.extractUpgradeModules(objectDef);
    const productionProfile = this.extractProductionProfile(objectDef);
    const queueProductionExitProfile = this.extractQueueProductionExitProfile(objectDef);
    const parkingPlaceProfile = this.extractParkingPlaceProfile(objectDef);
    const containProfile = this.extractContainProfile(objectDef);
    const supplyWarehouseProfile = this.extractSupplyWarehouseProfile(objectDef);
    const supplyTruckProfile = this.extractSupplyTruckProfile(objectDef);
    const chinookAIProfile = this.extractChinookAIProfile(objectDef);
    const repairDockProfile = this.extractRepairDockProfile(objectDef);
    const dozerAIProfile = this.extractDozerAIProfile(objectDef);
    const isSupplyCenter = this.detectIsSupplyCenter(objectDef);
    const experienceProfile = this.extractExperienceProfile(objectDef);
    const jetAIProfile = this.extractJetAIProfile(objectDef);
    const animationSteeringProfile = this.extractAnimationSteeringProfile(objectDef);
    const tensileFormationProfile = this.extractTensileFormationProfile(objectDef);
    const weaponTemplateSets = this.extractWeaponTemplateSets(objectDef);
    const armorTemplateSets = this.extractArmorTemplateSets(objectDef);
    const attackWeapon = this.resolveAttackWeaponProfile(objectDef, iniDataRegistry);
    const specialPowerModules = this.extractSpecialPowerModules(objectDef);
    const bodyStats = this.resolveBodyStats(objectDef);
    const energyBonus = readNumericField(objectDef?.fields ?? {}, ['EnergyBonus']) ?? 0;
    const largestWeaponRange = this.resolveLargestWeaponRange(objectDef, iniDataRegistry);
    const totalWeaponAntiMask = this.resolveTotalWeaponAntiMaskForSetSelection(
      weaponTemplateSets, 0, iniDataRegistry,
    );
    const armorDamageCoefficients = this.resolveArmorDamageCoefficientsForSetSelection(
      armorTemplateSets,
      0,
      iniDataRegistry,
    );
    const locomotorProfile = locomotorSetProfiles.get(LOCOMOTORSET_NORMAL) ?? {
      surfaceMask: NO_SURFACES,
      downhillOnly: false,
      movementSpeed: 0,
    };
    const combatProfile = this.resolveCombatCollisionProfile(objectDef);
    const attackNeedsLineOfSight = normalizedKindOf.has('ATTACK_NEEDS_LINE_OF_SIGHT');
    const isImmobile = normalizedKindOf.has('IMMOBILE');
    const blocksPath = this.shouldPathfindObstacle(objectDef);
    // Source parity: mines don't block pathfinding but still need collision geometry
    // for MinefieldBehavior::onCollide. Crushers need geometry for crush overlap detection.
    // Crates need geometry for CrateCollide::onCollide collection radius.
    const needsGeometry = blocksPath || normalizedKindOf.has('MINE') || normalizedKindOf.has('CRATE') || combatProfile.crusherLevel > 0;
    const obstacleGeometry = needsGeometry ? this.resolveObstacleGeometry(objectDef) : null;
    const obstacleFootprint = blocksPath ? this.footprintInCells(category, objectDef, obstacleGeometry) : 0;
    const { pathDiameter, pathfindCenterInCell } = this.resolvePathRadiusAndCenter(category, objectDef, obstacleGeometry);
    const geometryMajorRadius = objectDef
      ? (this.pathDiameterFromGeometryFields(objectDef)
        ?? obstacleGeometry?.majorRadius
        ?? MAP_XY_FACTOR / 2)
      : MAP_XY_FACTOR / 2;
    const [worldX, worldY, worldZ] = this.objectToWorldPosition(mapObject, heightmap);
    const baseHeight = nominalHeight / 2;
    const x = worldX;
    const y = worldY + baseHeight;
    const z = worldZ;
    const rotationY = THREE.MathUtils.degToRad(mapObject.angle);
    const bridgeFlags = mapObject.flags & (OBJECT_FLAG_BRIDGE_POINT1 | OBJECT_FLAG_BRIDGE_POINT2);
    const mapCellX = Math.floor(mapObject.position.x / MAP_XY_FACTOR);
    const mapCellZ = Math.floor(mapObject.position.y / MAP_XY_FACTOR);

    const [posCellX, posCellZ] = this.worldToGrid(x, z);
    const initialClipAmmo = attackWeapon && attackWeapon.clipSize > 0 ? attackWeapon.clipSize : 0;
    const initialScatterTargetsUnused = attackWeapon
      ? Array.from({ length: attackWeapon.scatterTargets.length }, (_entry, index) => index)
      : [];
    const normalizedOriginalSide = this.normalizeSide(objectDef?.side ?? '');

    const entity: MapEntity = {
      id: objectId,
      templateName: mapObject.templateName,
      category,
      kindOf: normalizedKindOf,
      side: objectDef?.side,
      originalOwningSide: normalizedOriginalSide,
      capturedFromOriginalOwner: false,
      controllingPlayerToken,
      resolved: isResolved,
      bridgeFlags,
      mapCellX,
      mapCellZ,
      renderAssetCandidates: renderAssetProfile.renderAssetCandidates,
      renderAssetPath: renderAssetProfile.renderAssetPath,
      renderAssetResolved: renderAssetProfile.renderAssetResolved,
      renderAnimationStateClips: renderAssetProfile.renderAnimationStateClips,
      x,
      y,
      z,
      rotationY,
      animationState: 'IDLE',
      baseHeight,
      nominalHeight,
      selected: false,
      crusherLevel: combatProfile.crusherLevel,
      crushableLevel: combatProfile.crushableLevel,
      canBeSquished: combatProfile.canBeSquished,
      isUnmanned: combatProfile.isUnmanned,
      attackNeedsLineOfSight,
      isImmobile,
      noCollisions: false,
      isIndestructible: false,
      keepObjectOnDeath: this.hasKeepObjectDie(objectDef),
      canMove: category === 'infantry' || category === 'vehicle' || category === 'air',
      locomotorSets: locomotorSetProfiles,
      completedUpgrades: new Set<string>(),
      locomotorUpgradeTriggers: new Set<string>(),
      executedUpgradeModules: new Set<string>(),
      upgradeModules,
      objectStatusFlags: new Set<string>(),
      modelConditionFlags: new Set<string>(),
      commandSetStringOverride: null,
      locomotorUpgradeEnabled: false,
      specialPowerModules,
      lastSpecialPowerDispatch: null,
      activeLocomotorSet: LOCOMOTORSET_NORMAL,
      locomotorSurfaceMask: locomotorProfile.surfaceMask,
      locomotorDownhillOnly: locomotorProfile.downhillOnly,
      bodyType: bodyStats.bodyType,
      hiveStructureProfile: this.extractHiveStructureProfile(objectDef, bodyStats.bodyType),
      // Source parity: UndeadBody — second life config and runtime state.
      undeadSecondLifeMaxHealth: bodyStats.secondLifeMaxHealth,
      undeadIsSecondLife: false,
      canTakeDamage: bodyStats.bodyType !== 'INACTIVE' && bodyStats.maxHealth > 0,
      maxHealth: bodyStats.maxHealth,
      initialHealth: bodyStats.initialHealth,
      health: bodyStats.bodyType === 'INACTIVE' ? 0 : bodyStats.initialHealth,
      energyBonus,
      attackWeapon,
      weaponTemplateSets,
      weaponSetFlagsMask: 0,
      weaponBonusConditionFlags: 0,
      forcedWeaponSlot: null,
      weaponLockStatus: 'NOT_LOCKED' as const,
      maxShotsRemaining: 0,
      leechRangeActive: false,
      turretProfiles: this.extractTurretProfiles(objectDef),
      turretStates: [], // Initialized after entity creation below.
      armorTemplateSets,
      armorSetFlagsMask: 0,
      armorDamageCoefficients,
      attackTargetEntityId: null,
      attackTargetPosition: null,
      attackOriginalVictimPosition: null,
      attackCommandSource: 'AI',
      attackSubState: 'IDLE',
      nextAttackFrame: 0,
      attackAmmoInClip: initialClipAmmo,
      attackReloadFinishFrame: 0,
      attackForceReloadFrame: 0,
      attackScatterTargetsUnused: initialScatterTargetsUnused,
      preAttackFinishFrame: 0,
      consecutiveShotsTargetEntityId: null,
      consecutiveShotsAtTarget: 0,
      continuousFireState: 'NONE',
      continuousFireCooldownFrame: 0,
      sneakyOffsetWhenAttacking: jetAIProfile?.sneakyOffsetWhenAttacking ?? 0,
      attackersMissPersistFrames: jetAIProfile?.attackersMissPersistFrames ?? 0,
      attackersMissExpireFrame: 0,
      productionProfile,
      productionQueue: [],
      productionNextId: 1,
      queueProductionExitProfile,
      rallyPoint: null,
      parkingPlaceProfile,
      containProfile,
      queueProductionExitDelayFramesRemaining: 0,
      queueProductionExitBurstRemaining: queueProductionExitProfile?.initialBurst ?? 0,
      parkingSpaceProducerId: null,
      helixCarrierId: null,
      garrisonContainerId: null,
      containPlayerEnteredSide: null,
      transportContainerId: null,
      tunnelContainerId: null,
      tunnelEnteredFrame: 0,
      healContainEnteredFrame: 0,
      helixPortableRiderId: null,
      slaverEntityId: null,
      spawnBehaviorState: this.extractSpawnBehaviorState(objectDef),
      pathDiameter,
      pathfindCenterInCell,
      blocksPath,
      geometryMajorRadius,
      obstacleGeometry,
      obstacleFootprint,
      largestWeaponRange,
      totalWeaponAntiMask,
      ignoredMovementObstacleId: null,
      movePath: [],
      pathIndex: 0,
      moving: false,
      speed: locomotorProfile.movementSpeed > 0 ? locomotorProfile.movementSpeed : this.config.defaultMoveSpeed,
      currentSpeed: 0,
      moveTarget: null,
      pathfindGoalCell: null,
      pathfindPosCell: (posCellX !== null && posCellZ !== null) ? { x: posCellX, z: posCellZ } : null,
      supplyWarehouseProfile,
      supplyTruckProfile,
      chinookAIProfile,
      repairDockProfile,
      dozerAIProfile,
      dozerIdleTooLongTimestamp: this.frameCounter,
      isSupplyCenter,
      experienceProfile,
      experienceState: createExperienceStateImpl(),
      visionRange: readNumericField(objectDef?.fields ?? {}, ['VisionRange', 'ShroudClearingRange']) ?? 0,
      visionState: createEntityVisionStateImpl(),
      stealthProfile: this.extractStealthProfile(objectDef),
      stealthDelayRemaining: 0,
      detectedUntilFrame: 0,
      lastDamageFrame: 0,
      lastAttackerEntityId: null,
      scriptLastDamageSourceEntityId: null,
      scriptLastDamageSourceTemplateName: null,
      scriptLastDamageSourceSide: null,
      detectorProfile: this.extractDetectorProfile(objectDef),
      detectorNextScanFrame: 0,
      autoHealProfile: this.extractAutoHealProfile(objectDef),
      autoHealNextFrame: 0,
      autoHealDamageDelayUntilFrame: 0,
      baseRegenDelayUntilFrame: 0,
      propagandaTowerProfile: this.extractPropagandaTowerProfile(objectDef),
      propagandaTowerNextScanFrame: 0,
      propagandaTowerTrackedIds: [],
      soleHealingBenefactorId: null,
      soleHealingBenefactorExpirationFrame: 0,
      autoTargetScanNextFrame: this.frameCounter + AUTO_TARGET_SCAN_RATE_FRAMES,
      // Guard state
      guardState: 'NONE' as GuardState,
      guardPositionX: 0,
      guardPositionZ: 0,
      guardObjectId: 0,
      guardMode: 0,
      guardNextScanFrame: 0,
      guardChaseExpireFrame: 0,
      guardInnerRange: 0,
      guardOuterRange: 0,
      // Poison DoT state
      poisonedBehaviorProfile: this.extractPoisonedBehaviorProfile(objectDef),
      poisonDamageAmount: 0,
      poisonNextDamageFrame: 0,
      poisonExpireFrame: 0,
      // Fire DoT state
      flameStatus: 'NORMAL' as const,
      flameDamageAccumulated: 0,
      flameEndFrame: 0,
      flameBurnedEndFrame: 0,
      flameDamageNextFrame: 0,
      flameLastDamageReceivedFrame: 0,
      flammableProfile: this.extractFlammableProfile(objectDef),
      fireSpreadProfile: this.extractFireSpreadProfile(objectDef),
      fireSpreadNextFrame: 0,
      // Mine behavior
      minefieldProfile: this.extractMinefieldProfile(objectDef),
      mineVirtualMinesRemaining: 0,
      mineImmunes: [],
      mineDetonators: [],
      mineScootFramesLeft: 0,
      mineDraining: false,
      mineRegenerates: false,
      mineNextDeathCheckFrame: 0,
      mineIgnoreDamage: false,
      mineCreatorId: 0,
      // Pilot eject
      ejectPilotTemplateName: this.extractEjectPilotTemplateName(objectDef),
      ejectPilotMinVeterancy: 1,
      // Prone behavior
      proneDamageToFramesRatio: this.extractProneDamageToFramesRatio(objectDef),
      proneFramesRemaining: 0,
      // Demo trap
      demoTrapProfile: this.extractDemoTrapProfile(objectDef),
      demoTrapNextScanFrame: 0,
      demoTrapDetonated: false,
      demoTrapProximityMode: false,
      // Rebuild hole expose die (buildings)
      rebuildHoleExposeDieProfile: this.extractRebuildHoleExposeDieProfile(objectDef),
      // Rebuild hole behavior (holes)
      rebuildHoleProfile: this.extractRebuildHoleBehaviorProfile(objectDef),
      rebuildHoleWorkerEntityId: 0,
      rebuildHoleReconstructingEntityId: 0,
      rebuildHoleSpawnerEntityId: 0,
      rebuildHoleWorkerWaitCounter: 0,
      rebuildHoleRebuildTemplateName: '',
      rebuildHoleMasked: false,
      // Auto deposit
      autoDepositProfile: this.extractAutoDepositProfile(objectDef),
      autoDepositNextFrame: 0,
      autoDepositInitialized: false,
      autoDepositCaptureBonusPending: false,
      // Auto-find-healing
      autoFindHealingProfile: this.extractAutoFindHealingProfile(objectDef),
      autoFindHealingNextScanFrame: 0,
      // Death OCLs
      deathOCLEntries: this.extractDeathOCLEntries(objectDef),
      // Deploy state machine
      deployStyleProfile: this.extractDeployStyleProfile(objectDef),
      deployState: 'READY_TO_MOVE' as DeployState,
      deployFrameToWait: 0,
      // Construction state — born complete unless dozer-placed.
      constructionPercent: CONSTRUCTION_COMPLETE,
      builderId: 0,
      buildTotalFrames: 0,
      destroyed: false,
      pendingDeathType: 'NORMAL',
      // Lifetime
      lifetimeDieFrame: this.resolveLifetimeDieFrame(objectDef),
      // Height die
      heightDieProfile: this.extractHeightDieProfile(objectDef),
      heightDieActiveFrame: 0, // Set after first update.
      heightDieLastY: 0,
      // Deletion
      deletionDieFrame: this.resolveDeletionDieFrame(objectDef),
      // Sticky bomb
      stickyBombProfile: this.extractStickyBombUpdateProfile(objectDef),
      stickyBombTargetId: 0,
      stickyBombDieFrame: 0,
      // Fire weapon when damaged
      fireWhenDamagedProfiles: this.extractFireWhenDamagedProfiles(objectDef),
      // Fire weapon update (autonomous fire at own position)
      fireWeaponUpdateProfiles: this.extractFireWeaponUpdateProfiles(objectDef),
      fireWeaponUpdateNextFireFrames: [],
      lastShotFiredFrame: 0,
      // OCL update (periodic Object Creation List spawning)
      oclUpdateProfiles: this.extractOCLUpdateProfiles(objectDef),
      oclUpdateNextCreationFrames: [],
      oclUpdateTimerStarted: [],
      // Weapon bonus update (aura-based weapon bonus)
      weaponBonusUpdateProfiles: this.extractWeaponBonusUpdateProfiles(objectDef),
      weaponBonusUpdateNextPulseFrames: [],
      // Temp weapon bonus (target side)
      tempWeaponBonusFlag: 0,
      tempWeaponBonusExpiryFrame: 0,
      // Instant death die modules
      instantDeathProfiles: this.extractInstantDeathProfiles(objectDef),
      // Fire weapon when dead die modules
      fireWeaponWhenDeadProfiles: this.extractFireWeaponWhenDeadProfiles(objectDef),
      // Slow death
      slowDeathProfiles: this.extractSlowDeathProfiles(objectDef),
      slowDeathState: null,
      // Structure collapse
      structureCollapseProfile: this.extractStructureCollapseProfile(objectDef),
      structureCollapseState: null,
      // EMP update (pulse field that disables nearby entities)
      empUpdateProfile: this.extractEmpUpdateProfile(objectDef),
      empUpdateState: null,
      // Hijacker update (hide in vehicle, eject on death)
      hijackerUpdateProfile: this.extractHijackerUpdateProfile(objectDef),
      hijackerState: null,
      // Leaflet drop (delayed radius disable)
      leafletDropProfile: this.extractLeafletDropProfile(objectDef),
      leafletDropState: null,
      // SmartBomb target homing (course correction for falling projectiles)
      smartBombProfile: this.extractSmartBombProfile(objectDef),
      smartBombState: null,
      // Dynamic geometry (collision shape morphing)
      dynamicGeometryProfile: this.extractDynamicGeometryProfile(objectDef),
      dynamicGeometryState: null,
      // Fire OCL after weapon cooldown
      fireOCLAfterCooldownProfiles: this.extractFireOCLAfterCooldownProfiles(objectDef),
      fireOCLAfterCooldownStates: [],
      // Neutron blast (death-triggered radius effect)
      neutronBlastProfile: this.extractNeutronBlastProfile(objectDef),
      // Bunker buster (kills garrisoned units on bomb death)
      bunkerBusterProfile: this.extractBunkerBusterProfile(objectDef),
      bunkerBusterVictimId: null,
      // Grant stealth (GPS Scrambler expanding radius)
      grantStealthProfile: this.extractGrantStealthProfile(objectDef),
      grantStealthCurrentRadius: 0,
      // Neutron missile slow death (timed blast waves)
      neutronMissileSlowDeathProfile: this.extractNeutronMissileSlowDeathProfile(objectDef),
      neutronMissileSlowDeathState: null,
      // Helicopter slow death (spiral crash)
      helicopterSlowDeathProfiles: this.extractHelicopterSlowDeathProfiles(objectDef),
      helicopterSlowDeathState: null,
      // Jet slow death (roll + forward motion + FX timeline)
      jetSlowDeathProfiles: this.extractJetSlowDeathProfiles(objectDef),
      jetSlowDeathState: null,
      // Cleanup hazard (workers scan and clean hazards)
      cleanupHazardProfile: this.extractCleanupHazardProfile(objectDef),
      cleanupHazardState: null,
      // Assisted targeting (laser designation)
      assistedTargetingProfile: this.extractAssistedTargetingProfile(objectDef),
      // Tech building behavior (neutral buildings)
      techBuildingProfile: this.extractTechBuildingProfile(objectDef),
      // SupplyWarehouseCrippling
      supplyWarehouseCripplingProfile: this.extractSupplyWarehouseCripplingProfile(objectDef),
      swCripplingHealSuppressedUntilFrame: 0,
      swCripplingNextHealFrame: 0,
      swCripplingDockDisabled: false,
      // Generate minefield
      generateMinefieldProfile: this.extractGenerateMinefieldProfile(objectDef),
      generateMinefieldDone: false,
      // Crate spawning on death
      createCrateDieProfile: this.extractCreateCrateDieProfile(objectDef),
      // Salvage crate collection
      salvageCrateProfile: this.extractSalvageCrateProfile(objectDef),
      crateCollideProfile: this.extractCrateCollideProfile(objectDef),
      // Battle plan
      battlePlanProfile: this.extractBattlePlanProfile(objectDef),
      battlePlanState: null,
      battlePlanDamageScalar: 1.0,
      baseVisionRange: readNumericField(objectDef?.fields ?? {}, ['VisionRange', 'ShroudClearingRange']) ?? 0,
      // Point defense laser
      pointDefenseLaserProfile: this.extractPointDefenseLaserProfile(objectDef),
      pdlNextScanFrame: 0,
      pdlTargetProjectileVisualId: 0,
      pdlNextShotFrame: 0,
      // Horde formation bonus
      hordeProfile: this.extractHordeUpdateProfile(objectDef),
      hordeNextCheckFrame: 0,
      isInHorde: false,
      isTrueHordeMember: false,
      // EnemyNear
      enemyNearScanDelayFrames: this.extractEnemyNearScanDelay(objectDef),
      enemyNearNextScanCountdown: 0,
      enemyNearDetected: false,
      // Slaved update (slave following behavior)
      slavedUpdateProfile: this.extractSlavedUpdateProfile(objectDef),
      slaveGuardOffsetX: 0,
      slaveGuardOffsetZ: 0,
      slavedNextUpdateFrame: 0,
      // Countermeasures (aircraft flare defense)
      countermeasuresProfile: this.extractCountermeasuresProfile(objectDef),
      countermeasuresState: null,
      // Pilot find vehicle
      pilotFindVehicleProfile: this.extractPilotFindVehicleProfile(objectDef),
      pilotFindVehicleNextScanFrame: 0,
      pilotFindVehicleDidMoveToBase: false,
      pilotFindVehicleTargetId: null,
      // Topple
      toppleProfile: this.extractToppleProfile(objectDef),
      toppleState: 'NONE' as ToppleState,
      toppleDirX: 0,
      toppleDirZ: 0,
      toppleAngularVelocity: 0,
      toppleAngularAccumulation: 0,
      toppleSpeed: 0,
      // Special ability
      specialAbilityProfile: this.extractSpecialAbilityProfile(objectDef),
      specialAbilityState: null,
      // RadarUpdate
      radarUpdateProfile: this.extractRadarUpdateProfile(objectDef),
      radarExtendDoneFrame: 0,
      radarExtendComplete: false,
      radarActive: false,
      // FloatUpdate
      floatUpdateProfile: this.extractFloatUpdateProfile(objectDef),
      // WanderAIUpdate
      hasWanderAI: this.hasModuleType(objectDef, 'WANDERAIUPDATE'),
      // VeterancyGainCreate
      veterancyGainCreateProfiles: this.extractVeterancyGainCreateProfiles(objectDef),
      // FXListDie
      fxListDieProfiles: this.extractFXListDieProfiles(objectDef),
      // CrushDie
      crushDieProfiles: this.extractCrushDieProfiles(objectDef),
      // DestroyDie
      destroyDieProfiles: this.extractDestroyDieProfiles(objectDef),
      // DamDie
      damDieProfiles: this.extractDamDieProfiles(objectDef),
      // SpecialPowerCompletionDie
      specialPowerCompletionDieProfiles: this.extractSpecialPowerCompletionDieProfiles(objectDef),
      specialPowerCompletionCreatorId: 0,
      specialPowerCompletionCreatorSet: false,
      frontCrushed: false,
      backCrushed: false,
      // GrantUpgradeCreate
      grantUpgradeCreateProfiles: this.extractGrantUpgradeCreateProfiles(objectDef),
      // LockWeaponCreate
      lockWeaponCreateSlot: this.extractLockWeaponCreateSlot(objectDef),
      // UpgradeDie
      upgradeDieProfiles: this.extractUpgradeDieProfiles(objectDef),
      producerEntityId: 0,
      // CheckpointUpdate
      checkpointProfile: this.extractCheckpointProfile(objectDef),
      checkpointAllyNear: false,
      checkpointEnemyNear: false,
      checkpointMaxMinorRadius: 0,
      checkpointScanCountdown: 0,
      // DynamicShroudClearingRangeUpdate
      dynamicShroudProfile: this.extractDynamicShroudProfile(objectDef),
      dynamicShroudState: 'NOT_STARTED' as DynamicShroudState,
      dynamicShroudStateCountdown: 0,
      dynamicShroudTotalFrames: 0,
      dynamicShroudShrinkStartDeadline: 0,
      dynamicShroudSustainDeadline: 0,
      dynamicShroudGrowStartDeadline: 0,
      dynamicShroudDoneForeverFrame: 0,
      dynamicShroudChangeIntervalCountdown: 0,
      dynamicShroudNativeClearingRange: 0,
      dynamicShroudCurrentClearingRange: 0,
      // JetAI
      jetAIProfile,
      jetAIState: null,
      // AnimationSteeringUpdate
      animationSteeringProfile,
      animationSteeringCurrentTurnAnim: null,
      animationSteeringNextTransitionFrame: 0,
      animationSteeringLastRotationY: rotationY,
      tensileFormationProfile,
      tensileFormationState: tensileFormationProfile ? {
        enabled: tensileFormationProfile.enabled,
        linksInited: false,
        links: [
          { id: 0, tensorX: 0, tensorZ: 0 },
          { id: 0, tensorX: 0, tensorZ: 0 },
          { id: 0, tensorX: 0, tensorZ: 0 },
          { id: 0, tensorX: 0, tensorZ: 0 },
        ],
        inertiaX: 0,
        inertiaZ: 0,
        motionlessCounter: 0,
        life: 0,
        lowestSlideElevation: 255,
        nextWakeFrame: 0,
        done: false,
      } : null,
      // AssaultTransport
      assaultTransportProfile: this.extractAssaultTransportProfile(objectDef),
      // PowerPlantUpdate
      powerPlantUpdateProfile: this.extractPowerPlantUpdateProfile(objectDef),
      powerPlantUpdateState: null,
      // SpecialPowerCreate
      hasSpecialPowerCreate: this.hasModuleType(objectDef, 'SPECIALPOWERCREATE'),
      shroudRange: 0,
      // SubdualDamageHelper
      subdualDamageCap: bodyStats.subdualDamageCap,
      subdualDamageHealRate: bodyStats.subdualDamageHealRate,
      subdualDamageHealAmount: bodyStats.subdualDamageHealAmount,
      currentSubdualDamage: 0,
      subdualHealingCountdown: 0,
    };

    // Source parity: PowerPlantUpdate init — extended=false, sleeping forever.
    if (entity.powerPlantUpdateProfile) {
      entity.powerPlantUpdateState = { extended: false, upgradeFinishFrame: 0 };
    }

    // Source parity: TurretAI init — create runtime state for each turret.
    entity.turretStates = entity.turretProfiles.map((tp) => ({
      currentAngle: tp.naturalAngle,
      state: 'IDLE' as const,
      holdUntilFrame: 0,
    }));

    // Source parity: StealthUpdate::init — InnateStealth sets CAN_STEALTH on creation.
    if (entity.stealthProfile?.innateStealth) {
      entity.objectStatusFlags.add('CAN_STEALTH');
    }

    // Source parity: StealthDetectorUpdate init — stagger initial scan with random offset.
    if (entity.detectorProfile) {
      entity.detectorNextScanFrame = this.frameCounter
        + this.gameRandom.nextRange(1, entity.detectorProfile.detectionRate);
    }

    // Source parity: BattlePlanUpdate init — initialize state machine.
    if (entity.battlePlanProfile) {
      entity.battlePlanState = {
        desiredPlan: 'NONE',
        activePlan: 'NONE',
        transitionStatus: 'IDLE',
        transitionFinishFrame: 0,
        idleCooldownFinishFrame: 0,
      };
    }

    // Source parity: PointDefenseLaserUpdate init — stagger initial scan.
    if (entity.pointDefenseLaserProfile) {
      const rate = Math.max(1, entity.pointDefenseLaserProfile.scanRate);
      entity.pdlNextScanFrame = this.frameCounter + this.gameRandom.nextRange(0, rate);
    }

    // Source parity: HordeUpdate init — stagger initial scan to spread load.
    // C++ uses GameLogicRandomValue(1, delay) → [1, delay] inclusive.
    if (entity.hordeProfile) {
      const rate = Math.max(1, entity.hordeProfile.updateRate);
      entity.hordeNextCheckFrame = this.frameCounter + this.gameRandom.nextRange(1, rate);
    }

    // Source parity: EnemyNearUpdate constructor — random initial delay for staggered scanning.
    // C++ uses GameLogicRandomValue(0, m_enemyScanDelayTime).
    if (entity.enemyNearScanDelayFrames > 0) {
      entity.enemyNearNextScanCountdown = this.gameRandom.nextRange(0, entity.enemyNearScanDelayFrames);
    }

    // Source parity: DemoTrapUpdate::onObjectCreated — set initial mode.
    if (entity.demoTrapProfile) {
      entity.demoTrapProximityMode = entity.demoTrapProfile.defaultsToProximityMode;
    }

    // Source parity: SpecialAbilityUpdate::onObjectCreated — init state machine.
    // Default to PACKED; if no unpack time or skipPackingWithNoTarget, start UNPACKED.
    if (entity.specialAbilityProfile) {
      const sap = entity.specialAbilityProfile;
      const initialPacking: SpecialAbilityPackingState =
        sap.unpackTimeFrames === 0 ? 'UNPACKED' : 'PACKED';
      entity.specialAbilityState = {
        active: false,
        packingState: initialPacking,
        prepFrames: 0,
        animFrames: 0,
        targetEntityId: null,
        targetX: null,
        targetZ: null,
        withinStartAbilityRange: false,
        noTargetCommand: false,
        persistentTriggerCount: 0,
      };
    }

    // Source parity: CountermeasuresBehavior::onObjectCreated — init state.
    if (entity.countermeasuresProfile) {
      const cp = entity.countermeasuresProfile;
      entity.countermeasuresState = {
        availableCountermeasures: cp.numberOfVolleys * cp.volleySize,
        activeCountermeasures: 0,
        flareIds: [],
        reactionFrame: 0,
        nextVolleyFrame: 0,
        reloadFrame: 0,
        incomingMissiles: 0,
        divertedMissiles: 0,
      };
    }

    // Source parity: CheckpointUpdate constructor — cache maxMinorRadius, random scan stagger.
    if (entity.checkpointProfile) {
      entity.checkpointMaxMinorRadius = entity.obstacleGeometry?.minorRadius ?? 0;
      entity.checkpointScanCountdown = this.gameRandom.nextRange(0, entity.checkpointProfile.scanDelayFrames);
    }

    // Source parity: AutoDepositUpdate constructor — schedule first deposit.
    // C++ line 78: m_depositOnFrame = TheGameLogic->getFrame() + m_depositFrame.
    if (entity.autoDepositProfile) {
      entity.autoDepositNextFrame = this.frameCounter + entity.autoDepositProfile.depositFrames;
    }

    // Source parity: DynamicShroudClearingRangeUpdate constructor — compute deadlines.
    // C++ lines 89-133: timeline deadlines computed from profile timing values.
    if (entity.dynamicShroudProfile) {
      const prof = entity.dynamicShroudProfile;
      const stateCountDown = prof.shrinkDelay + prof.shrinkTime;
      entity.dynamicShroudStateCountdown = stateCountDown;
      entity.dynamicShroudTotalFrames = Math.max(1, stateCountDown);
      entity.dynamicShroudShrinkStartDeadline = stateCountDown - prof.shrinkDelay;
      entity.dynamicShroudGrowStartDeadline = stateCountDown - prof.growDelay;
      entity.dynamicShroudSustainDeadline = entity.dynamicShroudGrowStartDeadline - prof.growTime;
      // Source parity: C++ DEBUG_ASSERTCRASH checks (DynamicShroudClearingRangeUpdate.cpp:104-105).
      if (entity.dynamicShroudSustainDeadline < entity.dynamicShroudShrinkStartDeadline) {
        console.warn(`DynamicShroudClearingRangeUpdate: sustainDeadline(${entity.dynamicShroudSustainDeadline}) < shrinkStartDeadline(${entity.dynamicShroudShrinkStartDeadline}) — invalid INI configuration`);
      }
      if (entity.dynamicShroudGrowStartDeadline < entity.dynamicShroudShrinkStartDeadline) {
        console.warn(`DynamicShroudClearingRangeUpdate: growStartDeadline(${entity.dynamicShroudGrowStartDeadline}) < shrinkStartDeadline(${entity.dynamicShroudShrinkStartDeadline}) — invalid INI configuration`);
      }
      entity.dynamicShroudDoneForeverFrame = this.frameCounter + stateCountDown;
      entity.dynamicShroudNativeClearingRange = entity.visionRange;
      entity.dynamicShroudCurrentClearingRange = 0;
      entity.dynamicShroudState = 'NOT_STARTED';
      entity.dynamicShroudChangeIntervalCountdown = 0;
    }

    // Source parity: JetAIUpdate::onObjectCreated — init flight state machine.
    // Map-placed aircraft start AIRBORNE (already flying). Produced aircraft are set
    // to PARKED by applyQueueProductionExitPath.
    if (jetAIProfile) {
      // Source parity: cruise height from MinHeight INI field, fallback to 100.
      // C++ uses locomotor preferredHeight as middle fallback but we don't parse that yet.
      const cruiseHeight = jetAIProfile.minHeight > 0 ? jetAIProfile.minHeight : 100;
      entity.jetAIState = {
        state: 'AIRBORNE',
        stateEnteredFrame: this.frameCounter,
        allowAirLoco: true,
        pendingCommand: null,
        producerX: entity.x,
        producerZ: entity.z,
        returnToBaseFrame: 0,
        attackLocoExpireFrame: 0,
        useReturnLoco: false,
        reloadDoneFrame: 0,
        reloadTotalFrames: 0,
        circlingNextCheckFrame: 0,
        cruiseHeight,
      };
      // Map-placed aircraft are airborne.
      entity.objectStatusFlags.add('AIRBORNE_TARGET');
    }

    // Source parity: GrantUpgradeCreate::onCreate — grant upgrades on entity creation.
    // C++ only grants in onCreate if ExemptStatus includes UNDER_CONSTRUCTION and entity
    // is NOT currently under construction (i.e. placed fully built).
    for (const prof of entity.grantUpgradeCreateProfiles) {
      if (prof.exemptUnderConstruction && !entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
        this.applyGrantUpgradeCreate(entity, prof);
      }
    }

    // Source parity: VeterancyGainCreate::onCreate — set min veterancy if player has science.
    // C++ file: VeterancyGainCreate.cpp lines 81-93.
    for (const prof of entity.veterancyGainCreateProfiles) {
      if (prof.scienceRequired === null || this.hasSideScience(entity.side ?? '', prof.scienceRequired)) {
        this.setMinVeterancyLevel(entity, prof.startingLevel);
      }
    }

    // Source parity: LockWeaponCreate::onBuildComplete — lock weapon slot permanently.
    // For non-building entities this fires immediately at creation.
    if (entity.lockWeaponCreateSlot !== null && !entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
      entity.forcedWeaponSlot = entity.lockWeaponCreateSlot;
      entity.weaponLockStatus = 'LOCKED_PERMANENTLY';
    }

    // Source parity: FireWeaponUpdate — initialize per-module fire timers with initial delay.
    if (entity.fireWeaponUpdateProfiles.length > 0) {
      entity.fireWeaponUpdateNextFireFrames = entity.fireWeaponUpdateProfiles.map(
        p => this.frameCounter + p.initialDelayFrames,
      );
    }

    // Source parity: OCLUpdate — initialize per-module creation timers (start at 0, first check sets timer).
    if (entity.oclUpdateProfiles.length > 0) {
      entity.oclUpdateNextCreationFrames = entity.oclUpdateProfiles.map(() => 0);
      entity.oclUpdateTimerStarted = entity.oclUpdateProfiles.map(() => false);
    }

    // Source parity: WeaponBonusUpdate — initialize per-module pulse timers.
    if (entity.weaponBonusUpdateProfiles.length > 0) {
      entity.weaponBonusUpdateNextPulseFrames = entity.weaponBonusUpdateProfiles.map(() => 0);
    }

    // Source parity: GrantStealthBehavior — initialize scan radius from profile.
    if (entity.grantStealthProfile) {
      entity.grantStealthCurrentRadius = entity.grantStealthProfile.startRadius;
    }

    return entity;
  }

  private resolveRenderAssetProfile(objectDef: ObjectDef | undefined): {
    renderAssetCandidates: string[];
    renderAssetPath: string | null;
    renderAssetResolved: boolean;
    renderAnimationStateClips: RenderAnimationStateClipCandidates;
  } {
    return resolveRenderAssetProfileImpl(objectDef);
  }

  private resolveForwardUnitVector(entity: MapEntity): { x: number; z: number } {
    return {
      x: Math.cos(entity.rotationY),
      z: Math.sin(entity.rotationY),
    };
  }

  private deriveRenderAnimationState(entity: MapEntity): RenderAnimationState {
    // Source parity note:
    // Generals/Code/GameEngine/Source/GameLogic/Thing/Drawable.cpp
    // drives render-state from object locomotor/combat lifecycle transitions.
    if (entity.slowDeathState || entity.structureCollapseState) {
      return 'DIE';
    }
    if (entity.destroyed) {
      return 'DIE';
    }

    if (entity.attackTargetEntityId !== null && this.canEntityAttackFromStatus(entity)) {
      return 'ATTACK';
    }

    // Source parity: ProneUpdate — prone overrides movement/idle state.
    if (entity.proneFramesRemaining > 0) {
      return 'PRONE';
    }

    if (entity.canMove && entity.moving) {
      return 'MOVE';
    }

    return 'IDLE';
  }

  private updateRenderState(entity: MapEntity): void {
    entity.animationState = this.deriveRenderAnimationState(entity);
  }

  private updateRenderStates(): void {
    for (const entity of this.spawnedEntities.values()) {
      this.updateRenderState(entity);
    }
  }

  private inferCategory(kindOf: string[] | undefined, fallbackKindOf?: unknown): ObjectCategory {
    const kinds = kindOf ?? coerceStringArray(fallbackKindOf);
    if (kinds.length === 0) {
      return 'unknown';
    }

    const uppercaseKinds = kinds.map((value) => value.toUpperCase());
    if (uppercaseKinds.includes('AIRCRAFT')) return 'air';
    if (uppercaseKinds.includes('STRUCTURE')) return 'building';
    if (uppercaseKinds.includes('INFANTRY')) return 'infantry';
    if (uppercaseKinds.includes('VEHICLE') || uppercaseKinds.includes('HUGE_VEHICLE')) return 'vehicle';

    return 'unknown';
  }

  private shouldPathfindObstacle(objectDef: ObjectDef | undefined): boolean {
    return shouldPathfindObstacleImpl(
      objectDef,
      {
        mapXyFactor: MAP_XY_FACTOR,
        normalizeKindOf: (kindOf) => this.normalizeKindOf(kindOf),
        isMobileObject: (nextObjectDef, kinds) => this.isMobileObject(nextObjectDef, kinds),
        isSmallGeometry: (fields) => this.isSmallGeometry(fields),
      },
    );
  }

  private resolveAttackMoveDistance(entity: MapEntity | undefined): number {
    if (!entity || entity.largestWeaponRange === NO_ATTACK_DISTANCE) {
      return NO_ATTACK_DISTANCE;
    }

    return entity.largestWeaponRange + ATTACK_MOVE_DISTANCE_FUDGE;
  }

  private resolveLargestWeaponRange(objectDef: ObjectDef | undefined, iniDataRegistry: IniDataRegistry): number {
    if (!objectDef) {
      return NO_ATTACK_DISTANCE;
    }

    return this.resolveLargestWeaponRangeForSetSelection(
      this.extractWeaponTemplateSets(objectDef),
      0,
      iniDataRegistry,
    );
  }

  private extractIniValueTokens(value: IniValue | undefined): string[][] {
    if (typeof value === 'undefined') {
      return [];
    }
    if (value === null) {
      return [];
    }
    if (typeof value === 'string') {
      return [value.split(/[\s,;|]+/).map((token) => token.trim()).filter(Boolean)];
    }
    if (typeof value === 'number' || typeof value === 'boolean') {
      return [[String(value)]];
    }
    if (Array.isArray(value)) {
      return value.flatMap((entry) => this.extractIniValueTokens(entry as IniValue));
    }
    return [];
  }

  private readIniFieldValue(fields: Record<string, IniValue>, fieldName: string): IniValue | undefined {
    const normalizedFieldName = fieldName.toUpperCase();
    for (const [name, value] of Object.entries(fields)) {
      if (name.toUpperCase() === normalizedFieldName) {
        return value;
      }
    }
    return undefined;
  }

  private resolveIniFieldString(fields: Record<string, IniValue>, fieldName: string): string | null {
    const value = this.readIniFieldValue(fields, fieldName);
    if (typeof value !== 'string') {
      return null;
    }
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : null;
  }

  private extractWeaponNamesFromTokens(tokens: string[]): string[] {
    const filteredTokens = tokens.filter((token) => token.trim().length > 0).map((token) => token.trim());
    if (filteredTokens.length === 0) {
      return [];
    }

    const slotNames = new Set(['PRIMARY', 'SECONDARY', 'TERTIARY']);
    const weapons: string[] = [];

    let tokenIndex = 0;
    while (tokenIndex < filteredTokens.length) {
      const token = filteredTokens[tokenIndex]!;
      const upperToken = token.toUpperCase();

      if (slotNames.has(upperToken)) {
        const weaponName = filteredTokens[tokenIndex + 1];
        tokenIndex += 2;
        if (weaponName === undefined) {
          continue;
        }
        if (weaponName.toUpperCase() === 'NONE') {
          continue;
        }
        weapons.push(weaponName);
        continue;
      }

      if (upperToken === 'NONE') {
        tokenIndex++;
        continue;
      }

      weapons.push(token);
      tokenIndex++;
    }
    return weapons;
  }

  private collectWeaponNamesInPriorityOrder(objectDef: ObjectDef): string[] {
    const slotPriority = new Map<string, number>([
      ['PRIMARY', 0],
      ['SECONDARY', 1],
      ['TERTIARY', 2],
    ]);
    const candidates: Array<{ name: string; priority: number; order: number }> = [];
    const seen = new Set<string>();
    let order = 0;

    const addCandidate = (name: string, priority: number): void => {
      const trimmed = name.trim();
      if (!trimmed || trimmed.toUpperCase() === 'NONE') {
        return;
      }
      const normalized = trimmed.toUpperCase();
      if (seen.has(normalized)) {
        return;
      }
      seen.add(normalized);
      candidates.push({ name: trimmed, priority, order });
      order += 1;
    };

    const collectFromFieldValue = (value: IniValue | undefined): void => {
      for (const tokens of this.extractIniValueTokens(value)) {
        if (tokens.length >= 2) {
          const slot = tokens[0]?.toUpperCase() ?? '';
          const slotPriorityValue = slotPriority.get(slot);
          if (slotPriorityValue !== undefined) {
            const weaponName = tokens[1];
            if (weaponName !== undefined) {
              addCandidate(weaponName, slotPriorityValue);
              continue;
            }
          }
        }
        for (const weaponName of this.extractWeaponNamesFromTokens(tokens)) {
          addCandidate(weaponName, 3);
        }
      }
    };

    const collectWeaponFields = (fields: Record<string, IniValue>): void => {
      for (const [fieldName, fieldValue] of Object.entries(fields)) {
        if (fieldName.toUpperCase() === 'WEAPON') {
          collectFromFieldValue(fieldValue);
        }
      }
    };

    const visitBlock = (block: IniBlock): void => {
      collectWeaponFields(block.fields);
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    collectWeaponFields(objectDef.fields);
    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return candidates
      .sort((left, right) => left.priority - right.priority || left.order - right.order)
      .map((candidate) => candidate.name);
  }

  private extractWeaponTemplateSets(objectDef: ObjectDef | undefined): WeaponTemplateSetProfile[] {
    if (!objectDef) {
      return [];
    }

    const sets: WeaponTemplateSetProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'WEAPONSET') {
        sets.push({
          conditionsMask: this.extractConditionsMask(
            this.readIniFieldValue(block.fields, 'Conditions'),
            WEAPON_SET_FLAG_MASK_BY_NAME,
          ),
          weaponNamesBySlot: this.extractWeaponNamesBySlot(block.fields),
        });
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (sets.length > 0) {
      return sets;
    }

    const fallback = this.collectWeaponNamesInPriorityOrder(objectDef);
    if (fallback.length === 0) {
      return [];
    }

    const fallbackBySlot: [string | null, string | null, string | null] = [
      fallback[0] ?? null,
      fallback[1] ?? null,
      fallback[2] ?? null,
    ];
    return [{ conditionsMask: 0, weaponNamesBySlot: fallbackBySlot }];
  }

  private extractArmorTemplateSets(objectDef: ObjectDef | undefined): ArmorTemplateSetProfile[] {
    if (!objectDef) {
      return [];
    }

    const sets: ArmorTemplateSetProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'ARMORSET') {
        sets.push({
          conditionsMask: this.extractConditionsMask(
            this.readIniFieldValue(block.fields, 'Conditions'),
            ARMOR_SET_FLAG_MASK_BY_NAME,
          ),
          armorName: this.resolveIniFieldString(block.fields, 'Armor'),
        });
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (sets.length > 0) {
      return sets;
    }

    const fallbackArmor = this.resolveIniFieldString(objectDef.fields, 'Armor');
    if (!fallbackArmor) {
      return [];
    }

    return [{ conditionsMask: 0, armorName: fallbackArmor }];
  }

  private extractConditionsMask(value: IniValue | undefined, flagMaskByName: Map<string, number>): number {
    if (typeof value === 'number' && Number.isFinite(value)) {
      return Math.max(0, Math.trunc(value));
    }

    let mask = 0;
    for (const tokens of this.extractIniValueTokens(value)) {
      for (const token of tokens) {
        const normalized = token.trim().toUpperCase();
        const bitMask = flagMaskByName.get(normalized);
        if (bitMask !== undefined) {
          mask |= bitMask;
        }
      }
    }

    return mask;
  }

  private resolveWeaponRadiusAffectsMask(weaponDef: WeaponDef): number {
    const affectsValue = this.readIniFieldValue(weaponDef.fields, 'RadiusDamageAffects');
    if (typeof affectsValue === 'undefined') {
      return WEAPON_AFFECTS_DEFAULT_MASK;
    }
    return this.extractConditionsMask(affectsValue, WEAPON_AFFECTS_MASK_BY_NAME);
  }

  private resolveWeaponProjectileCollideMask(weaponDef: WeaponDef): number {
    const collideValue = this.readIniFieldValue(weaponDef.fields, 'ProjectileCollidesWith');
    if (typeof collideValue === 'undefined') {
      return WEAPON_COLLIDE_DEFAULT_MASK;
    }
    return this.extractConditionsMask(collideValue, WEAPON_COLLIDE_MASK_BY_NAME);
  }

  private resolveWeaponScatterTargets(weaponDef: WeaponDef): Array<{ x: number; z: number }> {
    const scatterTargetValue = this.readIniFieldValue(weaponDef.fields, 'ScatterTarget');
    if (typeof scatterTargetValue === 'undefined') {
      return [];
    }

    const resolvedTargets: Array<{ x: number; z: number }> = [];
    for (const tokens of this.extractIniValueTokens(scatterTargetValue)) {
      const numericTokens = tokens
        .map((token) => Number(token))
        .filter((value) => Number.isFinite(value));
      if (numericTokens.length >= 2) {
        resolvedTargets.push({
          x: numericTokens[0] ?? 0,
          z: numericTokens[1] ?? 0,
        });
      }
    }

    if (resolvedTargets.length > 0) {
      return resolvedTargets;
    }

    const flattenedNumbers = readNumericList(scatterTargetValue);
    for (let index = 0; index + 1 < flattenedNumbers.length; index += 2) {
      resolvedTargets.push({
        x: flattenedNumbers[index] ?? 0,
        z: flattenedNumbers[index + 1] ?? 0,
      });
    }

    return resolvedTargets;
  }

  private extractWeaponNamesBySlot(fields: Record<string, IniValue>): [string | null, string | null, string | null] {
    const slots: [string | null, string | null, string | null] = [null, null, null];

    for (const [fieldName, fieldValue] of Object.entries(fields)) {
      if (fieldName.toUpperCase() !== 'WEAPON') {
        continue;
      }

      const tokenGroups = this.extractIniValueTokens(fieldValue);
      if (
        Array.isArray(fieldValue)
        && fieldValue.every((entry) => typeof entry === 'string' || typeof entry === 'number' || typeof entry === 'boolean')
      ) {
        const inlineTokens = fieldValue
          .map((entry) => String(entry).trim())
          .filter((entry) => entry.length > 0);
        if (inlineTokens.length > 0) {
          tokenGroups.unshift(inlineTokens);
        }
      }

      for (const tokens of tokenGroups) {
        const slotName = tokens[0]?.trim().toUpperCase() ?? '';
        const weaponName = tokens[1]?.trim();
        if (!weaponName) {
          continue;
        }
        const normalizedWeaponName = weaponName.toUpperCase() === 'NONE' ? null : weaponName;
        if (slotName === 'PRIMARY') {
          slots[0] = normalizedWeaponName;
        } else if (slotName === 'SECONDARY') {
          slots[1] = normalizedWeaponName;
        } else if (slotName === 'TERTIARY') {
          slots[2] = normalizedWeaponName;
        }
      }
    }

    return slots;
  }

  private selectBestSetByConditions<T extends { conditionsMask: number }>(
    sets: readonly T[],
    currentMask: number,
  ): T | null {
    if (sets.length === 0) {
      return null;
    }

    let best: T | null = null;
    let bestYesMatch = 0;
    let bestYesExtraneousBits = Number.MAX_SAFE_INTEGER;
    for (const candidate of sets) {
      const yesFlags = candidate.conditionsMask >>> 0;
      const yesMatch = this.countSetBits((currentMask & yesFlags) >>> 0);
      const yesExtraneousBits = this.countSetBits((yesFlags & ~currentMask) >>> 0);
      if (yesMatch > bestYesMatch || (yesMatch >= bestYesMatch && yesExtraneousBits < bestYesExtraneousBits)) {
        best = candidate;
        bestYesMatch = yesMatch;
        bestYesExtraneousBits = yesExtraneousBits;
      }
    }

    return best;
  }

  private normalizeWeaponSlot(weaponSlot: number | null): number | null {
    if (weaponSlot === null || !Number.isFinite(weaponSlot)) {
      return null;
    }
    const normalized = Math.trunc(weaponSlot);
    if (!Number.isFinite(normalized) || normalized < 0 || normalized > 2) {
      return null;
    }
    return normalized;
  }

  private countSetBits(value: number): number {
    let v = value >>> 0;
    let count = 0;
    while (v !== 0) {
      count += v & 1;
      v >>>= 1;
    }
    return count;
  }

  private resolveWeaponDamageTypeName(weaponDef: WeaponDef): string {
    const explicitType = this.resolveIniFieldString(weaponDef.fields, 'DamageType')?.toUpperCase();
    if (explicitType && SOURCE_DAMAGE_TYPE_NAME_SET.has(explicitType)) {
      return explicitType;
    }

    const indexedType = readNumericField(weaponDef.fields, ['DamageType']);
    if (indexedType !== null) {
      const index = Math.trunc(indexedType);
      if (index >= 0 && index < SOURCE_DAMAGE_TYPE_NAMES.length) {
        return SOURCE_DAMAGE_TYPE_NAMES[index]!;
      }
    }

    return 'EXPLOSION';
  }

  private resolveWeaponProfileFromDef(weaponDef: WeaponDef): AttackWeaponProfile | null {
    const attackRangeRaw = readNumericField(weaponDef.fields, ['AttackRange', 'Range']) ?? NO_ATTACK_DISTANCE;
    const unmodifiedAttackRange = Math.max(0, attackRangeRaw);
    const attackRange = Math.max(0, attackRangeRaw - ATTACK_RANGE_CELL_EDGE_FUDGE);
    const minAttackRange = Math.max(0, readNumericField(weaponDef.fields, ['MinimumAttackRange']) ?? 0);
    const continueAttackRange = Math.max(0, readNumericField(weaponDef.fields, ['ContinueAttackRange']) ?? 0);
    const primaryDamage = readNumericField(weaponDef.fields, ['PrimaryDamage']) ?? 0;
    const secondaryDamage = readNumericField(weaponDef.fields, ['SecondaryDamage']) ?? 0;
    const primaryDamageRadius = Math.max(0, readNumericField(weaponDef.fields, ['PrimaryDamageRadius']) ?? 0);
    const secondaryDamageRadius = Math.max(0, readNumericField(weaponDef.fields, ['SecondaryDamageRadius']) ?? 0);
    const scatterTargetScalar = Math.max(0, readNumericField(weaponDef.fields, ['ScatterTargetScalar']) ?? 0);
    const scatterTargets = this.resolveWeaponScatterTargets(weaponDef);
    const scatterRadius = Math.max(0, readNumericField(weaponDef.fields, ['ScatterRadius']) ?? 0);
    const scatterRadiusVsInfantry = Math.max(0, readNumericField(weaponDef.fields, ['ScatterRadiusVsInfantry']) ?? 0);
    const radiusDamageAngleDegrees = readNumericField(weaponDef.fields, ['RadiusDamageAngle']);
    const radiusDamageAngle = radiusDamageAngleDegrees === null
      ? Math.PI
      : Math.max(0, radiusDamageAngleDegrees * (Math.PI / 180));
    const projectileObjectRaw = readStringField(weaponDef.fields, ['ProjectileObject'])?.trim() ?? '';
    const projectileObjectName = projectileObjectRaw && projectileObjectRaw.toUpperCase() !== 'NONE'
      ? projectileObjectRaw
      : null;
    const damageDealtAtSelfPosition = readBooleanField(weaponDef.fields, ['DamageDealtAtSelfPosition']) ?? false;
    const radiusDamageAffectsMask = this.resolveWeaponRadiusAffectsMask(weaponDef);
    const projectileCollideMask = this.resolveWeaponProjectileCollideMask(weaponDef);
    const weaponSpeedRaw = readNumericField(weaponDef.fields, ['WeaponSpeed']) ?? 999999;
    const weaponSpeed = Number.isFinite(weaponSpeedRaw) && weaponSpeedRaw > 0 ? weaponSpeedRaw : 999999;
    const minWeaponSpeedRaw = readNumericField(weaponDef.fields, ['MinWeaponSpeed']) ?? 999999;
    const minWeaponSpeed = Number.isFinite(minWeaponSpeedRaw) && minWeaponSpeedRaw > 0 ? minWeaponSpeedRaw : 999999;
    const scaleWeaponSpeed = readBooleanField(weaponDef.fields, ['ScaleWeaponSpeed']) ?? false;
    const leechRangeWeapon = readBooleanField(weaponDef.fields, ['LeechRangeWeapon']) ?? false;
    const clipSizeRaw = readNumericField(weaponDef.fields, ['ClipSize']) ?? 0;
    const clipSize = Math.max(0, Math.trunc(clipSizeRaw));
    const clipReloadFrames = this.msToLogicFrames(readNumericField(weaponDef.fields, ['ClipReloadTime']) ?? 0);
    const autoReloadWhenIdleFrames = this.msToLogicFrames(readNumericField(weaponDef.fields, ['AutoReloadWhenIdle']) ?? 0);
    const preAttackDelayFrames = this.msToLogicFrames(readNumericField(weaponDef.fields, ['PreAttackDelay']) ?? 0);
    const preAttackTypeToken = readStringField(weaponDef.fields, ['PreAttackType'])?.trim().toUpperCase();
    const preAttackType: WeaponPrefireTypeName =
      preAttackTypeToken === 'PER_ATTACK' || preAttackTypeToken === 'PER_CLIP'
        ? preAttackTypeToken
        : 'PER_SHOT';
    const delayValues = readNumericList(weaponDef.fields['DelayBetweenShots']);
    const minDelayMs = delayValues[0] ?? 0;
    const maxDelayMs = delayValues[1] ?? minDelayMs;
    const minDelayFrames = this.msToLogicFrames(minDelayMs);
    const maxDelayFrames = this.msToLogicFrames(maxDelayMs);
    // Source parity: Weapon::m_antiMask — WeaponTemplate::clear() pre-seeds WEAPON_ANTI_GROUND
    // before INI parsing, so all weapons can target ground by default unless explicitly cleared.
    let antiMask = WEAPON_ANTI_GROUND;
    if (readBooleanField(weaponDef.fields, ['AntiAirborneVehicle'])) antiMask |= WEAPON_ANTI_AIRBORNE_VEHICLE;
    if (readBooleanField(weaponDef.fields, ['AntiGround']) === false) antiMask &= ~WEAPON_ANTI_GROUND;
    if (readBooleanField(weaponDef.fields, ['AntiProjectile'])) antiMask |= WEAPON_ANTI_PROJECTILE;
    if (readBooleanField(weaponDef.fields, ['AntiSmallMissile'])) antiMask |= WEAPON_ANTI_SMALL_MISSILE;
    if (readBooleanField(weaponDef.fields, ['AntiMine'])) antiMask |= WEAPON_ANTI_MINE;
    if (readBooleanField(weaponDef.fields, ['AntiAirborneInfantry'])) antiMask |= WEAPON_ANTI_AIRBORNE_INFANTRY;
    if (readBooleanField(weaponDef.fields, ['AntiBallisticMissile'])) antiMask |= WEAPON_ANTI_BALLISTIC_MISSILE;
    if (readBooleanField(weaponDef.fields, ['AntiParachute'])) antiMask |= WEAPON_ANTI_PARACHUTE;

    // Source parity: FiringTracker continuous-fire INI properties on WeaponTemplate.
    const continuousFireOneShotsNeeded = Math.max(0, Math.trunc(
      readNumericField(weaponDef.fields, ['ContinuousFireOne']) ?? 0,
    ));
    const continuousFireTwoShotsNeeded = Math.max(0, Math.trunc(
      readNumericField(weaponDef.fields, ['ContinuousFireTwo']) ?? 0,
    ));
    const continuousFireCoastFrames = this.msToLogicFrames(
      readNumericField(weaponDef.fields, ['ContinuousFireCoast']) ?? 0,
    );
    // Source parity: per-weapon WeaponBonus lines — parse RATE_OF_FIRE multipliers
    // for CONTINUOUS_FIRE_MEAN and CONTINUOUS_FIRE_FAST conditions.
    const { continuousFireMeanRateOfFire, continuousFireFastRateOfFire } =
      this.resolveWeaponContinuousFireBonuses(weaponDef);

    // Source parity: WeaponTemplate::m_deathType — per-weapon death type (Weapon.cpp line 186).
    // Default is DEATH_NORMAL. INI field: DeathType (parsed as index list into TheDeathNames).
    const deathTypeRaw = readStringField(weaponDef.fields, ['DeathType'])?.trim().toUpperCase() ?? '';
    const deathType = deathTypeRaw || 'NORMAL';

    // Source parity: Weapon::isLaser() — weapon is a laser if LaserName is non-empty.
    const laserNameRaw = readStringField(weaponDef.fields, ['LaserName'])?.trim() ?? '';
    const laserName = laserNameRaw && laserNameRaw.toUpperCase() !== 'NONE' ? laserNameRaw : null;

    // Source parity: DumbProjectileBehavior arc parameters — parsed from the projectile
    // object template referenced by ProjectileObject on this weapon.
    const bezierArc = projectileObjectName
      ? this.extractDumbProjectileArcParams(projectileObjectName)
      : null;

    if (attackRange <= 0 || primaryDamage <= 0) {
      return null;
    }

    return {
      name: weaponDef.name,
      primaryDamage,
      secondaryDamage,
      primaryDamageRadius,
      secondaryDamageRadius,
      scatterTargetScalar,
      scatterTargets,
      scatterRadius,
      scatterRadiusVsInfantry,
      radiusDamageAngle,
      damageType: this.resolveWeaponDamageTypeName(weaponDef),
      deathType,
      damageDealtAtSelfPosition,
      radiusDamageAffectsMask,
      projectileCollideMask,
      weaponSpeed,
      minWeaponSpeed,
      scaleWeaponSpeed,
      projectileObjectName,
      attackRange,
      unmodifiedAttackRange,
      minAttackRange,
      continueAttackRange,
      clipSize,
      clipReloadFrames,
      autoReloadWhenIdleFrames,
      preAttackDelayFrames,
      preAttackType,
      minDelayFrames: Math.max(0, Math.min(minDelayFrames, maxDelayFrames)),
      maxDelayFrames: Math.max(minDelayFrames, maxDelayFrames),
      antiMask,
      continuousFireOneShotsNeeded,
      continuousFireTwoShotsNeeded,
      continuousFireCoastFrames,
      continuousFireMeanRateOfFire,
      continuousFireFastRateOfFire,
      laserName,
      projectileArcFirstHeight: bezierArc?.firstHeight ?? 0,
      projectileArcSecondHeight: bezierArc?.secondHeight ?? 0,
      projectileArcFirstPercentIndent: bezierArc?.firstPercentIndent ?? 0,
      projectileArcSecondPercentIndent: bezierArc?.secondPercentIndent ?? 0,
      leechRangeWeapon,
    };
  }

  /**
   * Source parity: DumbProjectileBehaviorModuleData — extract Bezier arc parameters
   * from the projectile object template's DumbProjectileBehavior module.
   */
  private extractDumbProjectileArcParams(projectileObjectName: string): {
    firstHeight: number;
    secondHeight: number;
    firstPercentIndent: number;
    secondPercentIndent: number;
  } | null {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return null;
    }
    const projectileDef = findObjectDefByName(registry, projectileObjectName);
    if (!projectileDef) {
      return null;
    }

    let firstHeight = 0;
    let secondHeight = 0;
    let firstPercentIndent = 0;
    let secondPercentIndent = 0;
    let found = false;

    const visitBlock = (block: IniBlock): void => {
      if (found) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DUMBPROJECTILEBEHAVIOR') {
          found = true;
          firstHeight = readNumericField(block.fields, ['FirstHeight']) ?? 0;
          secondHeight = readNumericField(block.fields, ['SecondHeight']) ?? 0;
          // Source parity: INI::parsePercentToReal stores percent as 0..1 fraction.
          // The browser INI parser already divides percent-suffixed values by 100.
          firstPercentIndent = readNumericField(block.fields, ['FirstPercentIndent']) ?? 0;
          secondPercentIndent = readNumericField(block.fields, ['SecondPercentIndent']) ?? 0;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of projectileDef.blocks) {
      visitBlock(block);
    }

    if (!found) {
      return null;
    }
    return { firstHeight, secondHeight, firstPercentIndent, secondPercentIndent };
  }

  /**
   * Source parity: MissileAIUpdateModuleData — extract homing missile config
   * from the projectile object template's MissileAIUpdate behavior.
   * C++ file: MissileAIUpdate.cpp.
   */
  private extractMissileAIProfile(projectileObjectName: string): MissileAIProfile | null {
    const normalizedTemplateName = projectileObjectName.trim().toUpperCase();
    const cached = this.missileAIProfileByProjectileTemplate.get(normalizedTemplateName);
    if (cached !== undefined) {
      return cached;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      this.missileAIProfileByProjectileTemplate.set(normalizedTemplateName, null);
      return null;
    }
    const projectileDef = findObjectDefByName(registry, projectileObjectName);
    if (!projectileDef) {
      this.missileAIProfileByProjectileTemplate.set(normalizedTemplateName, null);
      return null;
    }

    let profile: MissileAIProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'MISSILEAIUPDATE') {
          const locomotorProfiles = this.resolveLocomotorProfiles(projectileDef, registry);
          const locomotorProfile = locomotorProfiles.get(LOCOMOTORSET_NORMAL)
            ?? locomotorProfiles.values().next().value
            ?? null;
          profile = {
            tryToFollowTarget: readBooleanField(block.fields, ['TryToFollowTarget']) ?? true,
            fuelLifetimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['FuelLifetime']) ?? 0),
            ignitionDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['IgnitionDelay']) ?? 0),
            initialVelocity: readNumericField(block.fields, ['InitialVelocity']) ?? 0,
            distanceToTravelBeforeTurning: readNumericField(block.fields, ['DistanceToTravelBeforeTurning']) ?? 0,
            distanceToTargetBeforeDiving: readNumericField(block.fields, ['DistanceToTargetBeforeDiving']) ?? 0,
            distanceToTargetForLock: readNumericField(block.fields, ['DistanceToTargetForLock']) ?? 75,
            useWeaponSpeed: readBooleanField(block.fields, ['UseWeaponSpeed']) ?? false,
            detonateOnNoFuel: readBooleanField(block.fields, ['DetonateOnNoFuel']) ?? false,
            distanceScatterWhenJammed: readNumericField(block.fields, ['DistanceScatterWhenJammed']) ?? 75,
            detonateCallsKill: readBooleanField(block.fields, ['DetonateCallsKill']) ?? false,
            killSelfDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['KillSelfDelay']) ?? 3),
            turnRatePerFrame: Math.max(0, (locomotorProfile?.turnRate ?? 0) / LOGIC_FRAME_RATE),
          };
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of projectileDef.blocks) {
      visitBlock(block);
    }

    this.missileAIProfileByProjectileTemplate.set(normalizedTemplateName, profile);
    return profile;
  }

  /**
   * Source parity: WeaponTemplate::parseWeaponBonusSet — extract per-weapon RATE_OF_FIRE
   * bonus multipliers for CONTINUOUS_FIRE_MEAN and CONTINUOUS_FIRE_FAST conditions.
   * INI format: `WeaponBonus = CONDITION_NAME FIELD_NAME VALUE%`
   */
  private resolveWeaponContinuousFireBonuses(weaponDef: WeaponDef): {
    continuousFireMeanRateOfFire: number;
    continuousFireFastRateOfFire: number;
  } {
    let meanROF = 1.0;
    let fastROF = 1.0;
    for (const tokens of this.extractIniValueTokens(weaponDef.fields['WeaponBonus'])) {
      if (tokens.length < 3) continue;
      const condition = tokens[0]!.toUpperCase();
      const field = tokens[1]!.toUpperCase();
      const valueStr = tokens[2]!;
      if (field !== 'RATE_OF_FIRE') continue;
      const percentMatch = valueStr.match(/^(\d+(?:\.\d+)?)%?$/);
      if (!percentMatch) continue;
      const multiplier = parseFloat(percentMatch[1]!) / 100;
      if (!Number.isFinite(multiplier) || multiplier <= 0) continue;
      if (condition === 'CONTINUOUS_FIRE_MEAN') {
        meanROF = multiplier;
      } else if (condition === 'CONTINUOUS_FIRE_FAST') {
        fastROF = multiplier;
      }
    }
    return { continuousFireMeanRateOfFire: meanROF, continuousFireFastRateOfFire: fastROF };
  }

  /**
   * Source parity: TurretAI::isWeaponSlotOnTurret — find which turret (if any) controls
   * the given weapon slot.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/AI/TurretAI.cpp:516-518)
   */
  private findTurretForWeaponSlot(entity: MapEntity, slotIndex: number): TurretProfile | null {
    const slotBit = 1 << slotIndex;
    for (const turret of entity.turretProfiles) {
      if ((turret.controlledWeaponSlotsMask & slotBit) !== 0) {
        return turret;
      }
    }
    return null;
  }

  /**
   * Resolve the weapon names present in each slot of the currently active weapon set.
   * Returns a 3-element array (PRIMARY, SECONDARY, TERTIARY) with weapon name or null.
   */
  private resolveActiveWeaponSetSlots(
    entity: MapEntity,
  ): [string | null, string | null, string | null] {
    const selectedSet = this.selectBestSetByConditions(entity.weaponTemplateSets, entity.weaponSetFlagsMask);
    if (!selectedSet) {
      return [null, null, null];
    }
    return [
      selectedSet.weaponNamesBySlot[0] ?? null,
      selectedSet.weaponNamesBySlot[1] ?? null,
      selectedSet.weaponNamesBySlot[2] ?? null,
    ];
  }

  private resolveAttackWeaponProfileForSetSelection(
    weaponTemplateSets: readonly WeaponTemplateSetProfile[],
    weaponSetFlagsMask: number,
    iniDataRegistry: IniDataRegistry,
    forcedWeaponSlot: number | null = null,
  ): AttackWeaponProfile | null {
    const selectedSet = this.selectBestSetByConditions(weaponTemplateSets, weaponSetFlagsMask);
    if (!selectedSet) {
      return null;
    }

    const normalizedForcedWeaponSlot = this.normalizeWeaponSlot(forcedWeaponSlot);
    if (normalizedForcedWeaponSlot !== null) {
      const weaponName = selectedSet.weaponNamesBySlot[normalizedForcedWeaponSlot];
      if (weaponName) {
        const forcedWeapon = findWeaponDefByName(iniDataRegistry, weaponName);
        if (forcedWeapon) {
          const profile = this.resolveWeaponProfileFromDef(forcedWeapon);
          if (profile) {
            return profile;
          }
        }
      }
    }

    for (const weaponName of selectedSet.weaponNamesBySlot) {
      if (!weaponName) {
        continue;
      }
      const weapon = findWeaponDefByName(iniDataRegistry, weaponName);
      if (!weapon) {
        continue;
      }
      const profile = this.resolveWeaponProfileFromDef(weapon);
      if (profile) {
        return profile;
      }
    }

    return null;
  }

  private resolveLargestWeaponRangeForSetSelection(
    weaponTemplateSets: readonly WeaponTemplateSetProfile[],
    weaponSetFlagsMask: number,
    iniDataRegistry: IniDataRegistry,
    forcedWeaponSlot: number | null = null,
  ): number {
    const selectedSet = this.selectBestSetByConditions(weaponTemplateSets, weaponSetFlagsMask);
    if (!selectedSet) {
      return NO_ATTACK_DISTANCE;
    }

    const normalizedForcedWeaponSlot = this.normalizeWeaponSlot(forcedWeaponSlot);
    if (normalizedForcedWeaponSlot !== null) {
      const weaponName = selectedSet.weaponNamesBySlot[normalizedForcedWeaponSlot];
      if (weaponName) {
        const weapon = findWeaponDefByName(iniDataRegistry, weaponName);
        if (weapon) {
          const weaponProfile = this.resolveWeaponProfileFromDef(weapon);
          if (weaponProfile) {
            return weaponProfile.attackRange;
          }
        }
      }
    }

    let largestWeaponRange = NO_ATTACK_DISTANCE;
    for (const weaponName of selectedSet.weaponNamesBySlot) {
      if (!weaponName) {
        continue;
      }
      const weapon = findWeaponDefByName(iniDataRegistry, weaponName);
      if (!weapon) {
        continue;
      }
      const weaponProfile = this.resolveWeaponProfileFromDef(weapon);
      if (!weaponProfile) {
        continue;
      }
      if (weaponProfile.attackRange > largestWeaponRange) {
        largestWeaponRange = weaponProfile.attackRange;
      }
    }

    return largestWeaponRange;
  }

  /**
   * Source parity: WeaponSet::m_totalAntiMask — bitwise OR of all weapon antiMasks in the
   * selected weapon set. Used for fast rejection in getAbleToAttackSpecificObject.
   */
  private resolveTotalWeaponAntiMaskForSetSelection(
    weaponTemplateSets: readonly WeaponTemplateSetProfile[],
    weaponSetFlagsMask: number,
    iniDataRegistry: IniDataRegistry,
    forcedWeaponSlot: number | null = null,
  ): number {
    const selectedSet = this.selectBestSetByConditions(weaponTemplateSets, weaponSetFlagsMask);
    if (!selectedSet) {
      return 0;
    }

    const normalizedForcedWeaponSlot = this.normalizeWeaponSlot(forcedWeaponSlot);
    if (normalizedForcedWeaponSlot !== null) {
      const weaponName = selectedSet.weaponNamesBySlot[normalizedForcedWeaponSlot];
      if (weaponName) {
        const weapon = findWeaponDefByName(iniDataRegistry, weaponName);
        if (weapon) {
          const profile = this.resolveWeaponProfileFromDef(weapon);
          if (profile) {
            return profile.antiMask;
          }
        }
      }
      return 0;
    }

    let totalAntiMask = 0;
    for (const weaponName of selectedSet.weaponNamesBySlot) {
      if (!weaponName) {
        continue;
      }
      const weapon = findWeaponDefByName(iniDataRegistry, weaponName);
      if (!weapon) {
        continue;
      }
      const profile = this.resolveWeaponProfileFromDef(weapon);
      if (profile) {
        totalAntiMask |= profile.antiMask;
      }
    }

    return totalAntiMask;
  }

  private resolveArmorDamageCoefficientsForSetSelection(
    armorTemplateSets: readonly ArmorTemplateSetProfile[],
    armorSetFlagsMask: number,
    iniDataRegistry: IniDataRegistry,
  ): Map<string, number> | null {
    const selectedSet = this.selectBestSetByConditions(armorTemplateSets, armorSetFlagsMask);
    if (!selectedSet || !selectedSet.armorName) {
      return null;
    }

    const armorDef = findArmorDefByName(iniDataRegistry, selectedSet.armorName);
    if (!armorDef) {
      return null;
    }

    return this.resolveArmorDamageCoefficientsFromDef(armorDef);
  }

  private resolveArmorDamageCoefficientsFromDef(armorDef: ArmorDef): Map<string, number> {
    let defaultCoefficient = 1;
    for (const [fieldName, fieldValue] of Object.entries(armorDef.fields)) {
      if (fieldName.trim().toUpperCase() !== 'DEFAULT') {
        continue;
      }
      const parsedDefault = this.parseNumericIniValue(fieldValue);
      if (parsedDefault !== null) {
        defaultCoefficient = Math.max(0, parsedDefault);
      }
      break;
    }

    const coefficients = new Map<string, number>();
    for (const damageType of SOURCE_DAMAGE_TYPE_NAMES) {
      coefficients.set(damageType, defaultCoefficient);
    }

    for (const [fieldName, fieldValue] of Object.entries(armorDef.fields)) {
      const normalizedFieldName = fieldName.trim().toUpperCase();
      if (normalizedFieldName === 'DEFAULT' || !SOURCE_DAMAGE_TYPE_NAME_SET.has(normalizedFieldName)) {
        continue;
      }
      const coefficient = this.parseNumericIniValue(fieldValue);
      if (coefficient === null) {
        continue;
      }
      coefficients.set(normalizedFieldName, Math.max(0, coefficient));
    }

    return coefficients;
  }

  private parseNumericIniValue(value: IniValue | undefined): number | null {
    if (typeof value === 'number' && Number.isFinite(value)) {
      return value;
    }

    if (typeof value === 'string') {
      const token = value.trim();
      if (token.endsWith('%')) {
        const parsedPercent = Number(token.slice(0, -1));
        if (Number.isFinite(parsedPercent)) {
          return parsedPercent / 100;
        }
      }
      const parsed = Number(token);
      return Number.isFinite(parsed) ? parsed : null;
    }

    if (Array.isArray(value)) {
      for (const entry of value) {
        const parsed = this.parseNumericIniValue(entry as IniValue);
        if (parsed !== null) {
          return parsed;
        }
      }
    }

    return null;
  }

  private resolveAttackWeaponProfile(
    objectDef: ObjectDef | undefined,
    iniDataRegistry: IniDataRegistry,
  ): AttackWeaponProfile | null {
    if (!objectDef) {
      return null;
    }
    return this.resolveAttackWeaponProfileForSetSelection(
      this.extractWeaponTemplateSets(objectDef),
      0,
      iniDataRegistry,
    );
  }

  private resolveBodyStats(objectDef: ObjectDef | undefined): {
    maxHealth: number;
    initialHealth: number;
    bodyType: BodyModuleType;
    secondLifeMaxHealth: number;
    subdualDamageCap: number;
    subdualDamageHealRate: number;
    subdualDamageHealAmount: number;
  } {
    if (!objectDef) {
      return { maxHealth: 0, initialHealth: 0, bodyType: 'ACTIVE', secondLifeMaxHealth: 0,
        subdualDamageCap: 0, subdualDamageHealRate: 0, subdualDamageHealAmount: 0 };
    }

    let maxHealth: number | null = null;
    let initialHealth: number | null = null;
    let bodyType: BodyModuleType = 'ACTIVE';
    let secondLifeMaxHealth = 0;
    let subdualDamageCap = 0;
    let subdualDamageHealRate = 0;
    let subdualDamageHealAmount = 0;

    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BODY') {
        const blockMaxHealth = readNumericField(block.fields, ['MaxHealth']);
        const blockInitialHealth = readNumericField(block.fields, ['InitialHealth']);
        if (blockMaxHealth !== null) {
          maxHealth = blockMaxHealth;
        }
        if (blockInitialHealth !== null) {
          initialHealth = blockInitialHealth;
        }
        // Source parity: ActiveBody subdual damage fields (ActiveBody.cpp:152-154).
        const cap = readNumericField(block.fields, ['SubdualDamageCap']);
        if (cap !== null && Number.isFinite(cap) && cap > 0) {
          subdualDamageCap = cap;
        }
        const healRate = readNumericField(block.fields, ['SubdualDamageHealRate']);
        if (healRate !== null && Number.isFinite(healRate) && healRate > 0) {
          // C++ uses parseDurationUnsignedInt → milliseconds → frames.
          subdualDamageHealRate = Math.max(1, Math.round(healRate / (1000 / LOGIC_FRAME_RATE)));
        }
        const healAmount = readNumericField(block.fields, ['SubdualDamageHealAmount']);
        if (healAmount !== null && Number.isFinite(healAmount) && healAmount > 0) {
          subdualDamageHealAmount = healAmount;
        }
        // Source parity: detect body module type from block name.
        const moduleName = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleName === 'HIGHLANDERBODY') {
          bodyType = 'HIGHLANDER';
        } else if (moduleName === 'IMMORTALBODY') {
          bodyType = 'IMMORTAL';
        } else if (moduleName === 'INACTIVEBODY') {
          bodyType = 'INACTIVE';
        } else if (moduleName === 'STRUCTUREBODY') {
          bodyType = 'STRUCTURE';
        } else if (moduleName === 'HIVESTRUCTUREBODY') {
          bodyType = 'HIVE_STRUCTURE';
        } else if (moduleName === 'UNDEADBODY') {
          bodyType = 'UNDEAD';
          // Source parity: UndeadBody.cpp — SecondLifeMaxHealth defaults to 1.
          const slmh = readNumericField(block.fields, ['SecondLifeMaxHealth']);
          secondLifeMaxHealth = (slmh !== null && Number.isFinite(slmh) && slmh > 0) ? slmh : 1;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    const resolvedMax = maxHealth !== null && Number.isFinite(maxHealth) && maxHealth > 0
      ? maxHealth
      : 0;
    const resolvedInitial = initialHealth !== null && Number.isFinite(initialHealth)
      ? clamp(initialHealth, 0, resolvedMax > 0 ? resolvedMax : Math.max(initialHealth, 0))
      : resolvedMax;

    return {
      maxHealth: resolvedMax,
      initialHealth: resolvedInitial,
      bodyType,
      secondLifeMaxHealth,
      subdualDamageCap,
      subdualDamageHealRate,
      subdualDamageHealAmount,
    };
  }

  /**
   * Source parity: HiveStructureBody — extract damage redirection config from INI.
   * Parses PropagateDamageTypesToSlavesWhenExisting and SwallowDamageTypesIfSlavesNotExisting.
   */
  private extractHiveStructureProfile(
    objectDef: ObjectDef | undefined,
    bodyType: BodyModuleType,
  ): HiveStructureBodyProfile | null {
    if (!objectDef || bodyType !== 'HIVE_STRUCTURE') return null;

    const propagateTypes = new Set<string>();
    const swallowTypes = new Set<string>();

    for (const block of objectDef.blocks) {
      if (block.type.toUpperCase() !== 'BODY') continue;
      const moduleName = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleName !== 'HIVESTRUCTUREBODY') continue;

      const propagateRaw = readStringField(block.fields, ['PropagateDamageTypesToSlavesWhenExisting']);
      if (propagateRaw) {
        for (const token of propagateRaw.trim().split(/\s+/)) {
          if (token) propagateTypes.add(token.toUpperCase());
        }
      }
      const swallowRaw = readStringField(block.fields, ['SwallowDamageTypesIfSlavesNotExisting']);
      if (swallowRaw) {
        for (const token of swallowRaw.trim().split(/\s+/)) {
          if (token) swallowTypes.add(token.toUpperCase());
        }
      }
      break;
    }

    return { propagateDamageTypes: propagateTypes, swallowDamageTypes: swallowTypes };
  }

  private parseUpgradeNames(value: IniValue | undefined): string[] {
    if (value === undefined) {
      return [];
    }

    return this.extractIniValueTokens(value)
      .flatMap((tokens) => tokens)
      .map((token) => token.trim().toUpperCase())
      .filter((token) => token.length > 0 && token !== 'NONE');
  }

  private parseKindOf(value: IniValue | undefined): string[] {
    if (value === undefined) {
      return [];
    }

    return this.extractIniValueTokens(value)
      .flatMap((tokens) => tokens)
      .map((token) => token.trim().toUpperCase())
      .filter((token) => token.length > 0 && token !== 'NONE');
  }

  private parsePercent(value: IniValue | undefined): number | null {
    if (value === undefined) {
      return null;
    }

    const tokens = this.extractIniValueTokens(value).flatMap((entry) => entry);
    for (const token of tokens) {
      const trimmed = token.trim();
      if (!trimmed || trimmed.toUpperCase() === 'NONE') {
        continue;
      }

      const numericText = trimmed.endsWith('%') ? trimmed.slice(0, -1) : trimmed;
      const parsed = Number(numericText);
      if (Number.isFinite(parsed)) {
        return parsed / 100;
      }
    }

    return null;
  }

  private parseObjectStatusNames(value: IniValue | undefined): string[] {
    if (value === undefined) {
      return [];
    }

    return this.extractIniValueTokens(value)
      .flatMap((tokens) => tokens)
      .map((token) => this.normalizeObjectStatusName(token))
      .filter((token) => token !== null);
  }

  private normalizeObjectStatusName(statusName: string): string | null {
    const normalized = statusName.trim().toUpperCase();
    if (!normalized || normalized === 'NONE') {
      return null;
    }
    if (normalized.startsWith('OBJECT_STATUS_')) {
      const withoutPrefix = normalized.slice('OBJECT_STATUS_'.length);
      return withoutPrefix.length > 0 ? withoutPrefix : null;
    }
    return normalized;
  }

  private extractProductionProfile(objectDef: ObjectDef | undefined): ProductionProfile | null {
    if (!objectDef) {
      return null;
    }

    let foundModule = false;
    let maxQueueEntries = 9;
    const quantityModifiers: Array<{ templateName: string; quantity: number }> = [];

    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'PRODUCTIONUPDATE') {
          foundModule = true;

          const configuredMaxQueueEntries = readNumericField(block.fields, ['MaxQueueEntries']);
          if (configuredMaxQueueEntries !== null && Number.isFinite(configuredMaxQueueEntries)) {
            maxQueueEntries = Math.max(0, Math.trunc(configuredMaxQueueEntries));
          }

          for (const tokens of this.extractIniValueTokens(block.fields['QuantityModifier'])) {
            const templateName = tokens[0]?.trim();
            if (!templateName || templateName.toUpperCase() === 'NONE') {
              continue;
            }
            const quantityRaw = tokens[1] !== undefined ? Number(tokens[1]) : 1;
            const quantity = Number.isFinite(quantityRaw) ? Math.max(1, Math.trunc(quantityRaw)) : 1;
            quantityModifiers.push({
              templateName: templateName.toUpperCase(),
              quantity,
            });
          }
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (!foundModule) {
      return null;
    }

    return {
      maxQueueEntries,
      quantityModifiers,
    };
  }

  private extractQueueProductionExitProfile(objectDef: ObjectDef | undefined): QueueProductionExitProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: QueueProductionExitProfile | null = null;

    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'QUEUEPRODUCTIONEXITUPDATE') {
          const unitCreatePoint = readCoord3DField(block.fields, ['UnitCreatePoint']) ?? { x: 0, y: 0, z: 0 };
          const naturalRallyPoint = readCoord3DField(block.fields, ['NaturalRallyPoint']);
          const exitDelayMs = readNumericField(block.fields, ['ExitDelay']) ?? 0;
          const initialBurstRaw = readNumericField(block.fields, ['InitialBurst']) ?? 0;
          profile = {
            moduleType: 'QUEUE',
            unitCreatePoint,
            naturalRallyPoint,
            exitDelayFrames: this.msToLogicFrames(exitDelayMs),
            allowAirborneCreation: readBooleanField(block.fields, ['AllowAirborneCreation']) === true,
            initialBurst: Math.max(0, Math.trunc(initialBurstRaw)),
            spawnPointBoneName: null,
          };
        } else if (moduleType === 'SUPPLYCENTERPRODUCTIONEXITUPDATE') {
          const unitCreatePoint = readCoord3DField(block.fields, ['UnitCreatePoint']) ?? { x: 0, y: 0, z: 0 };
          const naturalRallyPoint = readCoord3DField(block.fields, ['NaturalRallyPoint']);
          profile = {
            moduleType: 'SUPPLY_CENTER',
            unitCreatePoint,
            naturalRallyPoint,
            exitDelayFrames: 0,
            allowAirborneCreation: false,
            initialBurst: 0,
            spawnPointBoneName: null,
          };
        } else if (moduleType === 'SPAWNPOINTPRODUCTIONEXITUPDATE') {
          // Source parity: SpawnPointProductionExitUpdate.cpp drives exits from named bone positions.
          // This browser port currently lacks bone-space exit placement, so we deterministically
          // use producer-local origin and emit no rally/airborne overrides.
          const spawnPointBoneName = readStringField(block.fields, ['SpawnPointBoneName']);
          profile = {
            moduleType: 'SPAWN_POINT',
            unitCreatePoint: { x: 0, y: 0, z: 0 },
            naturalRallyPoint: null,
            exitDelayFrames: 0,
            allowAirborneCreation: false,
            initialBurst: 0,
            spawnPointBoneName: spawnPointBoneName ?? null,
          };
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  private extractParkingPlaceProfile(objectDef: ObjectDef | undefined): ParkingPlaceProfile | null {
    if (!objectDef) {
      return null;
    }

    let foundModule = false;
    let numRows = 0;
    let numCols = 0;

    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() !== 'BEHAVIOR') {
        for (const child of block.blocks) {
          visitBlock(child);
        }
        return;
      }

      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType === 'PARKINGPLACEBEHAVIOR') {
        foundModule = true;
        const rowsRaw = readNumericField(block.fields, ['NumRows']);
        const colsRaw = readNumericField(block.fields, ['NumCols']);
        if (rowsRaw !== null && Number.isFinite(rowsRaw)) {
          numRows = Math.max(0, Math.trunc(rowsRaw));
        }
        if (colsRaw !== null && Number.isFinite(colsRaw)) {
          numCols = Math.max(0, Math.trunc(colsRaw));
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (!foundModule) {
      return null;
    }

    return {
      totalSpaces: numRows * numCols,
      occupiedSpaceEntityIds: new Set<number>(),
      reservedProductionIds: new Set<number>(),
    };
  }

  private extractContainProfile(objectDef: ObjectDef | undefined): ContainProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: ContainProfile | null = null;

    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() !== 'BEHAVIOR') {
        for (const child of block.blocks) {
          visitBlock(child);
        }
        return;
      }

      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      const passengersAllowedRaw = readBooleanField(block.fields, ['PassengersAllowedToFire']);
      const passengersAllowedToFire = passengersAllowedRaw === true;
      const containMax = readNumericField(block.fields, ['ContainMax']) ?? 0;
      const payloadTemplateNames = readStringList(block.fields, ['PayloadTemplateName']).map((templateName) =>
        templateName.toUpperCase(),
      );
      // Source parity: OpenContainModuleData — parsePercentToReal (INI percentage → 0-1 fraction).
      const damagePercentRaw = readNumericField(block.fields, ['DamagePercentToUnits']);
      const damagePercentToUnits = damagePercentRaw != null ? damagePercentRaw / 100 : 0;
      // Source parity: OpenContainModuleData::m_isBurnedDeathToUnits — default TRUE.
      const burnedDeathRaw = readBooleanField(block.fields, ['BurnedDeathToUnits']);
      const burnedDeathToUnits = burnedDeathRaw !== false;

      if (moduleType === 'OPENCONTAIN') {
        profile = {
          moduleType: 'OPEN',
          passengersAllowedToFire,
          passengersAllowedToFireDefault: passengersAllowedToFire,
          garrisonCapacity: 0,
          transportCapacity: containMax,
          timeForFullHealFrames: 0,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'TRANSPORTCONTAIN') {
        profile = {
          moduleType: 'TRANSPORT',
          passengersAllowedToFire,
          passengersAllowedToFireDefault: passengersAllowedToFire,
          garrisonCapacity: 0,
          transportCapacity: containMax,
          timeForFullHealFrames: 0,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'OVERLORDCONTAIN') {
        profile = {
          moduleType: 'OVERLORD',
          passengersAllowedToFire,
          passengersAllowedToFireDefault: passengersAllowedToFire,
          garrisonCapacity: 0,
          transportCapacity: containMax,
          timeForFullHealFrames: 0,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'HELIXCONTAIN') {
        // HELIXCONTAIN is a Zero Hour-specific container module name used by data INIs;
        // we map it to a dedicated internal container profile to preserve source behavior.
        profile = {
          moduleType: 'HELIX',
          passengersAllowedToFire,
          passengersAllowedToFireDefault: passengersAllowedToFire,
          portableStructureTemplateNames: payloadTemplateNames,
          garrisonCapacity: 0,
          transportCapacity: containMax,
          timeForFullHealFrames: 0,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'GARRISONCONTAIN') {
        // GarrisonContain is OpenContain-derived in source but always returns TRUE from
        // isPassengerAllowedToFire(), so we track it explicitly for behavior parity.
        profile = {
          moduleType: 'GARRISON',
          passengersAllowedToFire: true,
          passengersAllowedToFireDefault: true,
          garrisonCapacity: containMax > 0 ? containMax : 10,
          transportCapacity: 0,
          timeForFullHealFrames: 0,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'TUNNELCONTAIN') {
        // Source parity: TunnelContain — per-player shared tunnel network.
        // Capacity is managed by TunnelTracker (global maxTunnelCapacity), not per-building.
        const timeForFullHealMs = readNumericField(block.fields, ['TimeForFullHeal']) ?? 0;
        profile = {
          moduleType: 'TUNNEL',
          passengersAllowedToFire: false,
          passengersAllowedToFireDefault: false,
          garrisonCapacity: 0,
          transportCapacity: 0,
          timeForFullHealFrames: timeForFullHealMs > 0 ? this.msToLogicFrames(timeForFullHealMs) : 1,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'HEALCONTAIN') {
        // Source parity: HealContain — passengers healed inside, auto-ejected when full health.
        // C++ file: HealContain.cpp — extends OpenContain, single param TimeForFullHeal.
        const timeForFullHealMs = readNumericField(block.fields, ['TimeForFullHeal']) ?? 0;
        profile = {
          moduleType: 'HEAL',
          passengersAllowedToFire: false,
          passengersAllowedToFireDefault: false,
          garrisonCapacity: 0,
          transportCapacity: containMax,
          timeForFullHealFrames: timeForFullHealMs > 0 ? this.msToLogicFrames(timeForFullHealMs) : 1,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      } else if (moduleType === 'INTERNETHACKCONTAIN') {
        // Source parity: InternetHackContain — extends TransportContain, auto-issues
        // hackInternet command to entering units. C++ file: InternetHackContain.cpp.
        profile = {
          moduleType: 'INTERNET_HACK',
          passengersAllowedToFire: false,
          passengersAllowedToFireDefault: false,
          garrisonCapacity: 0,
          transportCapacity: containMax,
          timeForFullHealFrames: 0,
          damagePercentToUnits,
          burnedDeathToUnits,
        };
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  private extractJetAIProfile(objectDef: ObjectDef | undefined): JetAIProfile | null {
    if (!objectDef) {
      return null;
    }

    let foundModule = false;
    let sneakyOffsetWhenAttacking = 0;
    let attackersMissPersistFrames = 0;
    let needsRunway = true;
    let keepsParkingSpaceWhenAirborne = true;
    let outOfAmmoDamagePerSecond = 0;
    let returnToBaseIdleFrames = 0;
    let minHeight = 0;
    let parkingOffset = 0;
    let takeoffPauseFrames = 0;
    let takeoffDistForMaxLift = 0;
    let attackLocomotorSet = '';
    let attackLocoPersistFrames = 0;
    let returnLocomotorSet = '';

    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'JETAIUPDATE') {
          foundModule = true;
          const sneakyOffsetRaw = readNumericField(block.fields, ['SneakyOffsetWhenAttacking']) ?? 0;
          if (Number.isFinite(sneakyOffsetRaw)) {
            sneakyOffsetWhenAttacking = sneakyOffsetRaw;
          }
          const persistMsRaw = readNumericField(block.fields, ['AttackersMissPersistTime']) ?? 0;
          attackersMissPersistFrames = this.msToLogicFrames(persistMsRaw);
          needsRunway = readBooleanField(block.fields, ['NeedsRunway']) ?? true;
          keepsParkingSpaceWhenAirborne = readBooleanField(block.fields, ['KeepsParkingSpaceWhenAirborne']) ?? true;
          const outOfAmmoDmgRaw = readNumericField(block.fields, ['OutOfAmmoDamagePerSecond']) ?? 0;
          outOfAmmoDamagePerSecond = outOfAmmoDmgRaw / 100;
          const returnIdleMsRaw = readNumericField(block.fields, ['ReturnToBaseIdleTime']) ?? 0;
          returnToBaseIdleFrames = this.msToLogicFrames(returnIdleMsRaw);
          minHeight = readNumericField(block.fields, ['MinHeight']) ?? 0;
          parkingOffset = readNumericField(block.fields, ['ParkingOffset']) ?? 0;
          const takeoffPauseMsRaw = readNumericField(block.fields, ['TakeoffPause']) ?? 0;
          takeoffPauseFrames = this.msToLogicFrames(takeoffPauseMsRaw);
          takeoffDistForMaxLift = readNumericField(block.fields, ['TakeoffDistForMaxLift']) ?? 0;
          attackLocomotorSet = readStringField(block.fields, ['AttackLocomotorType'])?.trim().toUpperCase() ?? '';
          const attackLocoPersistMsRaw = readNumericField(block.fields, ['AttackLocomotorPersistTime']) ?? 0;
          attackLocoPersistFrames = this.msToLogicFrames(attackLocoPersistMsRaw);
          returnLocomotorSet = readStringField(block.fields, ['ReturnForAmmoLocomotorType'])?.trim().toUpperCase() ?? '';
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (!foundModule) {
      return null;
    }

    return {
      sneakyOffsetWhenAttacking,
      attackersMissPersistFrames,
      needsRunway,
      keepsParkingSpaceWhenAirborne,
      outOfAmmoDamagePerSecond,
      returnToBaseIdleFrames,
      minHeight,
      parkingOffset,
      takeoffPauseFrames,
      takeoffDistForMaxLift,
      attackLocomotorSet,
      attackLocoPersistFrames,
      returnLocomotorSet,
    };
  }

  /**
   * Source parity: AnimationSteeringUpdateModuleData::m_transitionFrames.
   * C++ parse field: MinTransitionTime (duration).
   */
  private extractAnimationSteeringProfile(objectDef: ObjectDef | undefined): AnimationSteeringProfile | null {
    if (!objectDef) {
      return null;
    }

    let transitionFrames: number | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (transitionFrames !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'ANIMATIONSTEERINGUPDATE') {
          const transitionMs = readNumericField(block.fields, ['MinTransitionTime']) ?? 0;
          transitionFrames = this.msToLogicFrames(transitionMs);
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (transitionFrames === null) {
      return null;
    }

    return {
      transitionFrames,
    };
  }

  /**
   * Source parity: TensileFormationUpdateModuleData.
   * C++ parse fields: Enabled, CrackSound.
   */
  private extractTensileFormationProfile(objectDef: ObjectDef | undefined): TensileFormationProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: TensileFormationProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) {
        return;
      }

      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'TENSILEFORMATIONUPDATE') {
          profile = {
            enabled: readBooleanField(block.fields, ['Enabled']) === true,
            crackSound: readStringField(block.fields, ['CrackSound'])?.trim() ?? '',
          };
          return;
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Source parity: AssaultTransportAIUpdate — extract assault transport profile from INI.
   * C++ file: AssaultTransportAIUpdate.h (buildFieldParse).
   */
  private extractAssaultTransportProfile(objectDef: ObjectDef | undefined): AssaultTransportProfile | null {
    if (!objectDef) return null;
    let profile: AssaultTransportProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'ASSAULTTRANSPORTAIUPDATE') {
          const ratio = readNumericField(block.fields, ['MembersGetHealedAtLifeRatio']) ?? 0;
          profile = { membersGetHealedAtLifeRatio: Math.max(0, Math.min(1, ratio)) };
        }
      }
      for (const child of block.blocks) visitBlock(child);
    };
    for (const block of objectDef.blocks) visitBlock(block);
    return profile;
  }

  /**
   * Source parity: TurretAI — extract turret module profiles from INI.
   * Each TurretAIUpdate module declares which weapon slots it controls and whether it
   * starts disabled. Units like Nuke Cannons have InitiallyDisabled turrets that must
   * be enabled by a deploy action before the weapon can fire.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/AI/TurretAI.cpp:236-261)
   */
  private extractTurretProfiles(objectDef: ObjectDef | undefined): TurretProfile[] {
    if (!objectDef) {
      return [];
    }

    const profiles: TurretProfile[] = [];
    const WEAPON_SLOT_NAMES: Record<string, number> = {
      PRIMARY: 0,
      SECONDARY: 1,
      TERTIARY: 2,
    };

    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'TURRETAIUPDATE') {
          const initiallyDisabled = readBooleanField(block.fields, ['InitiallyDisabled']) === true;

          // Source parity: TurretAIData::m_turretWeaponSlots is a bitmask built from
          // ControlledWeaponSlots INI field (space-separated slot names).
          let controlledWeaponSlotsMask = 0;
          const controlledSlotsRaw = readStringField(block.fields, ['ControlledWeaponSlots']);
          if (controlledSlotsRaw) {
            for (const slotToken of controlledSlotsRaw.split(/\s+/)) {
              const slotIndex = WEAPON_SLOT_NAMES[slotToken.toUpperCase()];
              if (slotIndex !== undefined) {
                controlledWeaponSlotsMask |= (1 << slotIndex);
              }
            }
          }

          // Source parity: TurretTurnRate is parsed as AngularVelocity (degrees/sec in INI).
          // C++ parseAngularVelocityReal converts to rad/frame: value * (PI/180) / LOGICFRAMES_PER_SECOND.
          const turnRateDegPerSec = readNumericField(block.fields, ['TurretTurnRate']) ?? 0;
          const turnRate = turnRateDegPerSec > 0
            ? turnRateDegPerSec * (Math.PI / 180) / LOGIC_FRAME_RATE
            : 0;

          // Source parity: NaturalTurretAngle is an angle (degrees in INI → radians).
          const naturalAngleDeg = readNumericField(block.fields, ['NaturalTurretAngle']) ?? 0;
          const naturalAngle = naturalAngleDeg * (Math.PI / 180);

          const firesWhileTurning = readBooleanField(block.fields, ['FiresWhileTurning']) === true;

          // Source parity: RecenterTime defaults to 2 * LOGICFRAMES_PER_SECOND (60 frames).
          // INI value is in milliseconds.
          const recenterTimeMs = readNumericField(block.fields, ['RecenterTime']) ?? 0;
          const recenterTimeFrames = recenterTimeMs > 0
            ? Math.round(recenterTimeMs / 1000 * LOGIC_FRAME_RATE)
            : 2 * LOGIC_FRAME_RATE;

          if (controlledWeaponSlotsMask !== 0) {
            profiles.push({
              controlledWeaponSlotsMask,
              initiallyDisabled,
              enabled: !initiallyDisabled,
              turnRate,
              naturalAngle,
              firesWhileTurning,
              recenterTimeFrames,
            });
          }
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profiles;
  }

  /**
   * Source parity: SupplyWarehouseDockUpdate.h — starting boxes + deleteWhenEmpty flag.
   */
  /**
   * Source parity: SpawnBehavior — parse spawn behavior module from INI and create
   * initial runtime state. Returns null if the object has no SpawnBehavior module.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Behavior/SpawnBehavior.cpp)
   */
  private extractSpawnBehaviorState(objectDef: ObjectDef | undefined): SpawnBehaviorState | null {
    if (!objectDef) {
      return null;
    }

    let profile: SpawnBehaviorProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SPAWNBEHAVIOR') {
          const spawnNumber = Math.max(0, Math.trunc(readNumericField(block.fields, ['SpawnNumber']) ?? 0));
          const spawnReplaceDelayMs = readNumericField(block.fields, ['SpawnReplaceDelay']) ?? 0;
          const spawnReplaceDelayFrames = this.msToLogicFrames(spawnReplaceDelayMs);
          const templateNames: string[] = [];
          const templateNameRaw = readStringField(block.fields, ['SpawnTemplateName']);
          if (templateNameRaw) {
            // SpawnTemplateName is parsed with INI_PARSE_APPEND in C++, meaning
            // multiple entries accumulate. Our INI parser stores the last value,
            // so we split on whitespace to handle potential multi-token values.
            for (const token of templateNameRaw.split(/\s+/)) {
              if (token) {
                templateNames.push(token.toUpperCase());
              }
            }
          }
          const oneShot = readBooleanField(block.fields, ['OneShot']) === true;
          const spawnedRequireSpawner = readBooleanField(block.fields, ['SpawnedRequireSpawner']) === true;
          const aggregateHealth = readBooleanField(block.fields, ['AggregateHealth']) === true;
          // Source parity: C++ defaults m_initialBurst to 0 when absent from INI.
          const initialBurst = Math.max(0, Math.trunc(readNumericField(block.fields, ['InitialBurst']) ?? 0));

          const slavesHaveFreeWill = readBooleanField(block.fields, ['SlavesHaveFreeWill']) === true;

          if (spawnNumber > 0 && templateNames.length > 0) {
            profile = {
              spawnNumber,
              spawnReplaceDelayFrames,
              spawnTemplateNames: templateNames,
              oneShot,
              spawnedRequireSpawner,
              aggregateHealth,
              initialBurst,
              slavesHaveFreeWill,
            };
          }
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    if (!profile) {
      return null;
    }

    return {
      profile,
      slaveIds: [],
      replacementFrames: [],
      templateNameIndex: 0,
      oneShotCompleted: false,
      initialBurstApplied: false,
    };
  }

  private extractSupplyWarehouseProfile(objectDef: ObjectDef | undefined): SupplyWarehouseProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: SupplyWarehouseProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SUPPLYWAREHOUSEDOCKUPDATE') {
          profile = {
            startingBoxes: Math.max(0, Math.trunc(readNumericField(block.fields, ['StartingBoxes']) ?? 1)),
            deleteWhenEmpty: readBooleanField(block.fields, ['DeleteWhenEmpty']) === true,
          };
          return;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Source parity: SupplyTruckAIUpdate.h — max boxes, action delays, scan distance.
   */
  private extractSupplyTruckProfile(objectDef: ObjectDef | undefined): SupplyTruckProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: SupplyTruckProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SUPPLYTRUCKAIUPDATE' || moduleType === 'WORKERAIUPDATE' || moduleType === 'CHINOOKAIUPDATE') {
          const maxBoxes = Math.max(1, Math.trunc(readNumericField(block.fields, ['MaxBoxes']) ?? 3));
          const supplyCenterActionDelayMs = readNumericField(block.fields, ['SupplyCenterActionDelay']) ?? 0;
          const supplyWarehouseActionDelayMs = readNumericField(block.fields, ['SupplyWarehouseActionDelay']) ?? 0;
          const scanDistance = readNumericField(block.fields, ['SupplyWarehouseScanDistance']) ?? 200;
          const upgradedSupplyBoost = Math.trunc(readNumericField(block.fields, ['UpgradedSupplyBoost']) ?? 0);
          profile = {
            maxBoxes,
            supplyCenterActionDelayFrames: this.msToLogicFrames(supplyCenterActionDelayMs),
            supplyWarehouseActionDelayFrames: this.msToLogicFrames(supplyWarehouseActionDelayMs),
            supplyWarehouseScanDistance: Math.max(0, scanDistance),
            upgradedSupplyBoost,
          };
          return;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Source parity subset: ChinookAIUpdate module data used by current systems.
   * C++ defaults from ChinookAIUpdateModuleData constructor.
   */
  private extractChinookAIProfile(objectDef: ObjectDef | undefined): ChinookAIProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: ChinookAIProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }

      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'CHINOOKAIUPDATE') {
          const perRopeDelayMinMs = readNumericField(block.fields, ['PerRopeDelayMin']) ?? 0x7fffffff;
          const perRopeDelayMaxMs = readNumericField(block.fields, ['PerRopeDelayMax']) ?? 0x7fffffff;
          profile = {
            numRopes: Math.max(1, Math.trunc(readNumericField(block.fields, ['NumRopes']) ?? 4)),
            perRopeDelayMinFrames: this.msToLogicFrames(perRopeDelayMinMs),
            perRopeDelayMaxFrames: this.msToLogicFrames(perRopeDelayMaxMs),
            minDropHeight: readNumericField(block.fields, ['MinDropHeight']) ?? 30.0,
            waitForRopesToDrop: readBooleanField(block.fields, ['WaitForRopesToDrop']) ?? true,
            rappelSpeed: readNumericField(block.fields, ['RappelSpeed']) ?? DEFAULT_CHINOOK_RAPPEL_SPEED,
            ropeDropSpeed: readNumericField(block.fields, ['RopeDropSpeed']) ?? 1e10,
            ropeFinalHeight: readNumericField(block.fields, ['RopeFinalHeight']) ?? 0.0,
          };
          return;
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Source parity: RepairDockUpdateModuleData::m_framesForFullHeal.
   * INI field: TimeForFullHeal (duration real, milliseconds -> frames).
   */
  private extractRepairDockProfile(objectDef: ObjectDef | undefined): RepairDockProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: RepairDockProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'REPAIRDOCKUPDATE') {
          const timeForFullHealMs = readNumericField(block.fields, ['TimeForFullHeal']) ?? 0;
          // Source parity: INI::parseDurationReal stores fractional frame values.
          const framesForFullHeal = timeForFullHealMs > 0
            ? this.msToLogicFramesReal(timeForFullHealMs)
            : 1;
          profile = {
            timeForFullHealFrames: Math.max(1, framesForFullHeal),
          };
          return;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Source parity: DozerAIUpdateModuleData / WorkerAIUpdateModuleData shared fields.
   * Parses DozerAIUpdate and WorkerAIUpdate modules for repair and bored behavior.
   */
  private extractDozerAIProfile(objectDef: ObjectDef | undefined): DozerAIProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: DozerAIProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DOZERAIUPDATE' || moduleType === 'WORKERAIUPDATE') {
          const repairHealthPercentPerSecond = this.parseNumericIniValue(
            this.readIniFieldValue(block.fields, 'RepairHealthPercentPerSecond'),
          ) ?? 0;
          const boredTimeMs = readNumericField(block.fields, ['BoredTime']) ?? 0;
          const boredRange = readNumericField(block.fields, ['BoredRange']) ?? 0;
          profile = {
            repairHealthPercentPerSecond: Math.max(0, repairHealthPercentPerSecond),
            boredTimeFrames: boredTimeMs > 0 ? this.msToLogicFramesReal(boredTimeMs) : 0,
            boredRange: Math.max(0, boredRange),
          };
          return;
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Detect if an entity definition includes a SupplyCenterDockUpdate behavior module.
   */
  private detectIsSupplyCenter(objectDef: ObjectDef | undefined): boolean {
    if (!objectDef) {
      return false;
    }

    let found = false;
    const visitBlock = (block: IniBlock): void => {
      if (found) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SUPPLYCENTERDOCKUPDATE') {
          found = true;
          return;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return found;
  }

  /**
   * Source parity: ThingTemplate — ExperienceRequired, ExperienceValue fields.
   * These are space-separated 4-element lists: [REGULAR] [VETERAN] [ELITE] [HEROIC].
   */
  private extractExperienceProfile(objectDef: ObjectDef | undefined): ExperienceProfile | null {
    if (!objectDef) {
      return null;
    }

    const expRequiredRaw = readNumericListField(objectDef.fields, ['ExperienceRequired']);
    const expValueRaw = readNumericListField(objectDef.fields, ['ExperienceValue']);

    if (!expRequiredRaw && !expValueRaw) {
      return null;
    }

    const expRequired: [number, number, number, number] = [0, 0, 0, 0];
    const expValue: [number, number, number, number] = [0, 0, 0, 0];

    if (expRequiredRaw) {
      for (let i = 0; i < 4 && i < expRequiredRaw.length; i++) {
        expRequired[i] = Math.max(0, Math.trunc(expRequiredRaw[i] ?? 0));
      }
    }

    if (expValueRaw) {
      for (let i = 0; i < 4 && i < expValueRaw.length; i++) {
        expValue[i] = Math.max(0, Math.trunc(expValueRaw[i] ?? 0));
      }
    }

    return {
      experienceRequired: expRequired,
      experienceValue: expValue,
    };
  }

  /**
   * Source parity: AutoHealBehavior — parse self-heal module from INI.
   */
  private extractAutoHealProfile(objectDef: ObjectDef | undefined): AutoHealProfile | null {
    if (!objectDef) return null;
    let profile: AutoHealProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'AUTOHEALBEHAVIOR') {
          profile = {
            healingAmount: readNumericField(block.fields, ['HealingAmount']) ?? 0,
            healingDelayFrames: readNumericField(block.fields, ['HealingDelay']) ?? 900,
            startHealingDelayFrames: readNumericField(block.fields, ['StartHealingDelay']) ?? 0,
            radius: readNumericField(block.fields, ['Radius']) ?? 0,
            affectsWholePlayer: readBooleanField(block.fields, ['AffectsWholePlayer']) ?? false,
            initiallyActive: readBooleanField(block.fields, ['StartsActive']) ?? false,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: PropagandaTowerBehavior — parse aura heal module from INI.
   */
  private extractPropagandaTowerProfile(objectDef: ObjectDef | undefined): PropagandaTowerProfile | null {
    if (!objectDef) return null;
    let profile: PropagandaTowerProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'PROPAGANDATOWERBEHAVIOR') {
          profile = {
            radius: readNumericField(block.fields, ['Radius']) ?? 100,
            scanDelayFrames: readNumericField(block.fields, ['DelayBetweenUpdates']) ?? 100,
            healPercentPerSecond: readNumericField(block.fields, ['HealPercentEachSecond']) ?? 0.01,
            upgradedHealPercentPerSecond: readNumericField(block.fields, ['UpgradedHealPercentEachSecond']) ?? 0.02,
            upgradeRequired: readStringField(block.fields, ['UpgradeRequired']) ?? null,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: StealthUpdate module — parse stealth behavior from INI.
   */
  private extractStealthProfile(objectDef: ObjectDef | undefined): StealthProfile | null {
    if (!objectDef) return null;
    let profile: StealthProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'STEALTHUPDATE') {
          const innateStealth = readBooleanField(block.fields, ['InnateStealth']) ?? true;
          const stealthDelayMs = readNumericField(block.fields, ['StealthDelay']) ?? 2000;
          const stealthDelayFrames = this.msToLogicFrames(stealthDelayMs);
          const moveThresholdSpeed = readNumericField(block.fields, ['MoveThresholdSpeed']) ?? 0;

          // Parse StealthForbiddenConditions — space-separated tokens.
          let forbiddenConditions = 0;
          const forbiddenStr = readStringField(block.fields, ['StealthForbiddenConditions']) ?? '';
          for (const token of forbiddenStr.split(/\s+/)) {
            switch (token.toUpperCase()) {
              case 'ATTACKING':
              case 'STEALTH_NOT_WHILE_ATTACKING':
                forbiddenConditions |= STEALTH_FORBIDDEN_ATTACKING;
                break;
              case 'MOVING':
              case 'STEALTH_NOT_WHILE_MOVING':
                forbiddenConditions |= STEALTH_FORBIDDEN_MOVING;
                break;
              case 'USING_ABILITY':
              case 'STEALTH_NOT_WHILE_USING_ABILITY':
                forbiddenConditions |= STEALTH_FORBIDDEN_USING_ABILITY;
                break;
              case 'FIRING_PRIMARY':
              case 'STEALTH_NOT_WHILE_FIRING_PRIMARY':
                forbiddenConditions |= STEALTH_FORBIDDEN_FIRING_PRIMARY;
                break;
              case 'FIRING_SECONDARY':
                forbiddenConditions |= STEALTH_FORBIDDEN_FIRING_SECONDARY;
                break;
              case 'FIRING_TERTIARY':
                forbiddenConditions |= STEALTH_FORBIDDEN_FIRING_TERTIARY;
                break;
              case 'FIRING_WEAPON':
              case 'STEALTH_NOT_WHILE_FIRING_WEAPON':
                // Composite: all weapon slots.
                forbiddenConditions |= STEALTH_FORBIDDEN_FIRING_PRIMARY
                  | STEALTH_FORBIDDEN_FIRING_SECONDARY | STEALTH_FORBIDDEN_FIRING_TERTIARY;
                break;
              case 'NO_BLACK_MARKET':
                forbiddenConditions |= STEALTH_FORBIDDEN_NO_BLACK_MARKET;
                break;
              case 'TAKING_DAMAGE':
              case 'STEALTH_NOT_WHILE_TAKING_DAMAGE':
                forbiddenConditions |= STEALTH_FORBIDDEN_TAKING_DAMAGE;
                break;
              case 'RIDERS_ATTACKING':
                forbiddenConditions |= STEALTH_FORBIDDEN_RIDERS_ATTACKING;
                break;
            }
          }

          // If no explicit conditions, use default (attacking + moving).
          if (forbiddenConditions === 0 && forbiddenStr.trim() === '') {
            forbiddenConditions = STEALTH_FORBIDDEN_DEFAULT;
          }

          profile = {
            stealthDelayFrames,
            innateStealth,
            forbiddenConditions,
            moveThresholdSpeed,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: StealthDetectorUpdate module — parse detector profile from INI.
   */
  private extractDetectorProfile(objectDef: ObjectDef | undefined): DetectorProfile | null {
    if (!objectDef) return null;
    let profile: DetectorProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'STEALTHDETECTORUPDATE') {
          const detectionRange = readNumericField(block.fields, ['DetectionRange']) ?? 0;
          const detectionRateMs = readNumericField(block.fields, ['DetectionRate']) ?? 33;
          const detectionRate = Math.max(1, this.msToLogicFrames(detectionRateMs));
          const canDetectWhileGarrisoned = readBooleanField(block.fields, ['CanDetectWhileGarrisoned']) ?? false;
          const canDetectWhileContained = readBooleanField(block.fields, ['CanDetectWhileContained']) ?? false;

          const extraRequiredKindOf = new Set<string>();
          const requiredStr = readStringField(block.fields, ['ExtraRequiredKindOf']) ?? '';
          for (const token of requiredStr.split(/\s+/)) {
            if (token) extraRequiredKindOf.add(token.toUpperCase());
          }

          const extraForbiddenKindOf = new Set<string>();
          const forbiddenStr = readStringField(block.fields, ['ExtraForbiddenKindOf']) ?? '';
          for (const token of forbiddenStr.split(/\s+/)) {
            if (token) extraForbiddenKindOf.add(token.toUpperCase());
          }

          profile = {
            detectionRange,
            detectionRate,
            canDetectWhileGarrisoned,
            canDetectWhileContained,
            extraRequiredKindOf,
            extraForbiddenKindOf,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: FlammableUpdate module — extract flammability profile from INI.
   */
  private extractFlammableProfile(objectDef: ObjectDef | undefined): FlammableProfile | null {
    if (!objectDef) return null;
    let profile: FlammableProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FLAMMABLEUPDATE') {
          profile = {
            flameDamageLimit: readNumericField(block.fields, ['FlameDamageLimit']) ?? DEFAULT_FLAME_DAMAGE_LIMIT,
            flameDamageExpirationDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['FlameDamageExpiration']) ?? 2000),
            aflameDurationFrames: this.msToLogicFrames(readNumericField(block.fields, ['AflameDuration']) ?? 3000),
            aflameDamageDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['AflameDamageDelay']) ?? 500),
            aflameDamageAmount: readNumericField(block.fields, ['AflameDamageAmount']) ?? DEFAULT_AFLAME_DAMAGE_AMOUNT,
            burnedDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['BurnedDelay']) ?? 0),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: FireSpreadUpdate — extract fire spread profile from INI.
   * C++ file: FireSpreadUpdate.cpp — spreads fire to nearby flammable objects.
   */
  private extractFireSpreadProfile(objectDef: ObjectDef | undefined): FireSpreadProfile | null {
    if (!objectDef) return null;
    let profile: FireSpreadProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FIRESPREADUPDATE') {
          profile = {
            minSpreadDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['MinSpreadDelay']) ?? 500),
            maxSpreadDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['MaxSpreadDelay']) ?? 1500),
            spreadTryRange: (readNumericField(block.fields, ['SpreadTryRange']) ?? 10) * MAP_XY_FACTOR,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: PoisonedBehavior — extract per-entity poison DoT parameters from INI.
   * C++ file: PoisonedBehavior.cpp lines 56-63 (buildFieldParse).
   */
  private extractPoisonedBehaviorProfile(objectDef: ObjectDef | undefined): PoisonedBehaviorProfile | null {
    if (!objectDef) return null;
    let profile: PoisonedBehaviorProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'POISONEDBEHAVIOR') {
          profile = {
            poisonDamageIntervalFrames: this.msToLogicFrames(readNumericField(block.fields, ['PoisonDamageInterval']) ?? 333),
            poisonDurationFrames: this.msToLogicFrames(readNumericField(block.fields, ['PoisonDuration']) ?? 3000),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: FireWeaponWhenDamagedBehavior — extract reaction/continuous weapon config.
   */
  private extractFireWhenDamagedProfiles(objectDef: ObjectDef | undefined): FireWhenDamagedProfile[] {
    if (!objectDef) return [];
    const profiles: FireWhenDamagedProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FIREWEAPONWHENDAMAGEDBEHAVIOR') {
          profiles.push({
            reactionWeapons: [
              readStringField(block.fields, ['ReactionWeaponPristine']),
              readStringField(block.fields, ['ReactionWeaponDamaged']),
              readStringField(block.fields, ['ReactionWeaponReallyDamaged']),
              readStringField(block.fields, ['ReactionWeaponRubble']),
            ],
            continuousWeapons: [
              readStringField(block.fields, ['ContinuousWeaponPristine']),
              readStringField(block.fields, ['ContinuousWeaponDamaged']),
              readStringField(block.fields, ['ContinuousWeaponReallyDamaged']),
              readStringField(block.fields, ['ContinuousWeaponRubble']),
            ],
            damageAmount: readNumericField(block.fields, ['DamageAmount']) ?? 0,
            reactionNextFireFrame: [0, 0, 0, 0],
            continuousNextFireFrame: [0, 0, 0, 0],
          });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: FireWeaponUpdate — extract autonomous weapon fire config from INI.
   * Multiple FireWeaponUpdate modules can exist on a single entity.
   */
  private extractFireWeaponUpdateProfiles(objectDef: ObjectDef | undefined): FireWeaponUpdateProfile[] {
    if (!objectDef) return [];
    const profiles: FireWeaponUpdateProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FIREWEAPONUPDATE') {
          const weaponName = readStringField(block.fields, ['Weapon']);
          if (!weaponName) return;

          profiles.push({
            weaponName,
            initialDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['InitialDelay']) ?? 0),
            exclusiveWeaponDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['ExclusiveWeaponDelay']) ?? 0),
          });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: OCLUpdate — extract periodic OCL spawning config from INI.
   * INI fields: OCL (name), MinDelay (ms), MaxDelay (ms).
   */
  private extractOCLUpdateProfiles(objectDef: ObjectDef | undefined): OCLUpdateProfile[] {
    if (!objectDef) return [];
    const profiles: OCLUpdateProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'OCLUPDATE') {
          const oclName = readStringField(block.fields, ['OCL']);
          if (!oclName) return;
          const minDelayMs = readNumericField(block.fields, ['MinDelay']) ?? 0;
          const maxDelayMs = readNumericField(block.fields, ['MaxDelay']) ?? minDelayMs;
          profiles.push({
            oclName,
            minDelayFrames: this.msToLogicFrames(minDelayMs),
            maxDelayFrames: this.msToLogicFrames(maxDelayMs),
          });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: WeaponBonusUpdate — extract weapon bonus aura config from INI.
   * INI fields: RequiredAffectKindOf, ForbiddenAffectKindOf, BonusDuration (ms),
   * BonusDelay (ms), BonusRange, BonusConditionType.
   */
  private extractWeaponBonusUpdateProfiles(objectDef: ObjectDef | undefined): WeaponBonusUpdateProfile[] {
    if (!objectDef) return [];
    const profiles: WeaponBonusUpdateProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'WEAPONBONUSUPDATE') {
          const conditionName = readStringField(block.fields, ['BonusConditionType'])?.toUpperCase();
          if (!conditionName) return;
          const bonusFlag = WEAPON_BONUS_CONDITION_BY_NAME.get(conditionName);
          if (bonusFlag === undefined) return;

          const requiredKindOf = new Set<string>();
          const forbiddenKindOf = new Set<string>();
          for (const tokens of this.extractIniValueTokens(block.fields['RequiredAffectKindOf'])) {
            for (const t of tokens) { if (t) requiredKindOf.add(t.toUpperCase()); }
          }
          for (const tokens of this.extractIniValueTokens(block.fields['ForbiddenAffectKindOf'])) {
            for (const t of tokens) { if (t) forbiddenKindOf.add(t.toUpperCase()); }
          }

          profiles.push({
            requiredKindOf,
            forbiddenKindOf,
            bonusDurationFrames: this.msToLogicFrames(readNumericField(block.fields, ['BonusDuration']) ?? 0),
            bonusDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['BonusDelay']) ?? 0),
            bonusRange: readNumericField(block.fields, ['BonusRange']) ?? 0,
            bonusConditionFlag: bonusFlag,
          });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: RadarUpdate — extract radar dish extension config from INI.
   * INI fields: RadarExtendTime (ms).
   */
  private extractRadarUpdateProfile(objectDef: ObjectDef | undefined): RadarUpdateProfile | null {
    if (!objectDef) return null;
    let profile: RadarUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'RADARUPDATE') {
          const extendTimeMs = readNumericField(block.fields, ['RadarExtendTime']) ?? 0;
          profile = {
            radarExtendTimeFrames: this.msToLogicFrames(extendTimeMs),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: FloatUpdate — extract water-surface snapping config from INI.
   * INI fields: Enabled (bool, default FALSE).
   */
  private extractFloatUpdateProfile(objectDef: ObjectDef | undefined): FloatUpdateProfile | null {
    if (!objectDef) return null;
    let profile: FloatUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FLOATUPDATE') {
          const enabledStr = readStringField(block.fields, ['Enabled'])?.toUpperCase();
          profile = {
            enabled: enabledStr === 'YES' || enabledStr === 'TRUE' || enabledStr === '1',
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: StickyBombUpdate — extract bomb attachment config from INI.
   * C++ file: StickyBombUpdate.h (StickyBombUpdateModuleData).
   */
  private extractStickyBombUpdateProfile(objectDef: ObjectDef | undefined): StickyBombUpdateProfile | null {
    if (!objectDef) return null;
    let profile: StickyBombUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'STICKYBOMBUPDATE') {
          profile = {
            offsetZ: readNumericField(block.fields, ['OffsetZ']) ?? 10.0,
            geometryBasedDamageWeaponName: readStringField(block.fields, ['GeometryBasedDamageWeapon']) ?? null,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: PointDefenseLaserUpdate — extract anti-projectile defense config from INI.
   */
  private extractPointDefenseLaserProfile(objectDef: ObjectDef | undefined): PointDefenseLaserProfile | null {
    if (!objectDef) return null;
    let profile: PointDefenseLaserProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'POINTDEFENSELASERUPDATE') {
          const weaponName = readStringField(block.fields, ['WeaponTemplate']);
          if (!weaponName) return;

          const primaryStr = readStringField(block.fields, ['PrimaryTargetTypes']) ?? '';
          const primaryTargetKindOf = new Set<string>();
          for (const token of primaryStr.split(/\s+/)) {
            if (token) primaryTargetKindOf.add(token.toUpperCase());
          }

          const secondaryStr = readStringField(block.fields, ['SecondaryTargetTypes']) ?? '';
          const secondaryTargetKindOf = new Set<string>();
          for (const token of secondaryStr.split(/\s+/)) {
            if (token) secondaryTargetKindOf.add(token.toUpperCase());
          }

          const scanRateMs = readNumericField(block.fields, ['ScanRate']) ?? 0;
          profile = {
            weaponName,
            primaryTargetKindOf,
            secondaryTargetKindOf,
            scanRate: Math.max(1, this.msToLogicFrames(scanRateMs)),
            scanRange: readNumericField(block.fields, ['ScanRange']) ?? 0,
            predictTargetVelocityFactor: readNumericField(block.fields, ['PredictTargetVelocityFactor']) ?? 0,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: HordeUpdate — extract horde formation bonus config from INI.
   */
  private extractHordeUpdateProfile(objectDef: ObjectDef | undefined): HordeUpdateProfile | null {
    if (!objectDef) return null;
    let profile: HordeUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'HORDEUPDATE') {
          const kindOfStr = readStringField(block.fields, ['KindOf']) ?? '';
          const kindOf = new Set<string>();
          for (const token of kindOfStr.split(/\s+/)) {
            if (token) kindOf.add(token.toUpperCase());
          }

          const updateRateMs = readNumericField(block.fields, ['UpdateRate']) ?? 1000;
          profile = {
            updateRate: Math.max(1, this.msToLogicFrames(updateRateMs)),
            kindOf,
            minCount: readNumericField(block.fields, ['Count']) ?? 2,
            minDist: readNumericField(block.fields, ['Radius']) ?? 100,
            rubOffRadius: readNumericField(block.fields, ['RubOffRadius']) ?? 20,
            alliesOnly: (readStringField(block.fields, ['AlliesOnly']) ?? 'Yes').toUpperCase() !== 'NO',
            exactMatch: (readStringField(block.fields, ['ExactMatch']) ?? 'No').toUpperCase() === 'YES',
            allowedNationalism: (readStringField(block.fields, ['AllowedNationalism']) ?? 'Yes').toUpperCase() !== 'NO',
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: EnemyNearUpdate — extract ScanDelayTime from INI.
   * Returns 0 if no EnemyNearUpdate behavior block is found.
   * C++ default: LOGICFRAMES_PER_SECOND (30 frames).
   */
  private extractEnemyNearScanDelay(objectDef: ObjectDef | undefined): number {
    if (!objectDef) return 0;
    let result = 0;
    const visitBlock = (block: IniBlock): void => {
      if (result > 0) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'ENEMYNEARUPDATE') {
          const scanDelayMs = readNumericField(block.fields, ['ScanDelayTime']) ?? 1000;
          result = Math.max(1, this.msToLogicFrames(scanDelayMs));
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return result;
  }

  /**
   * Helper: check if an object definition contains a behavior/update module of the given type.
   */
  private hasModuleType(objectDef: ObjectDef | undefined, moduleType: string): boolean {
    if (!objectDef) return false;
    const upperType = moduleType.toUpperCase();
    let found = false;
    const visitBlock = (block: IniBlock): void => {
      if (found) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'DRAW') {
        const mt = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (mt === upperType) { found = true; return; }
      }
      if (block.blocks) { for (const child of block.blocks) visitBlock(child); }
    };
    if (objectDef.blocks) { for (const block of objectDef.blocks) visitBlock(block); }
    return found;
  }

  /**
   * Source parity: VeterancyGainCreate — extract all VeterancyGainCreate modules from INI.
   * C++ file: VeterancyGainCreate.cpp — sets veterancy level on creation if science is present.
   */
  private extractVeterancyGainCreateProfiles(objectDef: ObjectDef | undefined): VeterancyGainCreateProfile[] {
    if (!objectDef) return [];
    const profiles: VeterancyGainCreateProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR' || block.type.toUpperCase() === 'DRAW') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'VETERANCYGAINCREATE') {
          const levelStr = readStringField(block.fields, ['StartingLevel'])?.trim().toUpperCase() ?? '';
          let startingLevel: VeterancyLevel = LEVEL_REGULAR;
          if (levelStr === 'VETERAN') startingLevel = LEVEL_VETERAN;
          else if (levelStr === 'ELITE') startingLevel = LEVEL_ELITE;
          else if (levelStr === 'HEROIC') startingLevel = LEVEL_HEROIC;

          const scienceStr = readStringField(block.fields, ['ScienceRequired'])?.trim().toUpperCase() ?? '';
          const scienceRequired = (scienceStr && scienceStr !== 'NONE' && scienceStr !== 'SCIENCE_INVALID')
            ? scienceStr : null;

          profiles.push({ startingLevel, scienceRequired });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: FXListDie — extract all FXListDie modules from INI.
   * C++ file: FXListDie.cpp — triggers death FX with isDieApplicable filtering.
   */
  private extractFXListDieProfiles(objectDef: ObjectDef | undefined): FXListDieProfile[] {
    if (!objectDef) return [];
    const profiles: FXListDieProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FXLISTDIE') {
          const deathFXName = readStringField(block.fields, ['DeathFX'])?.trim().toUpperCase() ?? '';
          if (!deathFXName) { return; }
          const orientToObject = (readStringField(block.fields, ['OrientToObject'])?.toUpperCase() ?? 'YES') !== 'NO';

          // DieMuxData filtering fields.
          const deathTypes = new Set<string>();
          const dtStr = readStringField(block.fields, ['DeathTypes'])?.trim().toUpperCase() ?? '';
          if (dtStr) { for (const t of dtStr.split(/\s+/)) { if (t) deathTypes.add(t); } }
          const veterancyLevels = new Set<string>();
          const vlStr = readStringField(block.fields, ['VeterancyLevels'])?.trim().toUpperCase() ?? '';
          if (vlStr) { for (const t of vlStr.split(/\s+/)) { if (t) veterancyLevels.add(t); } }
          const exemptStatus = new Set<string>();
          const esStr = readStringField(block.fields, ['ExemptStatus'])?.trim().toUpperCase() ?? '';
          if (esStr) { for (const t of esStr.split(/\s+/)) { if (t) exemptStatus.add(t); } }
          const requiredStatus = new Set<string>();
          const rsStr = readStringField(block.fields, ['RequiredStatus'])?.trim().toUpperCase() ?? '';
          if (rsStr) { for (const t of rsStr.split(/\s+/)) { if (t) requiredStatus.add(t); } }

          profiles.push({ deathFXName, orientToObject, deathTypes, veterancyLevels, exemptStatus, requiredStatus });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: CrushDie — extract all CrushDie modules from INI.
   * C++ file: CrushDie.h — die module that sets FRONTCRUSHED/BACKCRUSHED model conditions.
   */
  private extractCrushDieProfiles(objectDef: ObjectDef | undefined): CrushDieProfile[] {
    if (!objectDef) return [];
    const profiles: CrushDieProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'CRUSHDIE') {
          // DieMuxData filtering fields.
          const deathTypes = new Set<string>();
          const dtStr = readStringField(block.fields, ['DeathTypes'])?.trim().toUpperCase() ?? '';
          if (dtStr) { for (const t of dtStr.split(/\s+/)) { if (t) deathTypes.add(t); } }
          const veterancyLevels = new Set<string>();
          const vlStr = readStringField(block.fields, ['VeterancyLevels'])?.trim().toUpperCase() ?? '';
          if (vlStr) { for (const t of vlStr.split(/\s+/)) { if (t) veterancyLevels.add(t); } }
          const exemptStatus = new Set<string>();
          const esStr = readStringField(block.fields, ['ExemptStatus'])?.trim().toUpperCase() ?? '';
          if (esStr) { for (const t of esStr.split(/\s+/)) { if (t) exemptStatus.add(t); } }
          const requiredStatus = new Set<string>();
          const rsStr = readStringField(block.fields, ['RequiredStatus'])?.trim().toUpperCase() ?? '';
          if (rsStr) { for (const t of rsStr.split(/\s+/)) { if (t) requiredStatus.add(t); } }

          profiles.push({ deathTypes, veterancyLevels, exemptStatus, requiredStatus });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  private extractDieMuxData(block: IniBlock): {
    deathTypes: Set<string>;
    veterancyLevels: Set<string>;
    exemptStatus: Set<string>;
    requiredStatus: Set<string>;
  } {
    const deathTypes = new Set<string>();
    const dtStr = readStringField(block.fields, ['DeathTypes'])?.trim().toUpperCase() ?? '';
    if (dtStr) {
      for (const token of dtStr.split(/\s+/)) {
        if (token) deathTypes.add(token);
      }
    }

    const veterancyLevels = new Set<string>();
    const vlStr = readStringField(block.fields, ['VeterancyLevels'])?.trim().toUpperCase() ?? '';
    if (vlStr) {
      for (const token of vlStr.split(/\s+/)) {
        if (token) veterancyLevels.add(token);
      }
    }

    const exemptStatus = new Set<string>();
    const esStr = readStringField(block.fields, ['ExemptStatus'])?.trim().toUpperCase() ?? '';
    if (esStr) {
      for (const token of esStr.split(/\s+/)) {
        if (token) exemptStatus.add(token);
      }
    }

    const requiredStatus = new Set<string>();
    const rsStr = readStringField(block.fields, ['RequiredStatus'])?.trim().toUpperCase() ?? '';
    if (rsStr) {
      for (const token of rsStr.split(/\s+/)) {
        if (token) requiredStatus.add(token);
      }
    }

    return { deathTypes, veterancyLevels, exemptStatus, requiredStatus };
  }

  /**
   * Source parity: DestroyDie — extract DestroyDie modules with DieMuxData filtering.
   * C++ file: DestroyDie.cpp.
   */
  private extractDestroyDieProfiles(objectDef: ObjectDef | undefined): DestroyDieProfile[] {
    if (!objectDef) return [];
    const profiles: DestroyDieProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DESTROYDIE') {
          profiles.push(this.extractDieMuxData(block));
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };
    for (const block of objectDef.blocks) {
      visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: DamDie — extract DamDie modules with DieMuxData filtering.
   * C++ file: DamDie.cpp.
   */
  private extractDamDieProfiles(objectDef: ObjectDef | undefined): DamDieProfile[] {
    if (!objectDef) return [];
    const profiles: DamDieProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DAMDIE') {
          profiles.push(this.extractDieMuxData(block));
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };
    for (const block of objectDef.blocks) {
      visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: SpecialPowerCompletionDie — extract script-notification die modules.
   * C++ file: SpecialPowerCompletionDie.cpp.
   */
  private extractSpecialPowerCompletionDieProfiles(objectDef: ObjectDef | undefined): SpecialPowerCompletionDieProfile[] {
    if (!objectDef) return [];
    const profiles: SpecialPowerCompletionDieProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SPECIALPOWERCOMPLETIONDIE') {
          const specialPowerTemplateName = this.normalizeShortcutSpecialPowerName(
            readStringField(block.fields, ['SpecialPowerTemplate']) ?? '',
          );
          if (!specialPowerTemplateName) {
            return;
          }

          profiles.push({
            specialPowerTemplateName,
            ...this.extractDieMuxData(block),
          });
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };
    for (const block of objectDef.blocks) {
      visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: GrantUpgradeCreate — extract all GrantUpgradeCreate modules from INI.
   * C++ file: GrantUpgradeCreate.cpp — grants upgrades on object creation / build complete.
   */
  private extractGrantUpgradeCreateProfiles(objectDef: ObjectDef | undefined): GrantUpgradeCreateProfile[] {
    if (!objectDef) return [];
    const profiles: GrantUpgradeCreateProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'GRANTUPGRADECREATE') {
          const upgradeName = readStringField(block.fields, ['UpgradeToGrant'])?.trim().toUpperCase() ?? '';
          if (upgradeName) {
            const exemptStatus = readStringField(block.fields, ['ExemptStatus'])?.trim().toUpperCase() ?? '';
            // Source parity: determine if this is a PLAYER upgrade by checking the UpgradeDef.
            // We check at runtime; for now store the name and resolve type on application.
            profiles.push({
              upgradeName,
              isPlayerUpgrade: false, // Resolved at application time from UpgradeDef.
              exemptUnderConstruction: exemptStatus.includes('UNDER_CONSTRUCTION'),
            });
          }
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: LockWeaponCreate — extract weapon slot to lock from INI.
   * C++ file: LockWeaponCreate.cpp — locks weapon choice to specified slot on build complete.
   */
  private extractLockWeaponCreateSlot(objectDef: ObjectDef | undefined): number | null {
    if (!objectDef) return null;
    let slot: number | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (slot !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'LOCKWEAPONCREATE') {
          const slotName = readStringField(block.fields, ['SlotToLock'])?.trim().toUpperCase() ?? '';
          if (slotName === 'SECONDARY_WEAPON') {
            slot = 1;
          } else if (slotName === 'TERTIARY_WEAPON') {
            slot = 2;
          } else {
            // PRIMARY_WEAPON or default.
            slot = 0;
          }
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return slot;
  }

  /**
   * Source parity: UpgradeDie — extract all UpgradeDie modules from INI.
   * C++ file: UpgradeDie.cpp — removes upgrade from producer when entity dies.
   */
  private extractUpgradeDieProfiles(objectDef: ObjectDef | undefined): UpgradeDieProfile[] {
    if (!objectDef) return [];
    const profiles: UpgradeDieProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'UPGRADEDIE') {
          const upgradeName = readStringField(block.fields, ['UpgradeToRemove'])?.trim().toUpperCase() ?? '';
          if (upgradeName) {
            // DieMuxData filtering.
            const deathTypesRaw = readStringField(block.fields, ['DeathTypes'])?.trim().toUpperCase() ?? '';
            const deathTypes: Set<string> | null = deathTypesRaw
              ? new Set(deathTypesRaw.split(/\s+/).filter(Boolean))
              : null;
            const exemptStatusRaw = readStringField(block.fields, ['ExemptStatus'])?.trim().toUpperCase() ?? '';
            const exemptStatus = new Set(exemptStatusRaw.split(/\s+/).filter(Boolean));
            const requiredStatusRaw = readStringField(block.fields, ['RequiredStatus'])?.trim().toUpperCase() ?? '';
            const requiredStatus = new Set(requiredStatusRaw.split(/\s+/).filter(Boolean));
            profiles.push({
              upgradeName,
              deathTypes,
              exemptStatus,
              requiredStatus,
            });
          }
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: CheckpointUpdate — extract checkpoint gate profile from INI.
   * C++ file: CheckpointUpdate.cpp — gate opens for allies when no enemies near.
   */
  private extractCheckpointProfile(objectDef: ObjectDef | undefined): CheckpointProfile | null {
    if (!objectDef) return null;
    let profile: CheckpointProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'CHECKPOINTUPDATE') {
          const scanDelayMs = readNumericField(block.fields, ['EnemyScanDelayTime']) ?? 1000;
          profile = {
            scanDelayFrames: Math.max(1, this.msToLogicFrames(scanDelayMs)),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: ProneUpdate — extract damage-to-frames ratio from INI.
   * Returns null if no ProneUpdate module is defined.
   */
  private extractProneDamageToFramesRatio(objectDef: ObjectDef | undefined): number | null {
    if (!objectDef) return null;
    let ratio: number | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (ratio !== null) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'PRONEUPDATE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'PRONEUPDATE' || blockType === 'PRONEUPDATE') {
          ratio = readNumericField(block.fields, ['DamageToFramesRatio']) ?? 1.0;
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return ratio;
  }

  /**
   * Source parity: DemoTrapUpdateModuleData — extract demo trap profile from INI.
   */
  private extractDemoTrapProfile(objectDef: ObjectDef | undefined): DemoTrapProfile | null {
    if (!objectDef) return null;
    let profile: DemoTrapProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'DEMOTRAPUPDATE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DEMOTRAPUPDATE' || blockType === 'DEMOTRAPUPDATE') {
          const ignoreStr = readStringField(block.fields, ['IgnoreTargetTypes']) ?? '';
          const ignoreKindOf = new Set<string>(
            ignoreStr.split(/\s+/).filter(Boolean).map(s => s.toUpperCase()),
          );
          profile = {
            defaultsToProximityMode: readBooleanField(block.fields, ['DefaultProximityMode']) ?? false,
            triggerDetonationRange: readNumericField(block.fields, ['TriggerDetonationRange']) ?? 0,
            ignoreKindOf,
            scanFrames: this.msToLogicFrames(readNumericField(block.fields, ['ScanRate']) ?? 0),
            friendlyDetonation: readBooleanField(block.fields, ['AutoDetonationWithFriendsInvolved']) ?? false,
            detonationWeaponName: readStringField(block.fields, ['DetonationWeapon']),
            detonateWhenKilled: readBooleanField(block.fields, ['DetonateWhenKilled']) ?? false,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: RebuildHoleExposeDie — extract die module config from INI.
   * Present on buildings that should create a hole when destroyed.
   */
  private extractRebuildHoleExposeDieProfile(objectDef: ObjectDef | undefined): RebuildHoleExposeDieProfile | null {
    if (!objectDef) return null;
    let profile: RebuildHoleExposeDieProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'DIE' || blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'REBUILDHOLEEXPOSEDIE') {
          const holeName = readStringField(block.fields, ['HoleName']);
          if (!holeName) return;
          profile = {
            holeName,
            holeMaxHealth: readNumericField(block.fields, ['HoleMaxHealth']) ?? 50,
            transferAttackers: readBooleanField(block.fields, ['TransferAttackers']) ?? true,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: RebuildHoleBehavior — extract behavior module config from INI.
   * Present on hole objects that manage the worker-spawn → reconstruct lifecycle.
   */
  private extractRebuildHoleBehaviorProfile(objectDef: ObjectDef | undefined): RebuildHoleBehaviorProfile | null {
    if (!objectDef) return null;
    let profile: RebuildHoleBehaviorProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'REBUILDHOLEBEHAVIOR') {
          const workerName = readStringField(block.fields, ['WorkerObjectName']);
          if (!workerName) return;
          // Source parity: WorkerRespawnDelay is in milliseconds → convert to frames.
          const respawnDelayMs = readNumericField(block.fields, ['WorkerRespawnDelay']) ?? 5000;
          // Source parity: HoleHealthRegen%PerSecond uses INI::parsePercentToReal
          // which divides by 100. E.g., INI value "10" → 0.1 (10%). Default = 0.1.
          const regenRaw = readNumericField(block.fields, ['HoleHealthRegen%PerSecond']);
          const regenPercent = regenRaw !== undefined ? regenRaw / 100 : 0.1;
          profile = {
            workerObjectName: workerName,
            workerRespawnDelay: this.msToLogicFrames(respawnDelayMs),
            holeHealthRegenPercentPerSecond: regenPercent,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: AutoDepositUpdate — extract periodic income config from INI.
   */
  private extractAutoDepositProfile(objectDef: ObjectDef | undefined): AutoDepositProfile | null {
    if (!objectDef) return null;
    let profile: AutoDepositProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'AUTODEPOSITUPDATE') {
          // Source parity: DepositTiming is in milliseconds → convert to frames.
          const depositTimingMs = readNumericField(block.fields, ['DepositTiming']) ?? 2000;
          const depositAmount = readNumericField(block.fields, ['DepositAmount']) ?? 0;
          const initialCaptureBonus = readNumericField(block.fields, ['InitialCaptureBonus']) ?? 0;
          profile = {
            depositFrames: Math.max(1, this.msToLogicFrames(depositTimingMs)),
            depositAmount,
            initialCaptureBonus,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: DynamicShroudClearingRangeUpdate — extract vision animation config from INI.
   * C++ file: DynamicShroudClearingRangeUpdate.cpp lines 61-78.
   * All duration fields are parsed as durations (ms → frames).
   */
  private extractDynamicShroudProfile(objectDef: ObjectDef | undefined): DynamicShroudProfile | null {
    if (!objectDef) return null;
    let profile: DynamicShroudProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DYNAMICSHROUDCLEARINGRANGEUPDATE' || moduleType === 'DYNAMICSHROUDCLEARINGRANGE') {
          profile = {
            shrinkDelay: Math.max(0, this.msToLogicFrames(readNumericField(block.fields, ['ShrinkDelay']) ?? 0)),
            shrinkTime: Math.max(0, this.msToLogicFrames(readNumericField(block.fields, ['ShrinkTime']) ?? 0)),
            growDelay: Math.max(0, this.msToLogicFrames(readNumericField(block.fields, ['GrowDelay']) ?? 0)),
            growTime: Math.max(0, this.msToLogicFrames(readNumericField(block.fields, ['GrowTime']) ?? 0)),
            finalVision: readNumericField(block.fields, ['FinalVision']) ?? 0,
            changeInterval: Math.max(1, this.msToLogicFrames(readNumericField(block.fields, ['ChangeInterval']) ?? 0)),
            growInterval: Math.max(1, this.msToLogicFrames(readNumericField(block.fields, ['GrowInterval']) ?? 0)),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: AutoFindHealingUpdate — extract auto-heal-seeking config from INI.
   * C++ file: AutoFindHealingUpdate.cpp — AI units automatically enter nearby heal pads.
   */
  private extractAutoFindHealingProfile(objectDef: ObjectDef | undefined): AutoFindHealingProfile | null {
    if (!objectDef) return null;
    let profile: AutoFindHealingProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'AUTOFINDHEALING' || moduleType === 'AUTOFINDHEALINGUPDATE') {
          profile = {
            scanRateFrames: this.msToLogicFrames(readNumericField(block.fields, ['ScanRate']) ?? 1000),
            scanRange: (readNumericField(block.fields, ['ScanRange']) ?? 200) * MAP_XY_FACTOR,
            neverHeal: readNumericField(block.fields, ['NeverHeal']) ?? 0.95,
            alwaysHeal: readNumericField(block.fields, ['AlwaysHeal']) ?? 0.25,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: SlavedUpdateModuleData — extract slave behavior config from INI.
   */
  private extractSlavedUpdateProfile(objectDef: ObjectDef | undefined): SlavedUpdateProfile | null {
    if (!objectDef) return null;
    let profile: SlavedUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SLAVEDUPDATE') {
          profile = {
            guardMaxRange: readNumericField(block.fields, ['GuardMaxRange']) ?? 0,
            guardWanderRange: readNumericField(block.fields, ['GuardWanderRange']) ?? 0,
            attackRange: readNumericField(block.fields, ['AttackRange']) ?? 0,
            attackWanderRange: readNumericField(block.fields, ['AttackWanderRange']) ?? 0,
            scoutRange: readNumericField(block.fields, ['ScoutRange']) ?? 0,
            scoutWanderRange: readNumericField(block.fields, ['ScoutWanderRange']) ?? 0,
            distToTargetToGrantRangeBonus: readNumericField(block.fields, ['DistToTargetToGrantRangeBonus']) ?? 0,
            repairRatePerSecond: readNumericField(block.fields, ['RepairRatePerSecond']) ?? 0,
            repairWhenBelowHealthPercent: readNumericField(block.fields, ['RepairWhenBelowHealth%']) ?? 0,
            stayOnSameLayerAsMaster: readStringField(block.fields, ['StayOnSameLayerAsMaster'])?.toUpperCase() === 'YES',
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: CountermeasuresBehavior — extract countermeasure config from INI.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Behavior/CountermeasuresBehavior.cpp)
   */
  private extractCountermeasuresProfile(objectDef: ObjectDef | undefined): CountermeasuresProfile | null {
    if (!objectDef) return null;
    let profile: CountermeasuresProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'COUNTERMEASURESBEHAVIOR') {
          const evasionRaw = readNumericField(block.fields, ['EvasionRate']);
          profile = {
            flareTemplateName: readStringField(block.fields, ['FlareTemplateName']) ?? '',
            volleySize: readNumericField(block.fields, ['VolleySize']) ?? 0,
            volleyArcAngle: (readNumericField(block.fields, ['VolleyArcAngle']) ?? 0) * (Math.PI / 180),
            volleyVelocityFactor: readNumericField(block.fields, ['VolleyVelocityFactor']) ?? 1.0,
            framesBetweenVolleys: this.msToLogicFrames(readNumericField(block.fields, ['DelayBetweenVolleys']) ?? 0),
            numberOfVolleys: readNumericField(block.fields, ['NumberOfVolleys']) ?? 0,
            reloadFrames: this.msToLogicFrames(readNumericField(block.fields, ['ReloadTime']) ?? 0),
            evasionRate: evasionRaw != null ? evasionRaw / 100 : 0,
            missileDecoyFrames: this.msToLogicFrames(readNumericField(block.fields, ['MissileDecoyDelay']) ?? 0),
            reactionFrames: this.msToLogicFrames(readNumericField(block.fields, ['ReactionLaunchLatency']) ?? 0),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: PilotFindVehicleUpdate — extract pilot-seek-vehicle config from INI.
   * (Generals/Code/GameEngine/Source/GameLogic/Object/Update/PilotFindVehicleUpdate.cpp)
   */
  private extractPilotFindVehicleProfile(objectDef: ObjectDef | undefined): PilotFindVehicleProfile | null {
    if (!objectDef) return null;
    let profile: PilotFindVehicleProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'PILOTFINDVEHICLEUPDATE') {
          profile = {
            scanFrames: this.msToLogicFrames(readNumericField(block.fields, ['ScanRate']) ?? 0),
            scanRange: readNumericField(block.fields, ['ScanRange']) ?? 0,
            minHealth: readNumericField(block.fields, ['MinHealth']) ?? 0.5,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: ToppleUpdate — extract topple config from INI.
   * (Generals/Code/GameEngine/Source/GameLogic/Object/Update/ToppleUpdate.cpp)
   */
  private extractToppleProfile(objectDef: ObjectDef | undefined): ToppleProfile | null {
    if (!objectDef) return null;
    let profile: ToppleProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'TOPPLEUPDATE') {
          // Source parity: C++ defaults are 0.2f, 0.01f, 0.3f (set in constructor).
          // Use null to distinguish "field not present" from "field explicitly set to 0".
          const parsePercent = (raw: number | null | undefined): number | null =>
            raw != null ? raw / 100 : null;
          profile = {
            initialVelocityPercent: parsePercent(readNumericField(block.fields, ['InitialVelocityPercent'])) ?? 0.20,
            initialAccelPercent: parsePercent(readNumericField(block.fields, ['InitialAccelPercent'])) ?? 0.01,
            bounceVelocityPercent: parsePercent(readNumericField(block.fields, ['BounceVelocityPercent'])) ?? 0.30,
            killWhenFinishedToppling: readBooleanField(block.fields, ['KillWhenFinishedToppling']) ?? true,
            killWhenStartToppling: readBooleanField(block.fields, ['KillWhenStartToppling']) ?? false,
            toppleLeftOrRightOnly: readBooleanField(block.fields, ['ToppleLeftOrRightOnly']) ?? false,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: SpecialAbilityUpdate — extract special ability config from INI Behavior block.
   * Identifies SPECIALABILITY module type and reads all SpecialAbilityUpdate-specific fields.
   */
  private extractSpecialAbilityProfile(objectDef: ObjectDef | undefined): SpecialAbilityProfile | null {
    if (!objectDef) return null;
    let profile: SpecialAbilityProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SPECIALABILITYUPDATE') {
          const specialPowerTemplate = readStringField(block.fields, ['SpecialPowerTemplate']);
          if (!specialPowerTemplate) return;
          const HUGE_DISTANCE = 10000000.0;
          profile = {
            specialPowerTemplateName: specialPowerTemplate.trim().toUpperCase(),
            startAbilityRange: readNumericField(block.fields, ['StartAbilityRange']) ?? HUGE_DISTANCE,
            abilityAbortRange: readNumericField(block.fields, ['AbilityAbortRange']) ?? HUGE_DISTANCE,
            preparationFrames: this.msToLogicFrames(readNumericField(block.fields, ['PreparationTime']) ?? 0),
            persistentPrepFrames: this.msToLogicFrames(readNumericField(block.fields, ['PersistentPrepTime']) ?? 0),
            packTimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['PackTime']) ?? 0),
            unpackTimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['UnpackTime']) ?? 0),
            packUnpackVariationFactor: readNumericField(block.fields, ['PackUnpackVariationFactor']) ?? 0,
            skipPackingWithNoTarget: readBooleanField(block.fields, ['SkipPackingWithNoTarget']) === true,
            effectDurationFrames: this.msToLogicFrames(readNumericField(block.fields, ['EffectDuration']) ?? 0),
            fleeRangeAfterCompletion: readNumericField(block.fields, ['FleeRangeAfterCompletion']) ?? 0,
            flipOwnerAfterPacking: readBooleanField(block.fields, ['FlipOwnerAfterPacking']) === true,
            flipOwnerAfterUnpacking: readBooleanField(block.fields, ['FlipOwnerAfterUnpacking']) === true,
            loseStealthOnTrigger: readBooleanField(block.fields, ['LoseStealthOnTrigger']) === true,
            preTriggerUnstealthFrames: this.msToLogicFrames(readNumericField(block.fields, ['PreTriggerUnstealthTime']) ?? 0),
            awardXPForTriggering: readNumericField(block.fields, ['AwardXPForTriggering']) ?? 0,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: GenerateMinefieldBehavior — extract mine generation config from INI.
   */
  private extractGenerateMinefieldProfile(objectDef: ObjectDef | undefined): GenerateMinefieldProfile | null {
    if (!objectDef) return null;
    let profile: GenerateMinefieldProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'GENERATEMINEFIELDBEHAVIOR') {
          const mineName = readStringField(block.fields, ['MineName']);
          if (!mineName) return;
          profile = {
            mineName,
            distanceAroundObject: readNumericField(block.fields, ['DistanceAroundObject']) ?? 20,
            borderOnly: readBooleanField(block.fields, ['BorderOnly']) ?? true,
            alwaysCircular: readBooleanField(block.fields, ['AlwaysCircular']) ?? false,
            generateOnlyOnDeath: readBooleanField(block.fields, ['GenerateOnlyOnDeath']) ?? false,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: CreateCrateDie — extract crate spawning config from INI.
   * Parses CrateData field which references a crate object template name.
   * In C++, CreateCrateDie uses CrateSystem to resolve templates with weighted chance
   * selection, veterancy conditions, etc. We simplify: take the first CrateData entry
   * directly as the object template to spawn.
   */
  private extractCreateCrateDieProfile(objectDef: ObjectDef | undefined): CreateCrateDieProfile | null {
    if (!objectDef) return null;
    let profile: CreateCrateDieProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'CREATECRATEDIE') {
          const crateTemplateName = readStringField(block.fields, ['CrateData']);
          if (crateTemplateName) {
            profile = { crateTemplateName };
          }
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: SalvageCrateCollide — extract salvage crate behavior from INI.
   * Parsed from a Behavior block on the crate object template itself.
   */
  private extractSalvageCrateProfile(objectDef: ObjectDef | undefined): SalvageCrateProfile | null {
    if (!objectDef) return null;
    let profile: SalvageCrateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'SALVAGECRATECOLLIDE') {
          profile = {
            weaponChance: this.parsePercent(this.readIniFieldValue(block.fields, 'WeaponChance')) ?? 1.0,
            levelChance: this.parsePercent(this.readIniFieldValue(block.fields, 'LevelChance')) ?? 0.25,
            minMoney: readNumericField(block.fields, ['MinMoney']) ?? 25,
            maxMoney: readNumericField(block.fields, ['MaxMoney']) ?? 75,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: CrateCollide hierarchy — extract general crate collide profile from INI.
   * Matches HealCrateCollide, MoneyCrateCollide, VeterancyCrateCollide,
   * ShroudCrateCollide, UnitCrateCollide behavior blocks.
   */
  private extractCrateCollideProfile(objectDef: ObjectDef | undefined): CrateCollideProfile | null {
    if (!objectDef) return null;
    let profile: CrateCollideProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        let crateType: CrateCollideType | null = null;
        if (moduleType === 'HEALCRATECOLLIDE') crateType = 'HEAL';
        else if (moduleType === 'MONEYCRATECOLLIDE') crateType = 'MONEY';
        else if (moduleType === 'VETERANCYCRATECOLLIDE') crateType = 'VETERANCY';
        else if (moduleType === 'SHROUDCRATECOLLIDE') crateType = 'SHROUD';
        else if (moduleType === 'UNITCRATECOLLIDE') crateType = 'UNIT';
        if (crateType !== null) {
          // Parse base CrateCollide fields.
          const requiredKindOf = this.parseKindOf(block.fields['RequiredKindOf'] ?? block.fields['KindOf']);
          const forbiddenKindOf = this.parseKindOf(block.fields['ForbiddenKindOf'] ?? block.fields['KindOfNot']);
          profile = {
            crateType,
            requiredKindOf,
            forbiddenKindOf,
            forbidOwnerPlayer: readBooleanField(block.fields, ['ForbidOwnerPlayer']) ?? false,
            buildingPickup: readBooleanField(block.fields, ['BuildingPickup']) ?? false,
            humanOnly: readBooleanField(block.fields, ['HumanOnly']) ?? false,
            moneyProvided: readNumericField(block.fields, ['MoneyProvided']) ?? 0,
            unitType: readStringField(block.fields, ['UnitName']) ?? '',
            unitCount: readNumericField(block.fields, ['UnitCount']) ?? 1,
            veterancyRange: readNumericField(block.fields, ['EffectRange']) ?? 0,
            addsOwnerVeterancy: readBooleanField(block.fields, ['AddsOwnerVeterancy']) ?? false,
            isPilot: readBooleanField(block.fields, ['IsPilot']) ?? false,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: DeployStyleAIUpdate — extract deploy/undeploy config from INI.
   */
  private extractDeployStyleProfile(objectDef: ObjectDef | undefined): DeployStyleProfile | null {
    if (!objectDef) return null;
    let profile: DeployStyleProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DEPLOYSTYLEAIUPDATE') {
          const unpackMs = readNumericField(block.fields, ['UnpackTime']) ?? 0;
          const packMs = readNumericField(block.fields, ['PackTime']) ?? 0;
          profile = {
            unpackTimeFrames: this.msToLogicFrames(unpackMs),
            packTimeFrames: this.msToLogicFrames(packMs),
            turretsFunctionOnlyWhenDeployed:
              readBooleanField(block.fields, ['TurretsFunctionOnlyWhenDeployed']) ?? false,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: BattlePlanUpdate — extract battle plan profile from INI.
   */
  private extractBattlePlanProfile(objectDef: ObjectDef | undefined): BattlePlanProfile | null {
    if (!objectDef) return null;
    let profile: BattlePlanProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'BATTLEPLANUPDATE') {
          const bombardmentMs = readNumericField(block.fields, ['BombardmentPlanAnimationTime']) ?? 2000;
          const holdTheLineMs = readNumericField(block.fields, ['HoldTheLinePlanAnimationTime']) ?? 2000;
          const searchAndDestroyMs = readNumericField(block.fields, ['SearchAndDestroyPlanAnimationTime']) ?? 2000;
          const transitionIdleMs = readNumericField(block.fields, ['TransitionIdleTime']) ?? 3000;
          const paralyzeMs = readNumericField(block.fields, ['BattlePlanChangeParalyzeTime']) ?? 2000;

          const validKindOf = readStringField(block.fields, ['ValidMemberKindOf']) ?? '';
          const invalidKindOf = readStringField(block.fields, ['InvalidMemberKindOf']) ?? '';

          profile = {
            bombardmentAnimationFrames: this.msToLogicFrames(bombardmentMs),
            holdTheLineAnimationFrames: this.msToLogicFrames(holdTheLineMs),
            searchAndDestroyAnimationFrames: this.msToLogicFrames(searchAndDestroyMs),
            transitionIdleFrames: this.msToLogicFrames(transitionIdleMs),
            battlePlanParalyzeFrames: this.msToLogicFrames(paralyzeMs),
            holdTheLineArmorDamageScalar:
              readNumericField(block.fields, ['HoldTheLinePlanArmorDamageScalar']) ?? 1.0,
            searchAndDestroySightRangeScalar:
              readNumericField(block.fields, ['SearchAndDestroyPlanSightRangeScalar']) ?? 1.0,
            strategyCenterSearchAndDestroySightRangeScalar:
              readNumericField(block.fields, ['StrategyCenterSearchAndDestroySightRangeScalar']) ?? 1.0,
            strategyCenterSearchAndDestroyDetectsStealth:
              readBooleanField(block.fields, ['StrategyCenterSearchAndDestroyDetectsStealth']) ?? false,
            strategyCenterHoldTheLineMaxHealthScalar:
              readNumericField(block.fields, ['StrategyCenterHoldTheLineMaxHealthScalar']) ?? 1.0,
            validMemberKindOf: new Set(
              validKindOf.split(/\s+/).map((t) => t.trim().toUpperCase()).filter(Boolean),
            ),
            invalidMemberKindOf: new Set(
              invalidKindOf.split(/\s+/).map((t) => t.trim().toUpperCase()).filter(Boolean),
            ),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: SlowDeathBehavior modules — extract all slow death profiles from INI.
   * An entity can have multiple SlowDeathBehavior modules; one is selected via weighted
   * random on death based on DeathTypes, VeterancyLevels, and ProbabilityModifier.
   */
  private resolveLifetimeDieFrame(objectDef: ObjectDef | undefined): number | null {
    if (!objectDef) return null;
    let minFrames: number | null = null;
    let maxFrames: number | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (minFrames !== null) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'LIFETIMEUPDATE') {
          // Source parity: parseDurationUnsignedInt stores frame counts directly.
          // INI values are in milliseconds, convert to frames.
          minFrames = this.msToLogicFrames(readNumericField(block.fields, ['MinLifetime']) ?? 0);
          maxFrames = this.msToLogicFrames(readNumericField(block.fields, ['MaxLifetime']) ?? 0);
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    if (minFrames === null || maxFrames === null) return null;
    // Source parity: delay = GameLogicRandomValue(min, max), minimum 1 frame.
    const delay = Math.max(1, minFrames === maxFrames
      ? minFrames : this.gameRandom.nextRange(minFrames, maxFrames));
    return this.frameCounter + delay;
  }

  /**
   * Source parity: HeightDieUpdate — extract height-based death profile from INI.
   * C++ file: HeightDieUpdate.cpp — kills entities below target height above terrain.
   */
  private extractHeightDieProfile(objectDef: ObjectDef | undefined): HeightDieProfile | null {
    if (!objectDef) return null;
    let profile: HeightDieProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'HEIGHTDIEUPDATE') {
          profile = {
            targetHeight: readNumericField(block.fields, ['TargetHeight']) ?? 0,
            onlyWhenMovingDown: (readStringField(block.fields, ['OnlyWhenMovingDown'])?.toUpperCase() === 'YES'),
            targetHeightIncludesStructures: (readStringField(block.fields, ['TargetHeightIncludesStructures'])?.toUpperCase() === 'YES'),
            snapToGroundOnDeath: (readStringField(block.fields, ['SnapToGroundOnDeath'])?.toUpperCase() === 'YES'),
            initialDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['InitialDelay']) ?? 0),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: DeletionUpdate — resolve die frame for silent object removal.
   * Same timer logic as LifetimeUpdate but calls destroyObject (instant removal, no death pipeline).
   */
  private resolveDeletionDieFrame(objectDef: ObjectDef | undefined): number | null {
    if (!objectDef) return null;
    let minFrames: number | null = null;
    let maxFrames: number | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (minFrames !== null) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'DELETIONUPDATE') {
          minFrames = this.msToLogicFrames(readNumericField(block.fields, ['MinLifetime']) ?? 0);
          maxFrames = this.msToLogicFrames(readNumericField(block.fields, ['MaxLifetime']) ?? 0);
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    if (minFrames === null || maxFrames === null) return null;
    const delay = Math.max(1, minFrames === maxFrames
      ? minFrames : this.gameRandom.nextRange(minFrames, maxFrames));
    return this.frameCounter + delay;
  }

  private extractSlowDeathProfiles(objectDef: ObjectDef | undefined): SlowDeathProfile[] {
    if (!objectDef) return [];
    const profiles: SlowDeathProfile[] = [];
    const phaseNames = ['INITIAL', 'MIDPOINT', 'FINAL'] as const;

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'DIE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType.includes('SLOWDEATH') || moduleType === 'HELICOPTERSLOWDEATHBEHAVIOR'
            || moduleType === 'JETSLOWDEATHBEHAVIOR') {
          // Parse DeathTypes set.
          const deathTypes = new Set<string>();
          const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
          if (deathTypesStr) {
            for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
              if (token) deathTypes.add(token);
            }
          }

          // Parse VeterancyLevels set.
          const veterancyLevels = new Set<string>();
          const vetStr = readStringField(block.fields, ['VeterancyLevels']);
          if (vetStr) {
            for (const token of vetStr.toUpperCase().split(/\s+/)) {
              if (token) veterancyLevels.add(token);
            }
          }

          // Parse ExemptStatus / RequiredStatus.
          const exemptStatus = new Set<string>();
          const exemptStr = readStringField(block.fields, ['ExemptStatus']);
          if (exemptStr) {
            for (const token of exemptStr.toUpperCase().split(/\s+/)) {
              if (token) exemptStatus.add(token);
            }
          }
          const requiredStatus = new Set<string>();
          const reqStr = readStringField(block.fields, ['RequiredStatus']);
          if (reqStr) {
            for (const token of reqStr.toUpperCase().split(/\s+/)) {
              if (token) requiredStatus.add(token);
            }
          }

          // Parse phase-specific OCLs and Weapons.
          // INI format: "OCL INITIAL OCLName" or "Weapon MIDPOINT WeaponName"
          // Fields can appear multiple times — INI parser stores as string or string[].
          const phaseOCLs: [string[], string[], string[]] = [[], [], []];
          const phaseWeapons: [string[], string[], string[]] = [[], [], []];

          const parsePhaseEntries = (fieldName: string, target: [string[], string[], string[]]): void => {
            const raw = block.fields[fieldName];
            const entries: string[] = [];
            if (typeof raw === 'string') {
              entries.push(raw);
            } else if (Array.isArray(raw)) {
              for (const entry of raw) {
                if (typeof entry === 'string') entries.push(entry);
              }
            }
            for (const entry of entries) {
              const parts = entry.trim().split(/\s+/);
              if (parts.length >= 2) {
                const phaseIdx = phaseNames.indexOf(parts[0]!.toUpperCase() as typeof phaseNames[number]);
                const name = parts[parts.length - 1]!;
                if (phaseIdx >= 0 && name) {
                  target[phaseIdx]!.push(name);
                }
              } else if (parts.length === 1 && parts[0]) {
                target[0]!.push(parts[0]);
              }
            }
          };
          parsePhaseEntries('OCL', phaseOCLs);
          parsePhaseEntries('Weapon', phaseWeapons);

          profiles.push({
            probabilityModifier: readNumericField(block.fields, ['ProbabilityModifier']) ?? 10,
            modifierBonusPerOverkillPercent: readNumericField(block.fields, ['ModifierBonusPerOverkillPercent']) ?? 0,
            sinkDelay: this.msToLogicFrames(readNumericField(block.fields, ['SinkDelay']) ?? 0),
            sinkDelayVariance: this.msToLogicFrames(readNumericField(block.fields, ['SinkDelayVariance']) ?? 0),
            sinkRate: (readNumericField(block.fields, ['SinkRate']) ?? 0) / LOGIC_FRAME_RATE,
            destructionDelay: this.msToLogicFrames(readNumericField(block.fields, ['DestructionDelay']) ?? 0),
            destructionDelayVariance: this.msToLogicFrames(readNumericField(block.fields, ['DestructionDelayVariance']) ?? 0),
            destructionAltitude: readNumericField(block.fields, ['DestructionAltitude']) ?? -10,
            deathTypes,
            veterancyLevels,
            exemptStatus,
            requiredStatus,
            phaseOCLs,
            phaseWeapons,
          });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: HelicopterSlowDeathBehavior — extract helicopter spiral death profiles.
   * C++ file: HelicopterSlowDeathUpdate.cpp (extends SlowDeathBehavior).
   */
  private extractHelicopterSlowDeathProfiles(objectDef: ObjectDef | undefined): HelicopterSlowDeathProfile[] {
    if (!objectDef) return [];
    const profiles: HelicopterSlowDeathProfile[] = [];

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'DIE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'HELICOPTERSLOWDEATHBEHAVIOR') return;

      // DieMuxData fields.
      const deathTypes = new Set<string>();
      const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
      if (deathTypesStr) {
        for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
          if (token) deathTypes.add(token);
        }
      }
      const veterancyLevels = new Set<string>();
      const vetStr = readStringField(block.fields, ['VeterancyLevels']);
      if (vetStr) {
        for (const token of vetStr.toUpperCase().split(/\s+/)) {
          if (token) veterancyLevels.add(token);
        }
      }
      const exemptStatus = new Set<string>();
      const exemptStr = readStringField(block.fields, ['ExemptStatus']);
      if (exemptStr) {
        for (const token of exemptStr.toUpperCase().split(/\s+/)) {
          if (token) exemptStatus.add(token);
        }
      }
      const requiredStatus = new Set<string>();
      const reqStr = readStringField(block.fields, ['RequiredStatus']);
      if (reqStr) {
        for (const token of reqStr.toUpperCase().split(/\s+/)) {
          if (token) requiredStatus.add(token);
        }
      }

      // C++ parseAngularVelocityReal: degrees/sec → radians/frame.
      const degPerSecToRadPerFrame = (v: number): number => (v * Math.PI / 180) / LOGIC_FRAME_RATE;
      // C++ parseVelocityReal: units/sec → units/frame.
      const unitsPerSecToPerFrame = (v: number): number => v / LOGIC_FRAME_RATE;

      // Helicopter-specific fields.
      const spiralOrbitTurnRate = degPerSecToRadPerFrame(
        readNumericField(block.fields, ['SpiralOrbitTurnRate']) ?? 0);
      const spiralOrbitForwardSpeed = unitsPerSecToPerFrame(
        readNumericField(block.fields, ['SpiralOrbitForwardSpeed']) ?? 0);
      const spiralOrbitForwardSpeedDamping =
        readNumericField(block.fields, ['SpiralOrbitForwardSpeedDamping']) ?? 1.0;
      const minSelfSpin = degPerSecToRadPerFrame(
        readNumericField(block.fields, ['MinSelfSpin']) ?? 0);
      const maxSelfSpin = degPerSecToRadPerFrame(
        readNumericField(block.fields, ['MaxSelfSpin']) ?? 0);
      const selfSpinUpdateDelay = this.msToLogicFrames(
        readNumericField(block.fields, ['SelfSpinUpdateDelay']) ?? 0);
      // parseAngleReal: degrees → radians, then divided by FPS in update.
      const selfSpinUpdateAmount = (readNumericField(block.fields, ['SelfSpinUpdateAmount']) ?? 0)
        * Math.PI / 180;
      // parsePercentToReal: percentage → 0-1.
      const fallHowFast = (readNumericField(block.fields, ['FallHowFast']) ?? 50) / 100;
      const delayFromGroundToFinalDeath = this.msToLogicFrames(
        readNumericField(block.fields, ['DelayFromGroundToFinalDeath']) ?? 0);

      // OCL references.
      const oclHitGround: string[] = [];
      const hitGroundStr = readStringField(block.fields, ['OCLHitGround']);
      if (hitGroundStr) oclHitGround.push(hitGroundStr);
      const oclFinalBlowUp: string[] = [];
      const finalStr = readStringField(block.fields, ['OCLFinalBlowUp']);
      if (finalStr) oclFinalBlowUp.push(finalStr);

      const finalRubbleObject = readStringField(block.fields, ['FinalRubbleObject']) ?? '';

      profiles.push({
        deathTypes,
        veterancyLevels,
        exemptStatus,
        requiredStatus,
        spiralOrbitTurnRate,
        spiralOrbitForwardSpeed,
        spiralOrbitForwardSpeedDamping,
        minSelfSpin,
        maxSelfSpin,
        selfSpinUpdateDelay,
        selfSpinUpdateAmount,
        fallHowFast,
        delayFromGroundToFinalDeath,
        oclHitGround,
        oclFinalBlowUp,
        finalRubbleObject,
      });
    };

    for (const block of objectDef.blocks) visitBlock(block);
    if (profiles.length === 0 && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: JetSlowDeathBehavior — extract jet-specific slow death profiles.
   * C++ file: JetSlowDeathBehavior.cpp — roll, FX timeline, forward descent.
   */
  private extractJetSlowDeathProfiles(objectDef: ObjectDef | undefined): JetSlowDeathProfile[] {
    if (!objectDef) return [];
    const profiles: JetSlowDeathProfile[] = [];

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'DIE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'JETSLOWDEATHBEHAVIOR') return;

      // DieMuxData fields.
      const deathTypes = new Set<string>();
      const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
      if (deathTypesStr) {
        for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
          if (token) deathTypes.add(token);
        }
      }
      const veterancyLevels = new Set<string>();
      const vetStr = readStringField(block.fields, ['VeterancyLevels']);
      if (vetStr) {
        for (const token of vetStr.toUpperCase().split(/\s+/)) {
          if (token) veterancyLevels.add(token);
        }
      }
      const exemptStatus = new Set<string>();
      const exemptStr = readStringField(block.fields, ['ExemptStatus']);
      if (exemptStr) {
        for (const token of exemptStr.toUpperCase().split(/\s+/)) {
          if (token) exemptStatus.add(token);
        }
      }
      const requiredStatus = new Set<string>();
      const reqStr = readStringField(block.fields, ['RequiredStatus']);
      if (reqStr) {
        for (const token of reqStr.toUpperCase().split(/\s+/)) {
          if (token) requiredStatus.add(token);
        }
      }

      // C++ parseReal: RollRate and PitchRate are raw floats (not degrees).
      // C++ TODO comment confirms they should use parseAngularVelocityReal but don't.
      // C++ parsePercentToReal: RollRateDelta, FallHowFast → 0-1.
      const rollRate = readNumericField(block.fields, ['RollRate']) ?? 0;
      const rollRateDelta = (readNumericField(block.fields, ['RollRateDelta']) ?? 100) / 100;
      const pitchRate = readNumericField(block.fields, ['PitchRate']) ?? 0;
      const fallHowFast = (readNumericField(block.fields, ['FallHowFast']) ?? 50) / 100;

      // FX/OCL timeline.
      const oclOnGroundDeath: string[] = [];
      const ogStr = readStringField(block.fields, ['OCLOnGroundDeath']);
      if (ogStr) oclOnGroundDeath.push(ogStr);
      const oclInitialDeath: string[] = [];
      const idStr = readStringField(block.fields, ['OCLInitialDeath']);
      if (idStr) oclInitialDeath.push(idStr);
      const delaySecondaryFromInitialDeath = this.msToLogicFrames(
        readNumericField(block.fields, ['DelaySecondaryFromInitialDeath']) ?? 0);
      const oclSecondary: string[] = [];
      const secStr = readStringField(block.fields, ['OCLSecondary']);
      if (secStr) oclSecondary.push(secStr);
      const oclHitGround: string[] = [];
      const hgStr = readStringField(block.fields, ['OCLHitGround']);
      if (hgStr) oclHitGround.push(hgStr);
      const delayFinalBlowUpFromHitGround = this.msToLogicFrames(
        readNumericField(block.fields, ['DelayFinalBlowUpFromHitGround']) ?? 0);
      const oclFinalBlowUp: string[] = [];
      const fbStr = readStringField(block.fields, ['OCLFinalBlowUp']);
      if (fbStr) oclFinalBlowUp.push(fbStr);

      profiles.push({
        deathTypes, veterancyLevels, exemptStatus, requiredStatus,
        oclOnGroundDeath, oclInitialDeath, delaySecondaryFromInitialDeath,
        oclSecondary, oclHitGround, delayFinalBlowUpFromHitGround, oclFinalBlowUp,
        rollRate, rollRateDelta, pitchRate, fallHowFast,
      });
    };

    for (const block of objectDef.blocks) visitBlock(block);
    if (profiles.length === 0 && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: CleanupHazardUpdate — extract cleanup hazard profile from INI.
   * C++ file: CleanupHazardUpdate.cpp — workers scan for CLEANUP_HAZARD entities.
   */
  private extractCleanupHazardProfile(objectDef: ObjectDef | undefined): CleanupHazardProfile | null {
    if (!objectDef) return null;
    for (const block of objectDef.blocks) {
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'CLEANUPHAZARDUPDATE') continue;
      const weaponSlotStr = readStringField(block.fields, ['WeaponSlot'])?.toUpperCase() ?? 'PRIMARY';
      const weaponSlot = weaponSlotStr === 'SECONDARY' ? 'SECONDARY' : weaponSlotStr === 'TERTIARY' ? 'TERTIARY' : 'PRIMARY';
      const scanFrames = this.msToLogicFrames(readNumericField(block.fields, ['ScanRate']) ?? 0);
      const scanRange = readNumericField(block.fields, ['ScanRange']) ?? 0;
      return { weaponSlot, scanFrames, scanRange };
    }
    if (objectDef.parentDef) {
      return this.extractCleanupHazardProfile(objectDef.parentDef);
    }
    return null;
  }

  /**
   * Source parity: AssistedTargetingUpdate — extract assisted targeting profile from INI.
   * C++ file: AssistedTargetingUpdate.cpp — laser designation system.
   */
  private extractAssistedTargetingProfile(objectDef: ObjectDef | undefined): AssistedTargetingProfile | null {
    if (!objectDef) return null;
    for (const block of objectDef.blocks) {
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'ASSISTEDTARGETINGUPDATE') continue;
      const clipSize = readNumericField(block.fields, ['AssistingClipSize']) ?? 1;
      const weaponSlotStr = readStringField(block.fields, ['AssistingWeaponSlot'])?.toUpperCase() ?? 'PRIMARY';
      const weaponSlot = weaponSlotStr === 'SECONDARY' ? 'SECONDARY' : weaponSlotStr === 'TERTIARY' ? 'TERTIARY' : 'PRIMARY';
      const laserFromAssisted = readStringField(block.fields, ['LaserFromAssisted']) ?? '';
      const laserToTarget = readStringField(block.fields, ['LaserToTarget']) ?? '';
      return { clipSize, weaponSlot, laserFromAssisted, laserToTarget };
    }
    if (objectDef.parentDef) {
      return this.extractAssistedTargetingProfile(objectDef.parentDef);
    }
    return null;
  }

  /**
   * Source parity: StructureCollapseUpdate — extract building collapse profile from INI.
   * C++ file: StructureCollapseUpdate.cpp (buildFieldParse) + DieModule.cpp (DieMuxData).
   * One per entity; combines UpdateModule + DieModuleInterface.
   */
  private extractStructureCollapseProfile(objectDef: ObjectDef | undefined): StructureCollapseProfile | null {
    if (!objectDef) return null;
    let profile: StructureCollapseProfile | null = null;

    const scPhaseNames = ['INITIAL', 'DELAY', 'BURST', 'FINAL'] as const;

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'UPDATE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'STRUCTURECOLLAPSEUPDATE') {
          // Parse DieMuxData fields.
          const deathTypes = new Set<string>();
          const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
          if (deathTypesStr) {
            for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
              if (token) deathTypes.add(token);
            }
          }
          const veterancyLevels = new Set<string>();
          const vetStr = readStringField(block.fields, ['VeterancyLevels']);
          if (vetStr) {
            for (const token of vetStr.toUpperCase().split(/\s+/)) {
              if (token) veterancyLevels.add(token);
            }
          }
          const exemptStatus = new Set<string>();
          const exemptStr = readStringField(block.fields, ['ExemptStatus']);
          if (exemptStr) {
            for (const token of exemptStr.toUpperCase().split(/\s+/)) {
              if (token) exemptStatus.add(token);
            }
          }
          const requiredStatus = new Set<string>();
          const reqStr = readStringField(block.fields, ['RequiredStatus']);
          if (reqStr) {
            for (const token of reqStr.toUpperCase().split(/\s+/)) {
              if (token) requiredStatus.add(token);
            }
          }

          // Parse phase OCLs: "OCL INITIAL SomeOCLName AnotherOCL"
          const phaseOCLs: [string[], string[], string[], string[]] = [[], [], [], []];
          const rawOCL = block.fields['OCL'];
          const oclEntries: string[] = [];
          if (typeof rawOCL === 'string') {
            oclEntries.push(rawOCL);
          } else if (Array.isArray(rawOCL)) {
            for (const e of rawOCL) {
              if (typeof e === 'string') oclEntries.push(e);
            }
          }
          for (const entry of oclEntries) {
            const parts = entry.trim().split(/\s+/);
            if (parts.length >= 2) {
              const phaseIdx = scPhaseNames.indexOf(parts[0]!.toUpperCase() as typeof scPhaseNames[number]);
              if (phaseIdx >= 0) {
                // All subsequent tokens are OCL names for this phase.
                for (let i = 1; i < parts.length; i++) {
                  if (parts[i]) phaseOCLs[phaseIdx]!.push(parts[i]!);
                }
              }
            }
          }

          profile = {
            deathTypes,
            veterancyLevels,
            exemptStatus,
            requiredStatus,
            minCollapseDelay: this.msToLogicFrames(readNumericField(block.fields, ['MinCollapseDelay']) ?? 0),
            maxCollapseDelay: this.msToLogicFrames(readNumericField(block.fields, ['MaxCollapseDelay']) ?? 0),
            minBurstDelay: this.msToLogicFrames(readNumericField(block.fields, ['MinBurstDelay']) ?? 9999),
            maxBurstDelay: this.msToLogicFrames(readNumericField(block.fields, ['MaxBurstDelay']) ?? 9999),
            collapseDamping: readNumericField(block.fields, ['CollapseDamping']) ?? 0.0,
            bigBurstFrequency: readNumericField(block.fields, ['BigBurstFrequency']) ?? 0,
            phaseOCLs,
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: EMPUpdate — extract EMP pulse configuration from INI.
   * C++ file: EMPUpdate.h/cpp. Attached to the EMP pulse object.
   */
  private extractEmpUpdateProfile(objectDef: ObjectDef | undefined): EMPUpdateProfile | null {
    if (!objectDef) return null;
    let profile: EMPUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'EMPUPDATE') return;

      const victimRequiredKindOf = new Set<string>();
      const victimForbiddenKindOf = new Set<string>();
      const victimReqRaw = readStringField(block.fields, ['VictimRequiredKindOf']);
      if (victimReqRaw) {
        for (const token of victimReqRaw.trim().split(/\s+/)) {
          if (token) victimRequiredKindOf.add(token.toUpperCase());
        }
      }
      const victimForbidRaw = readStringField(block.fields, ['VictimForbiddenKindOf']);
      if (victimForbidRaw) {
        for (const token of victimForbidRaw.trim().split(/\s+/)) {
          if (token) victimForbiddenKindOf.add(token.toUpperCase());
        }
      }

      profile = {
        lifetimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['Lifetime']) ?? 33),
        startFadeFrame: this.msToLogicFrames(readNumericField(block.fields, ['StartFadeTime']) ?? 0),
        disabledDurationFrames: this.msToLogicFrames(readNumericField(block.fields, ['DisabledDuration']) ?? 0),
        effectRadius: readNumericField(block.fields, ['EffectRadius']) ?? 200.0,
        doesNotAffectMyOwnBuildings: readStringField(block.fields, ['DoesNotAffectMyOwnBuildings'])?.toUpperCase() === 'YES',
        victimRequiredKindOf,
        victimForbiddenKindOf,
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: HijackerUpdate — extract hijacker profile from INI.
   * C++ file: HijackerUpdate.h/cpp.
   */
  private extractHijackerUpdateProfile(objectDef: ObjectDef | undefined): HijackerUpdateProfile | null {
    if (!objectDef) return null;
    let profile: HijackerUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'HIJACKERUPDATE') return;
      profile = {
        parachuteName: readStringField(block.fields, ['ParachuteName']) ?? null,
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: LeafletDropBehavior — extract leaflet drop profile from INI.
   * C++ file: EMPUpdate.h (same header). Delays before disabling enemy infantry+vehicles in radius.
   */
  private extractLeafletDropProfile(objectDef: ObjectDef | undefined): LeafletDropProfile | null {
    if (!objectDef) return null;
    let profile: LeafletDropProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'LEAFLETDROPBEHAVIOR') return;
      profile = {
        delayFrames: this.msToLogicFrames(readNumericField(block.fields, ['Delay']) ?? 33),
        disabledDurationFrames: this.msToLogicFrames(readNumericField(block.fields, ['DisabledDuration']) ?? 0),
        affectRadius: readNumericField(block.fields, ['AffectRadius']) ?? 60.0,
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: SmartBombTargetHomingUpdate — extract course correction profile from INI.
   * C++ file: SmartBombTargetHomingUpdate.h (buildFieldParse).
   */
  private extractSmartBombProfile(objectDef: ObjectDef | undefined): SmartBombTargetHomingProfile | null {
    if (!objectDef) return null;
    let profile: SmartBombTargetHomingProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'SMARTBOMBTARGETHOMINGUPDATE') return;
      profile = {
        courseCorrectionScalar: readNumericField(block.fields, ['CourseCorrectionScalar']) ?? 0.99,
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: DynamicGeometryInfoUpdate — extract geometry morphing profile from INI.
   * C++ file: DynamicGeometryInfoUpdate.cpp (buildFieldParse).
   */
  private extractDynamicGeometryProfile(objectDef: ObjectDef | undefined): DynamicGeometryInfoUpdateProfile | null {
    if (!objectDef) return null;
    let profile: DynamicGeometryInfoUpdateProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'DYNAMICGEOMETRYINFOUPDATE') return;
      profile = {
        initialDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['InitialDelay']) ?? 0),
        initialHeight: readNumericField(block.fields, ['InitialHeight']) ?? 0,
        initialMajorRadius: readNumericField(block.fields, ['InitialMajorRadius']) ?? 0,
        initialMinorRadius: readNumericField(block.fields, ['InitialMinorRadius']) ?? 0,
        finalHeight: readNumericField(block.fields, ['FinalHeight']) ?? 0,
        finalMajorRadius: readNumericField(block.fields, ['FinalMajorRadius']) ?? 0,
        finalMinorRadius: readNumericField(block.fields, ['FinalMinorRadius']) ?? 0,
        transitionTimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['TransitionTime']) ?? 1),
        reverseAtTransitionTime: (readStringField(block.fields, ['ReverseAtTransitionTime']) ?? '').toUpperCase() === 'YES',
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: FireOCLAfterWeaponCooldownUpdate — extract OCL-after-cooldown profiles from INI.
   * C++ file: FireOCLAfterWeaponCooldownUpdate.cpp (buildFieldParse).
   * Multiple modules per entity are allowed.
   */
  private extractFireOCLAfterCooldownProfiles(objectDef: ObjectDef | undefined): FireOCLAfterWeaponCooldownProfile[] {
    if (!objectDef) return [];
    const profiles: FireOCLAfterWeaponCooldownProfile[] = [];
    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'FIREOCLAFTERWEAPONCOOLDOWNUPDATE') return;
      const slotStr = (readStringField(block.fields, ['WeaponSlot']) ?? 'PRIMARY').toUpperCase();
      const slot = slotStr === 'SECONDARY' ? 1 : slotStr === 'TERTIARY' ? 2 : 0;
      profiles.push({
        weaponSlot: slot,
        oclName: readStringField(block.fields, ['OCL']) ?? '',
        minShotsRequired: readNumericField(block.fields, ['MinShotsToCreateOCL']) ?? 1,
        oclLifetimePerSecond: readNumericField(block.fields, ['OCLLifetimePerSecond']) ?? 1000,
        oclMaxFrames: this.msToLogicFrames(readNumericField(block.fields, ['OCLLifetimeMaxCap']) ?? 33333),
      });
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: NeutronBlastBehavior — extract neutron blast profile from INI.
   * C++ file: NeutronBlastBehavior.h (buildFieldParse).
   */
  private extractNeutronBlastProfile(objectDef: ObjectDef | undefined): NeutronBlastProfile | null {
    if (!objectDef) return null;
    let profile: NeutronBlastProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'NEUTRONBLASTBEHAVIOR') return;
      profile = {
        blastRadius: readNumericField(block.fields, ['BlastRadius']) ?? 10.0,
        affectAirborne: (readStringField(block.fields, ['AffectAirborne']) ?? 'Yes').toUpperCase() !== 'NO',
        affectAllies: (readStringField(block.fields, ['AffectAllies']) ?? 'Yes').toUpperCase() !== 'NO',
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (!profile && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: BunkerBusterBehavior — extract bunker buster profile from INI.
   * C++ file: BunkerBusterBehavior.h (buildFieldParse).
   */
  private extractBunkerBusterProfile(objectDef: ObjectDef | undefined): BunkerBusterProfile | null {
    if (!objectDef) return null;
    let profile: BunkerBusterProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'BUNKERBUSTERBEHAVIOR') return;
      profile = {
        upgradeRequired: (readStringField(block.fields, ['UpgradeRequired']) ?? '').trim().toUpperCase(),
        occupantDamageWeaponName: (readStringField(block.fields, ['OccupantDamageWeaponTemplate']) ?? '').trim(),
        shockwaveWeaponName: (readStringField(block.fields, ['ShockwaveWeaponTemplate']) ?? '').trim(),
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (!profile && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: GrantStealthBehavior — extract expanding stealth grant profile from INI.
   * C++ file: GrantStealthBehavior.h (buildFieldParse).
   */
  private extractGrantStealthProfile(objectDef: ObjectDef | undefined): GrantStealthProfile | null {
    if (!objectDef) return null;
    let profile: GrantStealthProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'GRANTSTEALTHBEHAVIOR') return;
      const kindOfStr = readStringField(block.fields, ['KindOf']);
      profile = {
        startRadius: readNumericField(block.fields, ['StartRadius']) ?? 0,
        finalRadius: readNumericField(block.fields, ['FinalRadius']) ?? 200,
        radiusGrowRate: readNumericField(block.fields, ['RadiusGrowRate']) ?? 10,
        kindOf: kindOfStr ? new Set(kindOfStr.split(/\s+/).map(s => s.toUpperCase())) : null,
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (!profile && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: NeutronMissileSlowDeathBehavior — extract blast wave profile from INI.
   * C++ file: NeutronMissileSlowDeathUpdate.h (buildFieldParse).
   * Up to 9 blast waves with independent delay/radius/damage/topple.
   */
  private extractNeutronMissileSlowDeathProfile(objectDef: ObjectDef | undefined): NeutronMissileSlowDeathProfile | null {
    if (!objectDef) return null;
    let profile: NeutronMissileSlowDeathProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'DIE' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'NEUTRONMISSILESLOWDEATHBEHAVIOR') return;
      const blasts: NeutronMissileBlastInfo[] = [];
      // Source parity: MAX_NEUTRON_BLASTS = 9 (indices 1-9 in INI).
      for (let i = 1; i <= 9; i++) {
        const prefix = `Blast${i}`;
        const enabled = (readStringField(block.fields, [`${prefix}Enabled`]) ?? 'No').toUpperCase() === 'YES';
        blasts.push({
          enabled,
          delay: this.msToLogicFrames(readNumericField(block.fields, [`${prefix}Delay`]) ?? 0),
          scorchDelay: this.msToLogicFrames(readNumericField(block.fields, [`${prefix}ScorchDelay`]) ?? 0),
          innerRadius: readNumericField(block.fields, [`${prefix}InnerRadius`]) ?? 0,
          outerRadius: readNumericField(block.fields, [`${prefix}OuterRadius`]) ?? 0,
          maxDamage: readNumericField(block.fields, [`${prefix}MaxDamage`]) ?? 0,
          minDamage: readNumericField(block.fields, [`${prefix}MinDamage`]) ?? 0,
          toppleSpeed: readNumericField(block.fields, [`${prefix}ToppleSpeed`]) ?? 0,
        });
      }
      profile = { blasts };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (!profile && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: TechBuildingBehavior — extract profile from INI.
   * C++ file: TechBuildingBehavior.cpp (buildFieldParse).
   */
  private extractTechBuildingProfile(objectDef: ObjectDef | undefined): TechBuildingBehaviorProfile | null {
    if (!objectDef) return null;
    let profile: TechBuildingBehaviorProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'TECHBUILDINGBEHAVIOR') return;
      profile = {
        pulseFXRateFrames: this.msToLogicFrames(readNumericField(block.fields, ['PulseFXRate']) ?? 0),
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (!profile && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: SupplyWarehouseCripplingBehavior — extract self-heal profile from INI.
   * C++ file: SupplyWarehouseCripplingBehavior.cpp (buildFieldParse).
   */
  private extractSupplyWarehouseCripplingProfile(objectDef: ObjectDef | undefined): SupplyWarehouseCripplingProfile | null {
    if (!objectDef) return null;
    let profile: SupplyWarehouseCripplingProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile) return;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR' && blockType !== 'UPDATE') return;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'SUPPLYWAREHOUSECRIPPLINGBEHAVIOR') return;
      profile = {
        selfHealSuppressionFrames: this.msToLogicFrames(readNumericField(block.fields, ['SelfHealSupression']) ?? 0),
        selfHealDelayFrames: this.msToLogicFrames(readNumericField(block.fields, ['SelfHealDelay']) ?? 0),
        selfHealAmount: readNumericField(block.fields, ['SelfHealAmount']) ?? 0,
      };
    };
    for (const block of objectDef.blocks) visitBlock(block);
    if (!profile && objectDef.parentDef) {
      for (const block of objectDef.parentDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: InstantDeathBehavior — extract die module profiles from INI.
   * C++ file: InstantDeathBehavior.cpp (buildFieldParse) + DieModule.cpp (DieMuxData).
   * An entity can have multiple InstantDeathBehavior modules; all matching ones fire on death.
   */
  private extractInstantDeathProfiles(objectDef: ObjectDef | undefined): InstantDeathProfile[] {
    if (!objectDef) return [];
    const profiles: InstantDeathProfile[] = [];

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'DIE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'INSTANTDEATHBEHAVIOR' || moduleType === 'DESTROYDIE') {
          // Parse DieMuxData fields.
          const deathTypes = new Set<string>();
          const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
          if (deathTypesStr) {
            for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
              if (token) deathTypes.add(token);
            }
          }

          const veterancyLevels = new Set<string>();
          const vetStr = readStringField(block.fields, ['VeterancyLevels']);
          if (vetStr) {
            for (const token of vetStr.toUpperCase().split(/\s+/)) {
              if (token) veterancyLevels.add(token);
            }
          }

          const exemptStatus = new Set<string>();
          const exemptStr = readStringField(block.fields, ['ExemptStatus']);
          if (exemptStr) {
            for (const token of exemptStr.toUpperCase().split(/\s+/)) {
              if (token) exemptStatus.add(token);
            }
          }

          const requiredStatus = new Set<string>();
          const reqStr = readStringField(block.fields, ['RequiredStatus']);
          if (reqStr) {
            for (const token of reqStr.toUpperCase().split(/\s+/)) {
              if (token) requiredStatus.add(token);
            }
          }

          // Parse effect lists (Weapon, OCL — space-separated or multi-valued).
          const weaponNames: string[] = [];
          const weaponRaw = block.fields['Weapon'];
          if (typeof weaponRaw === 'string') {
            const name = weaponRaw.trim();
            if (name) weaponNames.push(name);
          } else if (Array.isArray(weaponRaw)) {
            for (const entry of weaponRaw) {
              const name = typeof entry === 'string' ? entry.trim() : '';
              if (name) weaponNames.push(name);
            }
          }

          const oclNames: string[] = [];
          const oclRaw = block.fields['OCL'];
          if (typeof oclRaw === 'string') {
            const name = oclRaw.trim();
            if (name) oclNames.push(name);
          } else if (Array.isArray(oclRaw)) {
            for (const entry of oclRaw) {
              const name = typeof entry === 'string' ? entry.trim() : '';
              if (name) oclNames.push(name);
            }
          }

          profiles.push({
            deathTypes,
            veterancyLevels,
            exemptStatus,
            requiredStatus,
            weaponNames,
            oclNames,
          });
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: FireWeaponWhenDeadBehavior — extract profiles from INI.
   * C++ file: FireWeaponWhenDeadBehavior.cpp (buildFieldParse) + DieModule.cpp (DieMuxData).
   */
  private extractFireWeaponWhenDeadProfiles(objectDef: ObjectDef | undefined): FireWeaponWhenDeadProfile[] {
    if (!objectDef) return [];
    const profiles: FireWeaponWhenDeadProfile[] = [];

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'DIE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'FIREWEAPONWHENDEADBEHAVIOR') {
          // Parse DieMuxData fields.
          const deathTypes = new Set<string>();
          const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
          if (deathTypesStr) {
            for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
              if (token) deathTypes.add(token);
            }
          }

          const veterancyLevels = new Set<string>();
          const vetStr = readStringField(block.fields, ['VeterancyLevels']);
          if (vetStr) {
            for (const token of vetStr.toUpperCase().split(/\s+/)) {
              if (token) veterancyLevels.add(token);
            }
          }

          const exemptStatus = new Set<string>();
          const exemptStr = readStringField(block.fields, ['ExemptStatus']);
          if (exemptStr) {
            for (const token of exemptStr.toUpperCase().split(/\s+/)) {
              if (token) exemptStatus.add(token);
            }
          }

          const requiredStatus = new Set<string>();
          const reqStr = readStringField(block.fields, ['RequiredStatus']);
          if (reqStr) {
            for (const token of reqStr.toUpperCase().split(/\s+/)) {
              if (token) requiredStatus.add(token);
            }
          }

          const deathWeaponName = readStringField(block.fields, ['DeathWeapon']) ?? '';
          // Source parity: C++ UpgradeMuxData::m_initiallyActive defaults to false.
          const startsActive = readBooleanField(block.fields, ['StartsActive']) ?? false;

          const triggeredBy: string[] = [];
          const triggeredByStr = readStringField(block.fields, ['TriggeredBy']);
          if (triggeredByStr) {
            for (const token of triggeredByStr.split(/\s+/)) {
              if (token) triggeredBy.push(token);
            }
          }

          const conflictsWith: string[] = [];
          const conflictsStr = readStringField(block.fields, ['ConflictsWith']);
          if (conflictsStr) {
            for (const token of conflictsStr.split(/\s+/)) {
              if (token) conflictsWith.push(token);
            }
          }

          if (deathWeaponName) {
            profiles.push({
              deathTypes,
              veterancyLevels,
              exemptStatus,
              requiredStatus,
              deathWeaponName,
              startsActive,
              triggeredBy,
              conflictsWith,
            });
          }
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profiles;
  }

  /**
   * Source parity: MinefieldBehavior module — extract mine configuration from INI.
   */
  private extractMinefieldProfile(objectDef: ObjectDef | undefined): MinefieldProfile | null {
    if (!objectDef) return null;
    let profile: MinefieldProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) return;
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'MINEFIELDBEHAVIOR') {
          // Parse DetonatedBy relationship mask.
          let detonatedByMask = MINE_DEFAULT_DETONATED_BY;
          const detonatedByStr = readStringField(block.fields, ['DetonatedBy'])?.toUpperCase();
          if (detonatedByStr) {
            detonatedByMask = 0;
            if (detonatedByStr.includes('ALLIES')) detonatedByMask |= MINE_DETONATED_BY_ALLIES;
            if (detonatedByStr.includes('ENEMIES')) detonatedByMask |= MINE_DETONATED_BY_ENEMIES;
            if (detonatedByStr.includes('NEUTRAL')) detonatedByMask |= MINE_DETONATED_BY_NEUTRAL;
          }

          profile = {
            detonationWeaponName: readStringField(block.fields, ['DetonationWeapon']) ?? null,
            detonatedByMask,
            numVirtualMines: readNumericField(block.fields, ['NumVirtualMines']) ?? 1,
            regenerates: readBooleanField(block.fields, ['Regenerates']) ?? false,
            workersDetonate: readBooleanField(block.fields, ['WorkersDetonate']) ?? false,
            repeatDetonateMoveThresh: readNumericField(block.fields, ['RepeatDetonateMoveThresh']) ?? 1.0,
            stopsRegenAfterCreatorDies: readBooleanField(block.fields, ['StopsRegenAfterCreatorDies']) ?? true,
            degenPercentPerSecondAfterCreatorDies: readNumericField(block.fields, ['DegenPercentPerSecondAfterCreatorDies']) ?? 0,
            scootFromStartingPointTimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['ScootFromStartingPointTime']) ?? 0),
          };
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return profile;
  }

  /**
   * Source parity: EjectPilotDie module — extract pilot template name from INI.
   * Searches for EjectPilotDie or HelicopterSlowDeathBehavior with OCLEjectPilot.
   */
  private extractEjectPilotTemplateName(objectDef: ObjectDef | undefined): string | null {
    if (!objectDef) return null;
    let pilotName: string | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (pilotName !== null) return;
      const blockType = block.type.toUpperCase();
      if (blockType === 'BEHAVIOR' || blockType === 'DIE') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'EJECTPILOTDIE' || moduleType === 'HELICOPTERSLOWDEATHBEHAVIOR') {
          // Look for OCLEjectPilot or CreationList fields that reference an OCL containing the pilot
          const oclName = readStringField(block.fields, ['GroundCreationList', 'AirCreationList', 'OCLEjectPilot']);
          if (oclName) {
            // Resolve the OCL to find the pilot unit template name.
            // For now, use a convention-based approach:
            // Most EjectPilot OCLs create an infantry pilot unit like 'AmericaPilot' or 'ChinaPilot'.
            pilotName = oclName;
          }
        }
      }
      if (block.blocks) {
        for (const child of block.blocks) visitBlock(child);
      }
    };
    if (objectDef.blocks) {
      for (const block of objectDef.blocks) visitBlock(block);
    }
    return pilotName;
  }

  private extractRailedTransportProfile(objectDef: ObjectDef | undefined): RailedTransportProfile | null {
    return extractRailedTransportProfileImpl(objectDef);
  }

  private extractHackInternetProfile(objectDef: ObjectDef | undefined): HackInternetProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: HackInternetProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'HACKINTERNETAIUPDATE') {
          const unpackTimeMs = readNumericField(block.fields, ['UnpackTime']) ?? 0;
          const packTimeMs = readNumericField(block.fields, ['PackTime']) ?? 0;
          const cashUpdateDelayMs = readNumericField(block.fields, ['CashUpdateDelay']) ?? 0;
          const cashUpdateDelayFastMs = readNumericField(block.fields, ['CashUpdateDelayFast']) ?? cashUpdateDelayMs;
          profile = {
            unpackTimeFrames: this.msToLogicFrames(unpackTimeMs),
            packTimeFrames: this.msToLogicFrames(packTimeMs),
            cashUpdateDelayFrames: this.msToLogicFrames(cashUpdateDelayMs),
            cashUpdateDelayFastFrames: this.msToLogicFrames(cashUpdateDelayFastMs),
            regularCashAmount: Math.max(0, Math.trunc(readNumericField(block.fields, ['RegularCashAmount']) ?? 0)),
            veteranCashAmount: Math.max(0, Math.trunc(readNumericField(block.fields, ['VeteranCashAmount']) ?? 0)),
            eliteCashAmount: Math.max(0, Math.trunc(readNumericField(block.fields, ['EliteCashAmount']) ?? 0)),
            heroicCashAmount: Math.max(0, Math.trunc(readNumericField(block.fields, ['HeroicCashAmount']) ?? 0)),
          };
          return;
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  private extractOverchargeBehaviorProfile(objectDef: ObjectDef | null | undefined): OverchargeBehaviorProfile | null {
    if (!objectDef) {
      return null;
    }

    let profile: OverchargeBehaviorProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === 'OVERCHARGEBEHAVIOR') {
          const drainPercent = this.parsePercent(this.readIniFieldValue(block.fields, 'HealthPercentToDrainPerSecond')) ?? 0;
          const minHealthPercent = this.parsePercent(
            this.readIniFieldValue(block.fields, 'NotAllowedWhenHealthBelowPercent'),
          ) ?? 0;
          profile = {
            healthPercentToDrainPerSecond: Math.max(0, drainPercent),
            notAllowedWhenHealthBelowPercent: clamp(minHealthPercent, 0, 1),
          };
          return;
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return profile;
  }

  /**
   * Source parity: PowerPlantUpdateModuleData::buildFieldParse — RodsExtendTime field.
   */
  private extractPowerPlantUpdateProfile(objectDef: ObjectDef | undefined): PowerPlantUpdateProfile | null {
    if (!objectDef) return null;
    let profile: PowerPlantUpdateProfile | null = null;
    for (const block of objectDef.blocks) {
      if (profile) break;
      const blockType = block.type.toUpperCase();
      if (blockType !== 'BEHAVIOR') continue;
      const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
      if (moduleType !== 'POWERPLANTUPDATE') continue;
      profile = {
        rodsExtendTimeFrames: this.msToLogicFrames(readNumericField(block.fields, ['RodsExtendTime']) ?? 0),
      };
    }
    return profile;
  }

  private extractUpgradeModules(objectDef: ObjectDef | undefined): UpgradeModuleProfile[] {
    if (!objectDef) {
      return [];
    }

    return this.extractUpgradeModulesFromBlocks(objectDef.blocks);
  }

  private extractSpecialPowerModules(objectDef: ObjectDef | undefined): Map<string, SpecialPowerModuleProfile> {
    const specialPowerModules = new Map<string, SpecialPowerModuleProfile>();
    if (!objectDef) {
      return specialPowerModules;
    }

    const visitBlock = (block: IniBlock): void => {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        const specialPowerTemplate = readStringField(block.fields, ['SpecialPowerTemplate']);
        if (specialPowerTemplate) {
          const normalizedSpecialPowerTemplate = specialPowerTemplate.trim().toUpperCase();
          if (normalizedSpecialPowerTemplate && normalizedSpecialPowerTemplate !== 'NONE') {
            specialPowerModules.set(normalizedSpecialPowerTemplate, {
              specialPowerTemplateName: normalizedSpecialPowerTemplate,
              moduleType,
              updateModuleStartsAttack: readBooleanField(block.fields, ['UpdateModuleStartsAttack']) === true,
              startsPaused: readBooleanField(block.fields, ['StartsPaused']) === true,
              // Source parity: read module-specific INI parameters.
              cashHackMoneyAmount: readNumericField(block.fields, ['MoneyAmount']) ?? 0,
              cashBountyPercent: readNumericField(block.fields, ['Bounty']) ?? 0,
              spyVisionBaseDurationMs: readNumericField(block.fields, ['BaseDuration']) ?? 0,
              fireWeaponMaxShots: readNumericField(block.fields, ['MaxShotsToFire']) ?? 1,
              cleanupMoveRange: readNumericField(block.fields, ['MaxMoveDistanceFromLocation']) ?? 0,
              // Source parity: OCLSpecialPower OCL name.
              oclName: readStringField(block.fields, ['OCL']) ?? '',
              // NOTE: In the original engine, area damage/heal parameters live on weapon templates
              // spawned via OCL, not on the special power module itself. These field names are
              // forward-looking placeholders for OCL-less parameter passing; real game INI files
              // won't populate them (they'll fall through to DEFAULT_* constants).
              areaDamageRadius: readNumericField(block.fields, ['Radius', 'WeaponRadius', 'DamageRadius']) ?? 0,
              areaDamageAmount: readNumericField(block.fields, ['Damage', 'DamageAmount']) ?? 0,
              areaHealAmount: readNumericField(block.fields, ['HealAmount', 'RepairAmount']) ?? 0,
              areaHealRadius: readNumericField(block.fields, ['HealRange', 'HealRadius', 'RepairRange']) ?? 0,
            });
          }
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return specialPowerModules;
  }

  private extractUpgradeModulesFromBlocks(
    blocks: IniBlock[] = [],
    sourceUpgradeName: string | null = null,
  ): UpgradeModuleProfile[] {
    return extractUpgradeModulesFromBlocksImpl(
      blocks,
      sourceUpgradeName,
      {
        parseUpgradeNames: (value) => this.parseUpgradeNames(value),
        parseObjectStatusNames: (value) => this.parseObjectStatusNames(value),
        parseKindOf: (value) => this.parseKindOf(value),
        parsePercent: (value) => this.parsePercent(value),
      },
    );
  }

  private applyUnpauseSpecialPowerUpgradeModule(
    entity: MapEntity,
    module: UpgradeModuleProfile,
  ): boolean {
    const specialPowerTemplateName = module.specialPowerTemplateName.trim().toUpperCase();
    if (!specialPowerTemplateName) {
      return false;
    }

    let isSharedSynced = false;
    const specialPowerDef = this.resolveSpecialPowerDefByName(specialPowerTemplateName);
    if (specialPowerDef) {
      isSharedSynced = readBooleanField(specialPowerDef.fields, ['SharedSyncedTimer']) === true;
    }

    // Source parity: UnpauseSpecialPowerUpgrade::upgradeImplementation() calls
    // pauseCountdown(FALSE) on the matching SpecialPowerModule.
    this.setSpecialPowerReadyFrame(specialPowerTemplateName, entity.id, isSharedSynced, this.frameCounter);
    return true;
  }

  /**
   * Source parity: ExperienceScalarUpgrade.cpp line 85 — adds XP scalar to experience tracker.
   */
  private applyExperienceScalarUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    if (!entity.experienceProfile) {
      return false;
    }
    entity.experienceState.experienceScalar += module.addXPScalar;
    return true;
  }

  private removeExperienceScalarUpgrade(entity: MapEntity, module: UpgradeModuleProfile): void {
    if (!entity.experienceProfile) {
      return;
    }
    entity.experienceState.experienceScalar -= module.addXPScalar;
  }

  /**
   * Source parity: ModelConditionUpgrade.cpp line 78 — sets a model condition flag.
   */
  private applyModelConditionUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    if (!module.conditionFlag) {
      return false;
    }
    entity.modelConditionFlags.add(module.conditionFlag);
    return true;
  }

  private removeModelConditionUpgrade(entity: MapEntity, module: UpgradeModuleProfile): void {
    if (!module.conditionFlag) {
      return;
    }
    // Only remove if no other active ModelConditionUpgrade also sets this flag.
    const hasOtherSource = entity.upgradeModules.some(
      (other) => other.moduleType === 'MODELCONDITIONUPGRADE'
        && other.conditionFlag === module.conditionFlag
        && other.id !== module.id
        && entity.executedUpgradeModules.has(other.id),
    );
    if (!hasOtherSource) {
      entity.modelConditionFlags.delete(module.conditionFlag);
    }
  }

  /**
   * Source parity: ObjectCreationUpgrade.cpp line 97 — executes OCL on upgrade application.
   */
  private applyObjectCreationUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    if (!module.upgradeObjectOCLName) {
      return false;
    }
    this.executeOCL(module.upgradeObjectOCLName, entity);
    return true;
  }

  /**
   * Source parity: ActiveShroudUpgrade.cpp line 87 — sets entity's active shroud range.
   * C++ calls Object::setShroudRange() (m_shroudRange), NOT visionRange.
   * This is the GPS Scrambler-style active shrouding distance, not sight distance.
   */
  private applyActiveShroudUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    // Source parity: C++ does not guard against zero — it always applies.
    entity.shroudRange = module.newShroudRange;
    return true;
  }

  // DEVIATION: C++ does not override processUpgradeRemoval for ActiveShroudUpgrade.
  // Upgrade removal only processes RemovesUpgrades in the base class. This removal
  // method is a conservative addition for completeness.
  private removeActiveShroudUpgrade(entity: MapEntity, _module: UpgradeModuleProfile): void {
    entity.shroudRange = 0;
  }

  /**
   * Source parity: ReplaceObjectUpgrade.cpp line 70-108.
   * Destroys the current entity and creates a replacement at the same position/rotation/team.
   * Fires onBuildComplete on the replacement and then notifies player structure completion.
   */
  private applyReplaceObjectUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    if (!module.replaceObjectName) {
      return false;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }

    // Resolve the replacement template.
    const replacementDef = findObjectDefByName(registry, module.replaceObjectName);
    if (!replacementDef) {
      return false;
    }

    // Capture the old entity's transform and team before destruction.
    const oldX = entity.x;
    const oldZ = entity.z;
    const oldY = entity.y;
    const oldRotationY = entity.rotationY;
    const oldSide = entity.side;
    const oldControllingPlayerToken = entity.controllingPlayerToken;

    // Source parity: C++ line 88-89 — remove from pathfind then destroy.
    this.silentDestroyEntity(entity.id);

    // Source parity: C++ line 91-93 — create replacement with same team and position.
    const replacement = this.spawnEntityFromTemplate(
      replacementDef.name,
      oldX,
      oldZ,
      oldRotationY,
      oldSide,
    );
    if (!replacement) {
      return true; // Old entity was already destroyed; nothing more we can do.
    }

    replacement.y = oldY;
    replacement.controllingPlayerToken = oldControllingPlayerToken;

    // Source parity: C++ line 97-103 — call onBuildComplete on all create modules.
    // GrantUpgradeCreate::onBuildComplete
    for (const prof of replacement.grantUpgradeCreateProfiles) {
      this.applyGrantUpgradeCreate(replacement, prof);
    }
    // VeterancyGainCreate::onCreate semantics are side/science dependent. ReplaceObjectUpgrade
    // runs onBuildComplete after side transfer, so re-evaluate veterancy with final owner side.
    for (const prof of replacement.veterancyGainCreateProfiles) {
      if (prof.scienceRequired === null || this.hasSideScience(replacement.side ?? '', prof.scienceRequired)) {
        this.setMinVeterancyLevel(replacement, prof.startingLevel);
      }
    }
    // LockWeaponCreate::onBuildComplete
    if (replacement.lockWeaponCreateSlot !== null) {
      replacement.forcedWeaponSlot = replacement.lockWeaponCreateSlot;
      replacement.weaponLockStatus = 'LOCKED_PERMANENTLY';
    }
    // SpecialPowerCreate::onBuildComplete
    if (replacement.hasSpecialPowerCreate) {
      this.onBuildCompleteSpecialPowerCreate(replacement);
    }
    if (replacement.kindOf.has('STRUCTURE')) {
      this.onStructureConstructionComplete(entity, replacement, false);
    }

    return true;
  }

  private applyCostModifierUpgradeModule(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    const side = this.normalizeSide(entity.side);
    if (!side) {
      return false;
    }

    // Source parity: CostModifierUpgrade.cpp calls Player::addKindOfProductionCostChange on upgrade completion.
    this.applyCostModifierUpgradeToSide(side, module);
    return true;
  }

  private applyCostModifierUpgradeToSide(side: string, module: UpgradeModuleProfile): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    // Source parity: Player::addKindOfProductionCostChange updates a refcounted side production list.
    applyCostModifierUpgradeToSideImpl(this.getSideKindOfProductionCostModifiers(normalizedSide), module);
  }

  private removeCostModifierUpgradeFromSide(side: string, module: UpgradeModuleProfile): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    // Source parity: Player::removeKindOfProductionCostChange decrements refcount and removes at zero.
    removeCostModifierUpgradeFromSideImpl(this.getSideKindOfProductionCostModifiers(normalizedSide), module);
  }

  private removeCostModifierUpgradeFromEntity(entity: MapEntity, module: UpgradeModuleProfile): void {
    const side = this.normalizeSide(entity.side);
    if (!side) {
      return;
    }
    this.removeCostModifierUpgradeFromSide(side, module);
  }

  private transferCostModifierUpgradesBetweenSides(entity: MapEntity, oldSide: string, newSide: string): void {
    const normalizedOldSide = this.normalizeSide(oldSide);
    const normalizedNewSide = this.normalizeSide(newSide);
    if (!normalizedOldSide || !normalizedNewSide || normalizedOldSide === normalizedNewSide) {
      return;
    }
    this.transferCostModifierUpgradesBetweenSidesForCapture(entity, normalizedOldSide, normalizedNewSide);
  }

  private transferCostModifierUpgradesBetweenSidesForCapture(
    entity: MapEntity,
    oldSide: string,
    newSide: string,
  ): void {
    if (!oldSide || !newSide || oldSide === newSide) {
      return;
    }

    // Source parity: Object::onCapture invokes each upgrade module's onCapture. For
    // COSTMODIFIERUPGRADE, this means removing side effects from the old owner and
    // re-applying them to the new owner while the upgrade is active.
    for (const module of entity.upgradeModules) {
      if (module.moduleType !== 'COSTMODIFIERUPGRADE') {
        continue;
      }
      if (!entity.executedUpgradeModules.has(module.id)) {
        continue;
      }
      this.removeCostModifierUpgradeFromSide(oldSide, module);
      this.applyCostModifierUpgradeToSide(newSide, module);
    }
  }

  private transferPowerPlantUpgradesBetweenSides(entity: MapEntity, oldSide: string, newSide: string): void {
    const normalizedOldSide = this.normalizeSide(oldSide);
    const normalizedNewSide = this.normalizeSide(newSide);
    if (!normalizedOldSide || !normalizedNewSide || normalizedOldSide === normalizedNewSide) {
      return;
    }
    this.transferPowerPlantUpgradesBetweenSidesForCapture(entity, normalizedOldSide, normalizedNewSide);
  }

  private transferPowerPlantUpgradesBetweenSidesForCapture(
    entity: MapEntity,
    oldSide: string,
    newSide: string,
  ): void {
    if (!oldSide || !newSide || oldSide === newSide) {
      return;
    }
    if (this.isObjectDisabledForUpgradeSideEffects(entity)) {
      return;
    }

    // Source parity: Object::onCapture invokes power-plant upgrade modules to move
    // production bonus ownership from old owner to new owner while upgrade remains active.
    for (const module of entity.upgradeModules) {
      if (module.moduleType !== 'POWERPLANTUPGRADE') {
        continue;
      }
      if (!entity.executedUpgradeModules.has(module.id)) {
        continue;
      }
      this.removePowerPlantUpgradeFromSide(oldSide, entity);
      this.applyPowerPlantUpgradeToSide(newSide, module, entity);
    }
  }

  private transferOverchargeBetweenSides(entity: MapEntity, oldSide: string, newSide: string): void {
    if (!this.overchargeStateByEntityId.has(entity.id)) {
      return;
    }

    const normalizedOldSide = this.normalizeSide(oldSide);
    const normalizedNewSide = this.normalizeSide(newSide);
    if (!normalizedOldSide || !normalizedNewSide || normalizedOldSide === normalizedNewSide) {
      return;
    }

    const oldSidePowerState = this.getSidePowerStateMap(normalizedOldSide);
    if (removePowerPlantUpgradeFromSideImpl(oldSidePowerState, entity.energyBonus)) {
      this.sidePowerBonus.delete(normalizedOldSide);
    }

    const newSidePowerState = this.getSidePowerStateMap(normalizedNewSide);
    applyPowerPlantUpgradeToSideImpl(newSidePowerState, entity.energyBonus);
  }

  private transferRadarUpgradesBetweenSides(entity: MapEntity, oldSide: string, newSide: string): void {
    const normalizedOldSide = this.normalizeSide(oldSide);
    const normalizedNewSide = this.normalizeSide(newSide);
    if (!normalizedOldSide || !normalizedNewSide || normalizedOldSide === normalizedNewSide) {
      return;
    }
    this.transferRadarUpgradesBetweenSidesForCapture(entity, normalizedOldSide, normalizedNewSide);
  }

  private transferRadarUpgradesBetweenSidesForCapture(
    entity: MapEntity,
    oldSide: string,
    newSide: string,
  ): void {
    if (!oldSide || !newSide || oldSide === newSide) {
      return;
    }
    if (this.isObjectDisabledForUpgradeSideEffects(entity)) {
      return;
    }

    // Source parity: Object::onCapture invokes radar-upgrade modules to transfer
    // radar ownership while preserving disable-proof counts.
    for (const module of entity.upgradeModules) {
      if (module.moduleType !== 'RADARUPGRADE') {
        continue;
      }
      if (!entity.executedUpgradeModules.has(module.id)) {
        continue;
      }
      this.removeRadarUpgradeFromSide(oldSide, module);
      this.applyRadarUpgradeToSide(newSide, module);
    }
  }

  private applyGrantScienceUpgradeModule(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    const side = this.normalizeSide(entity.side);
    if (!side || !module.grantScienceName || module.grantScienceName === 'NONE') {
      return false;
    }

    // Source parity: GrantScienceUpgrade.cpp translates the configured science name to
    // a science type and invokes Player::grantScience().
    return this.grantSideScience(side, module.grantScienceName);
  }

  private applyKindOfProductionCostModifiers(buildCost: number, side: string, kindOf: Set<string>): number {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return buildCost;
    }

    return applyKindOfProductionCostModifiersImpl(
      buildCost,
      kindOf,
      this.getSideKindOfProductionCostModifiers(normalizedSide),
    );
  }

  private applyPowerPlantUpgradeModule(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    const side = this.normalizeSide(entity.side);
    if (!side) {
      return false;
    }
    if (this.isObjectDisabledForUpgradeSideEffects(entity)) {
      return false;
    }
    this.applyPowerPlantUpgradeToSide(side, module, entity);
    // Source parity: PowerPlantUpgrade.cpp line 120-125 — call extendRods(TRUE) on PowerPlantUpdateInterface.
    this.extendPowerPlantRods(entity, true);
    return true;
  }

  /**
   * Source parity: PowerPlantUpdate::extendRods — manage rod extension animation.
   * C++ PowerPlantUpdate.cpp lines 80-107.
   */
  private extendPowerPlantRods(entity: MapEntity, extend: boolean): void {
    const state = entity.powerPlantUpdateState;
    if (!state) return;
    const profile = entity.powerPlantUpdateProfile;
    if (!profile) return;

    if (extend) {
      if (!state.extended) {
        // Set UPGRADING model condition. Timer will transition to UPGRADED.
        entity.modelConditionFlags.add('POWER_PLANT_UPGRADING');
        state.extended = true;
        state.upgradeFinishFrame = this.frameCounter + profile.rodsExtendTimeFrames;
      }
    } else {
      // De-extend instantly: clear both conditions.
      entity.modelConditionFlags.delete('POWER_PLANT_UPGRADING');
      entity.modelConditionFlags.delete('POWER_PLANT_UPGRADED');
      state.extended = false;
      state.upgradeFinishFrame = 0;
    }
  }

  private applyPowerPlantUpgradeToSide(
    side: string,
    _module: UpgradeModuleProfile,
    entity: MapEntity,
  ): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    // Source parity: PowerPlantUpgrade.cpp adds energy from the templated object.
    const sideState = this.getSidePowerStateMap(normalizedSide);
    applyPowerPlantUpgradeToSideImpl(sideState, entity.energyBonus);
  }

  private removePowerPlantUpgradeFromEntity(entity: MapEntity, _module: UpgradeModuleProfile): void {
    if (this.isObjectDisabledForUpgradeSideEffects(entity)) {
      return;
    }
    const side = this.normalizeSide(entity.side);
    if (!side) {
      return;
    }
    this.removePowerPlantUpgradeFromSide(side, entity);
  }

  private removePowerPlantUpgradeFromSide(
    side: string,
    entity: MapEntity,
  ): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    // Source parity: PowerPlantUpgrade.cpp mirrors removePowerBonus() on upgrade removal/capture.
    const sideState = this.getSidePowerStateMap(normalizedSide);
    if (removePowerPlantUpgradeFromSideImpl(sideState, entity.energyBonus)) {
      this.sidePowerBonus.delete(normalizedSide);
    }
  }

  private enableOverchargeForEntity(entity: MapEntity, profile: OverchargeBehaviorProfile): void {
    const normalizedSide = this.normalizeSide(entity.side);
    if (!normalizedSide) {
      return;
    }

    if (this.overchargeStateByEntityId.has(entity.id)) {
      return;
    }

    const sideState = this.getSidePowerStateMap(normalizedSide);
    applyPowerPlantUpgradeToSideImpl(sideState, entity.energyBonus);
    this.overchargeStateByEntityId.set(entity.id, {
      healthPercentToDrainPerSecond: Math.max(0, profile.healthPercentToDrainPerSecond),
      notAllowedWhenHealthBelowPercent: clamp(profile.notAllowedWhenHealthBelowPercent, 0, 1),
    });
    // Source parity: OverchargeBehavior.cpp line 218-223 — extendRods(TRUE) on overcharge enable.
    this.extendPowerPlantRods(entity, true);
  }

  private disableOverchargeForEntity(entity: MapEntity): void {
    if (!this.overchargeStateByEntityId.has(entity.id)) {
      return;
    }

    const normalizedSide = this.normalizeSide(entity.side);
    if (normalizedSide) {
      const sideState = this.getSidePowerStateMap(normalizedSide);
      if (removePowerPlantUpgradeFromSideImpl(sideState, entity.energyBonus)) {
        this.sidePowerBonus.delete(normalizedSide);
      }
    }

    this.overchargeStateByEntityId.delete(entity.id);
    // Source parity: OverchargeBehavior.cpp line 189-194 — extendRods(FALSE) on overcharge disable.
    this.extendPowerPlantRods(entity, false);
  }

  /**
   * Register an entity's energyBonus with its side's power tracking.
   * Positive = production, negative = consumption.
   */
  private registerEntityEnergy(entity: MapEntity): void {
    // Source parity: buildings under construction do not contribute/consume power.
    if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) return;
    const normalizedSide = this.normalizeSide(entity.side);
    if (!normalizedSide || entity.energyBonus === 0) return;
    const state = this.getSidePowerStateMap(normalizedSide);
    if (entity.energyBonus > 0) {
      state.energyProduction += entity.energyBonus;
    } else {
      state.energyConsumption += -entity.energyBonus;
    }
  }

  /**
   * Unregister an entity's energyBonus from its side's power tracking.
   */
  private unregisterEntityEnergy(entity: MapEntity): void {
    const normalizedSide = this.normalizeSide(entity.side);
    if (!normalizedSide || entity.energyBonus === 0) return;
    const state = this.getSidePowerStateMap(normalizedSide);
    if (entity.energyBonus > 0) {
      state.energyProduction = Math.max(0, state.energyProduction - entity.energyBonus);
    } else {
      state.energyConsumption = Math.max(0, state.energyConsumption + entity.energyBonus);
    }
  }

  /**
   * Source parity: Player::onPowerBrownOutChange — set/clear DISABLED_UNDERPOWERED
   * on all KINDOF_POWERED entities when power balance crosses the threshold.
   * C++ Player.cpp:3250-3273: iterates objects with doPowerDisable callback.
   */
  private updatePowerBrownOut(): void {
    for (const [side, powerState] of this.sidePowerBonus.entries()) {
      const totalProduction = powerState.energyProduction + powerState.powerBonus;
      // Source parity: SabotagePowerPlantCrateCollide forces brownout until timer expires.
      const isSabotaged = powerState.powerSabotagedUntilFrame > this.frameCounter;
      const isNowBrownedOut = isSabotaged
        || (powerState.energyConsumption > 0 && totalProduction < powerState.energyConsumption);

      if (isNowBrownedOut === powerState.brownedOut) {
        // No change in power state for this side.
        if (isNowBrownedOut) {
          // Source parity: SpecialPowerModule::pauseCountdown — while paused,
          // countdown frame is pushed forward by 1 each logic frame.
          this.pauseSpecialPowerCountdownsForSide(side);
        }
        continue;
      }

      powerState.brownedOut = isNowBrownedOut;

      // Source parity: Player::onPowerBrownOutChange (Player.cpp:3250-3273) calls
      // disableRadar()/enableRadar() alongside the entity disable iteration.
      const radarState = this.getSideRadarStateMap(side);
      radarState.radarDisabled = isNowBrownedOut;

      // Apply or clear DISABLED_UNDERPOWERED on all KINDOF_POWERED entities.
      for (const entity of this.spawnedEntities.values()) {
        if (entity.destroyed) continue;
        const entitySide = this.normalizeSide(entity.side);
        if (entitySide !== side) continue;
        if (!entity.kindOf.has('POWERED')) continue;

        if (isNowBrownedOut) {
          entity.objectStatusFlags.add('DISABLED_UNDERPOWERED');
        } else {
          entity.objectStatusFlags.delete('DISABLED_UNDERPOWERED');
        }
      }
    }
  }

  /**
   * Source parity: Object::pauseAllSpecialPowers — increment ready frames by 1
   * for all special powers on underpowered entities of the given side.
   */
  private pauseSpecialPowerCountdownsForSide(side: string): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const entitySide = this.normalizeSide(entity.side);
      if (entitySide !== side) continue;
      if (!entity.objectStatusFlags.has('DISABLED_UNDERPOWERED')) continue;

      for (const [, module] of entity.specialPowerModules) {
        const normalizedPower = module.specialPowerTemplateName.toUpperCase().replace(/\s+/g, '');
        const currentReady = this.sharedShortcutSpecialPowerReadyFrames.get(normalizedPower) ?? 0;
        // Only push forward if the countdown is still running (readyFrame > current frame).
        if (currentReady > this.frameCounter) {
          this.sharedShortcutSpecialPowerReadyFrames.set(normalizedPower, currentReady + 1);
        }
      }
    }
  }

  private applyRadarUpgradeModule(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    const side = this.normalizeSide(entity.side);
    if (!side) {
      return false;
    }
    if (this.isObjectDisabledForUpgradeSideEffects(entity)) {
      return false;
    }
    this.applyRadarUpgradeToSide(side, module);
    // Source parity: RadarUpgrade::upgradeImplementation calls radarUpdate->extendRadar().
    if (entity.radarUpdateProfile) {
      entity.radarExtendDoneFrame = this.frameCounter + entity.radarUpdateProfile.radarExtendTimeFrames;
      entity.radarActive = true; // C++ sets m_radarActive = true immediately.
    }
    return true;
  }

  private applyRadarUpgradeToSide(side: string, module: UpgradeModuleProfile): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    const state = this.getSideRadarStateMap(normalizedSide);
    applyRadarUpgradeToSideImpl(state, module.radarIsDisableProof);
  }

  private removeRadarUpgradeFromEntity(entity: MapEntity, module: UpgradeModuleProfile): void {
    if (this.isObjectDisabledForUpgradeSideEffects(entity)) {
      return;
    }
    const side = this.normalizeSide(entity.side);
    if (!side) {
      return;
    }
    this.removeRadarUpgradeFromSide(side, module);
  }

  private removeRadarUpgradeFromSide(side: string, module: UpgradeModuleProfile): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    const state = this.getSideRadarStateMap(normalizedSide);
    if (removeRadarUpgradeFromSideImpl(state, module.radarIsDisableProof)) {
      this.sideRadarState.delete(normalizedSide);
    }
  }

  private canExecuteUpgradeModule(
    entity: MapEntity,
    module: UpgradeModuleProfile,
    upgradeMask?: ReadonlySet<string>,
  ): boolean {
    // Source parity: upgrades are blocked while UNDER_CONSTRUCTION (Object.cpp line 2436).
    if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
      return false;
    }
    const maskToCheck = upgradeMask ?? this.buildEntityUpgradeMask(entity);
    return this.wouldUpgradeModuleWithMask(entity, module, maskToCheck, true);
  }

  private canRemainActiveUpgradeModule(
    entity: MapEntity,
    module: UpgradeModuleProfile,
    upgradeMask: ReadonlySet<string>,
  ): boolean {
    // Source parity: upgrade removals and command-set refresh evaluate whether a module
    // stays active under current prerequisites without excluding modules already in the
    // executed set.
    return this.wouldUpgradeModuleWithMask(entity, module, upgradeMask, false);
  }

  private entityHasUpgrade(entity: MapEntity, upgradeName: string): boolean {
    const normalizedUpgrade = upgradeName.trim().toUpperCase();
    if (!normalizedUpgrade || normalizedUpgrade === 'NONE') {
      return false;
    }

    if (entity.completedUpgrades.has(normalizedUpgrade)) {
      return true;
    }

    const side = this.normalizeSide(entity.side);
    if (!side) {
      return false;
    }
    return this.getSideUpgradeSet(this.sideCompletedUpgrades, side).has(normalizedUpgrade);
  }

  private buildEntityUpgradeMask(entity: MapEntity, additionalUpgradeName?: string): Set<string> {
    const upgradeMask = new Set<string>();
    for (const upgradeName of entity.completedUpgrades) {
      upgradeMask.add(upgradeName);
    }

    const side = this.normalizeSide(entity.side);
    if (side) {
      for (const sideUpgrade of this.getSideUpgradeSet(this.sideCompletedUpgrades, side)) {
        upgradeMask.add(sideUpgrade);
      }
    }

    const normalizedAdditional = additionalUpgradeName?.trim().toUpperCase();
    if (normalizedAdditional && normalizedAdditional !== 'NONE') {
      upgradeMask.add(normalizedAdditional);
    }

    return upgradeMask;
  }

  private wouldUpgradeModuleWithMask(
    entity: MapEntity,
    module: UpgradeModuleProfile,
    upgradeMask: ReadonlySet<string>,
    skipExecutedGate: boolean,
  ): boolean {
    // Source parity: GeneralsMD's UpgradeMux::wouldUpgrade requires both activation and key masks
    // to be non-empty before considering triggers, and refuses re-running an already executed module.
    if (skipExecutedGate && entity.executedUpgradeModules.has(module.id)) {
      return false;
    }

    for (const conflictingUpgrade of module.conflictsWith) {
      if (upgradeMask.has(conflictingUpgrade)) {
        return false;
      }
    }

    if (module.requiresAllTriggers) {
      for (const activationUpgrade of module.triggeredBy) {
        if (!upgradeMask.has(activationUpgrade)) {
          return false;
        }
      }
      return true;
    }

    for (const activationUpgrade of module.triggeredBy) {
      if (upgradeMask.has(activationUpgrade)) {
        return true;
      }
    }

    return false;
  }


  private isEntityAffectedByUpgrade(entity: MapEntity, upgradeName: string): boolean {
    const normalizedUpgrade = upgradeName.trim().toUpperCase();
    if (!normalizedUpgrade || normalizedUpgrade === 'NONE') {
      return false;
    }

    const maskToCheck = this.buildEntityUpgradeMask(entity, normalizedUpgrade);
    for (const module of entity.upgradeModules) {
      if (this.wouldUpgradeModuleWithMask(entity, module, maskToCheck, false)) {
        return true;
      }
    }

    return false;
  }

  private applyMaxHealthUpgrade(
    entity: MapEntity,
    addMaxHealth: number,
    changeType: MaxHealthChangeTypeName,
  ): boolean {
    if (!Number.isFinite(addMaxHealth) || addMaxHealth === 0) {
      return false;
    }

    const previousMaxHealth = entity.maxHealth;
    const nextMaxHealth = Math.max(0, previousMaxHealth + addMaxHealth);
    entity.maxHealth = nextMaxHealth;
    entity.initialHealth = nextMaxHealth;

    switch (changeType) {
      case 'PRESERVE_RATIO': {
        if (previousMaxHealth > 0) {
          entity.health = nextMaxHealth * (entity.health / previousMaxHealth);
        }
        break;
      }
      case 'ADD_CURRENT_HEALTH_TOO':
        entity.health += nextMaxHealth - previousMaxHealth;
        break;
      case 'SAME_CURRENTHEALTH':
      default:
        break;
    }

    if (entity.health > entity.maxHealth) {
      entity.health = entity.maxHealth;
    }
    if (entity.health < 0) {
      entity.health = 0;
    }
    entity.canTakeDamage = entity.bodyType !== 'INACTIVE' && entity.maxHealth > 0;
    return true;
  }

  private applyArmorUpgrade(entity: MapEntity): boolean {
    entity.armorSetFlagsMask |= ARMOR_SET_FLAG_PLAYER_UPGRADE;
    this.refreshEntityCombatProfiles(entity);
    return true;
  }

  private applyWeaponSetUpgrade(entity: MapEntity): boolean {
    entity.weaponSetFlagsMask |= WEAPON_SET_FLAG_PLAYER_UPGRADE;
    this.refreshEntityCombatProfiles(entity);
    return true;
  }

  // Source parity: WeaponBonusUpgrade.cpp sets WEAPONBONUSCONDITION_PLAYER_UPGRADE,
  // which maps to WEAPON_SET_FLAG_PLAYER_UPGRADE in this port's weapon-set selection.
  private applyWeaponBonusUpgrade(entity: MapEntity): boolean {
    entity.weaponSetFlagsMask |= WEAPON_SET_FLAG_PLAYER_UPGRADE;
    // Source parity: WeaponBonusUpgrade sets WEAPONBONUSCONDITION_PLAYER_UPGRADE.
    entity.weaponBonusConditionFlags |= WEAPON_BONUS_PLAYER_UPGRADE;
    this.refreshEntityCombatProfiles(entity);
    return true;
  }

  // Source parity: StealthUpgrade.cpp sets OBJECT_STATUS_CAN_STEALTH.
  private applyStealthUpgrade(entity: MapEntity): boolean {
    entity.objectStatusFlags.add('CAN_STEALTH');
    return true;
  }

  private applyCommandSetUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    const targetCommandSetName = this.resolveCommandSetUpgradeTarget(entity, module);
    entity.commandSetStringOverride = targetCommandSetName;
    return true;
  }

  private resolveCommandSetUpgradeTarget(entity: MapEntity, module: UpgradeModuleProfile): string | null {
    let targetCommandSetName = module.commandSetName;
    if (
      module.commandSetAltTriggerUpgrade
      && this.entityHasUpgrade(entity, module.commandSetAltTriggerUpgrade)
    ) {
      targetCommandSetName = module.commandSetAltName;
    }

    if (!targetCommandSetName || targetCommandSetName === 'NONE') {
      return null;
    }
    return targetCommandSetName;
  }

  private refreshEntityCommandSetOverride(entity: MapEntity): void {
    let commandSetName: string | null = null;
    const upgradeMask = this.buildEntityUpgradeMask(entity);
    for (const module of entity.upgradeModules) {
      if (module.moduleType !== 'COMMANDSETUPGRADE' || !entity.executedUpgradeModules.has(module.id)) {
        continue;
      }

      if (!this.canRemainActiveUpgradeModule(entity, module, upgradeMask)) {
        continue;
      }

      commandSetName = this.resolveCommandSetUpgradeTarget(entity, module);
    }

    entity.commandSetStringOverride = commandSetName;
  }

  private applyStatusBitsUpgrade(entity: MapEntity, module: UpgradeModuleProfile): boolean {
    let changed = false;
    for (const statusName of module.statusToSet) {
      if (!entity.objectStatusFlags.has(statusName)) {
        entity.objectStatusFlags.add(statusName);
        changed = true;
      }
    }

    for (const statusName of module.statusToClear) {
      if (entity.objectStatusFlags.delete(statusName)) {
        changed = true;
      }
    }

    // Always sync derived fields when status-affecting modules are evaluated, even if
    // all flags were already in the desired state, to keep cached booleans consistent.
    if (module.statusToSet.size > 0 || module.statusToClear.size > 0) {
      this.syncDerivedStatusFields(entity);
    }
    return changed || module.statusToSet.size > 0 || module.statusToClear.size > 0;
  }

  private removeWeaponBonusUpgradeFromEntity(entity: MapEntity): void {
    // Recompute weapon-set flags from all currently active modules so that removing
    // one WEAPONBONUSUPGRADE does not clear a remaining WEAPONSETUPGRADE source.
    entity.weaponSetFlagsMask &= ~WEAPON_SET_FLAG_PLAYER_UPGRADE;
    entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_PLAYER_UPGRADE;
    for (const module of entity.upgradeModules) {
      if (!entity.executedUpgradeModules.has(module.id)) {
        continue;
      }
      if (module.moduleType === 'WEAPONSETUPGRADE' || module.moduleType === 'WEAPONBONUSUPGRADE') {
        entity.weaponSetFlagsMask |= WEAPON_SET_FLAG_PLAYER_UPGRADE;
        entity.weaponBonusConditionFlags |= WEAPON_BONUS_PLAYER_UPGRADE;
        break;
      }
    }
    this.refreshEntityCombatProfiles(entity);
  }

  private removeStealthUpgradeFromEntity(entity: MapEntity): void {
    // Keep CAN_STEALTH active if any other STEALTHUPGRADE module remains executed.
    entity.objectStatusFlags.delete('CAN_STEALTH');
    for (const module of entity.upgradeModules) {
      if (!entity.executedUpgradeModules.has(module.id)) {
        continue;
      }
      if (module.moduleType === 'STEALTHUPGRADE') {
        entity.objectStatusFlags.add('CAN_STEALTH');
        break;
      }
    }
  }

  private removeLocomotorUpgradeFromEntity(entity: MapEntity): void {
    // Source parity: LocomotorSetUpgrade removal should restore base locomotor state when
    // the source object-upgrade mask is no longer present.
    this.setEntityLocomotorUpgrade(entity.id, false);
  }

  private removeStatusBitsUpgradeFromEntity(entity: MapEntity): void {
    const controlledStatuses = new Set<string>();
    for (const module of entity.upgradeModules) {
      if (
        !entity.executedUpgradeModules.has(module.id)
        || module.moduleType !== 'STATUSBITSUPGRADE'
      ) {
        continue;
      }
      for (const statusName of module.statusToSet) {
        controlledStatuses.add(statusName);
      }
      for (const statusName of module.statusToClear) {
        controlledStatuses.add(statusName);
      }
    }

    for (const statusName of controlledStatuses) {
      entity.objectStatusFlags.delete(statusName);
    }

    for (const module of entity.upgradeModules) {
      if (!entity.executedUpgradeModules.has(module.id) || module.moduleType !== 'STATUSBITSUPGRADE') {
        continue;
      }
      this.applyStatusBitsUpgrade(entity, module);
    }
    // Always sync derived fields after bulk status mutations even if no reapply loop ran.
    this.syncDerivedStatusFields(entity);
  }

  private isObjectDisabledForUpgradeSideEffects(entity: MapEntity): boolean {
    // Source parity: upgrade modules with side effects are suppressed while the object
    // is disabled, matching Player::isDisabled()/Object::isDisabled behavior.
    return (
      this.entityHasObjectStatus(entity, 'DISABLED_SUBDUED')
      || this.entityHasObjectStatus(entity, 'DISABLED_HACKED')
      || this.entityHasObjectStatus(entity, 'DISABLED_EMP')
      || this.entityHasObjectStatus(entity, 'DISABLED_UNDERPOWERED')
    );
  }

  private processUpgradeModuleRemovals(entity: MapEntity, module: UpgradeModuleProfile): void {
    for (const upgradeName of module.removesUpgrades) {
      this.removeEntityUpgrade(entity, upgradeName);
    }
  }

  private removeEntityUpgrade(entity: MapEntity, upgradeName: string): void {
    const normalizedUpgrade = upgradeName.trim().toUpperCase();
    if (!normalizedUpgrade || normalizedUpgrade === 'NONE') {
      return;
    }

    entity.completedUpgrades.delete(normalizedUpgrade);
    const upgradeMask = this.buildEntityUpgradeMask(entity);
    for (const module of entity.upgradeModules) {
      if (!entity.executedUpgradeModules.has(module.id)) {
        continue;
      }

      if (this.canRemainActiveUpgradeModule(entity, module, upgradeMask)) {
        continue;
      }

      entity.executedUpgradeModules.delete(module.id);
      if (module.moduleType === 'COSTMODIFIERUPGRADE') {
        this.removeCostModifierUpgradeFromEntity(entity, module);
      } else if (module.moduleType === 'POWERPLANTUPGRADE') {
        this.removePowerPlantUpgradeFromEntity(entity, module);
      } else if (module.moduleType === 'RADARUPGRADE') {
        this.removeRadarUpgradeFromEntity(entity, module);
      } else if (module.moduleType === 'LOCOMOTORSETUPGRADE') {
        this.removeLocomotorUpgradeFromEntity(entity);
      } else if (module.moduleType === 'WEAPONBONUSUPGRADE') {
        this.removeWeaponBonusUpgradeFromEntity(entity);
      } else if (module.moduleType === 'STEALTHUPGRADE') {
        this.removeStealthUpgradeFromEntity(entity);
      } else if (module.moduleType === 'COMMANDSETUPGRADE') {
        // Side effect is recomputed from remaining executable command-set modules.
      } else if (module.moduleType === 'STATUSBITSUPGRADE') {
        this.removeStatusBitsUpgradeFromEntity(entity);
      } else if (module.moduleType === 'PASSENGERSFIREUPGRADE') {
        // Source parity for PassengersFireUpgrade: when the upgrade is removed, restore
        // container firing permission to its configured baseline unless another active
        // PassengersFireUpgrade still applies.
        const hasOtherPassengerFireUpgrade = entity.upgradeModules.some(
          (executedModule) => executedModule.moduleType === 'PASSENGERSFIREUPGRADE'
            && entity.executedUpgradeModules.has(executedModule.id),
        );
        if (!hasOtherPassengerFireUpgrade && entity.containProfile) {
          entity.containProfile.passengersAllowedToFire = entity.containProfile.passengersAllowedToFireDefault;
        }
      } else if (module.moduleType === 'UNPAUSESPECIALPOWERUPGRADE') {
        // Source parity: UnpauseSpecialPowerUpgrade is an instantaneous cooldown-release action,
        // so no persistent entity-side state needs removal here.
      } else if (module.moduleType === 'EXPERIENCESCALARUPGRADE') {
        this.removeExperienceScalarUpgrade(entity, module);
      } else if (module.moduleType === 'MODELCONDITIONUPGRADE') {
        this.removeModelConditionUpgrade(entity, module);
      } else if (module.moduleType === 'OBJECTCREATIONUPGRADE') {
        // ObjectCreationUpgrade is instantaneous (spawns OCL), no persistent state to remove.
      } else if (module.moduleType === 'ACTIVESHROUDUPGRADE') {
        this.removeActiveShroudUpgrade(entity, module);
      } else if (module.moduleType === 'REPLACEOBJECTUPGRADE') {
        // ReplaceObjectUpgrade is irreversible — the original entity was destroyed.
      }
    }

    this.refreshEntityCommandSetOverride(entity);

    // Source parity: Object::removeUpgrade calls UpgradeModule::resetUpgrade(removedUpgradeMask)
    // on all behavior modules; this loop mirrors that behavior by clearing modules whose
    // trigger mask no longer matches the current upgrade mask.
  }

  private entityHasObjectStatus(entity: MapEntity, statusName: string): boolean {
    const normalizedStatusName = this.normalizeObjectStatusName(statusName);
    if (!normalizedStatusName) {
      return false;
    }
    return entity.objectStatusFlags.has(normalizedStatusName);
  }

  /**
   * Source parity: sync cached boolean fields derived from ObjectStatus flags.
   * Called whenever objectStatusFlags change so pathfinding/targeting stay consistent.
   */
  private syncDerivedStatusFields(entity: MapEntity): void {
    entity.noCollisions = entity.objectStatusFlags.has('NO_COLLISIONS');
  }

  private canEntityAttackFromStatus(entity: MapEntity): boolean {
    // Source parity: DeployStyleAIUpdate — only allow attacks when fully deployed.
    if (entity.deployStyleProfile && entity.deployState !== 'READY_TO_ATTACK') {
      return false;
    }
    // Source parity: GeneralsMD Object::isAbleToAttack() early-outs on OBJECT_STATUS_NO_ATTACK,
    // OBJECT_STATUS_UNDER_CONSTRUCTION, and OBJECT_STATUS_SOLD.
    if (this.entityHasObjectStatus(entity, 'NO_ATTACK')) {
      return false;
    }
    if (this.entityHasObjectStatus(entity, 'UNDER_CONSTRUCTION')) {
      return false;
    }
    if (this.entityHasObjectStatus(entity, 'SOLD')) {
      return false;
    }

    // Source parity: GeneralsMD Object::isAbleToAttack() adds DISABLED_SUBDUED guard.
    // - Portable structures and spawned-weapon units are also blocked while
    //   DISABLED_HACKED or DISABLED_EMP (see Object.cpp).
    if (this.entityHasObjectStatus(entity, 'DISABLED_SUBDUED')) {
      return false;
    }
    const containingEntity = this.resolveEntityContainingObject(entity);
    const kindOf = this.resolveEntityKindOfSet(entity);
    const isPortableOrSpawnWeaponUnit = kindOf.has('PORTABLE_STRUCTURE') || kindOf.has('SPAWNS_ARE_THE_WEAPONS');
    if (isPortableOrSpawnWeaponUnit && (
      this.entityHasObjectStatus(entity, 'DISABLED_HACKED')
      || this.entityHasObjectStatus(entity, 'DISABLED_EMP')
    )) {
      return false;
    }
    if (containingEntity && !this.isPassengerAllowedToFireFromContainingObject(entity, containingEntity)) {
      // Source parity: GeneralsMD/Object.cpp checks contain modules via
      // getContainedBy()->getContain()->isPassengerAllowedToFire().
      return false;
    }
    if (isPortableOrSpawnWeaponUnit && kindOf.has('INFANTRY')) {
      // Source parity: Object::isAbleToAttack() (Object.cpp:3212-3230) — spawned infantry
      // checks SlavedUpdateInterface::getSlaverID() and blocks attacks when slaver is
      // DISABLED_SUBDUED (e.g., Microwave Tank suppressing a Stinger Site also suppresses
      // its stinger soldiers).
      const slaverEntity = entity.slaverEntityId !== null
        ? this.spawnedEntities.get(entity.slaverEntityId) ?? null
        : containingEntity;
      if (
        slaverEntity
        && this.entityHasObjectStatus(slaverEntity, 'DISABLED_SUBDUED')
      ) {
        return false;
      }
    }

    // Source parity: Object::isAbleToAttack() (Object.cpp:3237-3280) checks if all
    // weapons are on disabled turrets. Only turreted weapons can be disabled.
    // KINDOF_CAN_ATTACK objects skip this check (e.g., Nuke Cannon needs isAbleToAttack()
    // true even with disabled turret so it can deploy).
    if (entity.turretProfiles.length > 0 && !kindOf.has('CAN_ATTACK')) {
      let anyWeapon = false;
      let anyEnabled = false;
      const weaponSlots = this.resolveActiveWeaponSetSlots(entity);
      for (let slotIndex = 0; slotIndex < weaponSlots.length; slotIndex += 1) {
        if (weaponSlots[slotIndex] === null) {
          continue;
        }
        anyWeapon = true;
        const turret = this.findTurretForWeaponSlot(entity, slotIndex);
        if (!turret) {
          // Non-turreted weapon — always considered enabled.
          anyEnabled = true;
          break;
        }
        if (turret.enabled) {
          anyEnabled = true;
          break;
        }
      }
      if (anyWeapon && !anyEnabled) {
        return false;
      }
    }

    return true;
  }

  private isEntityStealthedAndUndetected(entity: MapEntity): boolean {
    return (
      this.entityHasObjectStatus(entity, 'STEALTHED')
      && !this.entityHasObjectStatus(entity, 'DETECTED')
      && !this.entityHasObjectStatus(entity, 'DISGUISED')
    );
  }

  private isEntityOffMap(entity: MapEntity): boolean {
    const heightmap = this.mapHeightmap;
    if (!heightmap) {
      return false;
    }

    // Source parity subset: PartitionFilterSameMapStatus compares Object::isOffMap() between
    // attacker and candidate. This port infers off-map status from current world position.
    return (
      entity.x < 0
      || entity.z < 0
      || entity.x >= heightmap.worldWidth
      || entity.z >= heightmap.worldDepth
    );
  }

  private canAttackerTargetEntity(
    attacker: MapEntity,
    target: MapEntity,
    commandSource: AttackCommandSource,
  ): boolean {
    if (!target.canTakeDamage || target.destroyed) {
      return false;
    }
    if (this.entityHasObjectStatus(target, 'MASKED')) {
      return false;
    }
    if (commandSource === 'AI' && this.entityHasObjectStatus(target, 'NO_ATTACK_FROM_AI')) {
      return false;
    }
    const targetKindOf = this.resolveEntityKindOfSet(target);
    if (targetKindOf.has('UNATTACKABLE')) {
      return false;
    }
    if (this.getTeamRelationship(attacker, target) !== RELATIONSHIP_ENEMIES) {
      return false;
    }
    if (this.isEntityOffMap(attacker) !== this.isEntityOffMap(target)) {
      return false;
    }
    if (
      !this.entityHasObjectStatus(attacker, 'IGNORING_STEALTH')
      && this.isEntityStealthedAndUndetected(target)
    ) {
      return false;
    }

    // Source parity: WeaponSet.cpp line 550 — cannot attack targets inside enclosing containers.
    if (this.isEntityInEnclosingContainer(target)) {
      return false;
    }

    // Source parity: AIUpdate.cpp line 4633 — fog of war affects human-player
    // auto-targeting (UNFOGGED flag). Computer AI players can target through fog.
    // Gate requires a fog grid and that the attacker has vision capability.
    if (commandSource === 'AI' && this.fogOfWarGrid && attacker.visionRange > 0) {
      const attackerSide = this.normalizeSide(attacker.side);
      if (attackerSide && this.getSidePlayerType(attackerSide) === 'HUMAN'
          && !this.isPositionVisible(attackerSide, target.x, target.z)) {
        return false;
      }
    }

    // Source parity: WeaponSet.cpp line 673 — weapon anti-mask vs target anti-mask.
    // If no weapon on the attacker can engage this target type, reject.
    if (attacker.totalWeaponAntiMask !== 0) {
      const targetAntiMask = this.resolveTargetAntiMask(target, targetKindOf);
      if (targetAntiMask !== 0 && (attacker.totalWeaponAntiMask & targetAntiMask) === 0) {
        return false;
      }
    }

    return true;
  }

  /**
   * Source parity: WeaponSet.cpp getVictimAntiMask — compute which weapon anti-mask bits
   * a target entity matches based on its kindOf flags and airborne status.
   */
  private resolveTargetAntiMask(target: MapEntity, targetKindOf: ReadonlySet<string>): number {
    // Source parity: WeaponSet.cpp getVictimAntiMask — priority order matches C++ exactly.
    if (targetKindOf.has('SMALL_MISSILE')) {
      return WEAPON_ANTI_SMALL_MISSILE;
    }
    if (targetKindOf.has('BALLISTIC_MISSILE')) {
      return WEAPON_ANTI_BALLISTIC_MISSILE;
    }
    if (targetKindOf.has('PROJECTILE')) {
      return WEAPON_ANTI_PROJECTILE;
    }
    if (targetKindOf.has('MINE') || targetKindOf.has('DEMOTRAP')) {
      return WEAPON_ANTI_MINE | WEAPON_ANTI_GROUND;
    }
    // Source parity: Object::isAirborneTarget checks OBJECT_STATUS_AIRBORNE_TARGET.
    if (this.entityHasObjectStatus(target, 'AIRBORNE_TARGET') || target.category === 'air') {
      if (targetKindOf.has('VEHICLE')) {
        return WEAPON_ANTI_AIRBORNE_VEHICLE;
      }
      if (targetKindOf.has('INFANTRY')) {
        return WEAPON_ANTI_AIRBORNE_INFANTRY;
      }
      if (targetKindOf.has('PARACHUTE')) {
        return WEAPON_ANTI_PARACHUTE;
      }
      // Airborne but not a recognized sub-type — unattackable in practice.
      return 0;
    }
    return WEAPON_ANTI_GROUND;
  }

  /**
   * Source parity: Contain::isEnclosingContainerFor — garrisoned and transport-carried
   * entities are shielded from direct attack.
   */
  private isEntityInEnclosingContainer(entity: MapEntity): boolean {
    if (entity.garrisonContainerId !== null) return true;
    if (entity.tunnelContainerId !== null) return true;
    if (entity.helixCarrierId !== null) {
      // Source parity: HelixContain::isEnclosingContainerFor returns FALSE for the
      // portable structure rider — it sits visibly on top and is attackable.
      const carrier = this.spawnedEntities.get(entity.helixCarrierId);
      if (carrier?.helixPortableRiderId === entity.id) return false;
      return true;
    }
    if (entity.transportContainerId !== null) {
      // Source parity: TransportContain/OverlordContain are enclosing by default.
      // OPEN containers are not (passengers visible and attackable, e.g., Battle Bus).
      const transport = this.spawnedEntities.get(entity.transportContainerId);
      if (transport) return this.isEnclosingContainer(transport);
    }
    return false;
  }

  private refreshEntityCombatProfiles(entity: MapEntity): void {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return;
    }

    const previousWeapon = entity.attackWeapon;
    entity.attackWeapon = this.resolveAttackWeaponProfileForSetSelection(
      entity.weaponTemplateSets,
      entity.weaponSetFlagsMask,
      registry,
      entity.forcedWeaponSlot,
    );
    entity.largestWeaponRange = this.resolveLargestWeaponRangeForSetSelection(
      entity.weaponTemplateSets,
      entity.weaponSetFlagsMask,
      registry,
      entity.forcedWeaponSlot,
    );
    entity.totalWeaponAntiMask = this.resolveTotalWeaponAntiMaskForSetSelection(
      entity.weaponTemplateSets,
      entity.weaponSetFlagsMask,
      registry,
      entity.forcedWeaponSlot,
    );
    entity.armorDamageCoefficients = this.resolveArmorDamageCoefficientsForSetSelection(
      entity.armorTemplateSets,
      entity.armorSetFlagsMask,
      registry,
    );

    // Source parity: apply RANGE bonus from global weapon bonus table to resolved weapon profile.
    if (entity.attackWeapon) {
      const rangeBonus = this.resolveWeaponRangeBonusMultiplier(entity);
      if (rangeBonus !== 1.0) {
        entity.attackWeapon = {
          ...entity.attackWeapon,
          attackRange: entity.attackWeapon.attackRange * rangeBonus,
        };
      }
    }

    const nextWeapon = entity.attackWeapon;
    const scatterTargetPatternChanged = (() => {
      if (!previousWeapon || !nextWeapon) {
        return previousWeapon !== nextWeapon;
      }
      if (previousWeapon.scatterTargets.length !== nextWeapon.scatterTargets.length) {
        return true;
      }
      for (let index = 0; index < previousWeapon.scatterTargets.length; index += 1) {
        const previousTarget = previousWeapon.scatterTargets[index];
        const nextTarget = nextWeapon.scatterTargets[index];
        if (!previousTarget || !nextTarget) {
          return true;
        }
        if (previousTarget.x !== nextTarget.x || previousTarget.z !== nextTarget.z) {
          return true;
        }
      }
      return false;
    })();
    // Source parity: WeaponSet::updateWeaponSet — when a set change keeps the same
    // weapon template in a slot, preserve runtime state (clip ammo, reload timers,
    // consecutive shots). Only fully reset timing when the template name changes
    // (i.e., a truly different weapon is now selected).
    const weaponTemplateChanged = previousWeapon?.name !== nextWeapon?.name;
    if (weaponTemplateChanged) {
      this.resetEntityWeaponTimingState(entity);
    } else if (scatterTargetPatternChanged && nextWeapon) {
      // Same weapon template but scatter offsets changed (e.g., upgrade modified scatter) —
      // rebuild scatter targets without resetting clip/reload state.
      this.rebuildEntityScatterTargets(entity);
    }
  }

  private msToLogicFrames(milliseconds: number): number {
    if (!Number.isFinite(milliseconds) || milliseconds <= 0) {
      return 0;
    }
    return Math.max(1, Math.ceil(milliseconds / LOGIC_FRAME_MS));
  }

  private msToLogicFramesReal(milliseconds: number): number {
    if (!Number.isFinite(milliseconds) || milliseconds <= 0) {
      return 0;
    }
    return milliseconds / LOGIC_FRAME_MS;
  }

  private isMobileObject(objectDef: ObjectDef, kinds: Set<string>): boolean {
    const explicit = readBooleanField(objectDef.fields, ['IsMobile', 'CanMove', 'Mobile']);
    if (explicit !== null) {
      return explicit;
    }

    if (this.hasLocomotorSetDefinition(objectDef)) {
      return true;
    }

    return this.isMobileByKindOf(kinds);
  }

  private hasLocomotorSetDefinition(objectDef: ObjectDef): boolean {
    for (const block of objectDef.blocks) {
      const type = block.type.toUpperCase();
      if (type === 'LOCOMOTOR' || type === 'LOCOMOTORSET') {
        return true;
      }
    }

    return false;
  }

  private isMobileByKindOf(kinds: Set<string>): boolean {
    return (
      kinds.has('INFANTRY')
      || kinds.has('VEHICLE')
      || kinds.has('HUGE_VEHICLE')
      || kinds.has('AIRCRAFT')
      || kinds.has('DOZER')
      || kinds.has('HARVESTER')
      || kinds.has('TRANSPORT')
      || kinds.has('DRONE')
      || kinds.has('MOBILE')
    );
  }

  private isSmallGeometry(fields: Record<string, IniValue>): boolean {
    const explicitSmall = readBooleanField(fields, ['GeometryIsSmall', 'IsSmall', 'Small']);
    if (explicitSmall !== null) {
      return explicitSmall;
    }

    const major = readNumericField(fields, ['GeometryMajorRadius', 'MajorRadius']);
    const minor = readNumericField(fields, ['GeometryMinorRadius', 'MinorRadius', 'GeometryMajorRadius', 'MajorRadius']);
    if (major !== null && minor !== null) {
      const maxRadius = Math.max(Math.abs(major), Math.abs(minor));
      return maxRadius > 0 && maxRadius <= MAP_XY_FACTOR * 0.35;
    }

    return false;
  }

  private normalizeKindOf(kindOf: string[] | undefined): Set<string> {
    const normalized = new Set<string>();
    if (!kindOf) {
      return normalized;
    }

    for (const kind of kindOf) {
      normalized.add(kind.toUpperCase());
    }

    return normalized;
  }

  private resolveCombatCollisionProfile(objectDef: ObjectDef | undefined): {
    crusherLevel: number;
    crushableLevel: number;
    canBeSquished: boolean;
    isUnmanned: boolean;
  } {
    if (!objectDef) {
      return {
        crusherLevel: 0,
        crushableLevel: 0,
        canBeSquished: false,
        isUnmanned: false,
      };
    }

    return {
      crusherLevel: toByte(readNumericField(objectDef.fields, ['CrusherLevel', 'Crusherlevel'])),
      crushableLevel: toByte(readNumericField(objectDef.fields, ['CrushableLevel', 'Crushablelevel'])),
      canBeSquished: this.hasSquishCollideModule(objectDef),
      isUnmanned: readBooleanField(objectDef.fields, ['Unmanned', 'IsUnmanned']) === true,
    };
  }

  private hasSquishCollideModule(objectDef: ObjectDef): boolean {
    const hasSquish = (blocks: IniBlock[]): boolean => {
      for (const block of blocks) {
        const blockType = block.type.toUpperCase();
        const blockName = block.name.toUpperCase();
        if (blockType.includes('SQUISHCOLLIDE') || blockName.includes('SQUISHCOLLIDE')) {
          return true;
        }
        if (hasSquish(block.blocks)) {
          return true;
        }
      }
      return false;
    };
    return hasSquish(objectDef.blocks);
  }

  private normalizeScriptVariableName(name: string): string {
    return name.trim();
  }

  private getOrCreateScriptCounter(counterName: string): ScriptCounterState | null {
    const normalizedName = this.normalizeScriptVariableName(counterName);
    if (!normalizedName) {
      return null;
    }

    const existing = this.scriptCountersByName.get(normalizedName);
    if (existing) {
      return existing;
    }

    const created: ScriptCounterState = {
      value: 0,
      isCountdownTimer: false,
    };
    this.scriptCountersByName.set(normalizedName, created);
    return created;
  }

  private evaluateScriptCounterCondition(filter: {
    counterName: string;
    comparison: ScriptComparisonInput;
    value: number;
  }): boolean {
    const counter = this.getOrCreateScriptCounter(filter.counterName);
    if (!counter) {
      return false;
    }
    return this.compareScriptCount(filter.comparison, counter.value, filter.value);
  }

  private evaluateScriptFlagCondition(filter: {
    flagName: string;
    value: boolean;
  }): boolean {
    const normalizedName = this.normalizeScriptVariableName(filter.flagName);
    if (!normalizedName) {
      return false;
    }

    const currentValue = this.scriptFlagsByName.get(normalizedName) ?? false;
    if (currentValue === filter.value) {
      return true;
    }

    // Source parity: shell/UI hooks are one-frame flag satisfiers.
    return this.scriptUIInteractions.has(normalizedName);
  }

  private evaluateScriptTimerExpired(filter: {
    counterName: string;
  }): boolean {
    const counter = this.getOrCreateScriptCounter(filter.counterName);
    if (!counter || !counter.isCountdownTimer) {
      return false;
    }
    return counter.value < 1;
  }

  private getOrCreateScriptConditionCache(conditionCacheId?: string): ScriptConditionCacheState | null {
    const normalizedId = conditionCacheId?.trim() ?? '';
    if (!normalizedId) {
      return null;
    }

    const existing = this.scriptConditionCacheById.get(normalizedId);
    if (existing) {
      return existing;
    }

    const created: ScriptConditionCacheState = { customData: 0, customFrame: 0 };
    this.scriptConditionCacheById.set(normalizedId, created);
    return created;
  }

  private resolveScriptActionTypeName(rawType: unknown): string | null {
    if (typeof rawType === 'number') {
      if (!Number.isFinite(rawType)) {
        return null;
      }
      return SCRIPT_ACTION_TYPE_NUMERIC_TO_NAME.get(Math.trunc(rawType)) ?? null;
    }

    if (typeof rawType !== 'string') {
      return null;
    }

    const normalized = rawType.trim().toUpperCase();
    if (!normalized) {
      return null;
    }

    const canonical = SCRIPT_ACTION_TYPE_ALIASES.get(normalized) ?? normalized;
    if (!SCRIPT_ACTION_TYPE_NAME_SET.has(canonical)) {
      return null;
    }
    return canonical;
  }

  private resolveScriptRandomInt(minValue: number, maxValue: number): number {
    const min = Number.isFinite(minValue) ? Math.trunc(minValue) : 0;
    const max = Number.isFinite(maxValue) ? Math.trunc(maxValue) : 0;
    if (max <= min) {
      return max;
    }
    return this.gameRandom.nextRange(min, max);
  }

  private resolveScriptRandomReal(minValue: number, maxValue: number): number {
    const min = Number.isFinite(minValue) ? minValue : 0;
    const max = Number.isFinite(maxValue) ? maxValue : 0;
    if (max <= min) {
      return max;
    }
    return min + this.gameRandom.nextFloat() * (max - min);
  }

  private secondsToScriptTimerFrames(seconds: number): number {
    if (!Number.isFinite(seconds)) {
      return 0;
    }
    return Math.ceil((seconds * 1000) / LOGIC_FRAME_MS);
  }

  private resolveScriptConditionTypeName(rawType: unknown): string | null {
    if (typeof rawType === 'number') {
      if (!Number.isFinite(rawType)) {
        return null;
      }
      const index = Math.trunc(rawType);
      if (index < 0 || index >= SCRIPT_CONDITION_TYPE_NAMES_BY_INDEX.length - 1) {
        return null;
      }
      return SCRIPT_CONDITION_TYPE_NAMES_BY_INDEX[index] ?? null;
    }

    if (typeof rawType !== 'string') {
      return null;
    }

    const normalized = rawType.trim().toUpperCase();
    if (!normalized) {
      return null;
    }

    const canonical = SCRIPT_CONDITION_TYPE_ALIASES.get(normalized) ?? normalized;
    if (canonical === 'NUM_ITEMS' || !SCRIPT_CONDITION_TYPE_NAME_SET.has(canonical)) {
      return null;
    }
    return canonical;
  }

  private resolveScriptConditionParams(condition: Record<string, unknown>): {
    paramsObject: Record<string, unknown> | null;
    paramsArray: readonly unknown[];
  } {
    const tryParse = (raw: unknown): { obj: Record<string, unknown> | null; arr: readonly unknown[] } | null => {
      if (Array.isArray(raw)) {
        return { obj: null, arr: raw };
      }
      if (raw && typeof raw === 'object') {
        return { obj: raw as Record<string, unknown>, arr: [] };
      }
      return null;
    };

    const primary = tryParse(condition.params);
    if (primary) {
      return { paramsObject: primary.obj, paramsArray: primary.arr };
    }

    const secondary = tryParse(condition.parameters);
    if (secondary) {
      return { paramsObject: secondary.obj, paramsArray: secondary.arr };
    }

    return { paramsObject: null, paramsArray: [] };
  }

  private resolveScriptConditionParamValue(
    condition: Record<string, unknown>,
    paramsObject: Record<string, unknown> | null,
    paramsArray: readonly unknown[],
    index: number,
    keyNames: readonly string[],
  ): unknown {
    for (const keyName of keyNames) {
      if (!keyName) {
        continue;
      }
      if (paramsObject && Object.prototype.hasOwnProperty.call(paramsObject, keyName)) {
        return paramsObject[keyName];
      }
      if (Object.prototype.hasOwnProperty.call(condition, keyName)) {
        return condition[keyName];
      }
    }

    if (index >= 0 && index < paramsArray.length) {
      return paramsArray[index];
    }

    return undefined;
  }

  private coerceScriptConditionString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    if (typeof value === 'number' && Number.isFinite(value)) {
      return String(value);
    }
    if (typeof value === 'boolean') {
      return value ? 'TRUE' : 'FALSE';
    }
    return '';
  }

  private coerceScriptConditionNumber(value: unknown): number | null {
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : null;
    }
    if (typeof value === 'string') {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  }

  private coerceScriptConditionBoolean(value: unknown, defaultValue: boolean): boolean {
    if (typeof value === 'boolean') {
      return value;
    }
    if (typeof value === 'number') {
      if (!Number.isFinite(value)) {
        return defaultValue;
      }
      return value !== 0;
    }
    if (typeof value === 'string') {
      const normalized = value.trim().toUpperCase();
      if (!normalized) {
        return defaultValue;
      }
      if (
        normalized === 'TRUE'
        || normalized === 'YES'
        || normalized === 'ON'
        || normalized === '1'
      ) {
        return true;
      }
      if (
        normalized === 'FALSE'
        || normalized === 'NO'
        || normalized === 'OFF'
        || normalized === '0'
      ) {
        return false;
      }
    }
    return defaultValue;
  }

  private resolveScriptConditionCacheId(
    condition: Record<string, unknown>,
    paramsObject: Record<string, unknown> | null,
  ): string | undefined {
    const rawCacheId = this.resolveScriptConditionParamValue(
      condition,
      paramsObject,
      [],
      -1,
      ['conditionCacheId', 'cacheId'],
    );
    if (typeof rawCacheId === 'string') {
      const normalized = rawCacheId.trim();
      if (normalized) {
        return normalized;
      }
    }

    const rawConditionId = condition.id ?? condition.conditionId;
    if (typeof rawConditionId === 'string') {
      const normalized = rawConditionId.trim();
      if (normalized) {
        return `SCRIPT_CONDITION:${normalized}`;
      }
    } else if (typeof rawConditionId === 'number' && Number.isFinite(rawConditionId)) {
      return `SCRIPT_CONDITION:${Math.trunc(rawConditionId)}`;
    }

    return undefined;
  }

  private countScriptObjectsByTemplateForSide(normalizedSide: string, normalizedTemplateName: string): number {
    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
        continue;
      }
      if (!this.areEquivalentTemplateNames(entity.templateName, normalizedTemplateName)) {
        continue;
      }
      count += 1;
    }
    return count;
  }

  private countScriptStructuresForSide(
    normalizedSide: string,
    requireVictoryFlag: boolean,
  ): number {
    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      if (!entity.kindOf.has('STRUCTURE')) {
        continue;
      }
      if (requireVictoryFlag && !entity.kindOf.has('MP_COUNT_FOR_VICTORY')) {
        continue;
      }
      count += 1;
    }
    return count;
  }

  private resolveEntityBuildCostRaw(entity: MapEntity): number {
    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    if (!objectDef) {
      return 0;
    }
    const buildCostRaw = readNumericField(objectDef.fields, ['BuildCost']) ?? 0;
    if (!Number.isFinite(buildCostRaw)) {
      return 0;
    }
    return Math.max(0, Math.trunc(buildCostRaw));
  }

  private resolveScriptComparisonCode(comparison: ScriptComparisonInput): number | null {
    if (typeof comparison === 'number') {
      if (!Number.isFinite(comparison)) {
        return null;
      }
      const code = Math.trunc(comparison);
      return code >= 0 && code <= 5 ? code : null;
    }

    switch (comparison.trim().toUpperCase()) {
      case 'LESS_THAN':
        return 0;
      case 'LESS_EQUAL':
        return 1;
      case 'EQUAL':
        return 2;
      case 'GREATER_EQUAL':
        return 3;
      case 'GREATER':
        return 4;
      case 'NOT_EQUAL':
        return 5;
      default:
        return null;
    }
  }

  private compareScriptNumeric(comparison: ScriptComparisonInput, left: number, right: number): boolean {
    const comparisonCode = this.resolveScriptComparisonCode(comparison);
    if (comparisonCode === null) {
      return false;
    }

    switch (comparisonCode) {
      case 0:
        return left < right;
      case 1:
        return left <= right;
      case 2:
        return left === right;
      case 3:
        return left >= right;
      case 4:
        return left > right;
      case 5:
        return left !== right;
      default:
        return false;
    }
  }

  private compareScriptCount(
    comparison: ScriptComparisonInput,
    currentCount: number,
    targetCount: number,
  ): boolean {
    const normalizedCurrentCount = Number.isFinite(currentCount) ? Math.trunc(currentCount) : 0;
    const normalizedTargetCount = Number.isFinite(targetCount) ? Math.trunc(targetCount) : 0;
    return this.compareScriptNumeric(comparison, normalizedCurrentCount, normalizedTargetCount);
  }

  private normalizeScriptCompletionName(name: string): string {
    return name.trim();
  }

  private consumeScriptCompletedName(list: string[], name: string): boolean {
    for (let index = 0; index < list.length; index += 1) {
      if (list[index] !== name) {
        continue;
      }
      list.splice(index, 1);
      return true;
    }
    return false;
  }

  private normalizeScriptTeamName(teamName: string): string {
    return teamName.trim().toUpperCase();
  }

  private getScriptTeamRecord(teamName: string): ScriptTeamRecord | null {
    const teamNameUpper = this.normalizeScriptTeamName(teamName);
    if (!teamNameUpper) {
      return null;
    }
    return this.scriptTeamsByName.get(teamNameUpper) ?? null;
  }

  private getOrCreateScriptTeamRecord(teamName: string): ScriptTeamRecord | null {
    const teamNameUpper = this.normalizeScriptTeamName(teamName);
    if (!teamNameUpper) {
      return null;
    }
    const existing = this.scriptTeamsByName.get(teamNameUpper);
    if (existing) {
      return existing;
    }
    const created: ScriptTeamRecord = {
      nameUpper: teamNameUpper,
      memberEntityIds: new Set<number>(),
      created: false,
      stateName: '',
      controllingSide: null,
    };
    this.scriptTeamsByName.set(teamNameUpper, created);
    return created;
  }

  private getScriptTeamMemberEntities(team: ScriptTeamRecord): MapEntity[] {
    const entities: MapEntity[] = [];
    for (const entityId of team.memberEntityIds) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity) {
        continue;
      }
      entities.push(entity);
    }
    return entities;
  }

  private isScriptTeamMemberAliveForObjects(entity: MapEntity): boolean {
    if (this.isScriptEntityEffectivelyDead(entity) || entity.destroyed) {
      return false;
    }
    if (entity.kindOf.has('PROJECTILE') || entity.kindOf.has('INERT') || entity.kindOf.has('MINE')) {
      return false;
    }
    return true;
  }

  private isScriptTeamMemberAliveForUnits(entity: MapEntity): boolean {
    if (this.isScriptEntityEffectivelyDead(entity) || entity.destroyed) {
      return false;
    }
    if (entity.kindOf.has('STRUCTURE') || entity.kindOf.has('PROJECTILE') || entity.kindOf.has('MINE')) {
      return false;
    }
    return true;
  }

  private resolveScriptTeamControllingSide(team: ScriptTeamRecord): string | null {
    if (team.controllingSide) {
      return team.controllingSide;
    }

    let resolvedSide: string | null = null;
    for (const entity of this.getScriptTeamMemberEntities(team)) {
      const entitySide = this.normalizeSide(entity.side);
      if (!entitySide) {
        return null;
      }
      if (resolvedSide === null) {
        resolvedSide = entitySide;
        continue;
      }
      if (resolvedSide !== entitySide) {
        return null;
      }
    }

    return resolvedSide;
  }

  private didScriptTeamMemberEnterOrExitThisFrame(team: ScriptTeamRecord): boolean {
    for (const entityId of team.memberEntityIds) {
      if (this.scriptTriggerEnterExitFrameByEntityId.get(entityId) === this.frameCounter) {
        return true;
      }
    }
    return false;
  }

  private isScriptTeamMemberInsideTrigger(entityId: number, triggerIndex: number): boolean {
    return this.scriptTriggerMembershipByEntityId.get(entityId)?.has(triggerIndex) ?? false;
  }

  private didScriptTeamMemberEnterTrigger(entityId: number, triggerIndex: number): boolean {
    return this.scriptTriggerEnteredByEntityId.get(entityId)?.has(triggerIndex) ?? false;
  }

  private didScriptTeamMemberExitTrigger(entityId: number, triggerIndex: number): boolean {
    return this.scriptTriggerExitedByEntityId.get(entityId)?.has(triggerIndex) ?? false;
  }

  private resolveScriptRelationshipInput(input: ScriptRelationshipInput): RelationshipValue | null {
    if (typeof input === 'number') {
      const value = Math.trunc(input);
      if (
        value === RELATIONSHIP_ENEMIES
        || value === RELATIONSHIP_NEUTRAL
        || value === RELATIONSHIP_ALLIES
      ) {
        return value;
      }
      return null;
    }

    const normalized = input.trim().toUpperCase();
    switch (normalized) {
      case 'ENEMY':
      case 'ENEMIES':
      case 'REL_ENEMY':
        return RELATIONSHIP_ENEMIES;
      case 'NEUTRAL':
      case 'REL_NEUTRAL':
        return RELATIONSHIP_NEUTRAL;
      case 'FRIEND':
      case 'FRIENDS':
      case 'ALLY':
      case 'ALLIES':
      case 'REL_FRIEND':
        return RELATIONSHIP_ALLIES;
      default:
        return null;
    }
  }

  private isScriptEntityEffectivelyDead(entity: MapEntity): boolean {
    return entity.destroyed || entity.slowDeathState !== null || entity.structureCollapseState !== null;
  }

  private isEntityScriptSpecialPowerDisabled(entity: MapEntity): boolean {
    if (entity.objectStatusFlags.has('DISABLED') || entity.objectStatusFlags.has('SCRIPT_DISABLED')) {
      return true;
    }
    for (const status of entity.objectStatusFlags) {
      if (status.startsWith('DISABLED_')) {
        return true;
      }
    }
    return false;
  }

  private evaluateScriptCommandButtonSpecialPowerReady(
    entity: MapEntity,
    normalizedSpecialPowerName: string,
  ): boolean | null {
    if (!entity.specialPowerModules.has(normalizedSpecialPowerName)) {
      return null;
    }
    if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
      return false;
    }
    if (this.isEntityScriptSpecialPowerDisabled(entity)) {
      return false;
    }
    return this.resolveSpecialPowerReadyFrameForSourceEntity(normalizedSpecialPowerName, entity.id) <= this.frameCounter;
  }

  private evaluateScriptCommandButtonUpgradeReady(
    entity: MapEntity,
    upgradeDef: UpgradeDef,
  ): boolean | null {
    if (!this.canEntityProduceUpgrade(entity, upgradeDef)) {
      return null;
    }

    const ownerSide = this.resolveEntityOwnerSide(entity);
    if (!ownerSide) {
      return false;
    }

    const normalizedUpgradeName = upgradeDef.name.trim().toUpperCase();
    if (!normalizedUpgradeName || normalizedUpgradeName === 'NONE') {
      return false;
    }

    const upgradeType = resolveUpgradeType(upgradeDef);
    if (upgradeType === 'PLAYER') {
      if (this.hasSideUpgradeCompleted(ownerSide, normalizedUpgradeName)) {
        return false;
      }
      if (this.hasSideUpgradeInProduction(ownerSide, normalizedUpgradeName)) {
        return false;
      }
    } else {
      if (entity.completedUpgrades.has(normalizedUpgradeName)) {
        return false;
      }
      if (entity.productionQueue.some(
        (entry) => entry.type === 'UPGRADE' && entry.upgradeName === normalizedUpgradeName,
      )) {
        return false;
      }
    }

    const buildCost = resolveUpgradeBuildCost(upgradeDef);
    return this.canAffordUpgrade(ownerSide, buildCost);
  }

  private resolveSpecialPowerReadyFrameForSourceEntity(
    normalizedSpecialPowerName: string,
    sourceEntityId: number,
  ): number {
    const sourcesForPower = this.shortcutSpecialPowerSourceByName.get(normalizedSpecialPowerName);
    if (!sourcesForPower) {
      return this.frameCounter;
    }
    const readyFrame = sourcesForPower.get(sourceEntityId);
    if (!Number.isFinite(readyFrame)) {
      return this.frameCounter;
    }
    return Math.max(0, Math.trunc(readyFrame!));
  }

  private normalizeSide(side?: string): string {
    return side ? side.trim().toLowerCase() : '';
  }

  private normalizePlayerIndex(playerIndex: number): number | null {
    if (!Number.isFinite(playerIndex)) {
      return null;
    }
    const normalized = Math.trunc(playerIndex);
    if (normalized < 0) {
      return null;
    }
    return normalized;
  }

  private relationshipValueToLabel(relationship: number): EntityRelationship {
    if (relationship === RELATIONSHIP_ENEMIES) {
      return 'enemies';
    }
    if (relationship === RELATIONSHIP_ALLIES) {
      return 'allies';
    }
    return 'neutral';
  }

  private normalizeShortcutSpecialPowerName(specialPowerName: string): string | null {
    const normalized = specialPowerName.trim().toUpperCase();
    return normalized || null;
  }

  private clearTrackedShortcutSpecialPowerName(normalizedSpecialPowerName: string): void {
    const sourcesForPower = this.shortcutSpecialPowerSourceByName.get(normalizedSpecialPowerName);
    if (!sourcesForPower) {
      return;
    }

    for (const sourceEntityId of sourcesForPower.keys()) {
      const powersForEntity = this.shortcutSpecialPowerNamesByEntityId.get(sourceEntityId);
      if (!powersForEntity) {
        continue;
      }
      powersForEntity.delete(normalizedSpecialPowerName);
      if (powersForEntity.size === 0) {
        this.shortcutSpecialPowerNamesByEntityId.delete(sourceEntityId);
      }
    }
    this.shortcutSpecialPowerSourceByName.delete(normalizedSpecialPowerName);
  }

  private normalizeControllingPlayerToken(token?: string): string | null {
    if (!token) {
      return null;
    }
    const normalized = token.trim().toLowerCase();
    return normalized.length > 0 ? normalized : null;
  }

  private resolveMapObjectControllingPlayerToken(mapObject: MapObjectJSON): string | null {
    for (const [key, value] of Object.entries(mapObject.properties)) {
      if (key.trim().toLowerCase() !== 'originalowner') {
        continue;
      }

      return this.normalizeControllingPlayerToken(value);
    }

    return null;
  }

  private relationshipKey(sourceSide: string, targetSide: string): string {
    return `${sourceSide}\u0000${targetSide}`;
  }

  private getTeamRelationshipBySides(sourceSide: string, targetSide: string): number {
    const source = this.normalizeSide(sourceSide);
    const target = this.normalizeSide(targetSide);
    if (!source || !target) {
      return RELATIONSHIP_NEUTRAL;
    }

    const teamOverride = this.teamRelationshipOverrides.get(this.relationshipKey(source, target));
    if (teamOverride !== undefined) {
      return teamOverride;
    }

    const playerOverride = this.playerRelationshipOverrides.get(this.relationshipKey(source, target));
    if (playerOverride !== undefined) {
      return playerOverride;
    }

    return source === target ? RELATIONSHIP_ALLIES : RELATIONSHIP_NEUTRAL;
  }

  private isValidRelationship(relationship: number): relationship is RelationshipValue {
    return (
      relationship === RELATIONSHIP_ENEMIES
      || relationship === RELATIONSHIP_NEUTRAL
      || relationship === RELATIONSHIP_ALLIES
    );
  }

  private getTeamRelationship(sourceEntity: MapEntity, targetEntity: MapEntity): number {
    if (!sourceEntity || !targetEntity) {
      return RELATIONSHIP_NEUTRAL;
    }
    return this.getTeamRelationshipBySides(sourceEntity.side ?? '', targetEntity.side ?? '');
  }

  setTeamRelationship(sourceSide: string, targetSide: string, relationship: number): void {
    const source = this.normalizeSide(sourceSide);
    const target = this.normalizeSide(targetSide);
    if (!source || !target) {
      return;
    }
    if (!this.isValidRelationship(relationship)) {
      return;
    }
    this.teamRelationshipOverrides.set(this.relationshipKey(source, target), relationship);
  }

  setPlayerRelationship(sourceSide: string, targetSide: string, relationship: number): void {
    const source = this.normalizeSide(sourceSide);
    const target = this.normalizeSide(targetSide);
    if (!source || !target) {
      return;
    }
    if (!this.isValidRelationship(relationship)) {
      return;
    }
    this.playerRelationshipOverrides.set(this.relationshipKey(source, target), relationship);
  }

  clearTeamRelationshipOverrides(): void {
    this.teamRelationshipOverrides.clear();
    this.playerRelationshipOverrides.clear();
  }

  private canCrushOrSquish(
    mover: MapEntity,
    target: MapEntity,
    testType: number = TEST_CRUSH_OR_SQUISH,
  ): boolean {
    if (!mover || !target) {
      return false;
    }
    if (mover.isUnmanned) {
      return false;
    }

    if (this.getTeamRelationship(mover, target) === RELATIONSHIP_ALLIES) {
      return false;
    }

    if (mover.crusherLevel <= 0) {
      return false;
    }

    if (testType === TEST_SQUISH_ONLY || testType === TEST_CRUSH_OR_SQUISH) {
      if (target.canBeSquished) {
        return true;
      }
    }

    if (testType === TEST_CRUSH_ONLY || testType === TEST_CRUSH_OR_SQUISH) {
      return mover.crusherLevel > target.crushableLevel;
    }

    return false;
  }

  private resolveLocomotorProfiles(
    objectDef: ObjectDef | undefined,
    iniDataRegistry: IniDataRegistry,
  ): Map<string, LocomotorSetProfile> {
    const profiles = new Map<string, LocomotorSetProfile>();
    if (!objectDef) {
      return profiles;
    }

    const locomotorSets = this.extractLocomotorSetEntries(objectDef);
    for (const [setName, locomotorNames] of locomotorSets) {
      let surfaceMask = 0;
      let downhillOnly = false;
      let movementSpeed = 0;
      // Source parity: physics fields come from the primary (fastest) locomotor in the set.
      let acceleration = 0;
      let braking = 0;
      let turnRate = 0;
      let minSpeed = 0;
      let appearance = 'OTHER';
      let primaryLocomotor: LocomotorDef | null = null;
      for (const locomotorName of locomotorNames) {
        const locomotor = iniDataRegistry.getLocomotor(locomotorName);
        if (!locomotor) {
          continue;
        }
        surfaceMask |= locomotor.surfaceMask;
        downhillOnly = downhillOnly || locomotor.downhillOnly;
        if ((locomotor.speed ?? 0) > movementSpeed) {
          movementSpeed = locomotor.speed ?? 0;
          primaryLocomotor = locomotor;
        }
      }
      if (primaryLocomotor) {
        const f = primaryLocomotor.fields;
        acceleration = readNumericField(f, ['Acceleration']) ?? 0;
        braking = readNumericField(f, ['Braking']) ?? 0;
        turnRate = readNumericField(f, ['TurnRate']) ?? 0;
        minSpeed = readNumericField(f, ['MinSpeed']) ?? 0;
        // Source parity: TurnRate in INI is degrees/sec, convert to radians/sec.
        turnRate = turnRate * (Math.PI / 180);
        const appearanceToken = readStringField(f, ['Appearance'])?.toUpperCase().trim();
        if (appearanceToken) {
          appearance = appearanceToken;
        }
      }
      profiles.set(setName, {
        surfaceMask,
        downhillOnly,
        movementSpeed,
        minSpeed,
        acceleration,
        braking,
        turnRate,
        appearance,
      });
    }

    return profiles;
  }

  private extractLocomotorSetEntries(objectDef: ObjectDef): Map<string, string[]> {
    const sets = new Map<string, string[]>();

    const addEntry = (setName: string, locomotors: string[]): void => {
      const normalizedSet = setName.trim().toUpperCase();
      if (!normalizedSet) {
        return;
      }
      sets.set(normalizedSet, locomotors);
    };

    const parseTokens = (tokens: string[]): { setName: string; locomotors: string[] } | null => {
      if (tokens.length < 1) {
        return null;
      }
      const setName = tokens[0]!.trim();
      const locomotors = tokens
        .slice(1)
        .map((token) => token.trim())
        .filter((token) => token.length > 0 && token.toUpperCase() !== 'NONE');
      return { setName, locomotors };
    };

    const parseIniScalarTokens = (value: IniValue): string[] => {
      if (typeof value === 'string') {
        return value.split(/[\s,;|]+/).filter(Boolean);
      }
      if (typeof value === 'number' || typeof value === 'boolean') {
        return [String(value)];
      }
      return [];
    };

    const parseLocomotorEntries = (value: IniValue | undefined): Array<{ setName: string; locomotors: string[] }> => {
      if (value === undefined) {
        return [];
      }
      if (Array.isArray(value)) {
        return value.flatMap((entry) => parseLocomotorEntries(entry as IniValue));
      }
      const parsed = parseTokens(parseIniScalarTokens(value));
      return parsed ? [parsed] : [];
    };

    const isLocomotorSetField = (fieldName: string): boolean => {
      const normalized = fieldName.toUpperCase();
      return normalized === 'LOCOMOTOR' || normalized === 'LOCOMOTORSET';
    };

    const visitBlock = (block: IniBlock): void => {
      const blockType = block.type.toUpperCase();
      if (blockType === 'LOCOMOTORSET' || blockType === 'LOCOMOTOR') {
        const tokens = block.name.split(/\s+/).filter(Boolean);
        const parsed = parseTokens(tokens);
        if (parsed) {
          addEntry(parsed.setName, parsed.locomotors);
        }
      }

      for (const [fieldName, fieldValue] of Object.entries(block.fields)) {
        if (!isLocomotorSetField(fieldName)) {
          continue;
        }
        const parsedEntries = parseLocomotorEntries(fieldValue);
        for (const parsed of parsedEntries) {
          addEntry(parsed.setName, parsed.locomotors);
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const [fieldName, fieldValue] of Object.entries(objectDef.fields)) {
      if (!isLocomotorSetField(fieldName)) {
        continue;
      }
      const parsedEntries = parseLocomotorEntries(fieldValue);
      for (const parsed of parsedEntries) {
        addEntry(parsed.setName, parsed.locomotors);
      }
    }

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }

    return sets;
  }

  private resolveObstacleGeometry(objectDef: ObjectDef | undefined): ObstacleGeometry | null {
    if (!objectDef) {
      return null;
    }

    const geometryType = readStringField(objectDef.fields, ['Geometry', 'GeometryType'])?.toUpperCase() ?? '';
    const majorRaw = readNumericField(objectDef.fields, ['GeometryMajorRadius', 'MajorRadius', 'GeometryRadius', 'Radius']);
    const minorRaw = readNumericField(objectDef.fields, ['GeometryMinorRadius', 'MinorRadius']);
    const majorRadius = majorRaw !== null ? Math.abs(majorRaw) : (minorRaw !== null ? Math.abs(minorRaw) : 0);
    const minorRadius = minorRaw !== null ? Math.abs(minorRaw) : majorRadius;

    if (!Number.isFinite(majorRadius) || majorRadius <= 0) {
      return null;
    }
    if (!Number.isFinite(minorRadius) || minorRadius <= 0) {
      return null;
    }

    const heightRaw = readNumericField(objectDef.fields, ['GeometryHeight', 'Height']);
    const height = heightRaw !== null && Number.isFinite(heightRaw) ? Math.abs(heightRaw) : 0;
    const shape: ObstacleGeometryShape = geometryType.includes('BOX') ? 'box' : 'circle';
    return { shape, majorRadius, minorRadius, height };
  }

  /**
   * Source parity: GeometryInfo::calcBoundingStuff() — computes the bounding sphere radius.
   *   SPHERE:   majorRadius
   *   CYLINDER: max(majorRadius, height/2)
   *   BOX:      sqrt(majorRadius² + minorRadius² + (height/2)²)
   * Falls back to baseHeight when no explicit geometry is available.
   */
  private resolveBoundingSphereRadius(entity: MapEntity): number {
    const geom = entity.obstacleGeometry;
    if (geom) {
      const halfHeight = geom.height * 0.5;
      if (geom.shape === 'box') {
        // Source parity: Geometry.cpp:515 — 3D diagonal of the box's half-extents.
        return Math.hypot(geom.majorRadius, geom.minorRadius, halfHeight);
      }
      // cylinder (circle shape)
      return Math.max(geom.majorRadius, halfHeight);
    }
    // Fallback: use baseHeight (= nominalHeight/2 ≈ GeometryHeight/2 for default geometry).
    // This covers the center-offset so entities at the same terrain level are not penalized.
    return entity.baseHeight;
  }

  private rasterizeObstacleGeometry(entity: MapEntity, grid: NavigationGrid): void {
    if (!entity.obstacleGeometry) {
      return;
    }

    const centerX = entity.x;
    const centerZ = entity.z;
    if (entity.obstacleGeometry.shape === 'box') {
      const angle = entity.rotationY;
      const major = entity.obstacleGeometry.majorRadius;
      const minor = entity.obstacleGeometry.minorRadius;
      const stepSize = MAP_XY_FACTOR * 0.5;
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const ydx = s * stepSize;
      const ydz = -c * stepSize;
      const xdx = c * stepSize;
      const xdz = s * stepSize;
      const numStepsX = Math.max(1, Math.ceil((2 * major) / stepSize));
      const numStepsZ = Math.max(1, Math.ceil((2 * minor) / stepSize));
      let topLeftX = centerX - major * c - minor * s;
      let topLeftZ = centerZ + minor * c - major * s;

      for (let iz = 0; iz < numStepsZ; iz++, topLeftX += ydx, topLeftZ += ydz) {
        let worldX = topLeftX;
        let worldZ = topLeftZ;
        for (let ix = 0; ix < numStepsX; ix++, worldX += xdx, worldZ += xdz) {
          const cellX = Math.floor((worldX + 0.5) / MAP_XY_FACTOR);
          const cellZ = Math.floor((worldZ + 0.5) / MAP_XY_FACTOR);
          this.markObstacleCell(cellX, cellZ, grid);
        }
      }
      return;
    }

    const radius = entity.obstacleGeometry.majorRadius;
    const topLeftX = Math.floor(0.5 + (centerX - radius) / MAP_XY_FACTOR) - 1;
    const topLeftZ = Math.floor(0.5 + (centerZ - radius) / MAP_XY_FACTOR) - 1;
    const size = radius / MAP_XY_FACTOR + 0.4;
    const r2 = size * size;
    const centerCellX = centerX / MAP_XY_FACTOR;
    const centerCellZ = centerZ / MAP_XY_FACTOR;
    const bottomRightX = topLeftX + Math.floor(2 * size + 2);
    const bottomRightZ = topLeftZ + Math.floor(2 * size + 2);

    for (let z = topLeftZ; z < bottomRightZ; z++) {
      for (let x = topLeftX; x < bottomRightX; x++) {
        const dx = x + 0.5 - centerCellX;
        const dz = z + 0.5 - centerCellZ;
        if (dx * dx + dz * dz <= r2) {
          this.markObstacleCell(x, z, grid);
        }
      }
    }
  }

  private markObstacleCell(cellX: number, cellZ: number, grid: NavigationGrid): void {
    if (!this.isCellInBounds(cellX, cellZ, grid)) {
      return;
    }
    const index = cellZ * grid.width + cellX;
    grid.blocked[index] = 1;
    grid.terrainType[index] = NAV_OBSTACLE;
  }

  private objectToWorldPosition(
    mapObject: MapObjectJSON,
    heightmap: HeightmapGrid | null,
  ): [number, number, number] {
    const worldX = mapObject.position.x;
    // Original C&C coordinates: x->ThreeX, y->ThreeZ, z->ThreeY.
    const worldZ = mapObject.position.y;
    const terrainHeight = heightmap ? heightmap.getInterpolatedHeight(worldX, worldZ) : 0;
    const worldY = terrainHeight + mapObject.position.z;

    return [worldX, worldY, worldZ];
  }

  private pickObjectByInput(input: InputState, camera: THREE.Camera): number | null {
    return this.config.pickObjectByInput?.(input, camera) ?? null;
  }

  private getMoveTargetFromMouse(input: InputState, camera: THREE.Camera): VectorXZ | null {
    const ndc = this.pixelToNDC(input.mouseX, input.mouseY, input.viewportWidth, input.viewportHeight);
    if (ndc === null) return null;

    this.raycaster.setFromCamera(ndc, camera);
    const hitPoint = new THREE.Vector3();
    if (!this.raycaster.ray.intersectPlane(this.groundPlane, hitPoint)) {
      return null;
    }

    if (this.mapHeightmap) {
      const [clampedX, clampedZ] = this.clampWorldPositionToMapBounds(hitPoint.x, hitPoint.z);
      return {
        x: clampedX,
        z: clampedZ,
      };
    }

    return {
      x: hitPoint.x,
      z: hitPoint.z,
    };
  }

  private flushCommands(): void {
    while (this.commandQueue.length > 0) {
      const command = this.commandQueue.shift();
      if (!command) return;
      this.applyCommand(command);
    }
  }

  private applyCommand(command: GameLogicCommand): void {
    if (this.deferCommandWhileHackInternetPacking(command)) {
      return;
    }

    if (this.deferCommandWhileChinookBusy(command)) {
      return;
    }

    if (this.shouldIgnoreRailedTransportPlayerCommand(command)) {
      return;
    }

    switch (command.type) {
      case 'clearSelection': {
        this.selectedEntityIds = [];
        this.selectedEntityId = null;
        this.clearEntitySelectionState();
        return;
      }
      case 'selectEntities': {
        const nextSelectionIds = this.filterValidSelectionIds(command.entityIds);
        this.selectedEntityIds = nextSelectionIds;
        this.selectedEntityId = nextSelectionIds[0] ?? null;
        this.updateSelectionHighlight();
        return;
      }
      case 'select': {
        const picked = this.spawnedEntities.get(command.entityId);
        if (!picked || picked.destroyed) return;
        // Source parity: Object::isSelectable — UNSELECTABLE or MASKED status prevents player selection.
        if (this.entityHasObjectStatus(picked, 'UNSELECTABLE') || this.entityHasObjectStatus(picked, 'MASKED')) return;
        this.selectedEntityIds = [command.entityId];
        this.selectedEntityId = command.entityId;
        this.updateSelectionHighlight();
        return;
      }
      case 'moveTo': {
        const moveEntity = this.spawnedEntities.get(command.entityId);
        const moveJs = moveEntity?.jetAIState;
        if (moveJs) {
          const s = moveJs.state;
          if (s === 'TAKING_OFF' || s === 'LANDING' || s === 'RETURNING_FOR_LANDING') {
            // Source parity: C++ JetAIUpdate::aiDoCommand lines 2415-2420 — queue during takeoff/landing.
            moveJs.pendingCommand = { type: 'moveTo', x: command.targetX, z: command.targetZ };
            return;
          }
          if (s === 'PARKED' || s === 'RELOAD_AMMO') {
            // Aircraft is parked/reloading — store as pending, takeoff will execute it.
            moveJs.pendingCommand = { type: 'moveTo', x: command.targetX, z: command.targetZ };
            return;
          }
        }
        this.cancelEntityCommandPathActions(command.entityId);
        this.clearAttackTarget(command.entityId);
        this.issueMoveTo(command.entityId, command.targetX, command.targetZ);
        return;
      }
      case 'attackMoveTo': {
        const amEntity = this.spawnedEntities.get(command.entityId);
        const amJs = amEntity?.jetAIState;
        if (amJs) {
          const s = amJs.state;
          if (s === 'TAKING_OFF' || s === 'LANDING' || s === 'RETURNING_FOR_LANDING') {
            amJs.pendingCommand = { type: 'moveTo', x: command.targetX, z: command.targetZ };
            return;
          }
          if (s === 'PARKED' || s === 'RELOAD_AMMO') {
            amJs.pendingCommand = { type: 'moveTo', x: command.targetX, z: command.targetZ };
            return;
          }
        }
        this.cancelEntityCommandPathActions(command.entityId);
        this.clearAttackTarget(command.entityId);
        this.issueMoveTo(
          command.entityId,
          command.targetX,
          command.targetZ,
          command.attackDistance,
        );
        // Source parity: AssaultTransportAIUpdate::aiDoCommand — begin assault on attack-move.
        if (amEntity?.assaultTransportProfile) {
          this.beginAssaultTransportAttackMove(amEntity, command.targetX, command.targetZ);
        }
        return;
      }
      case 'guardPosition':
        this.cancelEntityCommandPathActions(command.entityId);
        this.clearAttackTarget(command.entityId);
        this.initGuardPosition(command.entityId, command.targetX, command.targetZ, command.guardMode);
        return;
      case 'guardObject':
        this.cancelEntityCommandPathActions(command.entityId);
        this.clearAttackTarget(command.entityId);
        this.initGuardObject(command.entityId, command.targetEntityId, command.guardMode);
        return;
      case 'setRallyPoint':
        this.setEntityRallyPoint(command.entityId, command.targetX, command.targetZ);
        return;
      case 'attackEntity': {
        const atkEntity = this.spawnedEntities.get(command.entityId);
        const atkJs = atkEntity?.jetAIState;
        if (atkJs) {
          const s = atkJs.state;
          if (s === 'TAKING_OFF' || s === 'LANDING' || s === 'RETURNING_FOR_LANDING') {
            // Source parity: C++ JetAIUpdate::aiDoCommand lines 2415-2420 — queue during takeoff/landing.
            atkJs.pendingCommand = { type: 'attackEntity', targetId: command.targetEntityId };
            return;
          }
          if (s === 'PARKED' || s === 'RELOAD_AMMO') {
            // Aircraft is parked/reloading — store as pending, takeoff will execute it.
            atkJs.pendingCommand = { type: 'attackEntity', targetId: command.targetEntityId };
            return;
          }
        }
        this.cancelEntityCommandPathActions(command.entityId);
        this.issueAttackEntity(
          command.entityId,
          command.targetEntityId,
          command.commandSource ?? 'PLAYER',
        );
        // Source parity: TransportAIUpdate::privateAttackObject — propagate attack to passengers.
        if (atkEntity) {
          this.propagateTransportAttackToPassengers(
            atkEntity, command.targetEntityId, command.commandSource ?? 'PLAYER',
          );
        }
        // Source parity: AssaultTransportAIUpdate::aiDoCommand — begin assault on attack command.
        if (atkEntity?.assaultTransportProfile && (command.commandSource ?? 'PLAYER') !== 'AI') {
          this.beginAssaultTransportAttack(atkEntity, command.targetEntityId, false);
        }
        return;
      }
      case 'fireWeapon':
        this.cancelEntityCommandPathActions(command.entityId);
        this.issueFireWeapon(
          command.entityId,
          command.weaponSlot,
          command.maxShotsToFire,
          command.targetObjectId,
          command.targetPosition,
        );
        return;
      case 'switchWeapon': {
        this.cancelEntityCommandPathActions(command.entityId);
        const entity = this.spawnedEntities.get(command.entityId);
        const weaponSlot = this.normalizeWeaponSlot(command.weaponSlot);
        if (!entity || entity.destroyed || weaponSlot === null) {
          return;
        }
        entity.forcedWeaponSlot = weaponSlot;
        this.refreshEntityCombatProfiles(entity);
        return;
      }
      case 'stop': {
        this.cancelEntityCommandPathActions(command.entityId);
        this.clearAttackTarget(command.entityId);
        this.stopEntity(command.entityId);
        // Source parity: AssaultTransportAIUpdate::aiDoCommand(AICMD_IDLE) — recall all members.
        this.resetAssaultTransportState(command.entityId);
        const stopEntity = this.spawnedEntities.get(command.entityId);
        if (stopEntity) {
          // Source parity: explicit stop resets auto-target scan timer and clears guard state.
          stopEntity.autoTargetScanNextFrame = this.frameCounter + AUTO_TARGET_SCAN_RATE_FRAMES;
          stopEntity.guardState = 'NONE';
        }
        return;
      }
      case 'bridgeDestroyed':
        this.onObjectDestroyed(command.entityId);
        return;
      case 'bridgeRepaired':
        this.onObjectRepaired(command.entityId);
        return;
      case 'setLocomotorSet':
        this.setEntityLocomotorSet(command.entityId, command.setName);
        return;
      case 'setLocomotorUpgrade':
        this.setEntityLocomotorUpgrade(command.entityId, command.enabled);
        return;
      case 'captureEntity':
        this.captureEntity(command.entityId, command.newSide);
        return;
      case 'applyUpgrade':
        this.applyUpgradeToEntity(command.entityId, command.upgradeName);
        return;
      case 'queueUnitProduction':
        this.queueUnitProduction(command.entityId, command.unitTemplateName);
        return;
      case 'cancelUnitProduction':
        this.cancelUnitProduction(command.entityId, command.productionId);
        return;
      case 'queueUpgradeProduction':
        this.queueUpgradeProduction(command.entityId, command.upgradeName);
        return;
      case 'cancelUpgradeProduction':
        this.cancelUpgradeProduction(command.entityId, command.upgradeName);
        return;
      case 'setSideCredits':
        this.setSideCredits(command.side, command.amount);
        return;
      case 'addSideCredits':
        this.addSideCredits(command.side, command.amount);
        return;
      case 'setSidePlayerType':
        this.setSidePlayerType(command.side, command.playerType);
        return;
      case 'grantSideScience':
        this.grantSideScience(command.side, command.scienceName);
        return;
      case 'applyPlayerUpgrade': {
        const localSide = this.resolveLocalPlayerSide();
        if (!localSide) {
          return;
        }
        const normalizedUpgradeName = command.upgradeName.trim().toUpperCase();
        if (!normalizedUpgradeName) {
          return;
        }
        this.setSideUpgradeCompleted(localSide, normalizedUpgradeName, true);
        this.applyCompletedPlayerUpgrade(localSide, normalizedUpgradeName);
        return;
      }
      case 'purchaseScience': {
        // Source parity: AI players pass side explicitly; human players fall back to local player.
        const purchaseSide = command.side
          ? this.normalizeSide(command.side)
          : this.resolveLocalPlayerSide();
        if (!purchaseSide) {
          return;
        }
        const normalizedScienceName = command.scienceName.trim().toUpperCase();
        if (!normalizedScienceName || normalizedScienceName === 'NONE') {
          return;
        }

        const registry = this.iniDataRegistry;
        if (!registry) {
          return;
        }

        const scienceDef = findScienceDefByName(registry, normalizedScienceName);
        if (!scienceDef) {
          return;
        }

        const normalizedScience = scienceDef.name.trim().toUpperCase();
        if (!normalizedScience || normalizedScience === 'NONE') {
          return;
        }

        const scienceCost = this.getPurchasableScienceCost(purchaseSide, normalizedScience);
        if (scienceCost <= 0) {
          return;
        }
        if (!this.addScienceToSide(purchaseSide, normalizedScience)) {
          return;
        }
        const normalizedPurchaseSide = this.normalizeSide(purchaseSide);
        if (normalizedPurchaseSide) {
          const rankState = this.getSideRankStateMap(normalizedPurchaseSide);
          rankState.sciencePurchasePoints = Math.max(0, rankState.sciencePurchasePoints - scienceCost);
        }
        return;
      }
      case 'issueSpecialPower':
        this.routeIssueSpecialPowerCommand(command);
        return;
      case 'exitContainer':
        this.handleExitContainerCommand(command.entityId);
        return;
      case 'evacuate': {
        this.handleEvacuateCommand(command.entityId);
        return;
      }
      case 'executeRailedTransport':
        this.handleExecuteRailedTransportCommand(command);
        return;
      case 'beaconDelete':
        this.handleBeaconDeleteCommand(command);
        return;
      case 'hackInternet':
        this.handleHackInternetCommand(command);
        return;
      case 'toggleOvercharge':
        this.handleToggleOverchargeCommand(command);
        return;
      case 'detonateDemoTrap':
        this.handleDetonateDemoTrapCommand(command);
        return;
      case 'toggleDemoTrapMode':
        this.handleToggleDemoTrapModeCommand(command);
        return;
      case 'combatDrop':
        this.handleCombatDropCommand(command);
        return;
      case 'placeBeacon':
        this.handlePlaceBeaconCommand(command);
        return;
      case 'enterObject':
        this.handleEnterObjectCommand(command);
        return;
      case 'constructBuilding':
        this.handleConstructBuildingCommand(command);
        return;
      case 'cancelDozerConstruction':
        this.handleCancelDozerConstructionCommand(command);
        return;
      case 'sell':
        this.handleSellCommand(command);
        return;
      case 'garrisonBuilding':
        this.handleGarrisonBuildingCommand(command);
        return;
      case 'repairBuilding':
        this.handleRepairBuildingCommand(command);
        return;
      case 'enterTransport':
        this.handleEnterTransportCommand(command);
        return;
      default:
        return;
    }
  }

  private deferCommandWhileHackInternetPacking(command: GameLogicCommand): boolean {
    const hasEntityId = 'entityId' in command && typeof command.entityId === 'number';
    if (!hasEntityId) {
      return false;
    }

    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed) {
      return false;
    }

    const pendingState = this.hackInternetPendingCommandByEntityId.get(entity.id);
    if (pendingState) {
      pendingState.command = command;
      return true;
    }

    if (command.type === 'hackInternet') {
      return false;
    }

    if (!this.hackInternetStateByEntityId.has(entity.id)) {
      return false;
    }

    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    const profile = this.extractHackInternetProfile(objectDef ?? undefined);
    if (!profile) {
      return false;
    }

    this.hackInternetStateByEntityId.delete(entity.id);
    const packDelayFrames = this.resolveHackInternetPackTimeFrames(entity, profile);
    if (packDelayFrames <= 0) {
      return false;
    }

    this.stopEntity(entity.id);
    this.clearAttackTarget(entity.id);
    this.hackInternetPendingCommandByEntityId.set(entity.id, {
      command,
      executeFrame: this.frameCounter + packDelayFrames,
    });
    return true;
  }

  private deferCommandWhileChinookBusy(command: GameLogicCommand): boolean {
    const hasEntityId = 'entityId' in command && typeof command.entityId === 'number';
    if (!hasEntityId) {
      return false;
    }

    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed || !entity.chinookAIProfile) {
      return false;
    }

    if (!this.pendingCombatDropActions.has(entity.id)) {
      return false;
    }

    this.pendingChinookCommandByEntityId.set(entity.id, command);
    return true;
  }

  private shouldIgnoreRailedTransportPlayerCommand(command: GameLogicCommand): boolean {
    const hasEntityId = 'entityId' in command && typeof command.entityId === 'number';
    if (!hasEntityId) {
      return false;
    }

    const blockedCommandType = this.isRailedTransportPlayerBlockedCommandType(command.type);
    if (!blockedCommandType) {
      return false;
    }

    return this.isRailedTransportEntity(command.entityId);
  }

  private isRailedTransportPlayerBlockedCommandType(commandType: GameLogicCommand['type']): boolean {
    switch (commandType) {
      case 'moveTo':
      case 'attackMoveTo':
      case 'guardPosition':
      case 'guardObject':
      case 'attackEntity':
      case 'fireWeapon':
      case 'switchWeapon':
      case 'stop':
      case 'enterObject':
      case 'combatDrop':
      case 'hackInternet':
      case 'toggleOvercharge':
      case 'detonateDemoTrap':
      case 'toggleDemoTrapMode':
      case 'setRallyPoint':
      case 'garrisonBuilding':
      case 'repairBuilding':
      case 'enterTransport':
        return true;
      default:
        return false;
    }
  }

  private isRailedTransportEntity(entityId: number): boolean {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return false;
    }

    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    return this.extractRailedTransportProfile(objectDef ?? undefined) !== null;
  }

  /**
   * Source parity: AIPlayer special power usage — collect all ready special powers
   * for entities belonging to a given side. Returns power name, source entity,
   * targeting info derived from the effect category.
   */
  private collectReadySpecialPowersForSide(side: string): Array<{
    specialPowerName: string;
    sourceEntityId: number;
    commandOption: number;
    commandButtonId: string;
    effectCategory: string;
  }> {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) return [];
    const result: Array<{
      specialPowerName: string;
      sourceEntityId: number;
      commandOption: number;
      commandButtonId: string;
      effectCategory: string;
    }> = [];

    for (const [powerName, sourcesMap] of this.shortcutSpecialPowerSourceByName.entries()) {
      for (const [entityId, readyFrame] of sourcesMap.entries()) {
        if (readyFrame > this.frameCounter) continue;
        const entity = this.spawnedEntities.get(entityId);
        if (!entity || entity.destroyed) continue;
        if (this.normalizeSide(entity.side) !== normalizedSide) continue;

        // Resolve effect category from entity's special power module.
        const module = entity.specialPowerModules.get(powerName);
        const effectCategory = module
          ? resolveEffectCategoryImpl(module.moduleType)
          : 'GENERIC';

        // Derive commandOption from effect category for AI dispatch.
        const NEED_TARGET_POS = 0x20;
        const NEED_TARGET_ENEMY = 0x01;
        let commandOption = 0;
        const upperCat = effectCategory.toUpperCase();
        if (upperCat === 'AREA_DAMAGE' || upperCat === 'EMP_PULSE'
            || upperCat === 'SPY_VISION' || upperCat === 'AREA_HEAL'
            || upperCat === 'OCL_SPAWN') {
          commandOption = NEED_TARGET_POS;
        } else if (upperCat === 'CASH_HACK' || upperCat === 'DEFECTOR') {
          commandOption = NEED_TARGET_ENEMY;
        }

        result.push({
          specialPowerName: powerName,
          sourceEntityId: entityId,
          commandOption,
          commandButtonId: '', // AI doesn't need button ID — routing uses specialPowerName.
          effectCategory,
        });
        break; // One source per power name is enough for AI.
      }
    }
    return result;
  }

  private routeIssueSpecialPowerCommand(command: IssueSpecialPowerCommand): void {
    const normalizeShortcutSpecialPowerName = this.normalizeShortcutSpecialPowerName.bind(this);
    routeIssueSpecialPowerCommandImpl(command, {
      iniDataRegistry: this.iniDataRegistry,
      frameCounter: this.frameCounter,
      selectedEntityId: this.selectedEntityId,
      spawnedEntities: this.spawnedEntities,
      msToLogicFrames: this.msToLogicFrames.bind(this),
      resolveShortcutSpecialPowerSourceEntityId: this.resolveShortcutSpecialPowerSourceEntityId.bind(this),
      resolveSharedReadyFrame: (specialPowerName) => (
        resolveSharedShortcutSpecialPowerReadyFrameImpl(
          specialPowerName,
          this.frameCounter,
          this.sharedShortcutSpecialPowerReadyFrames,
          normalizeShortcutSpecialPowerName,
        )
      ),
      resolveSourceReadyFrameBySource: (specialPowerName, sourceEntityId) => (
        resolveShortcutSpecialPowerSourceEntityReadyFrameBySourceImpl(
          specialPowerName,
          sourceEntityId,
          this.frameCounter,
          this.shortcutSpecialPowerSourceByName,
          normalizeShortcutSpecialPowerName,
        )
      ),
      setReadyFrame: this.setSpecialPowerReadyFrame.bind(this),
      getTeamRelationship: this.getTeamRelationship.bind(this),
      onIssueSpecialPowerNoTarget: this.onIssueSpecialPowerNoTarget.bind(this),
      onIssueSpecialPowerTargetPosition: this.onIssueSpecialPowerTargetPosition.bind(this),
      onIssueSpecialPowerTargetObject: this.onIssueSpecialPowerTargetObject.bind(this),
    });
  }

  private setSpecialPowerReadyFrame(
    specialPowerName: string,
    sourceEntityId: number,
    isShared: boolean,
    readyFrame: number,
  ): void {
    const normalizeShortcutSpecialPowerName = this.normalizeShortcutSpecialPowerName.bind(this);
    setSpecialPowerReadyFrameImpl(
      specialPowerName,
      sourceEntityId,
      isShared,
      readyFrame,
      this.frameCounter,
      this.sharedShortcutSpecialPowerReadyFrames,
      normalizeShortcutSpecialPowerName,
      this.trackShortcutSpecialPowerSourceEntity.bind(this),
    );
  }

  protected onIssueSpecialPowerNoTarget(
    sourceEntityId: number,
    specialPowerName: string,
    commandOption: number,
    commandButtonId: string,
    _specialPowerDef: SpecialPowerDef,
  ): void {
    const module = this.resolveSpecialPowerModuleProfile(sourceEntityId, specialPowerName);
    if (!module) {
      return;
    }

    this.recordSpecialPowerDispatch(
      sourceEntityId,
      module,
      'NO_TARGET',
      commandOption,
      commandButtonId,
      null,
      null,
      null,
    );

    // Source parity: SpecialAbilityUpdate — deferred execution via state machine.
    if (module.moduleType === 'SPECIALABILITYUPDATE') {
      this.initiateSpecialAbility(sourceEntityId, null, null, null);
      return;
    }

    // Execute no-target effects (spy vision centered on source, cash bounty, etc.).
    const source = this.spawnedEntities.get(sourceEntityId);
    if (!source || source.destroyed) {
      return;
    }

    // Source parity: BattlePlanUpdate — each battle plan has its own SpecialPower in C++
    // (SpecialPowerChangeBombardmentBattlePlan, etc.). Identify plan type from power name.
    if (source.battlePlanState && source.battlePlanProfile) {
      const upperName = specialPowerName.toUpperCase();
      let desiredPlan: BattlePlanType = 'NONE';
      if (upperName.includes('BOMBARDMENT')) desiredPlan = 'BOMBARDMENT';
      else if (upperName.includes('HOLDTHELINE')) desiredPlan = 'HOLDTHELINE';
      else if (upperName.includes('SEARCHANDDESTROY')) desiredPlan = 'SEARCHANDDESTROY';
      if (desiredPlan !== 'NONE') {
        this.requestBattlePlanChange(source, desiredPlan);
        return;
      }
    }

    const effectCategory = resolveEffectCategoryImpl(module.moduleType);
    const effectContext = this.createSpecialPowerEffectContext();

    switch (effectCategory) {
      case 'OCL_SPAWN':
        // Source parity: OCLSpecialPower::initiateInternal — execute OCL at source position.
        // No target for no-target powers; FireWeapon nuggets fire at source position.
        if (module.oclName) {
          this.executeOCL(module.oclName, source, undefined, source.x, source.z);
        }
        break;
      case 'SPY_VISION':
        // Simplified: C++ spy vision globally spies on all enemy unit vision for a duration.
        // Until the full SpyVisionUpdate system is ported, approximate as area reveal.
        executeSpyVisionImpl({
          sourceSide: source.side ?? '',
          targetX: source.x,
          targetZ: source.z,
          revealRadius: source.visionRange > 0 ? source.visionRange : DEFAULT_SPY_VISION_RADIUS,
          durationMs: module.spyVisionBaseDurationMs,
        }, effectContext);
        break;
      case 'CASH_BOUNTY': {
        // Source parity: CashBountyPower::onSpecialPowerCreation — sets the player's cash bounty
        // percentage. When enemies are killed by this player's units, they receive a percentage
        // of the victim's build cost as credits. Max-wins: only increases, never decreases.
        const bountyPercent = module.cashBountyPercent > 0 ? module.cashBountyPercent : 0;
        const side = this.normalizeSide(source.side);
        if (side && bountyPercent > 0) {
          const current = this.sideCashBountyPercent.get(side) ?? 0;
          if (bountyPercent > current) {
            this.sideCashBountyPercent.set(side, bountyPercent);
          }
        }
        break;
      }
    }
  }

  protected onIssueSpecialPowerTargetPosition(
    sourceEntityId: number,
    specialPowerName: string,
    targetX: number,
    targetZ: number,
    commandOption: number,
    commandButtonId: string,
    _specialPowerDef: SpecialPowerDef,
  ): void {
    const module = this.resolveSpecialPowerModuleProfile(sourceEntityId, specialPowerName);
    if (!module) {
      return;
    }

    this.recordSpecialPowerDispatch(
      sourceEntityId,
      module,
      'POSITION',
      commandOption,
      commandButtonId,
      null,
      targetX,
      targetZ,
    );

    // Source parity: SpecialAbilityUpdate — deferred execution via state machine.
    if (module.moduleType === 'SPECIALABILITYUPDATE') {
      this.initiateSpecialAbility(sourceEntityId, null, targetX, targetZ);
      return;
    }

    // Execute position-targeted effects.
    const source = this.spawnedEntities.get(sourceEntityId);
    if (!source || source.destroyed) {
      return;
    }

    const effectCategory = resolveEffectCategoryImpl(module.moduleType);
    const effectContext = this.createSpecialPowerEffectContext();
    const sourceSide = source.side ?? '';

    switch (effectCategory) {
      case 'OCL_SPAWN':
        // Source parity: OCLSpecialPower::initiateInternal — execute OCL at source,
        // passing target position so FireWeapon nuggets fire at the target location.
        // CreateObject nuggets spawn at source entity; FireWeapon nuggets fire at target.
        if (module.oclName) {
          this.executeOCL(module.oclName, source, undefined, targetX, targetZ);
        } else {
          // Fallback: if no OCL name, apply flat area damage (legacy behavior).
          executeAreaDamageImpl({
            sourceEntityId,
            sourceSide,
            targetX,
            targetZ,
            radius: module.areaDamageRadius > 0 ? module.areaDamageRadius : DEFAULT_AREA_DAMAGE_RADIUS,
            damage: module.areaDamageAmount > 0 ? module.areaDamageAmount : DEFAULT_AREA_DAMAGE_AMOUNT,
            damageType: 'EXPLOSION',
          }, effectContext);
        }
        break;
      case 'AREA_DAMAGE':
        executeAreaDamageImpl({
          sourceEntityId,
          sourceSide,
          targetX,
          targetZ,
          radius: module.areaDamageRadius > 0 ? module.areaDamageRadius : DEFAULT_AREA_DAMAGE_RADIUS,
          damage: module.areaDamageAmount > 0 ? module.areaDamageAmount : DEFAULT_AREA_DAMAGE_AMOUNT,
          damageType: 'EXPLOSION',
        }, effectContext);
        break;
      case 'SPY_VISION':
        executeSpyVisionImpl({
          sourceSide,
          targetX,
          targetZ,
          revealRadius: source.visionRange > 0 ? source.visionRange : DEFAULT_SPY_VISION_RADIUS,
          durationMs: module.spyVisionBaseDurationMs,
        }, effectContext);
        break;
      case 'AREA_HEAL':
        executeAreaHealImpl({
          sourceSide,
          targetX,
          targetZ,
          radius: module.areaHealRadius > 0 ? module.areaHealRadius : DEFAULT_AREA_HEAL_RADIUS,
          healAmount: module.areaHealAmount > 0 ? module.areaHealAmount : DEFAULT_AREA_HEAL_AMOUNT,
          kindOfFilter: [],
        }, effectContext);
        break;
      case 'EMP_PULSE':
        // Source parity: EMP damage pulse at position, disabling vehicles/electronics in radius.
        executeEmpPulseImpl({
          sourceEntityId,
          sourceSide,
          targetX,
          targetZ,
          radius: module.areaDamageRadius > 0 ? module.areaDamageRadius : DEFAULT_EMP_RADIUS,
          damage: module.areaDamageAmount > 0 ? module.areaDamageAmount : DEFAULT_EMP_DAMAGE,
        }, effectContext);
        break;
      case 'FIRE_WEAPON':
        // Source parity: FireWeaponPower — reloads ammo and issues attack at position.
        // C++ calls ai->aiAttackPosition(loc, maxShotsToFire, CMD_FROM_AI).
        this.issueFireWeaponAtPosition(sourceEntityId, targetX, targetZ, module.fireWeaponMaxShots);
        break;
    }
  }

  protected onIssueSpecialPowerTargetObject(
    sourceEntityId: number,
    specialPowerName: string,
    targetEntityId: number,
    commandOption: number,
    commandButtonId: string,
    _specialPowerDef: SpecialPowerDef,
  ): void {
    const module = this.resolveSpecialPowerModuleProfile(sourceEntityId, specialPowerName);
    if (!module) {
      return;
    }

    this.recordSpecialPowerDispatch(
      sourceEntityId,
      module,
      'OBJECT',
      commandOption,
      commandButtonId,
      targetEntityId,
      null,
      null,
    );

    // Source parity: SpecialAbilityUpdate — deferred execution via state machine.
    if (module.moduleType === 'SPECIALABILITYUPDATE') {
      this.initiateSpecialAbility(sourceEntityId, targetEntityId, null, null);
      return;
    }

    // Execute object-targeted effects.
    const source = this.spawnedEntities.get(sourceEntityId);
    if (!source || source.destroyed) {
      return;
    }

    const effectCategory = resolveEffectCategoryImpl(module.moduleType);
    const effectContext = this.createSpecialPowerEffectContext();
    const sourceSide = source.side ?? '';

    switch (effectCategory) {
      case 'CASH_HACK':
        // Source parity: CashHackSpecialPowerModuleData::m_defaultAmountToSteal from INI MoneyAmount.
        executeCashHackImpl({
          sourceEntityId,
          sourceSide,
          targetEntityId,
          amountToSteal: module.cashHackMoneyAmount > 0
            ? module.cashHackMoneyAmount
            : DEFAULT_CASH_HACK_AMOUNT,
        }, effectContext);
        break;
      case 'DEFECTOR':
        executeDefectorImpl({
          sourceEntityId,
          sourceSide,
          targetEntityId,
        }, effectContext);
        break;
    }
  }

  private resolveSpecialPowerModuleProfile(
    sourceEntityId: number,
    specialPowerName: string,
  ): SpecialPowerModuleProfile | null {
    const sourceEntity = this.spawnedEntities.get(sourceEntityId);
    if (!sourceEntity) {
      return null;
    }

    const normalizedSpecialPowerName = specialPowerName.trim().toUpperCase();
    if (!normalizedSpecialPowerName || normalizedSpecialPowerName === 'NONE') {
      return null;
    }

    return sourceEntity.specialPowerModules.get(normalizedSpecialPowerName) ?? null;
  }

  private recordSpecialPowerDispatch(
    sourceEntityId: number,
    module: SpecialPowerModuleProfile,
    dispatchType: SpecialPowerDispatchProfile['dispatchType'],
    commandOption: number,
    commandButtonId: string,
    targetEntityId: number | null,
    targetX: number | null,
    targetZ: number | null,
  ): void {
    const sourceEntity = this.spawnedEntities.get(sourceEntityId);
    if (!sourceEntity) {
      return;
    }

    sourceEntity.lastSpecialPowerDispatch = {
      specialPowerTemplateName: module.specialPowerTemplateName,
      moduleType: module.moduleType,
      dispatchType,
      commandOption,
      commandButtonId,
      targetEntityId,
      targetX,
      targetZ,
    };

    const normalizedSide = this.normalizeSide(sourceEntity.side);
    if (normalizedSide) {
      this.recordScriptTriggeredSpecialPowerEvent(
        normalizedSide,
        module.specialPowerTemplateName,
        sourceEntityId,
      );
    }

    // Source parity: Eva SUPERWEAPON_LAUNCHED fires for FS_SUPERWEAPON entities.
    if (sourceEntity.kindOf.has('FS_SUPERWEAPON') && sourceEntity.side) {
      this.emitEvaEvent('SUPERWEAPON_LAUNCHED', sourceEntity.side, 'own', sourceEntityId, module.specialPowerTemplateName);
      // Notify enemies about the launch.
      for (const [side] of this.sidePowerBonus.entries()) {
        if (side !== sourceEntity.side) {
          this.emitEvaEvent('SUPERWEAPON_LAUNCHED', side, 'enemy', sourceEntityId, module.specialPowerTemplateName);
        }
      }
    }
  }

  private cancelEntityCommandPathActions(entityId: number): void {
    this.cancelRailedTransportTransit(entityId);
    this.hackInternetStateByEntityId.delete(entityId);
    this.hackInternetPendingCommandByEntityId.delete(entityId);
    this.pendingEnterObjectActions.delete(entityId);
    this.pendingRepairDockActions.delete(entityId);
    this.pendingCombatDropActions.delete(entityId);
    this.clearChinookCombatDropIgnoredObstacle(entityId);
    this.pendingGarrisonActions.delete(entityId);
    this.pendingTransportActions.delete(entityId);
    this.pendingRepairActions.delete(entityId);
    // Source parity: DozerAIUpdate::cancelTask — clear active construction assignment.
    this.cancelDozerConstructionTask(entityId);
    // Source parity: SpecialAbilityUpdate — cancel any active special ability.
    this.cancelActiveSpecialAbility(entityId);
  }

  /**
   * Source parity: Cancel a running special ability on the given entity (if any).
   * Called when the entity receives a new command (stop, move, attack, etc.).
   */
  private cancelActiveSpecialAbility(entityId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) return;
    const state = entity.specialAbilityState;
    if (!state || !state.active) return;
    this.finishSpecialAbility(entity, false);
  }

  /**
   * Source parity: DozerAIUpdate::internalCancelTask — clear dozer's active build task.
   * Building stays partially built and can be resumed by another dozer.
   */
  private cancelDozerConstructionTask(dozerId: number): void {
    const buildingId = this.pendingConstructionActions.get(dozerId);
    if (buildingId !== undefined) {
      this.pendingConstructionActions.delete(dozerId);
      const building = this.spawnedEntities.get(buildingId);
      if (building && !building.destroyed && building.builderId === dozerId) {
        building.builderId = 0;
      }
    }
  }

  private cancelRailedTransportTransit(entityId: number): void {
    const state = this.railedTransportStateByEntityId.get(entityId);
    if (!state) {
      return;
    }
    state.inTransit = false;
    state.transitWaypointIds = [];
    state.transitWaypointIndex = 0;
  }

  private resolveRailedTransportRuntimeState(entityId: number): RailedTransportRuntimeState {
    let state = this.railedTransportStateByEntityId.get(entityId);
    if (!state) {
      state = createRailedTransportRuntimeStateImpl();
      this.railedTransportStateByEntityId.set(entityId, state);
    }
    return state;
  }

  private handleExitContainerCommand(entityId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return;
    }

    // Source parity: TunnelContain — use exitTunnel for proper scatter behavior.
    if (entity.tunnelContainerId !== null) {
      const tunnel = this.spawnedEntities.get(entity.tunnelContainerId);
      if (tunnel && !tunnel.destroyed) {
        this.exitTunnel(entity, tunnel);
      } else {
        this.releaseEntityFromContainer(entity);
      }
      return;
    }

    const containerId = entity.parkingSpaceProducerId
      ?? entity.helixCarrierId
      ?? entity.garrisonContainerId
      ?? entity.transportContainerId;
    if (containerId === null) {
      return;
    }

    const container = this.spawnedEntities.get(containerId);
    if (!container || container.destroyed) {
      this.releaseEntityFromContainer(entity);
      return;
    }

    // Source parity: ChinookAIUpdate::getAiFreeToExit — combat-drop exits are owned by
    // ChinookCombatDropState (rappel), not by generic passenger exit commands.
    if (container.chinookAIProfile && this.pendingCombatDropActions.has(container.id)) {
      return;
    }

    // Source parity: AIUpdate::privateExit — blocked when container is DISABLED_SUBDUED.
    // C++ AIUpdate.cpp:3819-3840: prevents passengers exiting subdued containers.
    if (this.entityHasObjectStatus(container, 'DISABLED_SUBDUED')) {
      return;
    }

    this.cancelEntityCommandPathActions(entity.id);
    this.releaseEntityFromContainer(entity);
    entity.x = container.x;
    entity.z = container.z;
    entity.y = this.resolveGroundHeight(entity.x, entity.z) + entity.baseHeight;
    this.updatePathfindPosCell(entity);

    if (entity.canMove) {
      this.issueMoveTo(entity.id, container.x + MAP_XY_FACTOR, container.z);
    }
  }

  private handleEvacuateCommand(entityId: number): void {
    const container = this.spawnedEntities.get(entityId);
    if (!container || container.destroyed) {
      return;
    }

    // Source parity: AIUpdate::privateEvacuate — blocked when container is DISABLED_SUBDUED.
    // C++ AIUpdate.cpp:3894-3896: prevents evacuation of subdued buildings (e.g., Microwave Tank).
    if (this.entityHasObjectStatus(container, 'DISABLED_SUBDUED')) {
      return;
    }

    // Source parity: TunnelContain evacuate — exit all shared passengers from this tunnel.
    if (container.containProfile?.moduleType === 'TUNNEL') {
      const tracker = this.resolveTunnelTracker(container.side);
      if (tracker) {
        for (const passengerId of Array.from(tracker.passengerIds)) {
          const passenger = this.spawnedEntities.get(passengerId);
          if (!passenger || passenger.destroyed) continue;
          this.exitTunnel(passenger, container);
        }
      }
      return;
    }

    const objectDef = this.resolveObjectDefByTemplateName(container.templateName);
    const railedProfile = this.extractRailedTransportProfile(objectDef ?? undefined);
    if (railedProfile) {
      const railedState = this.resolveRailedTransportRuntimeState(container.id);
      if (railedState.inTransit) {
        return;
      }
    }

    this.cancelEntityCommandPathActions(container.id);
    this.evacuateContainedEntities(container, container.x, container.z, null);
  }

  private handleExecuteRailedTransportCommand(command: ExecuteRailedTransportCommand): void {
    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed || !entity.canMove) {
      return;
    }

    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    const profile = this.extractRailedTransportProfile(objectDef ?? undefined);
    if (!profile) {
      return;
    }

    executeRailedTransportCommandImpl(entity, profile, {
      waypointIndex: this.railedTransportWaypointIndex,
      resolveRuntimeState: this.resolveRailedTransportRuntimeState.bind(this),
      cancelEntityCommandPathActions: this.cancelEntityCommandPathActions.bind(this),
      clearAttackTarget: this.clearAttackTarget.bind(this),
      stopEntity: this.stopEntity.bind(this),
      issueMoveTo: this.issueMoveTo.bind(this),
      isValidEntity: (candidate) => !candidate.destroyed && candidate.canMove,
    });
  }

  private handleBeaconDeleteCommand(command: BeaconDeleteCommand): void {
    const beacon = this.spawnedEntities.get(command.entityId);
    if (!beacon || beacon.destroyed || !this.isBeaconEntity(beacon)) {
      return;
    }

    const localSide = this.resolveLocalPlayerSide();
    const beaconSide = this.normalizeSide(beacon.side);
    if (!localSide || !beaconSide || beaconSide !== localSide) {
      // Source parity: non-owner delete requests are client-visibility only.
      return;
    }

    this.markEntityDestroyed(beacon.id, -1);
  }

  private handleHackInternetCommand(command: HackInternetCommand): void {
    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed) {
      return;
    }

    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    if (!objectDef) {
      return;
    }

    const profile = this.extractHackInternetProfile(objectDef);
    if (!profile) {
      return;
    }

    // Source parity subset: MSG_INTERNET_HACK clears active AI state and enters
    // HackInternetAIUpdate (UNPACKING -> HACK_INTERNET persistent loop).
    this.cancelEntityCommandPathActions(entity.id);
    this.clearAttackTarget(entity.id);
    this.stopEntity(entity.id);

    const cashUpdateDelayFrames = this.resolveHackInternetCashUpdateDelayFrames(entity, profile);
    const cashAmountPerCycle = profile.regularCashAmount > 0
      ? profile.regularCashAmount
      : SOURCE_HACK_FALLBACK_CASH_AMOUNT;
    const initialDelayFrames = Math.max(1, profile.unpackTimeFrames + cashUpdateDelayFrames);
    this.hackInternetStateByEntityId.set(entity.id, {
      cashUpdateDelayFrames,
      cashAmountPerCycle,
      nextCashFrame: this.frameCounter + initialDelayFrames,
    });
  }

  private resolveHackInternetPackTimeFrames(entity: MapEntity, profile: HackInternetProfile): number {
    if (this.isEntityContained(entity)) {
      return 0;
    }
    return Math.max(0, profile.packTimeFrames);
  }

  private resolveHackInternetCashUpdateDelayFrames(entity: MapEntity, profile: HackInternetProfile): number {
    const delayFrames = this.isEntityContained(entity)
      ? profile.cashUpdateDelayFastFrames
      : profile.cashUpdateDelayFrames;
    return Math.max(0, delayFrames);
  }

  private handleToggleOverchargeCommand(command: ToggleOverchargeCommand): void {
    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed) {
      return;
    }

    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    const profile = this.extractOverchargeBehaviorProfile(objectDef);
    if (!profile) {
      return;
    }

    if (this.overchargeStateByEntityId.has(entity.id)) {
      this.disableOverchargeForEntity(entity);
      return;
    }

    const minimumAllowedHealth = entity.maxHealth * profile.notAllowedWhenHealthBelowPercent;
    if (minimumAllowedHealth > 0 && entity.health < minimumAllowedHealth) {
      return;
    }

    this.enableOverchargeForEntity(entity, profile);
  }

  private handleDetonateDemoTrapCommand(command: DetonateDemoTrapCommand): void {
    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed) return;
    const profile = entity.demoTrapProfile;
    if (!profile || entity.demoTrapDetonated) return;
    // Source parity: C++ update() returns early if UNDER_CONSTRUCTION or SOLD.
    if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION') ||
        entity.objectStatusFlags.has('SOLD')) return;
    this.detonateDemoTrap(entity, profile);
  }

  private handleToggleDemoTrapModeCommand(command: ToggleDemoTrapModeCommand): void {
    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed) return;
    if (!entity.demoTrapProfile || entity.demoTrapDetonated) return;
    entity.demoTrapProximityMode = !entity.demoTrapProximityMode;
  }

  private handleCombatDropCommand(command: CombatDropCommand): void {
    const source = this.spawnedEntities.get(command.entityId);
    if (!source || source.destroyed) {
      return;
    }
    if (this.countContainedRappellers(source.id) <= 0) {
      return;
    }

    let targetObjectId: number | null = null;
    let targetX: number;
    let targetZ: number;
    if (command.targetObjectId !== null) {
      const target = this.spawnedEntities.get(command.targetObjectId);
      if (!target || target.destroyed) {
        return;
      }
      targetObjectId = target.id;
      targetX = target.x;
      targetZ = target.z;
    } else if (command.targetPosition !== null) {
      targetX = command.targetPosition[0];
      targetZ = command.targetPosition[2];
    } else {
      return;
    }

    // Source parity subset: MSG_COMBATDROP routes through AIGroup::groupCombatDrop,
    // which delegates per-unit AI combat-drop behavior.
    this.cancelEntityCommandPathActions(source.id);
    this.clearAttackTarget(source.id);
    // Source parity: ChinookAIUpdate::getBuildingToNotPathAround.
    // While in MOVE_TO_COMBAT_DROP/DO_COMBAT_DROP, pathing must not avoid the goal building.
    this.syncChinookCombatDropIgnoredObstacle(source, targetObjectId);
    this.issueMoveTo(source.id, targetX, targetZ);
    this.pendingCombatDropActions.set(source.id, {
      targetObjectId,
      targetX,
      targetZ,
      nextDropFrame: 0,
    });
  }

  private handlePlaceBeaconCommand(command: PlaceBeaconCommand): void {
    const localSide = this.resolveLocalPlayerSide();
    if (!localSide) {
      return;
    }

    const beaconTemplateName = this.resolveBeaconTemplateNameForSide(localSide);
    if (!beaconTemplateName) {
      return;
    }

    if (
      this.countActiveEntitiesOfTemplateForSide(localSide, beaconTemplateName)
      >= SOURCE_DEFAULT_MAX_BEACONS_PER_PLAYER
    ) {
      return;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return;
    }
    const beaconObjectDef = findObjectDefByName(registry, beaconTemplateName);
    if (!beaconObjectDef) {
      return;
    }

    const [x, z] = this.clampWorldPositionToMapBounds(command.targetPosition[0], command.targetPosition[2]);
    const terrainY = this.resolveGroundHeight(x, z);

    const mapObject: MapObjectJSON = {
      templateName: beaconObjectDef.name,
      angle: 0,
      flags: 0,
      position: {
        x,
        y: z,
        z: 0,
      },
      properties: {},
    };
    const created = this.createMapEntity(mapObject, beaconObjectDef, registry, this.mapHeightmap);
    created.side = localSide;
    created.controllingPlayerToken = this.normalizeControllingPlayerToken(localSide);
    created.x = x;
    created.z = z;
    created.y = terrainY + created.baseHeight;
    this.updatePathfindPosCell(created);
    this.addEntityToWorld(created);
    this.registerEntityEnergy(created);
    this.initializeMinefieldState(created);
    this.registerTunnelEntity(created);
  }

  private handleEnterObjectCommand(command: EnterObjectCommand): void {
    const source = this.spawnedEntities.get(command.entityId);
    const target = this.spawnedEntities.get(command.targetObjectId);
    if (!source || !target || source.destroyed || target.destroyed) {
      return;
    }

    if (!this.canQueueEnterObjectAction(source, target, command.action)) {
      return;
    }

    // Source parity subset: MSG_ENTER routes through AIGroup::groupEnter into
    // aiEnter target-action state. We track pending enter intent and resolve a
    // minimal action subset on contact.
    this.cancelEntityCommandPathActions(source.id);
    this.clearAttackTarget(source.id);
    this.issueMoveTo(source.id, target.x, target.z);
    this.pendingEnterObjectActions.set(source.id, {
      targetObjectId: target.id,
      action: command.action,
    });
  }

  private canQueueEnterObjectAction(
    source: MapEntity,
    target: MapEntity,
    action: EnterObjectCommand['action'],
  ): boolean {
    if (source.id === target.id) {
      return false;
    }
    if (!source.canMove) {
      return false;
    }
    if (this.entityHasObjectStatus(source, 'UNDER_CONSTRUCTION')) {
      return false;
    }
    if (this.entityHasObjectStatus(target, 'UNDER_CONSTRUCTION')) {
      return false;
    }
    if (this.entityHasObjectStatus(target, 'SOLD')) {
      return false;
    }
    if (this.entityHasObjectStatus(target, 'DISABLED_SUBDUED')) {
      return false;
    }

    switch (action) {
      case 'hijackVehicle':
        return this.canExecuteHijackVehicleEnterAction(source, target);
      case 'convertToCarBomb':
        return this.canExecuteConvertToCarBombEnterAction(source, target);
      case 'sabotageBuilding':
        return this.resolveSabotageBuildingProfile(source, target) !== null;
      case 'repairVehicle':
        return this.canExecuteRepairVehicleEnterAction(source, target);
      default:
        return false;
    }
  }

  private isEntityDozerCapable(entity: MapEntity): boolean {
    const kindOf = this.resolveEntityKindOfSet(entity);
    return kindOf.has('DOZER') || entity.dozerAIProfile !== null;
  }

  private handleConstructBuildingCommand(command: ConstructBuildingCommand): void {
    const constructor = this.spawnedEntities.get(command.entityId);
    if (!constructor || constructor.destroyed) {
      return;
    }

    if (!this.isEntityDozerCapable(constructor)) {
      return;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return;
    }

    const objectDef = findObjectDefByName(registry, command.templateName);
    if (!objectDef) {
      return;
    }

    const side = this.normalizeSide(constructor.side);
    if (!side) {
      return;
    }
    if (!this.canSideBuildUnitTemplate(side, objectDef)) {
      return;
    }
    if (!this.canEntityIssueBuildCommandForTemplate(constructor, objectDef.name, ['DOZER_CONSTRUCT', 'UNIT_BUILD'])) {
      return;
    }

    const placementPositions = this.resolveConstructPlacementPositions(command, objectDef);
    if (placementPositions.length === 0) {
      return;
    }

    const buildCost = this.resolveObjectBuildCost(objectDef, side);
    const maxSimultaneousOfType = this.resolveMaxSimultaneousOfType(objectDef);
    const isLineBuildTemplate = this.isLineBuildTemplate(objectDef);
    for (const [x, y, z] of placementPositions) {
      this.clearRemovableForConstruction(
        objectDef,
        x,
        z,
        command.angle,
        constructor.id,
      );
      if (
        !this.moveObjectsForConstruction(
          objectDef,
          x,
          z,
          command.angle,
          side,
          constructor.id,
        )
      ) {
        continue;
      }

      if (
        !this.isConstructLocationClear(
          objectDef,
          x,
          z,
          command.angle,
          side,
          constructor.id,
        )
      ) {
        continue;
      }

      // Source parity: BuildAssistant::isLocationLegalToBuild —
      // terrain tile restrictions and height flatness check.
      if (!this.isConstructTerrainLegal(objectDef, x, z, command.angle)) {
        continue;
      }

      if (maxSimultaneousOfType > 0) {
        const existingCount = this.countActiveEntitiesForMaxSimultaneousForSide(side, objectDef);
        if (existingCount >= maxSimultaneousOfType) {
          break;
        }
      }

      if (buildCost > 0) {
        const withdrawn = this.withdrawSideCredits(side, buildCost);
        if (withdrawn < buildCost) {
          if (withdrawn > 0) {
            this.depositSideCredits(side, withdrawn);
          }
          this.emitEvaEvent('INSUFFICIENT_FUNDS', side, 'own');
          break;
        }
      }

      const created = this.spawnConstructedObject(
        constructor,
        objectDef,
        [x, y, z],
        command.angle,
      );
      if (!created) {
        if (isLineBuildTemplate) {
          continue;
        }
        break;
      }
    }
  }

  private clearRemovableForConstruction(
    objectDef: ObjectDef,
    worldX: number,
    worldZ: number,
    angle: number,
    ignoredEntityId: number,
  ): void {
    const buildGeometry = this.resolveConstructCollisionGeometry(objectDef);
    if (!buildGeometry) {
      return;
    }

    for (const blocker of this.spawnedEntities.values()) {
      if (blocker.id === ignoredEntityId || blocker.destroyed) {
        continue;
      }

      if (
        !this.doesConstructionGeometryOverlap(
          { x: worldX, z: worldZ },
          angle,
          buildGeometry,
          blocker,
          this.resolveConstructCollisionGeometryForEntity(blocker),
        )
      ) {
        continue;
      }

      if (this.isRemovableForConstruction(blocker) && !this.isAlwaysSelectableForConstruction(blocker)) {
        this.markEntityDestroyed(blocker.id, -1);
      }
    }
  }

  private moveObjectsForConstruction(
    objectDef: ObjectDef,
    worldX: number,
    worldZ: number,
    angle: number,
    owningSide: string,
    ignoredEntityId: number,
  ): boolean {
    const buildGeometry = this.resolveConstructCollisionGeometry(objectDef);
    if (!buildGeometry) {
      return true;
    }

    let anyUnmovables = false;
    const clearanceRadius = Math.hypot(buildGeometry.majorRadius, buildGeometry.minorRadius) * 1.4;
    for (const blocker of this.spawnedEntities.values()) {
      if (blocker.id === ignoredEntityId || blocker.destroyed) {
        continue;
      }

      if (
        !this.doesConstructionGeometryOverlap(
          { x: worldX, z: worldZ },
          angle,
          buildGeometry,
          blocker,
          this.resolveConstructCollisionGeometryForEntity(blocker),
        )
      ) {
        continue;
      }

      if (
        this.isRemovableForConstruction(blocker)
        || this.isMineForConstruction(blocker)
        || this.isInertForConstruction(blocker)
      ) {
        continue;
      }
      if (this.isAlwaysSelectableForConstruction(blocker)) {
        continue;
      }

      const relationship = this.getConstructingRelationship(owningSide, blocker.side);
      if (relationship === RELATIONSHIP_ENEMIES || this.isDisabledForConstruction(blocker) || blocker.canMove === false) {
        anyUnmovables = true;
        continue;
      }

      const variedRadius = (0.5 + this.gameRandom.nextFloat()) * clearanceRadius;
      const direction = (this.gameRandom.nextFloat() * Math.PI * 2) - Math.PI;
      const destinationX = worldX + Math.cos(direction) * variedRadius;
      const destinationZ = worldZ + Math.sin(direction) * variedRadius;
      this.issueMoveTo(blocker.id, destinationX, destinationZ, NO_ATTACK_DISTANCE, true);
      if (!blocker.canMove) {
        anyUnmovables = true;
      }
    }

    return !anyUnmovables;
  }

  private isConstructLocationClear(
    objectDef: ObjectDef,
    worldX: number,
    worldZ: number,
    angle: number,
    owningSide: string,
    ignoredEntityId: number,
  ): boolean {
    const buildGeometry = this.resolveConstructCollisionGeometry(objectDef);
    if (!buildGeometry) {
      return true;
    }

    for (const blocker of this.spawnedEntities.values()) {
      if (blocker.id === ignoredEntityId || blocker.destroyed) {
        continue;
      }

      if (
        !this.doesConstructionGeometryOverlap(
          { x: worldX, z: worldZ },
          angle,
          buildGeometry,
          blocker,
          this.resolveConstructCollisionGeometryForEntity(blocker),
        )
      ) {
        continue;
      }

      if (
        this.isRemovableForConstruction(blocker)
        || this.isMineForConstruction(blocker)
        || this.isInertForConstruction(blocker)
      ) {
        continue;
      }

      const relationship = this.getConstructingRelationship(owningSide, blocker.side);
      if (
        relationship === RELATIONSHIP_ENEMIES
        || this.isImmobileForConstruction(blocker)
        || this.isDisabledForConstruction(blocker)
      ) {
        return false;
      }
    }

    return true;
  }

  /**
   * Source parity: BuildAssistant::isLocationLegalToBuild —
   * checks terrain tile restrictions and height flatness across the
   * building's footprint.  Rejects placement on water, cliffs, or
   * impassable cells, and rejects placement where the height variation
   * across the footprint exceeds the cliff threshold.
   */
  private isConstructTerrainLegal(
    objectDef: ObjectDef,
    worldX: number,
    worldZ: number,
    angle: number,
  ): boolean {
    const navGrid = this.navigationGrid;
    const heightmap = this.mapHeightmap;
    if (!navGrid || !heightmap) {
      return true;
    }

    const geometry = this.resolveConstructCollisionGeometry(objectDef);
    if (!geometry) {
      return true;
    }

    // Compute footprint half-extents.
    const halfW = geometry.majorRadius;
    const halfH = geometry.shape === 'box' ? geometry.minorRadius : geometry.majorRadius;

    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    let loHeight = Infinity;
    let hiHeight = -Infinity;

    // Sample the footprint at cell resolution (MAP_XY_FACTOR).
    for (let ly = -halfH; ly <= halfH + 0.01; ly += MAP_XY_FACTOR) {
      for (let lx = -halfW; lx <= halfW + 0.01; lx += MAP_XY_FACTOR) {
        // For circular geometry, skip points outside the circle.
        if (geometry.shape === 'circle') {
          const dist2 = lx * lx + ly * ly;
          if (dist2 > halfW * halfW) {
            continue;
          }
        }

        // Transform local → world.
        const wx = worldX + (lx * cosA - ly * sinA);
        const wz = worldZ + (lx * sinA + ly * cosA);

        // Check navigation cell type.
        const cellX = Math.floor(wx / MAP_XY_FACTOR);
        const cellZ = Math.floor(wz / MAP_XY_FACTOR);
        if (cellX >= 0 && cellX < navGrid.width && cellZ >= 0 && cellZ < navGrid.height) {
          const cellIndex = cellZ * navGrid.width + cellX;
          const terrainCell = navGrid.terrainType[cellIndex]!;
          if (
            terrainCell === NAV_WATER
            || terrainCell === NAV_CLIFF
            || terrainCell === NAV_IMPASSABLE
          ) {
            return false;
          }
        } else {
          // Out of map bounds.
          return false;
        }

        // Track height range for flatness check.
        const h = heightmap.getInterpolatedHeight(wx, wz);
        if (h < loHeight) loHeight = h;
        if (h > hiHeight) hiHeight = h;
      }
    }

    // Source parity: BuildAssistant::checkSampleBuildLocation —
    // reject if height variation exceeds threshold.  C++ uses
    // TheGlobalData->m_allowedHeightVariationForBuilding (default 0.0
    // which is overridden in INI).  We use the cliff delta as a
    // reasonable default.
    if (hiHeight - loHeight > CLIFF_HEIGHT_DELTA) {
      return false;
    }

    return true;
  }

  private resolveConstructCollisionGeometry(objectDef: ObjectDef | undefined): ObstacleGeometry | null {
    const geometry = this.resolveObstacleGeometry(objectDef);
    if (!geometry) {
      return null;
    }

    if (geometry.shape === 'box') {
      return geometry;
    }

    const radius = geometry.majorRadius;
    if (!Number.isFinite(radius) || radius <= 0) {
      return null;
    }
    return {
      shape: 'circle',
      majorRadius: radius,
      minorRadius: radius,
      height: geometry.height,
    };
  }

  private resolveConstructCollisionGeometryForEntity(entity: MapEntity): ObstacleGeometry | null {
    if (entity.obstacleGeometry) {
      return entity.obstacleGeometry;
    }

    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    return this.resolveConstructCollisionGeometry(objectDef ?? undefined);
  }

  private doesConstructionGeometryOverlap(
    leftPosition: { x: number; z: number },
    leftAngle: number,
    leftGeometry: ObstacleGeometry,
    rightEntity: MapEntity,
    rightGeometry: ObstacleGeometry | null,
  ): boolean {
    if (!rightGeometry) {
      return false;
    }

    if (leftGeometry.shape === 'circle' && rightGeometry.shape === 'circle') {
      return this.doesCircleGeometryOverlap(
        leftPosition,
        leftGeometry.majorRadius,
        { x: rightEntity.x, z: rightEntity.z },
        rightGeometry.majorRadius,
      );
    }

    if (leftGeometry.shape === 'box' && rightGeometry.shape === 'box') {
      return this.doesBoxGeometryOverlap(
        leftPosition,
        leftAngle,
        leftGeometry,
        { x: rightEntity.x, z: rightEntity.z },
        rightEntity.rotationY,
        rightGeometry,
      );
    }

    if (leftGeometry.shape === 'circle') {
      return this.doesCircleBoxGeometryOverlap(
        leftPosition,
        leftGeometry.majorRadius,
        {
          x: rightEntity.x,
          z: rightEntity.z,
          angle: rightEntity.rotationY,
          geometry: rightGeometry,
        },
      );
    }

    return this.doesCircleBoxGeometryOverlap(
      { x: rightEntity.x, z: rightEntity.z },
      rightGeometry.majorRadius,
      {
        x: leftPosition.x,
        z: leftPosition.z,
        angle: leftAngle,
        geometry: leftGeometry,
      },
    );
  }

  private doesCircleGeometryOverlap(
    firstPosition: { x: number; z: number },
    firstRadius: number,
    secondPosition: { x: number; z: number },
    secondRadius: number,
  ): boolean {
    const distanceX = firstPosition.x - secondPosition.x;
    const distanceZ = firstPosition.z - secondPosition.z;
    const minDistance = firstRadius + secondRadius;
    return (distanceX * distanceX + distanceZ * distanceZ) <= (minDistance * minDistance);
  }

  private doesCircleBoxGeometryOverlap(
    circlePosition: { x: number; z: number },
    circleRadius: number,
    box: {
      x: number;
      z: number;
      angle: number;
      geometry: ObstacleGeometry;
    },
  ): boolean {
    if (box.geometry.majorRadius <= 0 || box.geometry.minorRadius <= 0) {
      return false;
    }

    const cos = Math.cos(-box.angle);
    const sin = Math.sin(-box.angle);
    const dx = circlePosition.x - box.x;
    const dz = circlePosition.z - box.z;
    const localX = (dx * cos) + (dz * sin);
    const localZ = (-dx * sin) + (dz * cos);
    const clampedX = clamp(localX, -box.geometry.majorRadius, box.geometry.majorRadius);
    const clampedZ = clamp(localZ, -box.geometry.minorRadius, box.geometry.minorRadius);
    const distanceX = localX - clampedX;
    const distanceZ = localZ - clampedZ;
    return (distanceX * distanceX + distanceZ * distanceZ) <= (circleRadius * circleRadius);
  }

  private doesBoxGeometryOverlap(
    leftPosition: { x: number; z: number },
    leftAngle: number,
    leftGeometry: ObstacleGeometry,
    rightPosition: { x: number; z: number },
    rightAngle: number,
    rightGeometry: ObstacleGeometry,
  ): boolean {
    if (leftGeometry.majorRadius <= 0 || leftGeometry.minorRadius <= 0
      || rightGeometry.majorRadius <= 0 || rightGeometry.minorRadius <= 0) {
      return false;
    }

    const deltaX = rightPosition.x - leftPosition.x;
    const deltaZ = rightPosition.z - leftPosition.z;

    const leftXAxisX = Math.cos(leftAngle);
    const leftXAxisZ = Math.sin(leftAngle);
    const leftZAxisX = -leftXAxisZ;
    const leftZAxisZ = leftXAxisX;
    const rightXAxisX = Math.cos(rightAngle);
    const rightXAxisZ = Math.sin(rightAngle);
    const rightZAxisX = -rightXAxisZ;
    const rightZAxisZ = rightXAxisX;

    const projectionAxes = [
      { x: leftXAxisX, z: leftXAxisZ },
      { x: leftZAxisX, z: leftZAxisZ },
      { x: rightXAxisX, z: rightXAxisZ },
      { x: rightZAxisX, z: rightZAxisZ },
    ];

    for (const axis of projectionAxes) {
      const leftRadius = this.projectBoxRadiusOntoAxis(leftGeometry, axis, leftXAxisX, leftXAxisZ, leftZAxisX, leftZAxisZ);
      const rightRadius = this.projectBoxRadiusOntoAxis(
        rightGeometry,
        axis,
        rightXAxisX,
        rightXAxisZ,
        rightZAxisX,
        rightZAxisZ,
      );
      const distanceToAxis = Math.abs((deltaX * axis.x) + (deltaZ * axis.z));
      if (distanceToAxis > leftRadius + rightRadius) {
        return false;
      }
    }

    return true;
  }

  private projectBoxRadiusOntoAxis(
    geometry: ObstacleGeometry,
    axis: { x: number; z: number },
    axisX: number,
    axisZ: number,
    zAxisX: number,
    zAxisZ: number,
  ): number {
    return (geometry.majorRadius * Math.abs((axis.x * axisX) + (axis.z * axisZ)))
      + (geometry.minorRadius * Math.abs((axis.x * zAxisX) + (axis.z * zAxisZ)));
  }

  private isRemovableForConstruction(entity: MapEntity): boolean {
    if (entity.destroyed) {
      return false;
    }

    const kindOf = this.resolveEntityKindOfSet(entity);
    if (kindOf.has('INERT')) {
      return false;
    }
    if (kindOf.has('SHRUBBERY') || kindOf.has('CLEARED_BY_BUILD')) {
      return true;
    }
    return entity.health <= 0;
  }

  private isMineForConstruction(entity: MapEntity): boolean {
    return this.resolveEntityKindOfSet(entity).has('MINE');
  }

  private isInertForConstruction(entity: MapEntity): boolean {
    return this.resolveEntityKindOfSet(entity).has('INERT');
  }

  private isAlwaysSelectableForConstruction(entity: MapEntity): boolean {
    return this.resolveEntityKindOfSet(entity).has('ALWAYS_SELECTABLE');
  }

  private isImmobileForConstruction(entity: MapEntity): boolean {
    return this.resolveEntityKindOfSet(entity).has('IMMOBILE');
  }

  /**
   * Source parity: Object::isMobile() — returns false when isDisabled() is true.
   * C++ Object.cpp:2902-2911: checks m_disabledMask.any() which covers all disabled types.
   * We check the specific gameplay-relevant disabled flags we track.
   */
  private isEntityDisabledForMovement(entity: MapEntity): boolean {
    return (
      this.entityHasObjectStatus(entity, 'DISABLED_HELD')
      || this.entityHasObjectStatus(entity, 'DISABLED_EMP')
      || this.entityHasObjectStatus(entity, 'DISABLED_HACKED')
      || this.entityHasObjectStatus(entity, 'DISABLED_SUBDUED')
      || this.entityHasObjectStatus(entity, 'DISABLED_PARALYZED')
      || this.entityHasObjectStatus(entity, 'DISABLED_UNMANNED')
      || this.entityHasObjectStatus(entity, 'DISABLED_UNDERPOWERED')
    );
  }

  private isDisabledForConstruction(entity: MapEntity): boolean {
    return (
      this.entityHasObjectStatus(entity, 'DISABLED')
      || this.entityHasObjectStatus(entity, 'DISABLED_SUBDUED')
      || this.entityHasObjectStatus(entity, 'DISABLED_HACKED')
      || this.entityHasObjectStatus(entity, 'DISABLED_EMP')
      || this.entityHasObjectStatus(entity, 'DISABLED_HELD')
      || this.entityHasObjectStatus(entity, 'DISABLED_UNDERPOWERED')
      || this.entityHasObjectStatus(entity, 'SCRIPT_DISABLED')
      || this.entityHasObjectStatus(entity, 'SCRIPT_UNPOWERED')
    );
  }

  private isLineBuildTemplate(objectDef: ObjectDef): boolean {
    return this.normalizeKindOf(objectDef.kindOf).has('LINEBUILD');
  }

  private getConstructingRelationship(owningSide: string, otherSide: string | undefined): number {
    const source = this.normalizeSide(owningSide);
    const target = this.normalizeSide(otherSide ?? '');
    if (!source || !target) {
      return RELATIONSHIP_NEUTRAL;
    }
    return this.getTeamRelationshipBySides(source, target);
  }

  private handleCancelDozerConstructionCommand(command: CancelDozerConstructionCommand): void {
    const building = this.spawnedEntities.get(command.entityId);
    if (!building || building.destroyed || building.category !== 'building') {
      return;
    }

    // Source parity: MSG_DOZER_CANCEL_CONSTRUCT only applies to structures under construction.
    if (!this.entityHasObjectStatus(building, 'UNDER_CONSTRUCTION')) {
      return;
    }

    if (!this.entityHasObjectStatus(building, 'RECONSTRUCTING')) {
      const objectDef = this.resolveObjectDefByTemplateName(building.templateName);
      if (objectDef) {
        const amount = this.resolveObjectBuildCost(objectDef, building.side ?? '');
        this.depositSideCredits(building.side, amount);
      }
    }

    this.markEntityDestroyed(building.id, -1);
  }

  private handleSellCommand(command: SellCommand): void {
    const entity = this.spawnedEntities.get(command.entityId);
    if (!entity || entity.destroyed) {
      return;
    }
    if (entity.category !== 'building') {
      return;
    }
    if (this.sellingEntities.has(entity.id)) {
      return;
    }
    // Source parity: buildings under construction use cancelDozerConstruction, not sell.
    // The InGameUI prevents the sell button from appearing for UNDER_CONSTRUCTION buildings.
    if (this.entityHasObjectStatus(entity, 'UNDER_CONSTRUCTION')) {
      return;
    }

    // Source parity subset: BuildAssistant::sellObject starts a timed teardown
    // (construction-percent countdown) and refunds queue production immediately.
    this.cancelEntityCommandPathActions(entity.id);
    this.clearAttackTarget(entity.id);
    this.stopEntity(entity.id);
    this.cancelAndRefundAllProductionOnDeath(entity);
    entity.objectStatusFlags.add('SOLD');
    entity.objectStatusFlags.add('UNSELECTABLE');
    this.removeEntityFromSelection(entity.id);

    // Source parity subset: BuildAssistant::sellObject invokes contain->onSelling().
    // Open/Garrison contain variants map to passenger evacuation on sell start.
    // Source parity: TunnelContain::onSelling — eject all if this is the last tunnel.
    if (entity.containProfile?.moduleType === 'TUNNEL') {
      this.handleTunnelSelling(entity);
    } else if (entity.containProfile && this.collectContainedEntityIds(entity.id).length > 0) {
      this.evacuateContainedEntities(entity, entity.x, entity.z, null);
    }

    if (entity.parkingPlaceProfile) {
      const parkedEntityIds = Array.from(entity.parkingPlaceProfile.occupiedSpaceEntityIds.values());
      for (const parkedEntityId of parkedEntityIds) {
        this.markEntityDestroyed(parkedEntityId, entity.id);
      }
    }

    this.sellingEntities.set(entity.id, {
      sellFrame: this.frameCounter,
      constructionPercent: 99.9,
    });
  }

  private noteContainerEnteredBy(container: MapEntity, rider: MapEntity): void {
    if (!container.containProfile) {
      return;
    }
    container.containPlayerEnteredSide = this.normalizeSide(rider.side);
  }

  private handleGarrisonBuildingCommand(command: GarrisonBuildingCommand): void {
    const infantry = this.spawnedEntities.get(command.entityId);
    const building = this.spawnedEntities.get(command.targetBuildingId);
    if (!infantry || !building || infantry.destroyed || building.destroyed) {
      return;
    }

    // Validate: source must be infantry, target must be garrisonable.
    if (infantry.category !== 'infantry') return;
    const containProfile = building.containProfile;
    if (!containProfile || containProfile.moduleType !== 'GARRISON') return;
    if (containProfile.garrisonCapacity <= 0) return;

    // Check capacity.
    const currentOccupants = this.collectContainedEntityIds(building.id).length;
    if (currentOccupants >= containProfile.garrisonCapacity) return;

    // Move infantry to building if not close enough.
    const distance = Math.hypot(building.x - infantry.x, building.z - infantry.z);
    if (distance > 15) {
      this.issueMoveTo(infantry.id, building.x, building.z);
      // Re-issue garrison when close enough via pending action.
      this.pendingGarrisonActions.set(infantry.id, building.id);
      return;
    }

    // Enter garrison.
    this.cancelEntityCommandPathActions(infantry.id);
    this.clearAttackTarget(infantry.id);
    infantry.garrisonContainerId = building.id;
    this.noteContainerEnteredBy(building, infantry);
    infantry.x = building.x;
    infantry.z = building.z;
    infantry.y = building.y;
    infantry.canMove = false;
    infantry.moving = false;
    this.pendingGarrisonActions.delete(infantry.id);
  }

  private updatePendingGarrisonActions(): void {
    for (const [infantryId, buildingId] of this.pendingGarrisonActions.entries()) {
      const infantry = this.spawnedEntities.get(infantryId);
      const building = this.spawnedEntities.get(buildingId);
      if (!infantry || !building || infantry.destroyed || building.destroyed) {
        this.pendingGarrisonActions.delete(infantryId);
        continue;
      }

      const distance = Math.hypot(building.x - infantry.x, building.z - infantry.z);
      if (distance > 15) continue;

      // Close enough — enter garrison.
      const containProfile = building.containProfile;
      if (!containProfile || containProfile.moduleType !== 'GARRISON') {
        this.pendingGarrisonActions.delete(infantryId);
        continue;
      }

      const currentOccupants = this.collectContainedEntityIds(building.id).length;
      if (currentOccupants >= containProfile.garrisonCapacity) {
        this.pendingGarrisonActions.delete(infantryId);
        continue;
      }

      this.cancelEntityCommandPathActions(infantry.id);
      this.clearAttackTarget(infantry.id);
      infantry.garrisonContainerId = building.id;
      this.noteContainerEnteredBy(building, infantry);
      infantry.x = building.x;
      infantry.z = building.z;
      infantry.y = building.y;
      infantry.canMove = false;
      infantry.moving = false;
      this.pendingGarrisonActions.delete(infantryId);
    }
  }

  /**
   * Source parity: OpenContain::addToContain / TransportContain::addToContain —
   * enter a transport-style container (Humvee, Chinook, Battle Bus, Overlord rider slots).
   */
  private handleEnterTransportCommand(command: EnterTransportCommand): void {
    const passenger = this.spawnedEntities.get(command.entityId);
    const transport = this.spawnedEntities.get(command.targetTransportId);
    if (!passenger || !transport || passenger.destroyed || transport.destroyed) {
      return;
    }

    // Source parity: OpenContain::addToContain — cannot enter if already contained.
    if (this.isEntityContained(passenger)) return;

    // Source parity: TransportContain::isValidContainerFor — same-side check.
    if (this.normalizeSide(passenger.side) !== this.normalizeSide(transport.side)) return;

    // Validate: target must have a transport-style contain profile.
    const containProfile = transport.containProfile;
    if (!containProfile) return;

    // Source parity: TunnelContain — route to tunnel-specific entry.
    if (containProfile.moduleType === 'TUNNEL') {
      const kindOf = this.resolveEntityKindOfSet(passenger);
      if (kindOf.has('AIRCRAFT')) return;
      const tracker = this.resolveTunnelTracker(transport.side);
      if (!tracker || tracker.passengerIds.size >= this.config.maxTunnelCapacity) return;

      const interactionDistance = this.resolveEntityInteractionDistance(passenger, transport);
      const distance = Math.hypot(transport.x - passenger.x, transport.z - passenger.z);
      if (distance > interactionDistance) {
        this.issueMoveTo(passenger.id, transport.x, transport.z);
        this.pendingTunnelActions.set(passenger.id, transport.id);
        return;
      }
      this.enterTunnel(passenger, transport);
      return;
    }

    if (containProfile.moduleType !== 'TRANSPORT'
      && containProfile.moduleType !== 'OVERLORD'
      && containProfile.moduleType !== 'HELIX'
      && containProfile.moduleType !== 'OPEN'
      && containProfile.moduleType !== 'HEAL'
      && containProfile.moduleType !== 'INTERNET_HACK') return;

    // Source parity: TransportContain type checks — only infantry for TRANSPORT,
    // infantry + portable structures for OVERLORD/HELIX.
    const kindOf = this.resolveEntityKindOfSet(passenger);
    if (containProfile.moduleType === 'TRANSPORT') {
      if (!kindOf.has('INFANTRY') && !kindOf.has('VEHICLE')) return;
    } else if (containProfile.moduleType === 'OVERLORD' || containProfile.moduleType === 'HELIX') {
      if (!kindOf.has('INFANTRY') && !kindOf.has('PORTABLE_STRUCTURE')) return;
    }

    // Check capacity.
    if (containProfile.transportCapacity > 0) {
      const currentOccupants = this.collectContainedEntityIds(transport.id).length;
      if (currentOccupants >= containProfile.transportCapacity) return;
    }

    // Move passenger to transport if not close enough.
    const interactionDistance = this.resolveEntityInteractionDistance(passenger, transport);
    const distance = Math.hypot(transport.x - passenger.x, transport.z - passenger.z);
    if (distance > interactionDistance) {
      this.issueMoveTo(passenger.id, transport.x, transport.z);
      this.pendingTransportActions.set(passenger.id, transport.id);
      return;
    }

    this.enterTransport(passenger, transport);
  }

  private enterTransport(passenger: MapEntity, transport: MapEntity): void {
    this.cancelEntityCommandPathActions(passenger.id);
    this.clearAttackTarget(passenger.id);
    passenger.transportContainerId = transport.id;
    this.noteContainerEnteredBy(transport, passenger);
    passenger.x = transport.x;
    passenger.z = transport.z;
    passenger.y = transport.y;
    passenger.moving = false;
    // Source parity: HealContain — track entry frame for healing calculation.
    if (transport.containProfile?.moduleType === 'HEAL') {
      passenger.healContainEnteredFrame = this.frameCounter;
    }
    // Source parity: InternetHackContain::onContaining — auto-issue hackInternet to entering unit.
    // C++ file: InternetHackContain.cpp — rider->getAI()->aiHackInternet(CMD_FROM_AI).
    if (transport.containProfile?.moduleType === 'INTERNET_HACK') {
      this.commandQueue.push({ type: 'hackInternet', entityId: passenger.id });
    }
    // Source parity: Object::onContainedBy — set UNSELECTABLE and MASKED for enclosed containers.
    passenger.objectStatusFlags.add('UNSELECTABLE');
    if (this.isEnclosingContainer(transport)) {
      passenger.objectStatusFlags.add('MASKED');
    }
    this.removeEntityFromSelection(passenger.id);
    this.pendingTransportActions.delete(passenger.id);
  }

  /**
   * Source parity: Contain::isEnclosingContainerFor — TRANSPORT and OVERLORD are enclosed
   * (passengers hidden), OPEN containers are not.
   */
  private isEnclosingContainer(container: MapEntity): boolean {
    const profile = container.containProfile;
    if (!profile) return false;
    return profile.moduleType === 'TRANSPORT'
      || profile.moduleType === 'OVERLORD'
      || profile.moduleType === 'HELIX'
      || profile.moduleType === 'TUNNEL'
      || profile.moduleType === 'HEAL'
      || profile.moduleType === 'INTERNET_HACK';
  }

  private updatePendingTransportActions(): void {
    for (const [passengerId, transportId] of this.pendingTransportActions.entries()) {
      const passenger = this.spawnedEntities.get(passengerId);
      const transport = this.spawnedEntities.get(transportId);
      if (!passenger || !transport || passenger.destroyed || transport.destroyed) {
        this.pendingTransportActions.delete(passengerId);
        continue;
      }

      if (this.isEntityContained(passenger)) {
        this.pendingTransportActions.delete(passengerId);
        continue;
      }

      const interactionDistance = this.resolveEntityInteractionDistance(passenger, transport);
      const distance = Math.hypot(transport.x - passenger.x, transport.z - passenger.z);
      if (distance > interactionDistance) continue;

      // Close enough — check capacity again and enter.
      const containProfile = transport.containProfile;
      if (!containProfile) {
        this.pendingTransportActions.delete(passengerId);
        continue;
      }

      if (containProfile.transportCapacity > 0) {
        const currentOccupants = this.collectContainedEntityIds(transport.id).length;
        if (currentOccupants >= containProfile.transportCapacity) {
          this.pendingTransportActions.delete(passengerId);
          continue;
        }
      }

      this.enterTransport(passenger, transport);
    }
  }

  /**
   * Source parity: BuildAssistant::repairObject — dozer repairs a damaged friendly building.
   */
  private handleRepairBuildingCommand(command: RepairBuildingCommand): void {
    const dozer = this.spawnedEntities.get(command.entityId);
    const building = this.spawnedEntities.get(command.targetBuildingId);
    if (!dozer || !building || dozer.destroyed || building.destroyed) return;
    if (!this.canDozerRepairTarget(dozer, building)) return;

    // Source parity: DozerAIUpdate::privateResumeConstruction — if the building is
    // still under construction, resume building instead of repairing.
    if (building.constructionPercent !== CONSTRUCTION_COMPLETE
      && building.objectStatusFlags.has('UNDER_CONSTRUCTION')
      && building.builderId === 0) {
      // Another dozer can resume. Claim it.
      building.builderId = dozer.id;
      this.pendingConstructionActions.set(dozer.id, building.id);
      this.issueMoveTo(dozer.id, building.x, building.z);
      return;
    }

    // Move dozer to building if not close enough.
    const distance = Math.hypot(building.x - dozer.x, building.z - dozer.z);
    if (distance > 20) {
      this.issueMoveTo(dozer.id, building.x, building.z);
    }
    this.pendingRepairActions.set(dozer.id, building.id);
  }

  /**
   * Source parity: BuildAssistant repair update — dozers repair buildings over time.
   * Repair rate comes from DozerAIUpdate/WorkerAIUpdate RepairHealthPercentPerSecond.
   * Repair still consumes build-cost-based credits over time.
   */
  private updatePendingRepairActions(): void {
    const REPAIR_COST_RATE = 0.005 / 30; // 0.5% of build cost per second at 30fps

    for (const [dozerId, buildingId] of this.pendingRepairActions.entries()) {
      const dozer = this.spawnedEntities.get(dozerId);
      const building = this.spawnedEntities.get(buildingId);
      if (!dozer || !building || dozer.destroyed || building.destroyed) {
        this.pendingRepairActions.delete(dozerId);
        continue;
      }

      // Building fully repaired.
      if (building.health >= building.maxHealth) {
        this.pendingRepairActions.delete(dozerId);
        continue;
      }

      // Must be close enough to repair.
      const distance = Math.hypot(building.x - dozer.x, building.z - dozer.z);
      if (distance > 20) continue; // Still moving

      // Stop dozer movement while repairing.
      if (dozer.moving) {
        dozer.moving = false;
        dozer.moveTarget = null;
        dozer.movePath = [];
      }

      // Check player can afford repair.
      const dozerSide = this.normalizeSide(dozer.side);
      if (!dozerSide) {
        this.pendingRepairActions.delete(dozerId);
        continue;
      }
      const credits = this.sideCredits.get(dozerSide) ?? 0;
      const buildCost = building.maxHealth; // Approximate — use maxHealth as fallback for build cost
      const frameCost = REPAIR_COST_RATE * buildCost;
      if (credits < frameCost) continue; // Can't afford this frame

      const repairHealthPercentPerSecond = dozer.dozerAIProfile?.repairHealthPercentPerSecond ?? 0.02;
      if (repairHealthPercentPerSecond <= 0) {
        continue;
      }
      const healAmount = (repairHealthPercentPerSecond / LOGIC_FRAME_RATE) * building.maxHealth;
      if (healAmount <= 0) {
        continue;
      }

      // Source parity: attemptHealingFromSoleBenefactor rejects competing dozers/workers.
      const healed = this.attemptHealingFromSoleBenefactor(building, healAmount, dozer.id, 2);
      if (!healed) {
        this.pendingRepairActions.delete(dozerId);
        continue;
      }

      // Deduct repair cost only when healing was accepted.
      this.sideCredits.set(dozerSide, credits - frameCost);
    }
  }

  /**
   * Source parity: DozerPrimaryIdleState::update — bored dozers auto-seek nearby repairs.
   */
  private updateDozerIdleBehavior(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.dozerAIProfile;
      if (!profile || profile.boredTimeFrames <= 0 || profile.boredRange <= 0) continue;

      const hasTask = this.pendingConstructionActions.has(entity.id)
        || this.pendingRepairActions.has(entity.id);
      const isIdle = !entity.moving
        && entity.moveTarget === null
        && entity.attackTargetEntityId === null
        && entity.attackTargetPosition === null
        && !hasTask;

      if (!isIdle) {
        entity.dozerIdleTooLongTimestamp = this.frameCounter;
        continue;
      }

      if ((this.frameCounter - entity.dozerIdleTooLongTimestamp) <= profile.boredTimeFrames) {
        continue;
      }

      // Source parity: throttle expensive scans by resetting idle timestamp after each check.
      entity.dozerIdleTooLongTimestamp = this.frameCounter;

      const target = this.findDozerAutoRepairTarget(entity, profile.boredRange);
      if (!target) {
        continue;
      }

      this.handleRepairBuildingCommand({
        type: 'repairBuilding',
        entityId: entity.id,
        targetBuildingId: target.id,
      });
    }
  }

  private findDozerAutoRepairTarget(dozer: MapEntity, range: number): MapEntity | null {
    const rangeSqr = range * range;
    let closest: MapEntity | null = null;
    let closestDistSqr = Infinity;
    for (const candidate of this.spawnedEntities.values()) {
      if (candidate.id === dozer.id || candidate.destroyed) continue;
      if (!candidate.kindOf.has('STRUCTURE')) continue;
      if (!this.canDozerRepairTarget(dozer, candidate)) continue;

      const dx = candidate.x - dozer.x;
      const dz = candidate.z - dozer.z;
      const distSqr = dx * dx + dz * dz;
      if (distSqr > rangeSqr) continue;

      if (distSqr < closestDistSqr) {
        closest = candidate;
        closestDistSqr = distSqr;
      }
    }
    return closest;
  }

  private canDozerRepairTarget(dozer: MapEntity, building: MapEntity): boolean {
    if (!this.isEntityDozerCapable(dozer)) return false;
    if (!building.kindOf.has('STRUCTURE')) return false;
    if (building.objectStatusFlags.has('SOLD')) return false;
    if (building.health >= building.maxHealth && building.constructionPercent === CONSTRUCTION_COMPLETE) return false;

    const dozerSide = this.normalizeSide(dozer.side);
    const buildingSide = this.normalizeSide(building.side);
    if (dozerSide !== buildingSide) return false;

    // Source parity: don't pile onto a target currently repaired by another dozer.
    if (
      building.soleHealingBenefactorId !== null
      && building.soleHealingBenefactorId !== dozer.id
      && this.frameCounter < building.soleHealingBenefactorExpirationFrame
    ) {
      return false;
    }

    return true;
  }

  /**
   * Source parity: DozerAIUpdate::update — per-frame construction progress loop.
   * Each frame while the dozer is close to the building: increment construction
   * percent by 100/totalFrames, increment health by maxHealth/totalFrames.
   * When percent >= 100: clear UNDER_CONSTRUCTION, emit CONSTRUCTION_COMPLETE.
   */
  private updatePendingConstructionActions(): void {
    for (const [dozerId, buildingId] of this.pendingConstructionActions.entries()) {
      const dozer = this.spawnedEntities.get(dozerId);
      const building = this.spawnedEntities.get(buildingId);
      if (!dozer || !building || dozer.destroyed || building.destroyed
        || building.objectStatusFlags.has('SOLD')) {
        this.pendingConstructionActions.delete(dozerId);
        if (building && !building.destroyed) {
          // Source parity: dozer dies → building stays partially built, builderId cleared.
          building.builderId = 0;
        }
        continue;
      }

      // Already complete (e.g. instant build).
      if (building.constructionPercent === CONSTRUCTION_COMPLETE) {
        this.pendingConstructionActions.delete(dozerId);
        continue;
      }

      // Source parity: builder exclusivity check — only the assigned builder may progress.
      if (building.builderId !== dozerId) {
        this.pendingConstructionActions.delete(dozerId);
        continue;
      }

      // Must be close enough to build (within obstacle radius + margin).
      const buildRadius = this.resolveEntityBoundingRadius(building) + 10;
      const distance = Math.hypot(building.x - dozer.x, building.z - dozer.z);
      if (distance > buildRadius) continue; // Still moving to site

      // Stop dozer movement while constructing.
      if (dozer.moving) {
        dozer.moving = false;
        dozer.moveTarget = null;
        dozer.movePath = [];
      }

      // Source parity: percentProgressThisFrame = 100.0 / framesToBuild
      const totalFrames = building.buildTotalFrames;
      if (totalFrames <= 0) {
        // Shouldn't happen — complete immediately.
        this.completeConstruction(building);
        this.pendingConstructionActions.delete(dozerId);
        continue;
      }

      const percentPerFrame = 100.0 / totalFrames;
      building.constructionPercent += percentPerFrame;

      // Source parity: health += maxHealth / framesToBuild each frame.
      const healthPerFrame = building.maxHealth / totalFrames;
      building.health = Math.min(building.maxHealth, building.health + healthPerFrame);

      // Check for completion.
      if (building.constructionPercent >= 100.0) {
        this.completeConstruction(building);
        this.pendingConstructionActions.delete(dozerId);
      }
    }
  }

  /**
   * Source parity: onBuildComplete — finalize construction state.
   */
  private completeConstruction(building: MapEntity): void {
    const builder = building.builderId !== 0 ? this.spawnedEntities.get(building.builderId) ?? null : null;
    building.constructionPercent = CONSTRUCTION_COMPLETE;
    building.builderId = 0;
    building.health = building.maxHealth;
    building.objectStatusFlags.delete('UNDER_CONSTRUCTION');
    building.objectStatusFlags.delete('RECONSTRUCTING');
    // Source parity: power contribution begins when construction finishes.
    this.registerEntityEnergy(building);

    // Source parity: Eva CONSTRUCTION_COMPLETE fires on build completion.
    if (building.side) {
      this.emitEvaEvent('CONSTRUCTION_COMPLETE', building.side, 'own', building.id, building.templateName);
    }

    // Source parity: GrantUpgradeCreate::onBuildComplete — grant upgrades when construction finishes.
    for (const prof of building.grantUpgradeCreateProfiles) {
      this.applyGrantUpgradeCreate(building, prof);
    }

    // Source parity: LockWeaponCreate::onBuildComplete — lock weapon slot for buildings.
    if (building.lockWeaponCreateSlot !== null) {
      building.forcedWeaponSlot = building.lockWeaponCreateSlot;
      building.weaponLockStatus = 'LOCKED_PERMANENTLY';
    }

    // Source parity: SpecialPowerCreate::onBuildComplete — start special power timers.
    // C++ file: SpecialPowerCreate.cpp line 58-72. Iterates all SpecialPowerModules on
    // the object and calls onSpecialPowerCreation() which starts the recharge timer.
    if (building.hasSpecialPowerCreate) {
      this.onBuildCompleteSpecialPowerCreate(building);
    }

    this.onStructureConstructionComplete(builder, building, false);
  }

  /**
   * Source parity hook: Player::onStructureConstructionComplete.
   * Performs script notifications, pathfind refresh, scorekeeper accounting,
   * AI callback, and EVA superweapon detection.
   */
  private onStructureConstructionComplete(
    builder: MapEntity | null,
    structure: MapEntity,
    isRebuild: boolean,
  ): void {
    if (!structure.kindOf.has('STRUCTURE')) {
      return;
    }
    // Source parity: ScriptEngine is notified when completed structures become "real".
    this.notifyScriptObjectCreationOrDestruction();
    this.refreshNavigationGridFromCurrentMap();
    this.addStructureCompletionScore(structure, isRebuild);
    this.notifySkirmishAIStructureProduced(builder, structure);
    this.emitSuperweaponDetectedOnStructureComplete(structure);
  }

  private notifyScriptObjectCreationOrDestruction(): void {
    this.scriptObjectTopologyVersion += 1;
    this.scriptObjectCountChangedFrame = this.frameCounter;
  }

  private addEntityToWorld(entity: MapEntity): void {
    this.spawnedEntities.set(entity.id, entity);
    this.scriptExistedEntityIds.add(entity.id);
    if (this.mapTriggerRegions.length > 0) {
      this.initializeScriptTriggerMembershipForEntity(entity);
    }
    this.notifyScriptObjectCreationOrDestruction();
  }

  private removeEntityFromWorld(entityId: number): void {
    if (this.spawnedEntities.delete(entityId)) {
      this.clearScriptTriggerTrackingForEntity(entityId);
      this.scriptCompletedWaypointPathsByEntityId.delete(entityId);
      for (const team of this.scriptTeamsByName.values()) {
        team.memberEntityIds.delete(entityId);
      }
      this.scriptTransportStatusByEntityId.delete(entityId);
      this.notifyScriptObjectCreationOrDestruction();
    }
  }

  private getOrCreateSideScoreState(side: string): SideScoreState {
    const existing = this.sideScoreState.get(side);
    if (existing) {
      return existing;
    }
    const created: SideScoreState = { structuresBuilt: 0, moneySpent: 0 };
    this.sideScoreState.set(side, created);
    return created;
  }

  /**
   * Source parity: Player::onStructureConstructionComplete scorekeeper increments.
   * C++: addObjectBuilt + addMoneySpent(calcCostToBuild).
   */
  private addStructureCompletionScore(structure: MapEntity, isRebuild: boolean): void {
    if (isRebuild) {
      return;
    }
    const side = this.normalizeSide(structure.side);
    if (!side) {
      return;
    }
    const score = this.getOrCreateSideScoreState(side);
    score.structuresBuilt += 1;
    const objectDef = this.resolveObjectDefByTemplateName(structure.templateName);
    if (objectDef) {
      score.moneySpent += this.resolveObjectBuildCost(objectDef, side);
    }
  }

  /**
   * Source parity: Player::onStructureConstructionComplete ai callback.
   * C++: m_ai->onStructureProduced(builder, structure).
   */
  private notifySkirmishAIStructureProduced(
    _builder: MapEntity | null,
    structure: MapEntity,
  ): void {
    const side = this.normalizeSide(structure.side);
    if (!side) {
      return;
    }
    const aiState = this.skirmishAIStates.get(side);
    if (!aiState) {
      return;
    }
    notifySkirmishAIStructureProducedImpl(aiState, structure.templateName);
  }

  private resolveEvaRelationshipForSides(
    observerSide: string,
    subjectSide: string,
  ): 'own' | 'ally' | 'enemy' {
    const observer = this.normalizeSide(observerSide);
    const subject = this.normalizeSide(subjectSide);
    if (!observer || !subject) {
      return 'enemy';
    }
    if (observer === subject) {
      return 'own';
    }
    return this.getTeamRelationshipBySides(observer, subject) === RELATIONSHIP_ALLIES
      ? 'ally'
      : 'enemy';
  }

  /**
   * Source parity: Player::onStructureConstructionComplete emits superweapon detection EVA
   * cues when a newly completed structure provides a superweapon.
   */
  private emitSuperweaponDetectedOnStructureComplete(structure: MapEntity): void {
    if (!structure.kindOf.has('FS_SUPERWEAPON')) {
      return;
    }
    const ownerSide = this.normalizeSide(structure.side);
    if (!ownerSide) {
      return;
    }

    const announcedPowers = new Set<string>();
    const knownSides = this.collectKnownSides();
    for (const [, module] of structure.specialPowerModules) {
      const normalizedPower = module.specialPowerTemplateName.trim().toUpperCase();
      if (!normalizedPower || announcedPowers.has(normalizedPower)) {
        continue;
      }
      announcedPowers.add(normalizedPower);

      for (const side of knownSides) {
        this.emitEvaEvent(
          'SUPERWEAPON_DETECTED',
          side,
          this.resolveEvaRelationshipForSides(side, ownerSide),
          structure.id,
          module.specialPowerTemplateName,
        );
      }
    }
  }

  private collectKnownSides(): string[] {
    const sides = new Set<string>();
    for (const side of this.sideCredits.keys()) {
      if (side) {
        sides.add(side);
      }
    }
    for (const side of this.sidePowerBonus.keys()) {
      if (side) {
        sides.add(side);
      }
    }
    for (const entity of this.spawnedEntities.values()) {
      const side = this.normalizeSide(entity.side);
      if (side) {
        sides.add(side);
      }
    }
    return Array.from(sides.values()).sort();
  }

  private refreshNavigationGridFromCurrentMap(): void {
    if (!this.loadedMapData) {
      return;
    }
    this.navigationGrid = this.buildNavigationGrid(this.loadedMapData, this.mapHeightmap);
  }

  private updatePendingEnterObjectActions(): void {
    for (const [sourceId, pending] of this.pendingEnterObjectActions.entries()) {
      const source = this.spawnedEntities.get(sourceId);
      const target = this.spawnedEntities.get(pending.targetObjectId);
      if (!source || !target || source.destroyed || target.destroyed) {
        this.pendingEnterObjectActions.delete(sourceId);
        continue;
      }

      const distance = Math.hypot(target.x - source.x, target.z - source.z);
      const reachDistance = this.resolveEntityInteractionDistance(source, target);
      if (distance > reachDistance) {
        if (!source.moving) {
          this.issueMoveTo(source.id, target.x, target.z);
        }
        continue;
      }

      this.resolvePendingEnterObjectAction(source, target, pending.action);
      this.pendingEnterObjectActions.delete(sourceId);
    }
  }

  /**
   * Source parity: AIDockProcessDockState + RepairDockUpdate::action.
   * While docked, heal docker each frame by precomputed amount, and fully heal its drone.
   */
  private updatePendingRepairDockActions(): void {
    for (const [dockerId, pending] of this.pendingRepairDockActions.entries()) {
      const docker = this.spawnedEntities.get(dockerId);
      const dock = this.spawnedEntities.get(pending.dockObjectId);
      if (!docker || !dock || docker.destroyed || dock.destroyed) {
        this.pendingRepairDockActions.delete(dockerId);
        continue;
      }

      if (!this.canExecuteRepairVehicleEnterAction(docker, dock)) {
        this.pendingRepairDockActions.delete(dockerId);
        continue;
      }

      const distance = Math.hypot(dock.x - docker.x, dock.z - docker.z);
      const reachDistance = this.resolveEntityInteractionDistance(docker, dock);
      if (distance > reachDistance) {
        if (!docker.moving) {
          this.issueMoveTo(docker.id, dock.x, dock.z);
        }
        continue;
      }

      if (docker.moving) {
        this.stopEntity(docker.id);
      }

      if (docker.health >= docker.maxHealth) {
        this.pendingRepairDockActions.delete(dockerId);
        continue;
      }

      const profile = dock.repairDockProfile;
      if (!profile) {
        this.pendingRepairDockActions.delete(dockerId);
        continue;
      }

      if (pending.lastRepairDockObjectId !== dock.id) {
        pending.lastRepairDockObjectId = dock.id;
        pending.healthToAddPerFrame = (docker.maxHealth - docker.health) / profile.timeForFullHealFrames;
      }

      if (pending.healthToAddPerFrame > 0) {
        docker.health = Math.min(docker.maxHealth, docker.health + pending.healthToAddPerFrame);
        this.clearPoisonFromEntity(docker);
      }

      const drone = this.findProducedDroneForDocker(docker.id);
      if (drone && drone.health < drone.maxHealth) {
        drone.health = drone.maxHealth;
        this.clearPoisonFromEntity(drone);
      }

      if (docker.health >= docker.maxHealth) {
        this.pendingRepairDockActions.delete(dockerId);
      }
    }
  }

  private findProducedDroneForDocker(dockerId: number): MapEntity | null {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (!entity.kindOf.has('DRONE')) {
        continue;
      }
      if (entity.producerEntityId === dockerId) {
        return entity;
      }
    }
    return null;
  }

  private resolvePendingEnterObjectAction(
    source: MapEntity,
    target: MapEntity,
    action: EnterObjectCommand['action'],
  ): void {
    if (source.destroyed || target.destroyed) {
      return;
    }

    if (action === 'hijackVehicle') {
      this.resolveHijackVehicleEnterAction(source, target);
      return;
    }

    if (action === 'convertToCarBomb') {
      this.resolveConvertToCarBombEnterAction(source, target);
      return;
    }

    if (action === 'sabotageBuilding') {
      this.resolveSabotageBuildingEnterAction(source, target);
      return;
    }

    if (action === 'repairVehicle') {
      this.resolveRepairVehicleEnterAction(source, target);
    }
  }

  private canExecuteRepairVehicleEnterAction(source: MapEntity, target: MapEntity): boolean {
    const targetProfile = target.repairDockProfile;
    if (!targetProfile) {
      return false;
    }
    if (this.isEntityContained(source)) {
      return false;
    }

    // Source parity: repair docks are side-owned service structures.
    const sourceSide = this.normalizeSide(source.side);
    const targetSide = this.normalizeSide(target.side);
    if (!sourceSide || sourceSide !== targetSide) {
      return false;
    }

    // Source parity subset: repair docks service ground vehicles.
    const sourceKindOf = this.resolveEntityKindOfSet(source);
    if (!sourceKindOf.has('VEHICLE')) {
      return false;
    }

    // Source parity: each dock services one docker at a time.
    for (const [otherDockerId, pending] of this.pendingRepairDockActions.entries()) {
      if (pending.dockObjectId !== target.id || otherDockerId === source.id) {
        continue;
      }
      const otherDocker = this.spawnedEntities.get(otherDockerId);
      if (otherDocker && !otherDocker.destroyed) {
        return false;
      }
    }

    return true;
  }

  private resolveRepairVehicleEnterAction(source: MapEntity, target: MapEntity): void {
    if (!this.canExecuteRepairVehicleEnterAction(source, target)) {
      return;
    }

    // Source parity: entering process-dock state halts movement while action runs.
    this.stopEntity(source.id);
    this.clearAttackTarget(source.id);

    this.pendingRepairDockActions.set(source.id, {
      dockObjectId: target.id,
      lastRepairDockObjectId: 0,
      healthToAddPerFrame: 0,
    });
  }

  private resolveHijackVehicleEnterAction(source: MapEntity, target: MapEntity): void {
    if (!this.canExecuteHijackVehicleEnterAction(source, target)) {
      return;
    }

    const sourceSide = this.normalizeSide(source.side);
    if (!sourceSide) {
      return;
    }

    this.captureEntity(target.id, sourceSide);
    target.objectStatusFlags.add('HIJACKED');
    target.weaponSetFlagsMask |= WEAPON_SET_FLAG_VEHICLE_HIJACK;
    this.refreshEntityCombatProfiles(target);

    // Source parity: if hijacker has HijackerUpdate, hide inside vehicle instead of destroying.
    if (source.hijackerUpdateProfile) {
      // Hide the hijacker: invisible, non-interactive, non-collidable.
      source.objectStatusFlags.add('NO_COLLISIONS');
      source.objectStatusFlags.add('MASKED');
      source.objectStatusFlags.add('UNSELECTABLE');
      // Sync veterancy: take the higher of both.
      const hijackerVet = source.experienceState.currentLevel;
      const vehicleVet = target.experienceState.currentLevel;
      const highestVet = Math.max(hijackerVet, vehicleVet);
      source.experienceState.currentLevel = highestVet;
      target.experienceState.currentLevel = highestVet;
      // Activate hijacker state.
      source.hijackerState = {
        targetId: target.id,
        isInVehicle: true,
        wasTargetAirborne: false,
        ejectX: target.x,
        ejectY: target.y,
        ejectZ: target.z,
      };
      // Clear any pending commands.
      this.cancelEntityCommandPathActions(source.id);
    } else {
      this.markEntityDestroyed(source.id, target.id);
    }
  }

  private canExecuteHijackVehicleEnterAction(source: MapEntity, target: MapEntity): boolean {
    if (target.category !== 'vehicle') {
      return false;
    }
    if (this.getTeamRelationship(source, target) !== RELATIONSHIP_ENEMIES) {
      return false;
    }

    const sourceObjectDef = this.resolveObjectDefByTemplateName(source.templateName);
    if (!sourceObjectDef || !this.hasBehaviorModuleType(sourceObjectDef, 'CONVERTTOHIJACKEDVEHICLECRATECOLLIDE')) {
      return false;
    }

    const targetKindOf = this.resolveEntityKindOfSet(target);
    if (targetKindOf.has('IMMUNE_TO_CAPTURE')) {
      return false;
    }
    if (targetKindOf.has('AIRCRAFT') || targetKindOf.has('BOAT') || targetKindOf.has('DRONE')) {
      return false;
    }
    if (targetKindOf.has('TRANSPORT') && this.collectContainedEntityIds(target.id).length > 0) {
      return false;
    }
    if (this.entityHasObjectStatus(target, 'HIJACKED')) {
      return false;
    }

    return true;
  }

  private resolveConvertToCarBombEnterAction(source: MapEntity, target: MapEntity): void {
    if (!this.canExecuteConvertToCarBombEnterAction(source, target)) {
      return;
    }

    const sourceSide = this.normalizeSide(source.side);
    if (!sourceSide) {
      return;
    }

    this.captureEntity(target.id, sourceSide);
    target.objectStatusFlags.add('CARBOMB');
    target.weaponSetFlagsMask |= WEAPON_SET_FLAG_CARBOMB;
    this.refreshEntityCombatProfiles(target);
    this.markEntityDestroyed(source.id, target.id);
  }

  private canExecuteConvertToCarBombEnterAction(source: MapEntity, target: MapEntity): boolean {
    if (target.category !== 'vehicle') {
      return false;
    }
    if (this.getTeamRelationship(source, target) === RELATIONSHIP_ALLIES) {
      return false;
    }

    const sourceObjectDef = this.resolveObjectDefByTemplateName(source.templateName);
    if (!sourceObjectDef || !this.hasBehaviorModuleType(sourceObjectDef, 'CONVERTTOCARBOMBCRATECOLLIDE')) {
      return false;
    }

    const targetKindOf = this.resolveEntityKindOfSet(target);
    if (targetKindOf.has('AIRCRAFT') || targetKindOf.has('BOAT')) {
      return false;
    }
    if (this.entityHasObjectStatus(target, 'CARBOMB')) {
      return false;
    }
    if ((target.weaponSetFlagsMask & WEAPON_SET_FLAG_CARBOMB) !== 0) {
      return false;
    }
    if (!this.hasCarBombWeaponSet(target)) {
      return false;
    }

    return true;
  }

  private hasCarBombWeaponSet(target: MapEntity): boolean {
    const carbombSet = this.selectBestSetByConditions(target.weaponTemplateSets, WEAPON_SET_FLAG_CARBOMB);
    if (!carbombSet) {
      return false;
    }
    if ((carbombSet.conditionsMask & WEAPON_SET_FLAG_CARBOMB) === 0) {
      return false;
    }
    return carbombSet.weaponNamesBySlot.some((weaponName) => weaponName !== null);
  }

  private resolveSabotageBuildingEnterAction(source: MapEntity, target: MapEntity): void {
    if (target.category !== 'building') {
      return;
    }
    if (this.getTeamRelationship(source, target) !== RELATIONSHIP_ENEMIES) {
      return;
    }

    const sabotageProfile = this.resolveSabotageBuildingProfile(source, target);
    if (!sabotageProfile) {
      return;
    }

    if (sabotageProfile.disableHackedDurationFrames > 0) {
      const disableUntilFrame = this.frameCounter + sabotageProfile.disableHackedDurationFrames;
      this.setDisabledHackedStatusUntil(target, disableUntilFrame);
      if (sabotageProfile.disableContainedHackers) {
        for (const passengerId of this.collectContainedEntityIds(target.id)) {
          const passenger = this.spawnedEntities.get(passengerId);
          if (!passenger || passenger.destroyed) {
            continue;
          }
          this.setDisabledHackedStatusUntil(passenger, disableUntilFrame);
        }
      }
    }

    if (sabotageProfile.stealsCashAmount > 0) {
      const sourceSide = this.normalizeSide(source.side);
      const targetSide = this.normalizeSide(target.side);
      if (sourceSide && targetSide) {
        const withdrawn = this.withdrawSideCredits(targetSide, sabotageProfile.stealsCashAmount);
        if (withdrawn > 0) {
          this.depositSideCredits(sourceSide, withdrawn);
        }
      }
    }

    if (sabotageProfile.destroysTarget) {
      this.markEntityDestroyed(target.id, source.id);
    }

    if (sabotageProfile.powerSabotageDurationFrames > 0) {
      // Source parity: SabotagePowerPlantCrateCollide::executeCrateBehavior (line 140-146).
      // Sets a timed power outage on the victim's controlling player.
      const targetSide = this.normalizeSide(target.side);
      if (targetSide) {
        const powerState = this.getSidePowerStateMap(targetSide);
        powerState.powerSabotagedUntilFrame = this.frameCounter + sabotageProfile.powerSabotageDurationFrames;
      }
    }

    if (sabotageProfile.resetsSpecialPowers) {
      // Source parity: SabotageCommandCenterCrateCollide / SabotageSuperweaponCrateCollide
      // iterates all SpecialPowerModules on the target and calls startPowerRecharge().
      this.resetEntitySpecialPowerCooldowns(target);
    }

    this.markEntityDestroyed(source.id, target.id);
  }

  /**
   * Look up a SpecialPowerDef by normalized (uppercased) name. The module stores names
   * uppercased but the registry may store them in original case, so we try exact match
   * first, then fall back to case-insensitive iteration.
   */
  private resolveSpecialPowerDefByName(normalizedName: string): ReturnType<IniDataRegistry['getSpecialPower']> {
    const registry = this.iniDataRegistry;
    if (!registry) return undefined;
    // Fast path: exact match.
    const exact = registry.getSpecialPower(normalizedName);
    if (exact) return exact;
    // Slow path: case-insensitive scan.
    for (const [key, value] of registry.specialPowers) {
      if (key.toUpperCase() === normalizedName) return value;
    }
    return undefined;
  }

  /**
   * Source parity: SpecialPowerCreate::onBuildComplete (SpecialPowerCreate.cpp line 58-72).
   * On building construction completion, iterates all SpecialPowerModules and calls
   * onSpecialPowerCreation() which starts the recharge timer.
   *
   * C++ flow per SpecialPowerModule::onSpecialPowerCreation (line 202-236):
   * 1. startPowerRecharge() — sets readyFrame = currentFrame + reloadTime
   * 2. SharedNSync powers: expressSpecialPowerReadyFrame(currentFrame) → ready immediately
   * 3. startsPaused modules: pauseCountdown(TRUE) — timer doesn't tick
   */
  private onBuildCompleteSpecialPowerCreate(entity: MapEntity): void {
    for (const [, module] of entity.specialPowerModules) {
      const specialPowerDef = this.resolveSpecialPowerDefByName(module.specialPowerTemplateName);
      if (!specialPowerDef) continue;
      const reloadFrames = this.msToLogicFrames(readNumericField(specialPowerDef.fields, ['ReloadTime']) ?? 0);
      if (reloadFrames <= 0) continue;
      const isSharedSynced = readBooleanField(specialPowerDef.fields, ['SharedSyncedTimer']) === true;

      if (isSharedSynced) {
        // Source parity: SharedNSync powers are ready immediately on build completion.
        // C++ calls startPowerRecharge (sets timer), then expressSpecialPowerReadyFrame
        // (overrides timer to current frame = ready now).
        this.setSpecialPowerReadyFrame(module.specialPowerTemplateName, entity.id, true, this.frameCounter);
      } else {
        // Source parity: Non-shared powers start counting down from build completion.
        // readyFrame = currentFrame + reloadTime.
        const newReadyFrame = this.frameCounter + reloadFrames;
        this.setSpecialPowerReadyFrame(module.specialPowerTemplateName, entity.id, false, newReadyFrame);
      }

      // Source parity: SpecialPowerModuleData::m_startsPaused — countdown is paused
      // until activated by an upgrade (UnpauseSpecialPowerUpgrade). We don't currently
      // model pause state, but the timer won't be visible until UI is wired up, so the
      // ready frame value is still correct and will be overridden by unpause.
    }
  }

  /**
   * Source parity: SabotageCommandCenterCrateCollide::executeCrateBehavior (line 142-150).
   * Resets all special power cooldowns on an entity to their full ReloadTime.
   */
  private resetEntitySpecialPowerCooldowns(entity: MapEntity): void {
    for (const [, module] of entity.specialPowerModules) {
      const specialPowerDef = this.resolveSpecialPowerDefByName(module.specialPowerTemplateName);
      if (!specialPowerDef) continue;
      const reloadFrames = this.msToLogicFrames(readNumericField(specialPowerDef.fields, ['ReloadTime']) ?? 0);
      if (reloadFrames <= 0) continue;
      const isSharedSynced = readBooleanField(specialPowerDef.fields, ['SharedSyncedTimer']) === true;
      const newReadyFrame = this.frameCounter + reloadFrames;
      this.setSpecialPowerReadyFrame(module.specialPowerTemplateName, entity.id, isSharedSynced, newReadyFrame);
    }
  }

  private setDisabledHackedStatusUntil(entity: MapEntity, disableUntilFrame: number): void {
    if (!Number.isFinite(disableUntilFrame)) {
      return;
    }
    const resolvedDisableUntilFrame = Math.max(this.frameCounter + 1, Math.trunc(disableUntilFrame));
    entity.objectStatusFlags.add('DISABLED_HACKED');
    const previousDisableUntil = this.disabledHackedStatusByEntityId.get(entity.id) ?? 0;
    if (resolvedDisableUntilFrame > previousDisableUntil) {
      this.disabledHackedStatusByEntityId.set(entity.id, resolvedDisableUntilFrame);
    }
  }

  private resolveSabotageBuildingProfile(source: MapEntity, target: MapEntity): SabotageBuildingProfile | null {
    const sourceObjectDef = this.resolveObjectDefByTemplateName(source.templateName);
    if (!sourceObjectDef) {
      return null;
    }
    const targetKindOf = this.resolveEntityKindOfSet(target);

    let profile: SabotageBuildingProfile | null = null;
    const visitBlock = (block: IniBlock): void => {
      if (profile !== null) {
        return;
      }

      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        const sabotageDurationFrames = this.msToLogicFrames(readNumericField(block.fields, ['SabotageDuration']) ?? 0);
        const sabotagePowerDurationFrames = this.msToLogicFrames(
          readNumericField(block.fields, ['SabotagePowerDuration']) ?? 0,
        );
        const stealCashAmount = Math.max(0, Math.trunc(readNumericField(block.fields, ['StealCashAmount']) ?? 0));

        if (
          moduleType === 'SABOTAGEMILITARYFACTORYCRATECOLLIDE'
          && this.matchesAnyKindOf(targetKindOf, ['FS_BARRACKS', 'FS_WARFACTORY', 'FS_AIRFIELD'])
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: sabotageDurationFrames,
            disableContainedHackers: false,
            stealsCashAmount: 0,
            destroysTarget: false,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: false,
          };
          return;
        }

        if (
          moduleType === 'SABOTAGEINTERNETCENTERCRATECOLLIDE'
          && targetKindOf.has('FS_INTERNET_CENTER')
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: sabotageDurationFrames,
            disableContainedHackers: true,
            stealsCashAmount: 0,
            destroysTarget: false,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: false,
          };
          return;
        }

        if (
          moduleType === 'SABOTAGESUPPLYCENTERCRATECOLLIDE'
          && targetKindOf.has('FS_SUPPLY_CENTER')
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: 0,
            disableContainedHackers: false,
            stealsCashAmount: stealCashAmount,
            destroysTarget: false,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: false,
          };
          return;
        }

        if (
          moduleType === 'SABOTAGESUPPLYDROPZONECRATECOLLIDE'
          && targetKindOf.has('FS_SUPPLY_DROPZONE')
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: 0,
            disableContainedHackers: false,
            stealsCashAmount: stealCashAmount,
            destroysTarget: false,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: false,
          };
          return;
        }

        if (
          moduleType === 'SABOTAGEFAKEBUILDINGCRATECOLLIDE'
          && targetKindOf.has('FS_FAKE')
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: 0,
            disableContainedHackers: false,
            stealsCashAmount: 0,
            destroysTarget: true,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: false,
          };
          return;
        }

        if (
          moduleType === 'SABOTAGEPOWERPLANTCRATECOLLIDE'
          && targetKindOf.has('FS_POWER')
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: 0,
            disableContainedHackers: false,
            stealsCashAmount: 0,
            destroysTarget: false,
            powerSabotageDurationFrames: sabotagePowerDurationFrames,
            resetsSpecialPowers: false,
          };
          return;
        }

        if (
          moduleType === 'SABOTAGECOMMANDCENTERCRATECOLLIDE'
          && targetKindOf.has('COMMANDCENTER')
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: 0,
            disableContainedHackers: false,
            stealsCashAmount: 0,
            destroysTarget: false,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: true,
          };
          return;
        }

        // Source parity: SabotageSuperweaponCrateCollide.cpp:99 — targets FS_SUPERWEAPON and FS_STRATEGY_CENTER.
        if (
          moduleType === 'SABOTAGESUPERWEAPONCRATECOLLIDE'
          && (targetKindOf.has('FS_SUPERWEAPON') || targetKindOf.has('FS_STRATEGY_CENTER'))
        ) {
          profile = {
            moduleType,
            disableHackedDurationFrames: 0,
            disableContainedHackers: false,
            stealsCashAmount: 0,
            destroysTarget: false,
            powerSabotageDurationFrames: 0,
            resetsSpecialPowers: true,
          };
          return;
        }
      }

      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of sourceObjectDef.blocks) {
      visitBlock(block);
    }
    return profile;
  }

  private matchesAnyKindOf(kindOf: ReadonlySet<string>, candidateKinds: readonly string[]): boolean {
    for (const candidateKind of candidateKinds) {
      if (kindOf.has(candidateKind)) {
        return true;
      }
    }
    return false;
  }

  private updateRailedTransport(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || !entity.canMove) {
        continue;
      }

      const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
      const profile = this.extractRailedTransportProfile(objectDef ?? undefined);
      if (!profile) {
        continue;
      }

      updateRailedTransportEntityImpl(entity, profile, {
        waypointIndex: this.railedTransportWaypointIndex,
        resolveRuntimeState: this.resolveRailedTransportRuntimeState.bind(this),
        issueMoveTo: this.issueMoveTo.bind(this),
        isValidEntity: (candidate) => !candidate.destroyed && candidate.canMove,
      });
    }
  }

  private initializeScriptTriggerMembershipBaselines(): void {
    this.scriptTriggerMembershipByEntityId.clear();
    this.scriptTriggerEnteredByEntityId.clear();
    this.scriptTriggerExitedByEntityId.clear();
    this.scriptTriggerEnterExitFrameByEntityId.clear();
    for (const entity of this.spawnedEntities.values()) {
      this.initializeScriptTriggerMembershipForEntity(entity);
    }
  }

  private initializeScriptTriggerMembershipForEntity(entity: MapEntity): void {
    if (entity.destroyed || entity.kindOf.has('INERT') || entity.kindOf.has('PROJECTILE')) {
      this.clearScriptTriggerTrackingForEntity(entity.id);
      return;
    }

    this.scriptTriggerMembershipByEntityId.set(
      entity.id,
      this.computeCurrentScriptTriggerMembership(entity),
    );
    this.scriptTriggerEnteredByEntityId.delete(entity.id);
    this.scriptTriggerExitedByEntityId.delete(entity.id);
    this.scriptTriggerEnterExitFrameByEntityId.delete(entity.id);
  }

  private clearScriptTriggerTrackingForEntity(entityId: number): void {
    this.scriptTriggerMembershipByEntityId.delete(entityId);
    this.scriptTriggerEnteredByEntityId.delete(entityId);
    this.scriptTriggerExitedByEntityId.delete(entityId);
    this.scriptTriggerEnterExitFrameByEntityId.delete(entityId);
  }

  private computeCurrentScriptTriggerMembership(entity: Pick<MapEntity, 'x' | 'z'>): Set<number> {
    const membership = new Set<number>();
    for (let index = 0; index < this.mapTriggerRegions.length; index += 1) {
      const region = this.mapTriggerRegions[index]!;
      if (this.isPointInsideTriggerRegion(region, entity.x, entity.z)) {
        membership.add(index);
      }
    }
    return membership;
  }

  private updateScriptTriggerTransitions(): void {
    if (this.mapTriggerRegions.length === 0) {
      return;
    }

    for (const trackedEntityId of Array.from(this.scriptTriggerMembershipByEntityId.keys())) {
      const trackedEntity = this.spawnedEntities.get(trackedEntityId);
      if (!trackedEntity || trackedEntity.destroyed) {
        this.clearScriptTriggerTrackingForEntity(trackedEntityId);
      }
    }

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.kindOf.has('INERT') || entity.kindOf.has('PROJECTILE')) {
        this.clearScriptTriggerTrackingForEntity(entity.id);
        continue;
      }

      const previousMembership = this.scriptTriggerMembershipByEntityId.get(entity.id) ?? new Set<number>();
      const currentMembership = this.computeCurrentScriptTriggerMembership(entity);
      const entered = new Set<number>();
      const exited = new Set<number>();

      for (const triggerIndex of currentMembership) {
        if (!previousMembership.has(triggerIndex)) {
          entered.add(triggerIndex);
        }
      }
      for (const triggerIndex of previousMembership) {
        if (!currentMembership.has(triggerIndex)) {
          exited.add(triggerIndex);
        }
      }

      this.scriptTriggerMembershipByEntityId.set(entity.id, currentMembership);

      if (entered.size === 0 && exited.size === 0) {
        continue;
      }

      this.scriptTriggerEnteredByEntityId.set(entity.id, entered);
      this.scriptTriggerExitedByEntityId.set(entity.id, exited);
      this.scriptTriggerEnterExitFrameByEntityId.set(entity.id, this.frameCounter);
    }
  }

  private findMapTriggerRegionsByName(triggerName: string): Array<{
    id: number;
    name: string;
    nameUpper: string;
    points: Array<{ x: number; y: number; z: number }>;
    minX: number;
    maxX: number;
    minZ: number;
    maxZ: number;
  }> {
    const normalizedName = triggerName.trim().toUpperCase();
    if (!normalizedName) {
      return [];
    }
    return this.mapTriggerRegions.filter((region) => region.nameUpper === normalizedName);
  }

  private isInsideAnyTriggerRegion(
    entity: Pick<MapEntity, 'x' | 'z'>,
    triggerRegions: Array<{
      points: Array<{ x: number; y: number; z: number }>;
      minX: number;
      maxX: number;
      minZ: number;
      maxZ: number;
    }>,
  ): boolean {
    for (const region of triggerRegions) {
      if (this.isPointInsideTriggerRegion(region, entity.x, entity.z)) {
        return true;
      }
    }
    return false;
  }

  private computeTriggerRegionCenterAndRadius(region: {
    points: Array<{ x: number; y: number; z: number }>;
  }): { centerX: number; centerZ: number; radius: number } {
    if (region.points.length === 0) {
      return { centerX: 0, centerZ: 0, radius: 0 };
    }

    let centerX = 0;
    let centerZ = 0;
    for (const point of region.points) {
      centerX += point.x;
      centerZ += point.y;
    }
    centerX /= region.points.length;
    centerZ /= region.points.length;

    let radius = 0;
    for (const point of region.points) {
      const dx = point.x - centerX;
      const dz = point.y - centerZ;
      radius = Math.max(radius, Math.sqrt(dx * dx + dz * dz));
    }
    return { centerX, centerZ, radius };
  }

  private isPointInsideTriggerRegion(
    region: {
      points: Array<{ x: number; y: number; z: number }>;
      minX: number;
      maxX: number;
      minZ: number;
      maxZ: number;
    },
    worldX: number,
    worldZ: number,
  ): boolean {
    if (worldX < region.minX || worldX > region.maxX || worldZ < region.minZ || worldZ > region.maxZ) {
      return false;
    }
    return pointInPolygon(worldX, worldZ, region.points);
  }

  private clearChinookSupplyBoxes(entityId: number): void {
    const state = this.supplyTruckStates.get(entityId);
    if (!state || state.currentBoxes <= 0) {
      return;
    }

    // Source parity: ChinookCombatDropState::onEnter — while (ai->loseOneBox()).
    state.currentBoxes = 0;
    if (state.aiState === SupplyTruckAIState.APPROACHING_DEPOT || state.aiState === SupplyTruckAIState.DEPOSITING) {
      state.targetDepotId = null;
      state.aiState = SupplyTruckAIState.IDLE;
    }
  }

  private countActiveChinookRappellers(sourceEntityId: number): number {
    let count = 0;
    for (const pending of this.pendingChinookRappels.values()) {
      if (pending.sourceEntityId === sourceEntityId) {
        count += 1;
      }
    }
    return count;
  }

  private clearPendingChinookCommands(entityId: number): void {
    this.pendingChinookCommandByEntityId.delete(entityId);
  }

  private flushPendingChinookCommand(entityId: number): void {
    const command = this.pendingChinookCommandByEntityId.get(entityId);
    if (!command) {
      return;
    }
    this.pendingChinookCommandByEntityId.delete(entityId);
    this.submitCommand(command);
  }

  private abortPendingChinookRappels(sourceEntityId: number): void {
    for (const [passengerId, pending] of this.pendingChinookRappels.entries()) {
      if (pending.sourceEntityId !== sourceEntityId) {
        continue;
      }
      const passenger = this.spawnedEntities.get(passengerId);
      if (passenger && !passenger.destroyed) {
        // Source parity: ChinookCombatDropState::onExit(STATE_FAILURE) -> rappellerAI->aiIdle().
        passenger.objectStatusFlags.delete('DISABLED_HELD');
        this.cancelEntityCommandPathActions(passenger.id);
        this.clearAttackTarget(passenger.id);
      }
      this.pendingChinookRappels.delete(passengerId);
    }
  }

  /**
   * Source parity: ChinookAIUpdate::getBuildingToNotPathAround.
   * During combat-drop movement/state, treat the target building as ignorable for pathing.
   */
  private syncChinookCombatDropIgnoredObstacle(source: MapEntity, targetObjectId: number | null): void {
    if (!source.chinookAIProfile || targetObjectId === null) {
      source.ignoredMovementObstacleId = null;
      return;
    }
    const target = this.spawnedEntities.get(targetObjectId);
    source.ignoredMovementObstacleId = target && !target.destroyed ? target.id : null;
  }

  private clearChinookCombatDropIgnoredObstacle(entityId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || !entity.chinookAIProfile) {
      return;
    }
    entity.ignoredMovementObstacleId = null;
  }

  private updatePendingChinookRappels(): void {
    for (const [passengerId, pending] of this.pendingChinookRappels.entries()) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (!passenger || passenger.destroyed) {
        this.pendingChinookRappels.delete(passengerId);
        continue;
      }

      const source = this.spawnedEntities.get(pending.sourceEntityId);
      if (!source || source.destroyed) {
        passenger.objectStatusFlags.delete('DISABLED_HELD');
        this.cancelEntityCommandPathActions(passenger.id);
        this.clearAttackTarget(passenger.id);
        this.pendingChinookRappels.delete(passengerId);
        continue;
      }

      const groundY = this.resolveGroundHeight(passenger.x, passenger.z) + passenger.baseHeight;
      if (passenger.y > groundY) {
        passenger.y = Math.max(groundY, passenger.y - Math.max(0, pending.descentSpeedPerFrame));
        continue;
      }

      passenger.y = groundY;
      passenger.objectStatusFlags.delete('DISABLED_HELD');
      this.pendingChinookRappels.delete(passengerId);
      this.issueDroppedPassengerCommand(passenger, pending.targetX, pending.targetZ, pending.targetObjectId);
    }
  }

  private updatePendingCombatDropActions(): void {
    for (const [sourceId, pending] of this.pendingCombatDropActions.entries()) {
      const source = this.spawnedEntities.get(sourceId);
      if (!source || source.destroyed) {
        this.clearChinookCombatDropIgnoredObstacle(sourceId);
        this.abortPendingChinookRappels(sourceId);
        this.clearPendingChinookCommands(sourceId);
        this.pendingCombatDropActions.delete(sourceId);
        continue;
      }

      this.syncChinookCombatDropIgnoredObstacle(source, pending.targetObjectId);

      if (source.moving) {
        continue;
      }

      const distance = Math.hypot(pending.targetX - source.x, pending.targetZ - source.z);
      const dropReachDistance = this.resolveEntityMajorRadius(source) + MAP_XY_FACTOR;
      if (distance > dropReachDistance) {
        this.issueMoveTo(source.id, pending.targetX, pending.targetZ);
        continue;
      }

      if (source.chinookAIProfile) {
        // Source parity subset: ChinookCombatDropState rappels CAN_RAPPEL passengers over time.
        const profile = source.chinookAIProfile;
        if (pending.nextDropFrame === 0) {
          // Source parity: combat drop holds the transport in place while rappelling.
          source.objectStatusFlags.add('DISABLED_HELD');
          // Source parity: ChinookCombatDropState::onEnter — lose all gathered supply boxes.
          this.clearChinookSupplyBoxes(source.id);
          // Source parity subset: keep chinook at min drop height while deploying ropes.
          const hoverGround = this.resolveGroundHeight(source.x, source.z);
          const hoverY = hoverGround + source.baseHeight + Math.max(0, profile.minDropHeight);
          if (source.y < hoverY) {
            source.y = hoverY;
          }
          pending.nextDropFrame = this.frameCounter + this.resolveChinookCombatDropInitialDelayFrames(source);
        }
        if (this.frameCounter < pending.nextDropFrame) {
          continue;
        }

        let droppedAny = false;
        const dropsThisTick = Math.max(1, profile.numRopes);
        for (let i = 0; i < dropsThisTick; i++) {
          if (!this.evacuateOneContainedRappeller(source, pending.targetX, pending.targetZ, pending.targetObjectId)) {
            break;
          }
          droppedAny = true;
        }

        const hasContainedRappellers = this.countContainedRappellers(source.id) > 0;
        const hasActiveRappellers = this.countActiveChinookRappellers(source.id) > 0;
        if (!hasContainedRappellers && !hasActiveRappellers) {
          source.objectStatusFlags.delete('DISABLED_HELD');
          this.clearChinookCombatDropIgnoredObstacle(sourceId);
          this.pendingCombatDropActions.delete(sourceId);
          this.flushPendingChinookCommand(source.id);
          continue;
        }

        pending.nextDropFrame = droppedAny
          ? this.frameCounter + this.resolveChinookCombatDropIntervalFrames(profile)
          : this.frameCounter + 1;
        continue;
      }

      // Non-Chinook combat-drop carriers: immediate evac at destination.
      this.evacuateContainedEntities(source, pending.targetX, pending.targetZ, pending.targetObjectId);
      this.clearChinookCombatDropIgnoredObstacle(sourceId);
      this.pendingCombatDropActions.delete(sourceId);
    }
  }

  private updateHackInternet(): void {
    for (const [entityId, hackState] of this.hackInternetStateByEntityId.entries()) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity || entity.destroyed) {
        this.hackInternetStateByEntityId.delete(entityId);
        continue;
      }

      if (this.frameCounter < hackState.nextCashFrame) {
        continue;
      }

      this.depositSideCredits(entity.side, hackState.cashAmountPerCycle);
      const cycleDelay = Math.max(1, hackState.cashUpdateDelayFrames);
      hackState.nextCashFrame = this.frameCounter + cycleDelay;
    }
  }

  private updatePendingHackInternetCommands(): void {
    for (const [entityId, pending] of this.hackInternetPendingCommandByEntityId.entries()) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity || entity.destroyed) {
        this.hackInternetPendingCommandByEntityId.delete(entityId);
        continue;
      }

      if (this.frameCounter < pending.executeFrame) {
        continue;
      }

      this.hackInternetPendingCommandByEntityId.delete(entityId);
      this.applyCommand(pending.command);
    }
  }

  // ── Source parity: AssaultTransportAIUpdate — auto-deploy/recall passengers ──

  private beginAssaultTransportAttack(transport: MapEntity, targetEntityId: number, _isAttackMove: boolean): void {
    const state = this.getOrCreateAssaultTransportState(transport.id);
    // Source parity: reset() then set attack flags.
    state.members = [];
    state.designatedTargetId = targetEntityId;
    state.isAttackObject = true;
    state.isAttackMove = false;
    state.newOccupantsAreNewMembers = false;
  }

  private beginAssaultTransportAttackMove(transport: MapEntity, targetX: number, targetZ: number): void {
    const state = this.getOrCreateAssaultTransportState(transport.id);
    state.members = [];
    state.designatedTargetId = null;
    state.attackMoveGoalX = targetX;
    state.attackMoveGoalZ = targetZ;
    state.isAttackMove = true;
    state.isAttackObject = false;
    state.newOccupantsAreNewMembers = false;
  }

  private resetAssaultTransportState(entityId: number): void {
    const state = this.assaultTransportStateByEntityId.get(entityId);
    if (!state) return;
    // Source parity: retrieveMembers() — order all outside members back in.
    for (const member of state.members) {
      const memberEntity = this.spawnedEntities.get(member.entityId);
      if (!memberEntity || memberEntity.destroyed) continue;
      if (!this.isEntityContained(memberEntity)) {
        // Order member to re-enter transport.
        this.commandQueue.push({ type: 'enterTransport', entityId: member.entityId, targetTransportId: entityId });
      }
    }
    this.assaultTransportStateByEntityId.delete(entityId);
  }

  private getOrCreateAssaultTransportState(entityId: number): AssaultTransportState {
    let state = this.assaultTransportStateByEntityId.get(entityId);
    if (!state) {
      state = {
        members: [],
        designatedTargetId: null,
        attackMoveGoalX: 0,
        attackMoveGoalZ: 0,
        isAttackMove: false,
        isAttackObject: false,
        newOccupantsAreNewMembers: false,
      };
      this.assaultTransportStateByEntityId.set(entityId, state);
    }
    return state;
  }

  /**
   * Source parity: AssaultTransportAIUpdate::update() — frame-by-frame member coordination.
   * C++ file: AssaultTransportAIUpdate.cpp lines 155-370.
   */
  private updateAssaultTransports(): void {
    for (const [transportId, state] of this.assaultTransportStateByEntityId.entries()) {
      const transport = this.spawnedEntities.get(transportId);
      if (!transport || transport.destroyed) {
        // Source parity: giveFinalOrders() — transfer commands to troops when transport dies.
        this.giveAssaultTransportFinalOrders(state);
        this.assaultTransportStateByEntityId.delete(transportId);
        continue;
      }
      const profile = transport.assaultTransportProfile;
      if (!profile) {
        this.assaultTransportStateByEntityId.delete(transportId);
        continue;
      }

      // Source parity: cleanup dead or externally-commanded members.
      state.members = state.members.filter((member) => {
        const memberEntity = this.spawnedEntities.get(member.entityId);
        if (!memberEntity || memberEntity.destroyed) return false;
        // Source parity: if member received direct player command, release from tracking.
        if (memberEntity.attackCommandSource === 'PLAYER') return false;
        return true;
      });

      // Source parity: add new contained passengers not yet tracked.
      const containedIds = this.collectContainedEntityIds(transportId);
      for (const passengerId of containedIds) {
        if (state.members.some((m) => m.entityId === passengerId)) continue;
        if (state.members.length >= 10) break; // MAX_TRANSPORT_SLOTS
        const passenger = this.spawnedEntities.get(passengerId);
        if (!passenger || passenger.destroyed) continue;
        const isWounded = profile.membersGetHealedAtLifeRatio > 0
          && passenger.health / passenger.maxHealth < profile.membersGetHealedAtLifeRatio;
        state.members.push({
          entityId: passengerId,
          isHealing: isWounded,
          isNew: state.newOccupantsAreNewMembers,
        });
      }
      // After first sync, all future occupants are new members.
      state.newOccupantsAreNewMembers = true;

      // Source parity: C++ isAttackPointless() (lines 386-408) — abort if all members are
      // new AND the transport is currently attacking. Calls aiIdle → retrieveMembers + reset.
      if (this.entityHasObjectStatus(transport, 'IS_ATTACKING')
        && state.members.length > 0 && state.members.every((m) => m.isNew)) {
        // Source parity: aiIdle(CMD_FROM_AI) → retrieveMembers + reset.
        for (const member of state.members) {
          const memberEntity = this.spawnedEntities.get(member.entityId);
          if (memberEntity && !memberEntity.destroyed && !this.isEntityContained(memberEntity)) {
            this.commandQueue.push({ type: 'enterTransport', entityId: member.entityId, targetTransportId: transportId });
          }
        }
        state.designatedTargetId = null;
        state.isAttackObject = false;
        state.isAttackMove = false;
        continue;
      }

      // Resolve designated target.
      let target = state.designatedTargetId !== null
        ? this.spawnedEntities.get(state.designatedTargetId) ?? null
        : null;
      if (target?.destroyed) {
        target = null;
        state.designatedTargetId = null;
      }

      if (target) {
        // Source parity: coordinate members for attack-object.
        for (const member of state.members) {
          const memberEntity = this.spawnedEntities.get(member.entityId);
          if (!memberEntity || memberEntity.destroyed) continue;
          const contained = this.isEntityContained(memberEntity);
          const isHealthy = memberEntity.health >= memberEntity.maxHealth;
          const isWounded = profile.membersGetHealedAtLifeRatio > 0
            && memberEntity.health / memberEntity.maxHealth < profile.membersGetHealedAtLifeRatio;

          if (contained && isHealthy && !member.isNew) {
            // Eject healthy members.
            this.commandQueue.push({ type: 'exitContainer', entityId: member.entityId });
          } else if (!contained && isWounded) {
            // Recall wounded members.
            member.isHealing = true;
            this.commandQueue.push({ type: 'enterTransport', entityId: member.entityId, targetTransportId: transportId });
          } else if (!contained && !isWounded) {
            // Order healthy outside members to attack target.
            member.isHealing = false;
            if (memberEntity.attackTargetEntityId !== target.id) {
              this.commandQueue.push({ type: 'attackEntity', entityId: member.entityId, targetEntityId: target.id, commandSource: 'AI' });
            }
          }
        }
      } else if (state.isAttackMove) {
        // Source parity: C++ lines 322-327 — re-issue attackMoveTo to continue advancing.
        // Target died during attack-move: recall members and keep transport moving.
        for (const member of state.members) {
          const memberEntity = this.spawnedEntities.get(member.entityId);
          if (!memberEntity || memberEntity.destroyed) continue;
          if (!this.isEntityContained(memberEntity)) {
            this.commandQueue.push({ type: 'enterTransport', entityId: member.entityId, targetTransportId: transportId });
          }
        }
        state.designatedTargetId = null;
        // Re-issue attack-move to the transport itself.
        if (!transport.moving) {
          this.commandQueue.push({
            type: 'attackMoveTo',
            entityId: transportId,
            targetX: state.attackMoveGoalX,
            targetZ: state.attackMoveGoalZ,
            attackDistance: 0,
          });
        }
      } else if (state.isAttackObject) {
        // Target died — retrieve members.
        for (const member of state.members) {
          const memberEntity = this.spawnedEntities.get(member.entityId);
          if (!memberEntity || memberEntity.destroyed) continue;
          if (!this.isEntityContained(memberEntity)) {
            this.commandQueue.push({ type: 'enterTransport', entityId: member.entityId, targetTransportId: transportId });
          }
        }
        state.isAttackObject = false;
        state.designatedTargetId = null;
      }
    }
  }

  /**
   * Source parity: AssaultTransportAIUpdate::giveFinalOrders() — transfer command to troops.
   */
  private giveAssaultTransportFinalOrders(state: AssaultTransportState): void {
    for (const member of state.members) {
      const memberEntity = this.spawnedEntities.get(member.entityId);
      if (!memberEntity || memberEntity.destroyed) continue;
      const target = state.designatedTargetId !== null
        ? this.spawnedEntities.get(state.designatedTargetId)
        : null;
      if (state.isAttackObject && target && !target.destroyed) {
        // Transfer as PLAYER command so troops continue independently.
        this.commandQueue.push({ type: 'attackEntity', entityId: member.entityId, targetEntityId: target.id, commandSource: 'PLAYER' });
      } else if (state.isAttackMove) {
        this.commandQueue.push({
          type: 'attackMoveTo',
          entityId: member.entityId,
          targetX: state.attackMoveGoalX,
          targetZ: state.attackMoveGoalZ,
          attackDistance: 0,
        });
      }
    }
  }

  private updateOvercharge(): void {
    for (const [entityId, overchargeState] of this.overchargeStateByEntityId.entries()) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity || entity.destroyed) {
        this.overchargeStateByEntityId.delete(entityId);
        continue;
      }

      const damageAmount = (entity.maxHealth * overchargeState.healthPercentToDrainPerSecond) / LOGIC_FRAME_RATE;
      if (damageAmount > 0 && entity.canTakeDamage && entity.health > 0) {
        this.applyWeaponDamageAmount(entity.id, entity, damageAmount, 'PENALTY');
      }

      const refreshed = this.spawnedEntities.get(entityId);
      if (!refreshed || refreshed.destroyed) {
        this.overchargeStateByEntityId.delete(entityId);
        continue;
      }

      const minimumAllowedHealth = refreshed.maxHealth * overchargeState.notAllowedWhenHealthBelowPercent;
      if (minimumAllowedHealth > 0 && refreshed.health < minimumAllowedHealth) {
        this.disableOverchargeForEntity(refreshed);
      }
    }
  }

  private updateDisabledHackedStatuses(): void {
    for (const [entityId, disableUntilFrame] of this.disabledHackedStatusByEntityId.entries()) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity || entity.destroyed) {
        this.disabledHackedStatusByEntityId.delete(entityId);
        continue;
      }

      if (this.frameCounter < disableUntilFrame) {
        continue;
      }

      entity.objectStatusFlags.delete('DISABLED_HACKED');
      this.disabledHackedStatusByEntityId.delete(entityId);
    }
  }

  /**
   * Source parity: EMPUpdate — timed DISABLED_EMP status expiry.
   */
  private updateDisabledEmpStatuses(): void {
    for (const [entityId, disableUntilFrame] of this.disabledEmpStatusByEntityId.entries()) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity || entity.destroyed) {
        this.disabledEmpStatusByEntityId.delete(entityId);
        continue;
      }
      if (this.frameCounter < disableUntilFrame) {
        continue;
      }
      entity.objectStatusFlags.delete('DISABLED_EMP');
      this.disabledEmpStatusByEntityId.delete(entityId);
    }
  }

  /**
   * Apply EMP disable effect to an entity for a duration.
   * Source parity: EMPUpdate::onObjectCreated / EMPWeapon hit.
   */
  private applyEmpDisable(entity: MapEntity, durationFrames: number): void {
    if (entity.destroyed) return;
    entity.objectStatusFlags.add('DISABLED_EMP');
    const resolvedDisableUntilFrame = this.frameCounter + durationFrames;
    const previous = this.disabledEmpStatusByEntityId.get(entity.id) ?? 0;
    if (resolvedDisableUntilFrame > previous) {
      this.disabledEmpStatusByEntityId.set(entity.id, resolvedDisableUntilFrame);
    }
  }

  /**
   * Source parity: Object::look() / Object::unlook()
   * Updates each entity's vision contribution to the fog of war grid.
   */
  /**
   * Source parity: StealthUpdate::allowedToStealth + update — auto-stealth entities
   * with CAN_STEALTH, break stealth based on INI-driven forbidden conditions, count
   * down per-entity stealth delay. Fallback to default 60-frame delay for entities
   * without an explicit StealthUpdate module.
   */
  private updateStealth(): void {
    const DEFAULT_STEALTH_DELAY_FRAMES = 60; // ~2s at 30fps

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;

      // Clear expired detection.
      if (entity.detectedUntilFrame > 0 && this.frameCounter >= entity.detectedUntilFrame) {
        entity.objectStatusFlags.delete('DETECTED');
        entity.detectedUntilFrame = 0;
      }

      if (!entity.objectStatusFlags.has('CAN_STEALTH')) continue;

      const profile = entity.stealthProfile;
      const delayFrames = profile ? profile.stealthDelayFrames : DEFAULT_STEALTH_DELAY_FRAMES;
      const forbidden = profile ? profile.forbiddenConditions : STEALTH_FORBIDDEN_DEFAULT;

      // Source parity: StealthUpdate::allowedToStealth — contained in non-garrisonable = no stealth.
      const stealthContainer = this.resolveEntityContainingObject(entity);
      if (stealthContainer) {
        const isGarrisonable = stealthContainer.containProfile !== null
          && stealthContainer.containProfile.garrisonCapacity > 0;
        if (!isGarrisonable) {
          if (entity.objectStatusFlags.has('STEALTHED')) {
            entity.objectStatusFlags.delete('STEALTHED');
          }
          entity.stealthDelayRemaining = delayFrames;
          continue;
        }
      }

      // Source parity: StealthUpdate::allowedToStealth — check forbidden conditions.
      let breakStealth = false;

      if ((forbidden & STEALTH_FORBIDDEN_ATTACKING) !== 0) {
        if (entity.attackTargetEntityId !== null) {
          breakStealth = true;
        }
      }

      if ((forbidden & STEALTH_FORBIDDEN_FIRING_PRIMARY) !== 0) {
        if (entity.objectStatusFlags.has('IS_FIRING_WEAPON')) {
          breakStealth = true;
        }
      }

      if ((forbidden & STEALTH_FORBIDDEN_MOVING) !== 0) {
        if (profile && profile.moveThresholdSpeed > 0) {
          // Source parity: break stealth only if speed exceeds threshold.
          if (entity.moving && entity.currentSpeed > profile.moveThresholdSpeed) {
            breakStealth = true;
          }
        } else if (entity.moving) {
          breakStealth = true;
        }
      }

      if ((forbidden & STEALTH_FORBIDDEN_TAKING_DAMAGE) !== 0) {
        // Source parity: getLastDamageTimestamp >= now - 1 — stealth breaks if damaged this frame or last.
        // Healing damage does not break stealth (C++ checks m_damageType != DAMAGE_HEALING).
        if (entity.lastDamageFrame > 0 && (this.frameCounter - entity.lastDamageFrame) <= 1) {
          breakStealth = true;
        }
      }

      if ((forbidden & STEALTH_FORBIDDEN_USING_ABILITY) !== 0) {
        if (entity.objectStatusFlags.has('IS_USING_ABILITY')) {
          breakStealth = true;
        }
      }

      if (breakStealth) {
        if (entity.objectStatusFlags.has('STEALTHED')) {
          entity.objectStatusFlags.delete('STEALTHED');
        }
        entity.stealthDelayRemaining = delayFrames;
        continue;
      }

      // Count down stealth delay.
      if (entity.stealthDelayRemaining > 0) {
        entity.stealthDelayRemaining--;
        continue;
      }

      // Enter stealth.
      if (!entity.objectStatusFlags.has('STEALTHED')) {
        entity.objectStatusFlags.add('STEALTHED');
      }
    }
  }

  /**
   * Source parity: GrantStealthBehavior::update — expanding radius stealth grant.
   * Each frame grows scan radius, scans allied entities in range with KindOf filtering,
   * grants permanent stealth to matching units, then self-destructs at finalRadius.
   * C++ file: GrantStealthBehavior.cpp lines 139-179.
   */
  private updateGrantStealth(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.grantStealthProfile;
      if (!profile) continue;

      // Source parity: grow radius each frame.
      entity.grantStealthCurrentRadius += profile.radiusGrowRate;

      let isFinalScan = false;
      if (entity.grantStealthCurrentRadius >= profile.finalRadius) {
        entity.grantStealthCurrentRadius = profile.finalRadius;
        isFinalScan = true;
      }

      const radiusSqr = entity.grantStealthCurrentRadius * entity.grantStealthCurrentRadius;

      // Source parity: scan allies in range.
      for (const target of this.spawnedEntities.values()) {
        if (target.destroyed || target.id === entity.id) continue;
        if (target.slowDeathState || target.structureCollapseState) continue;

        // Source parity: PartitionFilterRelationship(ALLOW_ALLIES).
        const rel = this.getEntityRelationship(entity.id, target.id);
        if (rel !== 'allies') continue;

        // Source parity: FROM_CENTER_2D distance check.
        const dx = target.x - entity.x;
        const dz = target.z - entity.z;
        if (dx * dx + dz * dz > radiusSqr) continue;

        this.grantStealthToEntity(target, profile);
      }

      // Source parity: self-destruct when final radius reached.
      if (isFinalScan) {
        this.silentDestroyEntity(entity.id);
      }
    }
  }

  /**
   * Source parity: GrantStealthBehavior::grantStealthToObject — grant permanent stealth.
   * Checks KindOf filter, then sets CAN_STEALTH + STEALTHED on the target entity.
   * C++ calls StealthUpdate::receiveGrant() which sets m_enabled=true.
   */
  private grantStealthToEntity(target: MapEntity, profile: GrantStealthProfile): void {
    // Source parity: C++ checks obj->getStealth() != null — only entities with StealthUpdate can receive stealth.
    if (!target.stealthProfile) return;

    // Source parity: KindOf filter — null means all types accepted.
    if (profile.kindOf) {
      const targetKindOf = this.resolveEntityKindOfSet(target);
      let matches = false;
      for (const kind of profile.kindOf) {
        if (targetKindOf.has(kind)) {
          matches = true;
          break;
        }
      }
      if (!matches) return;
    }

    // Source parity: StealthUpdate::receiveGrant(TRUE, 0) — permanent stealth grant.
    // Sets CAN_STEALTH + STEALTHED flags, clears stealth delay.
    target.objectStatusFlags.add('CAN_STEALTH');
    target.objectStatusFlags.add('STEALTHED');
    target.stealthDelayRemaining = 0;
  }

  /**
   * Source parity: StealthDetectorUpdate — detector units reveal stealthed enemies.
   * Uses per-entity DetectorProfile for range, rate, and KindOf filters when available.
   * Falls back to KINDOF_DETECTOR + visionRange for entities without explicit module.
   */
  private updateDetection(): void {
    const DEFAULT_DETECTION_DURATION_FRAMES = 30; // ~1s at 30fps

    for (const detector of this.spawnedEntities.values()) {
      if (detector.destroyed) continue;

      // Source parity: detector needs either KINDOF_DETECTOR or a StealthDetectorUpdate module.
      const profile = detector.detectorProfile;
      if (!detector.kindOf.has('DETECTOR') && !profile) continue;

      // Source parity: detector must be fully constructed and not sold.
      if (detector.constructionPercent !== CONSTRUCTION_COMPLETE) continue;
      if (detector.objectStatusFlags.has('SOLD')) continue;

      // Source parity: DetectionRate throttle — skip scan if not yet due.
      if (profile) {
        if (this.frameCounter < detector.detectorNextScanFrame) continue;
        detector.detectorNextScanFrame = this.frameCounter + profile.detectionRate;
      }

      // Source parity: contained/garrisoned detector checks.
      // C++ uses isGarrisonable() — garrison buildings allow fire; transports enclose passengers.
      if (profile) {
        const containingObject = this.resolveEntityContainingObject(detector);
        if (containingObject) {
          const isGarrison = containingObject.containProfile !== null
            && containingObject.containProfile.garrisonCapacity > 0;
          if (isGarrison && !profile.canDetectWhileGarrisoned) continue;
          if (!isGarrison && !profile.canDetectWhileContained) continue;
        }
      }

      // Detection range: profile override > visionRange > fallback 150.
      const detectionRange = (profile && profile.detectionRange > 0)
        ? profile.detectionRange
        : (detector.visionRange > 0 ? detector.visionRange : 150);
      const detRangeSq = detectionRange * detectionRange;

      // Detection duration matches the scan interval (+ 1 frame) to prevent flicker.
      const detectionDuration = profile
        ? profile.detectionRate + 1
        : DEFAULT_DETECTION_DURATION_FRAMES;

      for (const target of this.spawnedEntities.values()) {
        if (target.destroyed || target === detector) continue;
        if (!target.objectStatusFlags.has('STEALTHED')) continue;

        // Source parity: detect enemies and neutrals (PartitionFilterRelationship::ALLOW_ENEMIES | ALLOW_NEUTRAL).
        const detRel = this.getTeamRelationship(detector, target);
        if (detRel !== RELATIONSHIP_ENEMIES && detRel !== RELATIONSHIP_NEUTRAL) continue;

        // Source parity: ExtraRequiredKindOf / ExtraForbiddenKindOf filters.
        if (profile && profile.extraRequiredKindOf.size > 0) {
          let hasRequired = false;
          for (const kind of profile.extraRequiredKindOf) {
            if (target.kindOf.has(kind)) { hasRequired = true; break; }
          }
          if (!hasRequired) continue;
        }
        if (profile && profile.extraForbiddenKindOf.size > 0) {
          let hasForbidden = false;
          for (const kind of profile.extraForbiddenKindOf) {
            if (target.kindOf.has(kind)) { hasForbidden = true; break; }
          }
          if (hasForbidden) continue;
        }

        const dx = target.x - detector.x;
        const dz = target.z - detector.z;
        if (dx * dx + dz * dz <= detRangeSq) {
          target.objectStatusFlags.add('DETECTED');
          target.detectedUntilFrame = this.frameCounter + detectionDuration;
        }
      }
    }
  }

  /**
   * Source parity: PoisonedBehavior — tick poison DoT on all poisoned entities.
   * Each poison tick applies UNRESISTABLE damage so it can't be re-poisoned recursively.
   */
  /**
   * Source parity: SubdualDamageHelper::update (SubdualDamageHelper.cpp:56-75).
   * Heals subdual damage over time. When no subdual damage remains, the helper sleeps.
   */
  private updateSubdualDamageHelpers(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.currentSubdualDamage <= 0 || entity.subdualDamageCap <= 0) continue;
      if (entity.subdualDamageHealRate <= 0 || entity.subdualDamageHealAmount <= 0) continue;

      // Source parity: SubdualDamageHelper::update — decrement countdown each frame.
      entity.subdualHealingCountdown--;
      if (entity.subdualHealingCountdown > 0) continue;

      // Reset countdown for next heal tick.
      entity.subdualHealingCountdown = entity.subdualDamageHealRate;

      // Source parity: heal subdual damage by SubdualDamageHealAmount via SUBDUAL_UNRESISTABLE.
      // C++ calls attemptDamage with negative amount, but we can directly adjust since the
      // negative path would just subtract from currentSubdualDamage anyway.
      const wasSubdued = entity.currentSubdualDamage >= entity.maxHealth;
      entity.currentSubdualDamage = Math.max(0, entity.currentSubdualDamage - entity.subdualDamageHealAmount);
      const nowSubdued = entity.currentSubdualDamage >= entity.maxHealth;

      // Source parity: onSubdualChange — clear DISABLED_SUBDUED when un-subdued.
      if (wasSubdued && !nowSubdued) {
        entity.objectStatusFlags.delete('DISABLED_SUBDUED');
      }
    }
  }

  private updatePoisonedEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.poisonDamageAmount <= 0) continue;

      // Check if poison has expired
      if (this.frameCounter >= entity.poisonExpireFrame) {
        entity.poisonDamageAmount = 0;
        entity.objectStatusFlags.delete('POISONED');
        continue;
      }

      // Apply poison damage tick
      if (this.frameCounter >= entity.poisonNextDamageFrame) {
        this.applyWeaponDamageAmount(null, entity, entity.poisonDamageAmount, 'UNRESISTABLE');
        const interval = entity.poisonedBehaviorProfile?.poisonDamageIntervalFrames ?? DEFAULT_POISON_DAMAGE_INTERVAL_FRAMES;
        entity.poisonNextDamageFrame = this.frameCounter + interval;
      }
    }
  }

  /**
   * Source parity: FlammableUpdate::update() — three independent timers for AFLAME entities.
   * 1. Periodic fire damage (aflameDamageDelay)
   * 2. BURNED status set (burnedDelay) — independent of flame end
   * 3. Flame extinguishment (aflameDuration) — transitions to NORMAL or BURNED
   */
  private updateFlammableEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.flameStatus !== 'AFLAME') continue;

      // Source parity: Timer 1 — periodic fire damage tick.
      const prof = entity.flammableProfile;
      if (prof && prof.aflameDamageDelayFrames > 0 && entity.flameDamageNextFrame > 0
          && this.frameCounter >= entity.flameDamageNextFrame) {
        entity.flameDamageNextFrame = this.frameCounter + prof.aflameDamageDelayFrames;
        this.applyWeaponDamageAmount(null, entity, prof.aflameDamageAmount, 'FLAME');
      }

      // Source parity: Timer 2 — BURNED status set (independent of flame end).
      if (entity.flameBurnedEndFrame > 0 && this.frameCounter >= entity.flameBurnedEndFrame) {
        entity.objectStatusFlags.add('BURNED');
        entity.flameBurnedEndFrame = 0; // Only set once.
      }

      // Source parity: Timer 3 — flame extinguishment.
      if (entity.flameEndFrame > 0 && this.frameCounter >= entity.flameEndFrame) {
        if (entity.objectStatusFlags.has('BURNED')) {
          // Already burned — permanent, can never catch fire again.
          entity.flameStatus = 'BURNED';
        } else {
          // Not yet burned — return to normal (can burn again).
          entity.flameStatus = 'NORMAL';
        }
        entity.objectStatusFlags.delete('AFLAME');
        entity.flameEndFrame = 0;
        entity.flameDamageNextFrame = 0;
      }
    }
  }

  /**
   * Source parity: FireSpreadUpdate::update() — entities on fire try to ignite nearby
   * flammable objects at random intervals. C++ uses PartitionFilterFlammable to find
   * the closest flammable target that wouldIgnite(), then calls tryToIgnite().
   */
  private updateFireSpread(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const prof = entity.fireSpreadProfile;
      if (!prof) continue;

      // Source parity: sleeps forever until entity is AFLAME.
      if (entity.flameStatus !== 'AFLAME') {
        entity.fireSpreadNextFrame = 0;
        continue;
      }

      // Activate spread timer when first set aflame.
      if (entity.fireSpreadNextFrame === 0) {
        entity.fireSpreadNextFrame = this.frameCounter + this.calcFireSpreadDelay(prof);
        continue;
      }

      if (this.frameCounter < entity.fireSpreadNextFrame) continue;

      // Schedule next attempt.
      entity.fireSpreadNextFrame = this.frameCounter + this.calcFireSpreadDelay(prof);

      if (prof.spreadTryRange <= 0) continue;

      // Source parity: find closest flammable target within range.
      const rangeSqr = prof.spreadTryRange * prof.spreadTryRange;
      let closestTarget: MapEntity | null = null;
      let closestDistSqr = Infinity;

      for (const candidate of this.spawnedEntities.values()) {
        if (candidate.destroyed || candidate.id === entity.id) continue;
        if (!candidate.flammableProfile) continue;
        // Source parity: PartitionFilterFlammable::wouldIgnite — only NORMAL status can ignite.
        if (candidate.flameStatus !== 'NORMAL') continue;

        const dx = candidate.x - entity.x;
        // Source parity: FireSpreadUpdate.cpp:147 uses FROM_CENTER_3D for distance.
        const dy = candidate.y - entity.y;
        const dz = candidate.z - entity.z;
        const distSqr = dx * dx + dy * dy + dz * dz;
        if (distSqr < rangeSqr && distSqr < closestDistSqr) {
          closestDistSqr = distSqr;
          closestTarget = candidate;
        }
      }

      // Source parity: tryToIgnite — set target aflame instantly.
      if (closestTarget) {
        this.igniteEntity(closestTarget);
      }
    }
  }

  /**
   * Source parity: calcNextSpreadDelay — random delay between min/max spread delay.
   */
  private calcFireSpreadDelay(prof: FireSpreadProfile): number {
    if (prof.minSpreadDelayFrames >= prof.maxSpreadDelayFrames) {
      return Math.max(1, prof.minSpreadDelayFrames);
    }
    return Math.max(1, this.gameRandom.nextRange(prof.minSpreadDelayFrames, prof.maxSpreadDelayFrames));
  }

  /**
   * Source parity: FlammableUpdate::tryToIgnite — force-ignite a flammable entity.
   * Sets entity aflame immediately (bypasses damage accumulation threshold).
   */
  private igniteEntity(entity: MapEntity): void {
    const prof = entity.flammableProfile;
    if (!prof) return;
    if (entity.flameStatus !== 'NORMAL') return;

    entity.flameStatus = 'AFLAME';
    entity.objectStatusFlags.add('AFLAME');
    entity.flameEndFrame = this.frameCounter + prof.aflameDurationFrames;
    entity.flameBurnedEndFrame = prof.burnedDelayFrames > 0
      ? this.frameCounter + prof.burnedDelayFrames
      : 0;
    entity.flameDamageNextFrame = prof.aflameDamageDelayFrames > 0
      ? this.frameCounter + prof.aflameDamageDelayFrames
      : 0;
  }

  /**
   * Source parity: FlammableUpdate.onDamage — accumulate fire damage and try to ignite.
   */
  private applyFireDamageToEntity(entity: MapEntity, actualDamage: number): void {
    const prof = entity.flammableProfile;
    if (!prof) return;
    if (entity.flameStatus !== 'NORMAL') return; // Can't reignite burned or already aflame

    // Reset accumulation if no fire damage in a while
    if (this.frameCounter - entity.flameLastDamageReceivedFrame > prof.flameDamageExpirationDelayFrames) {
      entity.flameDamageAccumulated = 0;
    }
    entity.flameLastDamageReceivedFrame = this.frameCounter;
    entity.flameDamageAccumulated += actualDamage;

    // Check ignition threshold.
    // C++ parity: do NOT reset flameDamageAccumulated on ignition. The accumulated
    // value stays, so if the entity returns to NORMAL and receives fire damage
    // before the expiration delay, it re-ignites instantly (matching C++ where
    // m_flameDamageLimit stays depleted after tryToIgnite).
    if (entity.flameDamageAccumulated >= prof.flameDamageLimit) {
      this.igniteEntity(entity);
    }
  }

  /**
   * Source parity: PoisonedBehavior.onDamage — start or refresh poison DoT.
   * C++ file: PoisonedBehavior.cpp lines 157-183 (startPoisonedEffects).
   * Only entities with a PoisonedBehavior module can be poisoned.
   */
  private applyPoisonToEntity(entity: MapEntity, actualDamage: number): void {
    if (actualDamage <= 0) return;
    // C++ parity: only entities with the PoisonedBehavior module react to poison.
    if (!entity.poisonedBehaviorProfile) return;
    const prof = entity.poisonedBehaviorProfile;
    entity.poisonDamageAmount = actualDamage;
    entity.poisonExpireFrame = this.frameCounter + prof.poisonDurationFrames;
    // C++ parity: re-poisoning uses min() of existing timer and new interval
    // to prevent "early" damage ticks. (PoisonedBehavior.cpp line 169-173)
    const newDamageFrame = this.frameCounter + prof.poisonDamageIntervalFrames;
    if (entity.poisonNextDamageFrame > this.frameCounter) {
      entity.poisonNextDamageFrame = Math.min(entity.poisonNextDamageFrame, newDamageFrame);
    } else {
      entity.poisonNextDamageFrame = newDamageFrame;
    }
    entity.objectStatusFlags.add('POISONED');
  }

  /**
   * Source parity: PoisonedBehavior::onHealing / stopPoisonedEffects.
   * C++ file: PoisonedBehavior.cpp lines 99-104, 186-195.
   * Any healing immediately clears all poison state.
   */
  private clearPoisonFromEntity(entity: MapEntity): void {
    if (entity.poisonDamageAmount <= 0) return;
    entity.poisonDamageAmount = 0;
    entity.poisonNextDamageFrame = 0;
    entity.poisonExpireFrame = 0;
    entity.objectStatusFlags.delete('POISONED');
  }

  /**
   * Source parity: AutoHealBehavior, BaseRegenerateUpdate, PropagandaTowerBehavior.
   * Runs all healing systems in a single pass.
   */
  private updateHealing(): void {
    const LOGICFRAMES_PER_SECOND = 30;
    const BASE_REGEN_INTERVAL = 3; // BaseRegenerateUpdate heals every 3 frames

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;

      // C++ parity: full-health check only skips self-heal and base-regen.
      // Radius and whole-player AutoHeal must still run to heal OTHER entities.
      const atFullHealth = entity.health >= entity.maxHealth && entity.health > 0;
      const hasRadiusOrPlayerHeal = entity.autoHealProfile
        && (entity.autoHealProfile.radius > 0 || entity.autoHealProfile.affectsWholePlayer);
      if (atFullHealth && !entity.propagandaTowerProfile && !hasRadiusOrPlayerHeal) continue;

      const isDisabled = entity.objectStatusFlags.has('DISABLED_EMP')
        || entity.objectStatusFlags.has('DISABLED_HACKED')
        || entity.objectStatusFlags.has('DISABLED_SUBDUED');

      // ── AutoHealBehavior ──
      if (entity.autoHealProfile && !isDisabled) {
        const prof = entity.autoHealProfile;
        if (prof.initiallyActive || entity.completedUpgrades.size > 0) {
          // Check damage delay.
          if (this.frameCounter >= entity.autoHealDamageDelayUntilFrame) {
            if (this.frameCounter >= entity.autoHealNextFrame) {
              if (prof.radius > 0) {
                // Radius heal mode — heal nearby allies.
                const radiusSq = prof.radius * prof.radius;
                for (const target of this.spawnedEntities.values()) {
                  if (target.destroyed || target === entity) continue;
                  if (target.health >= target.maxHealth) continue;
                  if (this.getTeamRelationship(entity, target) === RELATIONSHIP_ENEMIES) continue;
                  const dx = target.x - entity.x;
                  const dz = target.z - entity.z;
                  if (dx * dx + dz * dz <= radiusSq) {
                    this.attemptHealingFromSoleBenefactor(target, prof.healingAmount, entity.id, prof.healingDelayFrames);
                  }
                }
              } else if (prof.affectsWholePlayer) {
                // Whole-player mode — heal all entities on same side.
                const side = this.normalizeSide(entity.side);
                for (const target of this.spawnedEntities.values()) {
                  if (target.destroyed || target.health >= target.maxHealth) continue;
                  if (this.normalizeSide(target.side) !== side) continue;
                  const prevHealth = target.health;
                  target.health = Math.min(target.maxHealth, target.health + prof.healingAmount);
                  if (target.health > prevHealth) {
                    this.clearPoisonFromEntity(target);
                    if (target.minefieldProfile) {
                      this.mineOnDamage(target, entity.id, 'HEALING');
                    }
                  }
                }
              } else if (entity.health < entity.maxHealth) {
                // Self-heal mode — only when entity is damaged.
                const prevHealth = entity.health;
                entity.health = Math.min(entity.maxHealth, entity.health + prof.healingAmount);
                if (entity.health > prevHealth) {
                  this.clearPoisonFromEntity(entity);
                  if (entity.minefieldProfile) {
                    this.mineOnDamage(entity, entity.id, 'HEALING');
                  }
                }
              }
              entity.autoHealNextFrame = this.frameCounter + prof.healingDelayFrames;
            }
          }
        }
      }

      // ── BaseRegenerateUpdate (structure regen) ──
      if (entity.kindOf.has('STRUCTURE') && !isDisabled && entity.health < entity.maxHealth
          && !entity.objectStatusFlags.has('UNDER_CONSTRUCTION')
          && !entity.objectStatusFlags.has('SOLD')
          && BASE_REGEN_HEALTH_PERCENT_PER_SECOND > 0) {
        if (this.frameCounter >= entity.baseRegenDelayUntilFrame) {
          if (this.frameCounter % BASE_REGEN_INTERVAL === 0) {
            const prevHealth = entity.health;
            const amount = BASE_REGEN_INTERVAL * entity.maxHealth * BASE_REGEN_HEALTH_PERCENT_PER_SECOND / LOGICFRAMES_PER_SECOND;
            entity.health = Math.min(entity.maxHealth, entity.health + amount);
            if (entity.health > prevHealth) {
              this.clearPoisonFromEntity(entity);
            }
          }
        }
      }

      // ── PropagandaTowerBehavior (radius heal aura) ──
      if (entity.propagandaTowerProfile && !isDisabled
          && !entity.objectStatusFlags.has('UNDER_CONSTRUCTION')
          && !entity.objectStatusFlags.has('SOLD')) {
        const prof = entity.propagandaTowerProfile;
        const isUpgraded = prof.upgradeRequired !== null
          && entity.completedUpgrades.has(prof.upgradeRequired.toUpperCase());
        const healPct = isUpgraded ? prof.upgradedHealPercentPerSecond : prof.healPercentPerSecond;

        // Rescan for units in range periodically.
        if (this.frameCounter >= entity.propagandaTowerNextScanFrame) {
          entity.propagandaTowerTrackedIds = [];
          const radiusSq = prof.radius * prof.radius;
          for (const target of this.spawnedEntities.values()) {
            if (target.destroyed || target === entity) continue;
            if (target.kindOf.has('STRUCTURE')) continue; // Only troops
            if (this.getTeamRelationship(entity, target) === RELATIONSHIP_ENEMIES) continue;
            const dx = target.x - entity.x;
            const dz = target.z - entity.z;
            if (dx * dx + dz * dz <= radiusSq) {
              entity.propagandaTowerTrackedIds.push(target.id);
            }
          }
          entity.propagandaTowerNextScanFrame = this.frameCounter + prof.scanDelayFrames;
        }

        // Heal tracked units each frame.
        for (const targetId of entity.propagandaTowerTrackedIds) {
          const target = this.spawnedEntities.get(targetId);
          if (!target || target.destroyed || target.health >= target.maxHealth) continue;
          const amount = healPct / LOGICFRAMES_PER_SECOND * target.maxHealth;
          this.attemptHealingFromSoleBenefactor(target, amount, entity.id, prof.scanDelayFrames);
        }
      }
    }
  }

  /**
   * Source parity: Object::attemptHealingFromSoleBenefactor — anti-stack healing.
   * Only one benefactor can heal a unit at a time.
   */
  private attemptHealingFromSoleBenefactor(
    target: MapEntity, amount: number, sourceId: number, duration: number,
  ): boolean {
    const now = this.frameCounter;
    if (now >= target.soleHealingBenefactorExpirationFrame || target.soleHealingBenefactorId === sourceId) {
      target.soleHealingBenefactorId = sourceId;
      target.soleHealingBenefactorExpirationFrame = now + duration;
      const prevHealth = target.health;
      target.health = Math.min(target.maxHealth, target.health + amount);
      if (target.health > prevHealth) {
        // Source parity: PoisonedBehavior::onHealing clears poison on any healing.
        this.clearPoisonFromEntity(target);
        // Source parity: healing triggers onDamage(HEALING) which recalculates virtual mines.
        if (target.minefieldProfile) {
          this.mineOnDamage(target, sourceId, 'HEALING');
        }
      }
      return true;
    }
    return false;
  }

  // ── Source parity: MinefieldBehavior — mine collision system ──────────────

  /**
   * Initialize mine runtime state from profile. Called once after entity creation.
   * Source parity: MinefieldBehavior constructor (MinefieldBehavior.cpp line 107).
   */
  private initializeMinefieldState(entity: MapEntity): void {
    const prof = entity.minefieldProfile;
    if (!prof) return;
    entity.mineVirtualMinesRemaining = prof.numVirtualMines;
    entity.mineRegenerates = prof.regenerates;
    entity.mineImmunes = [];
    entity.mineDetonators = [];
    entity.mineScootFramesLeft = 0;
    entity.mineDraining = false;
    entity.mineNextDeathCheckFrame = 0;
    entity.mineIgnoreDamage = false;
    // Source parity: mines are not auto-acquirable (OBJECT_STATUS_NO_ATTACK_FROM_AI).
    entity.objectStatusFlags.add('NO_ATTACK_FROM_AI');
  }

  /**
   * Source parity: PartitionManager collision detection for mines.
   * Iterates mine entities and checks for geometry overlap with other entities.
   * Called once per frame from the main update loop.
   */
  private updateMineCollisions(): void {
    for (const mine of this.spawnedEntities.values()) {
      if (!mine.minefieldProfile || mine.destroyed) continue;
      if (mine.mineVirtualMinesRemaining <= 0) continue;
      if (mine.mineScootFramesLeft > 0) continue;

      const mineGeom = mine.obstacleGeometry;
      if (!mineGeom) continue;

      // Check all entities for geometry overlap with this mine.
      for (const other of this.spawnedEntities.values()) {
        if (other.id === mine.id || other.destroyed) continue;
        if (other.kindOf.has('NO_COLLIDE')) continue;
        if (other.noCollisions) continue;
        // Mines are immobile — only check mobile entities colliding into us.
        if (!other.moving && other.isImmobile) continue;

        // Quick 2D bounding circle rejection.
        const otherRadius = other.obstacleGeometry ? Math.max(other.obstacleGeometry.majorRadius, other.obstacleGeometry.minorRadius) : 0;
        const mineRadius = Math.max(mineGeom.majorRadius, mineGeom.minorRadius);
        const dx = other.x - mine.x;
        const dz = other.z - mine.z;
        const combinedRadius = mineRadius + otherRadius;
        if (dx * dx + dz * dz > combinedRadius * combinedRadius) continue;

        // Geometry overlap confirmed — dispatch collision.
        this.handleMineCollision(mine, other);

        // Mine may have been destroyed by detonation.
        if (mine.destroyed || mine.mineVirtualMinesRemaining <= 0) break;
      }
    }
  }

  /**
   * Source parity: MinefieldBehavior::onCollide (MinefieldBehavior.cpp line 345).
   */
  private handleMineCollision(mine: MapEntity, other: MapEntity): void {
    const prof = mine.minefieldProfile!;
    if (mine.mineVirtualMinesRemaining <= 0) return;

    // Check immunity list (must always update collideTime first).
    for (const immune of mine.mineImmunes) {
      if (immune.entityId === other.id) {
        immune.collideFrame = this.frameCounter;
        return;
      }
    }

    // Workers (infantry+dozer) don't detonate by default.
    if (!prof.workersDetonate) {
      if (other.kindOf.has('INFANTRY') && other.kindOf.has('DOZER')) {
        return;
      }
    }

    // Relationship check: does this entity detonate us?
    const relationship = this.getEntityRelationship(mine.id, other.id);
    let requiredBit = 0;
    if (relationship === 'allies') requiredBit = MINE_DETONATED_BY_ALLIES;
    else if (relationship === 'enemies') requiredBit = MINE_DETONATED_BY_ENEMIES;
    else requiredBit = MINE_DETONATED_BY_NEUTRAL;
    if ((prof.detonatedByMask & requiredBit) === 0) return;

    // Mine-clearing immunity: units attacking with WEAPON_ANTI_MINE get immunity.
    if (this.isEntityClearingMines(other)) {
      // Grant immunity in a free slot.
      let granted = false;
      for (const immune of mine.mineImmunes) {
        if (immune.entityId === other.id) {
          immune.collideFrame = this.frameCounter;
          granted = true;
          break;
        }
      }
      if (!granted && mine.mineImmunes.length < MINE_MAX_IMMUNITY) {
        mine.mineImmunes.push({ entityId: other.id, collideFrame: this.frameCounter });
      } else if (!granted) {
        // Replace oldest slot.
        for (const immune of mine.mineImmunes) {
          if (immune.entityId === 0) {
            immune.entityId = other.id;
            immune.collideFrame = this.frameCounter;
            granted = true;
            break;
          }
        }
      }
      return;
    }

    // Repeat detonation threshold: same object must move before re-triggering.
    const threshSq = prof.repeatDetonateMoveThresh * prof.repeatDetonateMoveThresh;
    let found = false;
    for (const det of mine.mineDetonators) {
      if (det.entityId === other.id) {
        found = true;
        const distSq = (other.x - det.x) * (other.x - det.x) + (other.z - det.z) * (other.z - det.z);
        if (distSq <= threshSq) {
          return; // Too close to last detonation point.
        }
        // Far enough — update position and detonate.
        det.x = other.x;
        det.z = other.z;
        break;
      }
    }
    if (!found) {
      mine.mineDetonators.push({ entityId: other.id, x: other.x, z: other.z });
    }

    // Clip detonation point to mine footprint (simplified: use mine center for circular).
    this.detonateMineOnce(mine, other.x, other.z);
  }

  /**
   * Source parity: MinefieldBehavior::detonateOnce (MinefieldBehavior.cpp line 275).
   * Fires the detonation weapon, decrements virtual mines, destroys if exhausted.
   */
  private detonateMineOnce(mine: MapEntity, detX: number, detZ: number): void {
    const prof = mine.minefieldProfile!;

    // Fire detonation weapon at the detonation point.
    if (prof.detonationWeaponName) {
      const weaponDef = this.iniDataRegistry?.getWeapon(prof.detonationWeaponName);
      if (weaponDef) {
        this.fireTemporaryWeaponAtPosition(mine, weaponDef, detX, detZ);
      }
    }

    if (mine.mineVirtualMinesRemaining > 0) {
      mine.mineVirtualMinesRemaining--;
    }

    if (!mine.mineRegenerates && mine.mineVirtualMinesRemaining <= 0) {
      // Mine exhausted — destroy.
      this.markEntityDestroyed(mine.id, mine.id);
    } else {
      // Adjust health proportional to remaining mines.
      const percent = mine.mineVirtualMinesRemaining / prof.numVirtualMines;
      const desired = Math.max(0.1, percent * mine.maxHealth);
      const healthToRemove = mine.health - desired;
      if (healthToRemove > 0) {
        mine.mineIgnoreDamage = true;
        this.applyWeaponDamageAmount(mine.id, mine, healthToRemove, 'UNRESISTABLE');
        mine.mineIgnoreDamage = false;
      }
    }

    // Source parity: MASKED status when all charges spent (for regenerating mines).
    if (mine.mineVirtualMinesRemaining <= 0) {
      mine.objectStatusFlags.add('MASKED');
    } else {
      mine.objectStatusFlags.delete('MASKED');
    }
  }

  /**
   * Source parity: MinefieldBehavior::update immunity expiry and creator death drain.
   * Called per mine per frame from updateMineCollisions.
   */
  private updateMineBehavior(): void {
    for (const mine of this.spawnedEntities.values()) {
      if (!mine.minefieldProfile || mine.destroyed) continue;
      const prof = mine.minefieldProfile;

      // Expire immunity entries (C++: 2 frames after last collision).
      mine.mineImmunes = mine.mineImmunes.filter(immune => {
        const entity = this.spawnedEntities.get(immune.entityId);
        if (!entity || entity.destroyed) return false;
        return this.frameCounter <= immune.collideFrame + 2;
      });

      // Source parity: MinefieldBehavior creator death check.
      // When the creator dies and stopsRegenAfterCreatorDies is set, stop regen and start draining.
      if (mine.mineRegenerates && prof.stopsRegenAfterCreatorDies && this.frameCounter >= mine.mineNextDeathCheckFrame) {
        mine.mineNextDeathCheckFrame = this.frameCounter + LOGIC_FRAME_RATE; // Check every second.
        if (mine.mineCreatorId > 0) {
          const creator = this.spawnedEntities.get(mine.mineCreatorId);
          if (!creator || creator.destroyed) {
            mine.mineRegenerates = false;
            mine.mineDraining = true;
            // Source parity: stopHealing() on AutoHealBehavior when creator dies.
            if (mine.autoHealProfile) {
              mine.autoHealDamageDelayUntilFrame = Number.MAX_SAFE_INTEGER;
            }
          }
        }
      }

      if (mine.mineDraining && prof.degenPercentPerSecondAfterCreatorDies > 0) {
        const drainAmount = (mine.maxHealth * prof.degenPercentPerSecondAfterCreatorDies) / LOGIC_FRAME_RATE;
        this.applyWeaponDamageAmount(mine.id, mine, drainAmount, 'UNRESISTABLE');
      }
    }
  }

  /**
   * Source parity: Check if an entity is actively clearing mines.
   * AIUpdate.cpp line 3144: attacking with a WEAPON_ANTI_MINE weapon.
   */
  private isEntityClearingMines(entity: MapEntity): boolean {
    if (!this.entityHasObjectStatus(entity, 'IS_ATTACKING')) return false;
    const weapon = entity.attackWeapon;
    if (!weapon) return false;
    return (weapon.antiMask & WEAPON_ANTI_MINE) !== 0;
  }

  // ──── Salvage Crate Collision System ─────────────────────────────────────

  /**
   * Source parity: CrateCollide::onCollide + SalvageCrateCollide.
   * Checks all crate entities against moving KINDOF_SALVAGER entities for
   * geometry overlap. On collision, executes the salvage behavior chain:
   * armor upgrade → weapon upgrade → veterancy → money fallback.
   */
  private updateCrateCollisions(): void {
    for (const crate of this.spawnedEntities.values()) {
      if (crate.destroyed) continue;
      const isSalvage = !!crate.salvageCrateProfile;
      const isGeneral = !!crate.crateCollideProfile;
      if (!isSalvage && !isGeneral) continue;

      const crateGeom = crate.obstacleGeometry;
      const crateRadius = crateGeom
        ? Math.max(crateGeom.majorRadius, crateGeom.minorRadius)
        : 1.0;

      for (const other of this.spawnedEntities.values()) {
        if (other.id === crate.id || other.destroyed) continue;

        // Source parity: SalvageCrateCollide requires SALVAGER KindOf.
        if (isSalvage && !other.kindOf.has('SALVAGER')) continue;

        // Source parity: CrateCollide::isValidToExecute — general crate eligibility.
        if (isGeneral && !this.isCrateCollideEligible(crate, other)) continue;

        const otherRadius = other.obstacleGeometry
          ? Math.max(other.obstacleGeometry.majorRadius, other.obstacleGeometry.minorRadius)
          : 1.0;
        const dx = other.x - crate.x;
        const dz = other.z - crate.z;
        const combinedRadius = crateRadius + otherRadius;
        if (dx * dx + dz * dz > combinedRadius * combinedRadius) continue;

        // Collision detected — execute appropriate behavior.
        if (isSalvage) {
          this.executeSalvageCrateBehavior(crate, other);
        } else {
          this.executeGeneralCrateBehavior(crate, other);
        }
        break; // Crate consumed.
      }
    }
  }

  /**
   * Source parity: CrateCollide::isValidToExecute — validate collector eligibility.
   * Checks KindOf requirements, death ownership, building pickup, human-only, etc.
   */
  private isCrateCollideEligible(crate: MapEntity, collector: MapEntity): boolean {
    const prof = crate.crateCollideProfile!;
    // Must not be effectively dead.
    if (collector.health <= 0 || collector.destroyed) return false;
    // Source parity: neutral units cannot collect crates.
    if (!collector.side) return false;
    // Source parity: must have KindOf requirements.
    if (prof.requiredKindOf.length > 0) {
      if (!prof.requiredKindOf.every(k => collector.kindOf.has(k))) return false;
    }
    // Source parity: must NOT have forbidden KindOf.
    if (prof.forbiddenKindOf.length > 0) {
      if (prof.forbiddenKindOf.some(k => collector.kindOf.has(k))) return false;
    }
    // Source parity: ForbidOwnerPlayer — dead unit's team cannot collect.
    if (prof.forbidOwnerPlayer && crate.side) {
      if (this.normalizeSide(collector.side) === this.normalizeSide(crate.side)) return false;
    }
    // Source parity: BuildingPickup — only buildings can bypass AI/movement check.
    if (!prof.buildingPickup && collector.kindOf.has('STRUCTURE')) return false;
    // Source parity: non-buildings must be able to move (have AI).
    if (!collector.kindOf.has('STRUCTURE') && !collector.canMove) return false;
    return true;
  }

  /**
   * Source parity: CrateCollide::onCollide → executeCrateBehavior dispatch.
   * Routes to the appropriate crate behavior handler based on crateType.
   */
  private executeGeneralCrateBehavior(crate: MapEntity, collector: MapEntity): void {
    const prof = crate.crateCollideProfile!;
    let success = false;
    switch (prof.crateType) {
      case 'HEAL':
        success = this.executeCrateHeal(collector);
        break;
      case 'MONEY':
        success = this.executeCrateMoney(collector, prof.moneyProvided);
        break;
      case 'VETERANCY':
        success = this.executeCrateVeterancy(crate, collector, prof);
        break;
      case 'SHROUD':
        success = this.executeCrateShroud(collector);
        break;
      case 'UNIT':
        success = this.executeCrateUnit(crate, collector, prof);
        break;
    }
    if (success) {
      this.markEntityDestroyed(crate.id, collector.id);
    }
  }

  /**
   * Source parity: HealCrateCollide::executeCrateBehavior — heals all units of collector's side.
   */
  private executeCrateHeal(collector: MapEntity): boolean {
    if (!collector.side) return false;
    const collectorSide = this.normalizeSide(collector.side);
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.health >= entity.maxHealth) continue;
      if (!entity.side) continue;
      if (this.normalizeSide(entity.side) !== collectorSide) continue;
      entity.health = entity.maxHealth;
    }
    return true;
  }

  /**
   * Source parity: MoneyCrateCollide::executeCrateBehavior — deposits credits.
   */
  private executeCrateMoney(collector: MapEntity, amount: number): boolean {
    if (!collector.side || amount <= 0) return false;
    depositSideCreditsImpl(this.sideCredits, this.normalizeSide(collector.side), amount);
    return true;
  }

  /**
   * Source parity: VeterancyCrateCollide::executeCrateBehavior — grants veterancy levels.
   */
  private executeCrateVeterancy(crate: MapEntity, collector: MapEntity, prof: CrateCollideProfile): boolean {
    if (!collector.experienceProfile) return false;
    if (collector.experienceState.currentLevel >= LEVEL_HEROIC) return false;

    if (prof.isPilot) {
      // Source parity: VeterancyCrateCollide::isValidToExecute / executeCrateBehavior.
      // Pilot only "enters" same-side, non-airborne targets and only while actively targeting it.
      const crateSide = crate.side ? this.normalizeSide(crate.side) : null;
      const collectorSide = collector.side ? this.normalizeSide(collector.side) : null;
      if (!crateSide || !collectorSide || crateSide !== collectorSide) return false;

      const terrainY = this.resolveGroundHeight(collector.x, collector.z);
      if ((collector.y - collector.baseHeight - terrainY) > SIGNIFICANTLY_ABOVE_TERRAIN_THRESHOLD) {
        return false;
      }

      if (crate.pilotFindVehicleTargetId !== null && crate.pilotFindVehicleTargetId !== collector.id) {
        return false;
      }
    }

    const levelsToGain = prof.addsOwnerVeterancy
      ? Math.max(1, crate.experienceState.currentLevel)
      : 1;

    if (prof.veterancyRange <= 0) {
      // Single unit effect.
      this.grantVeterancyLevels(collector, levelsToGain);
    } else {
      // Area effect — upgrade all nearby same-side units.
      const collectorSide = this.normalizeSide(collector.side ?? '');
      const rangeSq = prof.veterancyRange * prof.veterancyRange;
      for (const entity of this.spawnedEntities.values()) {
        if (entity.destroyed || !entity.experienceProfile) continue;
        if (!entity.side || this.normalizeSide(entity.side) !== collectorSide) continue;
        if (entity.experienceState.currentLevel >= LEVEL_HEROIC) continue;
        const dx = entity.x - collector.x;
        const dz = entity.z - collector.z;
        if (dx * dx + dz * dz <= rangeSq) {
          this.grantVeterancyLevels(entity, levelsToGain);
        }
      }
    }
    return true;
  }

  /**
   * Source parity: ShroudCrateCollide::executeCrateBehavior — reveals entire map.
   */
  private executeCrateShroud(collector: MapEntity): boolean {
    if (!collector.side) return false;
    // Reveal entire map for collector's side by marking all fog-of-war as revealed.
    const side = this.normalizeSide(collector.side);
    this.revealEntireMapForSide(side);
    return true;
  }

  /**
   * Source parity: UnitCrateCollide::executeCrateBehavior — spawns N units nearby.
   */
  private executeCrateUnit(crate: MapEntity, collector: MapEntity, prof: CrateCollideProfile): boolean {
    if (!prof.unitType) return false;
    const count = Math.max(1, prof.unitCount);
    for (let i = 0; i < count; i++) {
      // Find position around crate (0-20 unit radius).
      const angle = this.gameRandom.nextFloat() * Math.PI * 2;
      const radius = this.gameRandom.nextFloat() * 20;
      const spawnX = crate.x + Math.cos(angle) * radius;
      const spawnZ = crate.z + Math.sin(angle) * radius;
      const rotation = this.gameRandom.nextFloat() * Math.PI * 2 - Math.PI;
      this.spawnEntityFromTemplate(prof.unitType, spawnX, spawnZ, rotation, collector.side);
    }
    return true;
  }

  /**
   * Helper: grant N veterancy levels to an entity.
   */
  private grantVeterancyLevels(entity: MapEntity, levels: number): void {
    const profile = entity.experienceProfile;
    if (!profile) return;
    for (let i = 0; i < levels; i++) {
      const currentLevel = entity.experienceState.currentLevel;
      const targetLevel = Math.min(currentLevel + 1, LEVEL_HEROIC) as VeterancyLevel;
      if (targetLevel <= currentLevel) break;
      const xpNeeded = (profile.experienceRequired[targetLevel] ?? 0) - entity.experienceState.currentExperience;
      if (xpNeeded <= 0) break;
      const result = addExperiencePointsImpl(entity.experienceState, profile, xpNeeded, true);
      if (result.didLevelUp) {
        this.onEntityLevelUp(entity, result.oldLevel, result.newLevel);
      }
    }
  }

  /**
   * Source parity: ExperienceTracker::setMinVeterancyLevel — raise veterancy to at least
   * the given level (never lowers). Used by VeterancyGainCreate::onCreate.
   * C++ file: ExperienceTracker.cpp.
   */
  private setMinVeterancyLevel(entity: MapEntity, targetLevel: VeterancyLevel): void {
    const profile = entity.experienceProfile;
    if (!profile) return;
    if (entity.experienceState.currentLevel >= targetLevel) return;
    // Source parity: C++ ExperienceTracker::setMinVeterancyLevel directly sets level and XP
    // rather than going through addExperiencePoints. This handles edge cases where
    // experienceRequired thresholds are 0.
    const oldLevel = entity.experienceState.currentLevel;
    entity.experienceState.currentLevel = targetLevel;
    entity.experienceState.currentExperience = profile.experienceRequired[targetLevel] ?? 0;
    this.onEntityLevelUp(entity, oldLevel, targetLevel);
  }

  /**
   * Source parity: revealMapForPlayer — reveals entire map fog-of-war for a side.
   * Unlike spy vision which is temporary, the shroud crate permanently reveals the map.
   */
  private revealEntireMapForSide(side: string): void {
    const grid = this.fogOfWarGrid;
    if (!grid) return;
    const playerIdx = this.resolvePlayerIndexForSide(side);
    if (playerIdx < 0) return;
    // Source parity: PartitionManager::revealMapForPlayer — reveal with a massive radius.
    // Use terrain dimensions for a guaranteed full-map reveal.
    const hm = this.mapHeightmap;
    const mapW = hm ? hm.worldWidth : 2000;
    const mapH = hm ? hm.worldDepth : 2000;
    const centerX = mapW / 2;
    const centerZ = mapH / 2;
    const maxRadius = Math.hypot(mapW, mapH);
    grid.addLooker(playerIdx, centerX, centerZ, maxRadius);
    // Add a long-duration temporary reveal (~10 minutes) so it persists through gameplay.
    this.temporaryVisionReveals.push({
      playerIndex: playerIdx,
      worldX: centerX,
      worldZ: centerZ,
      radius: maxRadius,
      expiryFrame: this.frameCounter + 18000, // ~10 minutes at 30fps
    });
  }

  /**
   * Source parity: SalvageCrateCollide::executeCrateBehavior.
   * Priority chain: armor upgrade (no chance) → weapon upgrade → veterancy gain → money fallback.
   * C++ file: SalvageCrateCollide.cpp:75-119.
   */
  private executeSalvageCrateBehavior(crate: MapEntity, collector: MapEntity): void {
    const prof = crate.salvageCrateProfile!;

    // Source parity: armor set upgrade is first priority with no chance roll.
    if (this.isSalvageEligibleForArmorSet(collector)) {
      this.doSalvageArmorSet(collector);
    } else if (this.isSalvageEligibleForWeaponSet(collector) && this.testSalvageChance(prof.weaponChance)) {
      this.doSalvageWeaponSet(collector);
    } else if (this.isSalvageEligibleForLevel(collector) && this.testSalvageChance(prof.levelChance)) {
      this.doSalvageLevelGain(collector);
    } else {
      this.doSalvageMoney(collector, prof);
    }

    // Destroy the crate after collection.
    this.markEntityDestroyed(crate.id, collector.id);
  }

  /**
   * Source parity: SalvageCrateCollide::eligibleForArmorSet.
   * Must be KINDOF_ARMOR_SALVAGER and not already at CRATE_UPGRADE_TWO.
   * C++ file: SalvageCrateCollide.cpp:138-150.
   */
  private isSalvageEligibleForArmorSet(collector: MapEntity): boolean {
    if (!collector.kindOf.has('ARMOR_SALVAGER')) return false;
    if ((collector.armorSetFlagsMask & ARMOR_SET_FLAG_CRATE_UPGRADE_TWO) !== 0) return false;
    return true;
  }

  /**
   * Source parity: SalvageCrateCollide::eligibleForWeaponSet.
   * Must be KINDOF_WEAPON_SALVAGER and not already at CRATEUPGRADE_TWO.
   */
  private isSalvageEligibleForWeaponSet(collector: MapEntity): boolean {
    if (!collector.kindOf.has('WEAPON_SALVAGER')) return false;
    if ((collector.weaponSetFlagsMask & WEAPON_SET_FLAG_CRATEUPGRADE_TWO) !== 0) return false;
    return true;
  }

  /**
   * Source parity: SalvageCrateCollide::eligibleForLevel.
   * Must not be HEROIC and must have an experience profile (trainable).
   */
  private isSalvageEligibleForLevel(collector: MapEntity): boolean {
    if (collector.experienceState.currentLevel === LEVEL_HEROIC) return false;
    if (!collector.experienceProfile) return false;
    return true;
  }

  /**
   * Source parity: SalvageCrateCollide::testWeaponChance / testLevelChance.
   */
  private testSalvageChance(chance: number): boolean {
    if (chance >= 1.0) return true;
    return this.gameRandom.nextFloat() < chance;
  }

  /**
   * Source parity: SalvageCrateCollide::doArmorSet.
   * Upgrades: none → CRATE_UPGRADE_ONE, ONE → clear ONE + set TWO.
   * Also sets model conditions for visual armor upgrade appearance.
   * C++ file: SalvageCrateCollide.cpp:212-227.
   */
  private doSalvageArmorSet(collector: MapEntity): void {
    if ((collector.armorSetFlagsMask & ARMOR_SET_FLAG_CRATE_UPGRADE_ONE) !== 0) {
      collector.armorSetFlagsMask &= ~ARMOR_SET_FLAG_CRATE_UPGRADE_ONE;
      collector.armorSetFlagsMask |= ARMOR_SET_FLAG_CRATE_UPGRADE_TWO;
      collector.modelConditionFlags.delete('ARMORSET_CRATEUPGRADE_ONE');
      collector.modelConditionFlags.add('ARMORSET_CRATEUPGRADE_TWO');
    } else {
      collector.armorSetFlagsMask |= ARMOR_SET_FLAG_CRATE_UPGRADE_ONE;
      collector.modelConditionFlags.add('ARMORSET_CRATEUPGRADE_ONE');
    }
    this.refreshEntityCombatProfiles(collector);
  }

  /**
   * Source parity: SalvageCrateCollide::doWeaponSet.
   * Upgrades: none → CRATEUPGRADE_ONE, ONE → clear ONE + set TWO.
   */
  private doSalvageWeaponSet(collector: MapEntity): void {
    if ((collector.weaponSetFlagsMask & WEAPON_SET_FLAG_CRATEUPGRADE_ONE) !== 0) {
      collector.weaponSetFlagsMask &= ~WEAPON_SET_FLAG_CRATEUPGRADE_ONE;
      collector.weaponSetFlagsMask |= WEAPON_SET_FLAG_CRATEUPGRADE_TWO;
    } else {
      collector.weaponSetFlagsMask |= WEAPON_SET_FLAG_CRATEUPGRADE_ONE;
    }
    this.refreshEntityCombatProfiles(collector);
  }

  /**
   * Source parity: SalvageCrateCollide::doLevelGain → ExperienceTracker::gainExpForLevel(1).
   * Awards exactly enough XP to gain one veterancy level.
   */
  private doSalvageLevelGain(collector: MapEntity): void {
    const profile = collector.experienceProfile;
    if (!profile) return;

    const currentLevel = collector.experienceState.currentLevel;
    const targetLevel = Math.min(currentLevel + 1, LEVEL_HEROIC) as VeterancyLevel;
    if (targetLevel <= currentLevel) return;

    const xpNeeded = (profile.experienceRequired[targetLevel] ?? 0) - collector.experienceState.currentExperience;
    if (xpNeeded <= 0) return;

    const result = addExperiencePointsImpl(
      collector.experienceState,
      profile,
      xpNeeded,
      true, // C++: gainExpForLevel calls addExperiencePoints with canScaleForBonus=TRUE by default
    );

    if (result.didLevelUp) {
      this.onEntityLevelUp(collector, result.oldLevel, result.newLevel);
    }
  }

  /**
   * Source parity: SalvageCrateCollide::doMoney.
   * Deposits random money in [minMoney, maxMoney] to the collector's side.
   */
  private doSalvageMoney(collector: MapEntity, prof: SalvageCrateProfile): void {
    let money: number;
    if (prof.minMoney !== prof.maxMoney) {
      money = this.gameRandom.nextRange(prof.minMoney, prof.maxMoney);
    } else {
      money = prof.minMoney;
    }

    if (money > 0 && collector.side) {
      depositSideCreditsImpl(this.sideCredits, this.normalizeSide(collector.side), money);
    }
  }

  /**
   * Source parity: MinefieldBehavior::onDamage (MinefieldBehavior.cpp line 453).
   * Recalculates virtual mines from health ratio. When mines > expected, detonate
   * sympathetically. When mines < expected (healing), increase mine count.
   */
  private mineOnDamage(mine: MapEntity, sourceEntityId: number | null, damageType: string): void {
    const prof = mine.minefieldProfile!;
    if (prof.numVirtualMines <= 0) return;

    // Source parity: loop until virtual mines match health-proportional expected count.
    for (let iterations = 0; iterations < prof.numVirtualMines + 1; iterations++) {
      const ratio = mine.health / mine.maxHealth;
      const virtualMinesExpectedF = prof.numVirtualMines * ratio;
      // Source parity: healing rounds down, damage rounds up.
      const virtualMinesExpected = Math.min(
        prof.numVirtualMines,
        damageType === 'HEALING'
          ? Math.floor(virtualMinesExpectedF)
          : Math.ceil(virtualMinesExpectedF),
      );

      if (mine.mineVirtualMinesRemaining < virtualMinesExpected) {
        // Healing: increase virtual mine count.
        mine.mineVirtualMinesRemaining = virtualMinesExpected;
      } else if (mine.mineVirtualMinesRemaining > virtualMinesExpected) {
        if (mine.mineDraining
            && sourceEntityId !== null && sourceEntityId === mine.id
            && damageType === 'UNRESISTABLE') {
          // Source parity: self-drain just removes a mine without detonation.
          mine.mineVirtualMinesRemaining--;
        } else {
          // Sympathetic detonation at the mine's own position.
          this.detonateMineOnce(mine, mine.x, mine.z);
        }
      } else {
        break;
      }

      if (mine.destroyed) break;
    }

    // Source parity: MASKED/regen health floor after recalculation.
    if (mine.mineVirtualMinesRemaining <= 0) {
      if (mine.mineRegenerates && mine.health < 0.1) {
        mine.health = 0.1;
      }
      mine.objectStatusFlags.add('MASKED');
    } else {
      mine.objectStatusFlags.delete('MASKED');
    }
  }

  /**
   * Fire a temporary weapon at a world position (source parity: createAndFireTempWeapon).
   * Used by mine detonation, death weapons, FireWeaponUpdate, and OCL FireWeapon nuggets.
   *
   * Source parity: Weapon.cpp dealDamageInternal — primary damage to targets within
   * PrimaryDamageRadius, secondary damage to targets within SecondaryDamageRadius,
   * filtered by RadiusDamageAffects mask (self/allies/enemies/neutrals).
   */
  private fireTemporaryWeaponAtPosition(source: MapEntity, weaponDef: WeaponDef, targetX: number, targetZ: number): void {
    const primaryDamage = readNumericField(weaponDef.fields, ['PrimaryDamage']) ?? 0;
    const primaryDamageRadius = readNumericField(weaponDef.fields, ['PrimaryDamageRadius', 'AttackRange']) ?? 0;
    const secondaryDamage = readNumericField(weaponDef.fields, ['SecondaryDamage']) ?? 0;
    const secondaryDamageRadius = readNumericField(weaponDef.fields, ['SecondaryDamageRadius']) ?? 0;
    const damageType = readStringField(weaponDef.fields, ['DamageType'])?.toUpperCase() ?? 'EXPLOSION';
    const deathType = readStringField(weaponDef.fields, ['DeathType'])?.toUpperCase() || undefined;
    const affectsMask = this.resolveWeaponRadiusAffectsMask(weaponDef);

    const effectRadius = Math.max(primaryDamageRadius, secondaryDamageRadius);

    if (effectRadius > 0 && (primaryDamage > 0 || secondaryDamage > 0)) {
      const effectRadiusSq = effectRadius * effectRadius;
      const primaryRadiusSq = primaryDamageRadius * primaryDamageRadius;
      const sourceSide = this.normalizeSide(source.side);

      for (const target of this.spawnedEntities.values()) {
        if (target.destroyed) continue;

        // Source parity: RadiusDamageAffects mask filtering.
        if (target.id === source.id) {
          if ((affectsMask & WEAPON_KILLS_SELF) !== 0) {
            this.applyWeaponDamageAmount(source.id, target, HUGE_DAMAGE_AMOUNT, damageType, deathType);
            continue;
          }
          if ((affectsMask & WEAPON_AFFECTS_SELF) === 0) continue;
        } else {
          const targetSide = this.normalizeSide(target.side);
          const relationship = this.getTeamRelationshipBySides(sourceSide ?? '', targetSide ?? '');
          let requiredMask = WEAPON_AFFECTS_NEUTRALS;
          if (relationship === RELATIONSHIP_ALLIES) {
            requiredMask = WEAPON_AFFECTS_ALLIES;
          } else if (relationship === RELATIONSHIP_ENEMIES) {
            requiredMask = WEAPON_AFFECTS_ENEMIES;
          }
          if ((affectsMask & requiredMask) === 0) continue;
        }

        const tdx = target.x - targetX;
        const tdz = target.z - targetZ;
        const distSq = tdx * tdx + tdz * tdz;
        if (distSq > effectRadiusSq) continue;

        // Source parity: primary damage within PrimaryDamageRadius,
        // secondary damage within SecondaryDamageRadius (but outside primary).
        if (distSq <= primaryRadiusSq && primaryDamage > 0) {
          this.applyWeaponDamageAmount(source.id, target, primaryDamage, damageType, deathType);
        } else if (secondaryDamage > 0) {
          this.applyWeaponDamageAmount(source.id, target, secondaryDamage, damageType, deathType);
        }
      }
    }

    // Emit visual event for the detonation.
    this.visualEventBuffer.push({
      type: 'WEAPON_IMPACT',
      x: targetX,
      y: source.y,
      z: targetZ,
      radius: effectRadius,
      sourceEntityId: source.id,
      projectileType: 'ARTILLERY',
    });
  }

  // ── Tunnel Network System ──────────────────────────────────────────────────

  /**
   * Source parity: TunnelTracker — resolve or create per-side tunnel state.
   */
  private resolveTunnelTracker(side: string | undefined): TunnelTrackerState | null {
    const normalized = this.normalizeSide(side);
    if (!normalized) return null;
    let tracker = this.tunnelTrackers.get(normalized);
    if (!tracker) {
      tracker = { tunnelIds: new Set(), passengerIds: new Set(), timeForFullHealFrames: 1 };
      this.tunnelTrackers.set(normalized, tracker);
    }
    return tracker;
  }

  /**
   * Register a tunnel-type building with the side's TunnelTracker.
   * Called after entity creation at all spawn points.
   */
  private registerTunnelEntity(entity: MapEntity): void {
    if (!entity.containProfile || entity.containProfile.moduleType !== 'TUNNEL') return;
    const tracker = this.resolveTunnelTracker(entity.side);
    if (!tracker) return;
    tracker.tunnelIds.add(entity.id);
    // Use the most recently registered tunnel's heal rate.
    if (entity.containProfile.timeForFullHealFrames > 0) {
      tracker.timeForFullHealFrames = entity.containProfile.timeForFullHealFrames;
    }
  }

  /**
   * Unregister a tunnel from the tracker. Returns the tracker for further handling.
   */
  private unregisterTunnelEntity(entity: MapEntity): TunnelTrackerState | null {
    if (!entity.containProfile || entity.containProfile.moduleType !== 'TUNNEL') return null;
    const tracker = this.resolveTunnelTracker(entity.side);
    if (!tracker) return null;
    tracker.tunnelIds.delete(entity.id);
    return tracker;
  }

  /**
   * Source parity: TunnelContain::onContaining — enter the shared tunnel network.
   */
  private enterTunnel(passenger: MapEntity, tunnel: MapEntity): void {
    const tracker = this.resolveTunnelTracker(tunnel.side);
    if (!tracker) return;

    // Source parity: TunnelTracker::isValidContainerFor — no aircraft.
    if (passenger.kindOf.has('AIRCRAFT')) return;

    // Check shared capacity.
    if (tracker.passengerIds.size >= this.config.maxTunnelCapacity) return;

    // Cannot enter if already contained.
    if (this.isEntityContained(passenger)) return;

    this.cancelEntityCommandPathActions(passenger.id);
    this.clearAttackTarget(passenger.id);

    passenger.tunnelContainerId = tunnel.id;
    this.noteContainerEnteredBy(tunnel, passenger);
    passenger.tunnelEnteredFrame = this.frameCounter;
    passenger.x = tunnel.x;
    passenger.z = tunnel.z;
    passenger.y = tunnel.y;
    passenger.moving = false;

    // Source parity: Object::onContainedBy + TunnelContain::onContaining — DISABLED_HELD, MASKED, UNSELECTABLE.
    passenger.objectStatusFlags.add('DISABLED_HELD');
    passenger.objectStatusFlags.add('MASKED');
    passenger.objectStatusFlags.add('UNSELECTABLE');

    tracker.passengerIds.add(passenger.id);
    this.removeEntityFromSelection(passenger.id);
    this.pendingTunnelActions.delete(passenger.id);
  }

  /**
   * Source parity: TunnelContain::removeFromContain — exit the tunnel network.
   * The passenger exits from the specified tunnel building.
   */
  private exitTunnel(passenger: MapEntity, exitTunnel: MapEntity): void {
    const tracker = this.resolveTunnelTracker(exitTunnel.side);
    if (tracker) {
      tracker.passengerIds.delete(passenger.id);
    }

    passenger.tunnelContainerId = null;
    passenger.tunnelEnteredFrame = 0;

    // Source parity: TunnelContain::onRemoving — clear DISABLED_HELD.
    passenger.objectStatusFlags.delete('DISABLED_HELD');
    passenger.objectStatusFlags.delete('MASKED');
    passenger.objectStatusFlags.delete('UNSELECTABLE');

    // Source parity: TunnelContain::scatterToNearbyPosition — scatter around the exit tunnel.
    const angle = this.gameRandom.nextFloat() * Math.PI * 2;
    const geom = exitTunnel.obstacleGeometry;
    const baseRadius = geom ? Math.max(geom.majorRadius, geom.minorRadius) : 10;
    const minRadius = baseRadius;
    const maxRadius = baseRadius * 1.5;
    const dist = minRadius + this.gameRandom.nextFloat() * (maxRadius - minRadius);
    const exitX = exitTunnel.x + Math.cos(angle) * dist;
    const exitZ = exitTunnel.z + Math.sin(angle) * dist;

    passenger.x = exitTunnel.x;
    passenger.z = exitTunnel.z;
    passenger.y = this.resolveGroundHeight(passenger.x, passenger.z) + passenger.baseHeight;
    passenger.rotationY = angle;
    this.updatePathfindPosCell(passenger);

    if (passenger.canMove) {
      this.issueMoveTo(passenger.id, exitX, exitZ);
    } else {
      // Source parity: scatterToNearbyPosition — non-AI units are placed directly.
      passenger.x = exitX;
      passenger.z = exitZ;
      passenger.y = this.resolveGroundHeight(exitX, exitZ) + passenger.baseHeight;
      this.updatePathfindPosCell(passenger);
    }
  }

  /**
   * Source parity: TunnelTracker::onTunnelDestroyed — handle tunnel death.
   * If last tunnel: cave-in kills all passengers. Otherwise: reassign passengers to another tunnel.
   */
  private handleTunnelDestroyed(entity: MapEntity): void {
    const tracker = this.unregisterTunnelEntity(entity);
    if (!tracker) return;

    if (tracker.tunnelIds.size === 0) {
      // Cave-in: last tunnel destroyed — kill all passengers.
      for (const passengerId of Array.from(tracker.passengerIds)) {
        const passenger = this.spawnedEntities.get(passengerId);
        if (!passenger || passenger.destroyed) continue;
        // Release from container first so markEntityDestroyed doesn't try to double-release.
        passenger.tunnelContainerId = null;
        passenger.objectStatusFlags.delete('DISABLED_HELD');
        passenger.objectStatusFlags.delete('MASKED');
        passenger.objectStatusFlags.delete('UNSELECTABLE');
        this.markEntityDestroyed(passengerId, entity.id);
      }
      tracker.passengerIds.clear();
    } else {
      // Reassign passengers to a remaining tunnel.
      const [validTunnelId] = tracker.tunnelIds;
      if (validTunnelId !== undefined) {
        for (const passengerId of tracker.passengerIds) {
          const passenger = this.spawnedEntities.get(passengerId);
          if (passenger && passenger.tunnelContainerId === entity.id) {
            passenger.tunnelContainerId = validTunnelId;
          }
        }
      }
    }
  }

  /**
   * Source parity: TunnelContain::onSelling — if last tunnel, eject passengers safely.
   */
  private handleTunnelSelling(entity: MapEntity): void {
    if (!entity.containProfile || entity.containProfile.moduleType !== 'TUNNEL') return;
    const tracker = this.resolveTunnelTracker(entity.side);
    if (!tracker) return;

    // Check if this is the last tunnel (count 1 means this is the only one left).
    if (tracker.tunnelIds.size <= 1) {
      // Eject all passengers safely before the tunnel is destroyed.
      for (const passengerId of Array.from(tracker.passengerIds)) {
        const passenger = this.spawnedEntities.get(passengerId);
        if (!passenger || passenger.destroyed) continue;
        this.exitTunnel(passenger, entity);
      }
    }

    // Source parity: TunnelContain::onSelling — ALWAYS unregister after eject,
    // even if not the last tunnel. Prevents double-sell cave-in race condition
    // when two tunnels are sold in the same frame.
    tracker.tunnelIds.delete(entity.id);
  }

  /**
   * Source parity: TunnelContain::update → TunnelTracker::healObjects — heal passengers.
   */
  private updateTunnelHealing(): void {
    for (const tracker of this.tunnelTrackers.values()) {
      if (tracker.passengerIds.size === 0) continue;
      const healFrames = tracker.timeForFullHealFrames;
      if (healFrames <= 0) continue;

      for (const passengerId of tracker.passengerIds) {
        const passenger = this.spawnedEntities.get(passengerId);
        if (!passenger || passenger.destroyed) continue;
        if (passenger.health >= passenger.maxHealth) continue;

        const framesInside = this.frameCounter - passenger.tunnelEnteredFrame;
        if (framesInside >= healFrames) {
          // Fully healed.
          passenger.health = passenger.maxHealth;
        } else {
          // Linear heal: maxHealth / framesForFullHeal per frame.
          const healPerFrame = passenger.maxHealth / healFrames;
          passenger.health = Math.min(passenger.maxHealth, passenger.health + healPerFrame);
        }
      }
    }
  }

  /**
   * Source parity: HealContain::update — heal all passengers per frame, auto-eject when full.
   * C++ file: HealContain.cpp lines 92-132.
   */
  private updateHealContainHealing(): void {
    // Find all heal containers and process their passengers.
    for (const container of this.spawnedEntities.values()) {
      if (container.destroyed) continue;
      const profile = container.containProfile;
      if (!profile || profile.moduleType !== 'HEAL') continue;
      const healFrames = profile.timeForFullHealFrames;
      if (healFrames <= 0) continue;

      // Collect passengers inside this heal container.
      const passengerIds: number[] = [];
      for (const entity of this.spawnedEntities.values()) {
        if (entity.transportContainerId === container.id && !entity.destroyed) {
          passengerIds.push(entity.id);
        }
      }

      const toEject: number[] = [];
      for (const passengerId of passengerIds) {
        const passenger = this.spawnedEntities.get(passengerId);
        if (!passenger || passenger.destroyed) continue;

        // Source parity: HealContain::doHeal — two-phase: if elapsed >= total, full heal; else linear.
        const framesInside = this.frameCounter - passenger.healContainEnteredFrame;
        if (passenger.health < passenger.maxHealth) {
          if (framesInside >= healFrames) {
            passenger.health = passenger.maxHealth;
          } else {
            const healPerFrame = passenger.maxHealth / healFrames;
            passenger.health = Math.min(passenger.maxHealth, passenger.health + healPerFrame);
          }
        }

        // Source parity: HealContain::update — auto-eject when fully healed.
        if (passenger.health >= passenger.maxHealth) {
          toEject.push(passengerId);
        }
      }

      // Eject healed passengers.
      for (const passengerId of toEject) {
        const passenger = this.spawnedEntities.get(passengerId);
        if (!passenger || passenger.destroyed) continue;
        this.releaseEntityFromContainer(passenger);
        passenger.x = container.x;
        passenger.z = container.z;
        passenger.y = this.resolveGroundHeight(container.x, container.z) + passenger.baseHeight;
        this.updatePathfindPosCell(passenger);
        if (passenger.canMove) {
          this.issueMoveTo(passenger.id, container.x + MAP_XY_FACTOR, container.z);
        }
      }
    }
  }

  /**
   * Source parity: AutoFindHealingUpdate::update() — AI-controlled units auto-seek
   * nearby heal pads when damaged and idle. C++ checks player type, health thresholds,
   * and idle state before issuing aiGetHealed() command.
   */
  private updateAutoFindHealing(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const prof = entity.autoFindHealingProfile;
      if (!prof) continue;

      // Source parity: only AI-controlled players auto-seek healing.
      const normalizedSide = this.normalizeSide(entity.side);
      if (!normalizedSide) continue;
      const playerType = this.sidePlayerTypes.get(normalizedSide);
      if (!playerType || playerType === 'HUMAN') continue;

      // Scan rate throttle.
      if (this.frameCounter < entity.autoFindHealingNextScanFrame) continue;
      entity.autoFindHealingNextScanFrame = this.frameCounter + prof.scanRateFrames;

      // Source parity: skip if already contained (in a transport/heal container).
      if (this.isEntityContained(entity)) continue;

      // Source parity: health threshold checks.
      const healthRatio = entity.health / Math.max(1, entity.maxHealth);
      if (healthRatio >= prof.neverHeal) continue;

      // Source parity: AutoFindHealingUpdate.cpp:130 — ai->isIdle() checks all activity states.
      // Approximation: check movement, attack, guard, special ability, and enter-transport states.
      const isIdle = !entity.moving
        && entity.attackTargetEntityId === null
        && entity.guardState === 'NONE'
        && (!entity.specialAbilityState || entity.specialAbilityState.packState === 'NONE')
        && entity.transportContainerId === null;
      if (!isIdle && healthRatio > prof.alwaysHeal) continue;

      // Source parity: scan for closest HEAL_PAD entity in range.
      const rangeSqr = prof.scanRange * prof.scanRange;
      let closestHealPad: MapEntity | null = null;
      let closestDistSqr = Infinity;

      for (const candidate of this.spawnedEntities.values()) {
        if (candidate.destroyed || candidate.id === entity.id) continue;
        // Must be a heal pad (KINDOF HEAL_PAD).
        const kindOf = this.resolveEntityKindOfSet(candidate);
        if (!kindOf.has('HEAL_PAD')) continue;
        // Must be same side.
        if (this.normalizeSide(candidate.side) !== normalizedSide) continue;
        // Must have a HEAL contain profile with capacity.
        const containProfile = candidate.containProfile;
        if (!containProfile || containProfile.moduleType !== 'HEAL') continue;
        if (containProfile.transportCapacity > 0) {
          const occupants = this.collectContainedEntityIds(candidate.id).length;
          if (occupants >= containProfile.transportCapacity) continue;
        }

        const dx = candidate.x - entity.x;
        const dz = candidate.z - entity.z;
        const distSqr = dx * dx + dz * dz;
        if (distSqr < rangeSqr && distSqr < closestDistSqr) {
          closestDistSqr = distSqr;
          closestHealPad = candidate;
        }
      }

      // Source parity: aiGetHealed — issue enter transport command to heal pad.
      if (closestHealPad) {
        this.handleEnterTransportCommand({
          type: 'enterTransport',
          entityId: entity.id,
          targetTransportId: closestHealPad.id,
        });
      }
    }
  }

  /**
   * Source parity: TunnelContain pending enter — units walking toward a tunnel.
   */
  private updatePendingTunnelActions(): void {
    for (const [passengerId, tunnelId] of this.pendingTunnelActions.entries()) {
      const passenger = this.spawnedEntities.get(passengerId);
      const tunnel = this.spawnedEntities.get(tunnelId);
      if (!passenger || !tunnel || passenger.destroyed || tunnel.destroyed) {
        this.pendingTunnelActions.delete(passengerId);
        continue;
      }
      if (this.isEntityContained(passenger)) {
        this.pendingTunnelActions.delete(passengerId);
        continue;
      }

      const interactionDistance = this.resolveEntityInteractionDistance(passenger, tunnel);
      const distance = Math.hypot(tunnel.x - passenger.x, tunnel.z - passenger.z);
      if (distance > interactionDistance) continue;

      // Check capacity again.
      const tracker = this.resolveTunnelTracker(tunnel.side);
      if (!tracker || tracker.passengerIds.size >= this.config.maxTunnelCapacity) {
        this.pendingTunnelActions.delete(passengerId);
        continue;
      }

      this.enterTunnel(passenger, tunnel);
    }
  }

  private updateFogOfWar(): void {
    const grid = this.fogOfWarGrid;
    if (!grid) {
      return;
    }

    for (const entity of this.spawnedEntities.values()) {
      const playerIdx = this.resolvePlayerIndexForSide(entity.side);
      if (playerIdx < 0) {
        continue;
      }

      // Source parity: buildings under construction use bounding radius instead of
      // full vision range (Object.cpp line 5156). Use 0 for simplicity until geometry
      // bounding radius is wired into vision.
      const effectiveVisionRange = entity.objectStatusFlags.has('UNDER_CONSTRUCTION')
        ? 0
        : entity.visionRange;

      updateEntityVisionImpl(
        grid,
        entity.visionState,
        playerIdx,
        entity.x,
        entity.z,
        effectiveVisionRange,
        !entity.destroyed,
      );
    }
  }

  /**
   * Resolve or allocate a player index for a side string.
   * Used by fog of war to track per-player visibility.
   */
  private resolvePlayerIndexForSide(side: string | undefined): number {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return -1;
    }

    let idx = this.sidePlayerIndex.get(normalizedSide);
    if (idx !== undefined) {
      return idx;
    }

    idx = this.nextPlayerIndex++;
    this.sidePlayerIndex.set(normalizedSide, idx);
    return idx;
  }

  /**
   * Get the visibility of a world position for a specific side.
   */
  getCellVisibility(side: string, worldX: number, worldZ: number): CellVisibility {
    const grid = this.fogOfWarGrid;
    if (!grid) {
      return CELL_CLEAR; // No fog of war without a grid.
    }

    const playerIdx = this.sidePlayerIndex.get(this.normalizeSide(side));
    if (playerIdx === undefined) {
      return CELL_SHROUDED;
    }

    return grid.getCellVisibility(playerIdx, worldX, worldZ);
  }

  /**
   * Check if a position is visible (CLEAR) for a side.
   */
  isPositionVisible(side: string, worldX: number, worldZ: number): boolean {
    return this.getCellVisibility(side, worldX, worldZ) === CELL_CLEAR;
  }

  /**
   * Source parity: ObjectShroudStatus — resolve entity visibility from local player's perspective.
   * Own-side entities are always CLEAR. Enemies/neutrals use the fog of war grid.
   * Source: Object.cpp getShroudedStatus, PartitionManager.cpp lines 1659-1690.
   */
  private resolveEntityShroudStatusForLocalPlayer(entity: MapEntity): 'CLEAR' | 'FOGGED' | 'SHROUDED' {
    const localSide = this.playerSideByIndex.get(this.localPlayerIndex);
    return this.resolveEntityShroudStatusForSide(entity, localSide ?? null);
  }

  private resolveEntityShroudStatusForSide(
    entity: MapEntity,
    viewerSide: string | null | undefined,
  ): 'CLEAR' | 'FOGGED' | 'SHROUDED' {
    const normalizedViewerSide = this.normalizeSide(viewerSide ?? '');
    if (!normalizedViewerSide) return 'CLEAR';
    // Source parity: KINDOF_ALWAYS_VISIBLE bypasses all shroud (Object.cpp line 1804).
    if (entity.kindOf.has('ALWAYS_VISIBLE')) return 'CLEAR';
    // Own entities always visible.
    const entitySide = this.normalizeSide(entity.side);
    if (entitySide && entitySide === normalizedViewerSide) return 'CLEAR';
    // Allied entities always visible (source parity: allied shroud is shared).
    if (entitySide && this.getTeamRelationshipBySides(normalizedViewerSide, entitySide) === RELATIONSHIP_ALLIES) {
      return 'CLEAR';
    }
    const vis = this.getCellVisibility(normalizedViewerSide, entity.x, entity.z);
    if (vis === CELL_CLEAR) return 'CLEAR';
    if (vis === CELL_FOGGED) {
      // Source parity: PartitionManager.cpp lines 1659-1676 — mobile enemies and
      // mines vanish in fog. Only immobile structures previously seen show as ghosts.
      const isImmobile = entity.kindOf.has('IMMOBILE');
      if (!isImmobile || entity.kindOf.has('MINE')) {
        return 'SHROUDED';
      }
      return 'FOGGED';
    }
    return 'SHROUDED';
  }

  /**
   * Get superweapon countdown timers for all sides.
   * Returns array of { side, entityId, powerName, readyFrame, currentFrame, isReady }.
   */
  getSuperweaponCountdowns(): Array<{
    side: string;
    entityId: number;
    powerName: string;
    readyFrame: number;
    currentFrame: number;
    isReady: boolean;
  }> {
    const results: Array<{
      side: string;
      entityId: number;
      powerName: string;
      readyFrame: number;
      currentFrame: number;
      isReady: boolean;
    }> = [];

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (!entity.kindOf.has('FS_SUPERWEAPON')) continue;

      for (const [, module] of entity.specialPowerModules) {
        const powerName = module.specialPowerTemplateName;
        // Look up shared ready frame.
        const normalizedPower = powerName.toUpperCase().replace(/\s+/g, '');
        const sharedFrame = this.sharedShortcutSpecialPowerReadyFrames.get(normalizedPower) ?? 0;
        const readyFrame = sharedFrame > 0 ? sharedFrame : 0;

        results.push({
          side: entity.side ?? '',
          entityId: entity.id,
          powerName,
          readyFrame,
          currentFrame: this.frameCounter,
          isReady: readyFrame > 0 && this.frameCounter >= readyFrame,
        });
      }
    }

    return results;
  }

  /**
   * Get the fog of war grid dimensions and raw visibility data for a side.
   * Returns null if no fog grid is active.
   * Data is a Uint8Array where each byte is: 0=SHROUDED, 1=FOGGED, 2=CLEAR.
   * Row-major order: index = row * cellsWide + col.
   */
  getFogOfWarTextureData(side: string): {
    cellsWide: number;
    cellsDeep: number;
    cellSize: number;
    data: Uint8Array;
  } | null {
    const grid = this.fogOfWarGrid;
    if (!grid) return null;

    const playerIdx = this.sidePlayerIndex.get(this.normalizeSide(side));
    if (playerIdx === undefined) return null;

    const cellsWide = grid.cellsWide;
    const cellsDeep = grid.cellsDeep;
    const data = new Uint8Array(cellsWide * cellsDeep);
    const cellSize = grid.cellSize;

    for (let row = 0; row < cellsDeep; row++) {
      for (let col = 0; col < cellsWide; col++) {
        const worldX = (col + 0.5) * cellSize;
        const worldZ = (row + 0.5) * cellSize;
        data[row * cellsWide + col] = grid.getCellVisibility(playerIdx, worldX, worldZ);
      }
    }

    return { cellsWide, cellsDeep, cellSize, data };
  }

  /**
   * Create the context object for special power effect execution.
   */
  private createSpecialPowerEffectContext(): SpecialPowerEffectContext<MapEntity> {
    return {
      spawnedEntities: this.spawnedEntities,
      applyDamage: (sourceEntityId, target, amount, damageType) => {
        this.applyWeaponDamageAmount(sourceEntityId, target, amount, damageType);
      },
      healEntity: (target, amount) => {
        if (target.destroyed || amount <= 0) {
          return;
        }
        const prevHealth = target.health;
        target.health = Math.min(target.maxHealth, target.health + amount);
        if (target.health > prevHealth) {
          this.clearPoisonFromEntity(target);
        }
      },
      depositCredits: (side, amount) => {
        depositSideCreditsImpl(this.sideCredits, this.normalizeSide(side), amount);
      },
      withdrawCredits: (side, amount) => {
        return withdrawSideCreditsImpl(this.sideCredits, this.normalizeSide(side), amount);
      },
      changeEntitySide: (entityId, newSide) => {
        this.captureEntity(entityId, newSide);
      },
      destroyEntity: (entityId, attackerId) => {
        this.markEntityDestroyed(entityId, attackerId);
      },
      getRelationship: (sideA, sideB) => {
        return this.getTeamRelationshipBySides(sideA, sideB);
      },
      revealFogOfWar: (side, worldX, worldZ, radius, durationMs) => {
        const grid = this.fogOfWarGrid;
        if (!grid) {
          return;
        }
        const playerIdx = this.resolvePlayerIndexForSide(side);
        if (playerIdx < 0) {
          return;
        }
        grid.addLooker(playerIdx, worldX, worldZ, radius);
        // Source parity: spy vision reveals are time-limited.
        // Default to ~30 seconds (900 frames) if no duration specified.
        const DEFAULT_SPY_DURATION_FRAMES = 900;
        const durationFrames = durationMs && durationMs > 0
          ? this.msToLogicFrames(durationMs)
          : DEFAULT_SPY_DURATION_FRAMES;
        this.temporaryVisionReveals.push({
          playerIndex: playerIdx,
          worldX,
          worldZ,
          radius,
          expiryFrame: this.frameCounter + durationFrames,
        });
      },
      normalizeSide: (side) => this.normalizeSide(side),
    };
  }

  /**
   * Source parity: SupplyTruckAIUpdate / SupplyWarehouseDockUpdate / SupplyCenterDockUpdate
   * Runs the supply truck AI state machine for all trucks each frame.
   */
  private hasPendingTransportEntryForContainer(containerId: number): boolean {
    for (const targetTransportId of this.pendingTransportActions.values()) {
      if (targetTransportId === containerId) {
        return true;
      }
    }
    return false;
  }

  /**
   * Source parity: ChinookAIUpdate::isAvailableForSupplying.
   * Chinooks cannot gather while handling transport enter/exit or carrying passengers.
   */
  private isChinookAvailableForSupplying(entity: MapEntity): boolean {
    if (!entity.chinookAIProfile) {
      return true;
    }
    if (this.pendingCombatDropActions.has(entity.id)) {
      return false;
    }
    if (this.collectContainedEntityIds(entity.id).length > 0) {
      return false;
    }
    if (this.hasPendingTransportEntryForContainer(entity.id)) {
      return false;
    }
    if (entity.containProfile?.moduleType === 'OVERLORD') {
      return false;
    }
    return true;
  }

  private updateSupplyChain(): void {
    const supplyChainContext: SupplyChainContext<MapEntity> = {
      frameCounter: this.frameCounter,
      spawnedEntities: this.spawnedEntities,
      supplyBoxValue: DEFAULT_SUPPLY_BOX_VALUE,
      getWarehouseProfile: (entity: MapEntity) => entity.supplyWarehouseProfile,
      getTruckProfile: (entity: MapEntity) => entity.supplyTruckProfile,
      isSupplyCenter: (entity: MapEntity) => entity.isSupplyCenter,
      isWarehouseDockCrippled: (entity: MapEntity) => entity.swCripplingDockDisabled,
      getWarehouseState: (entityId: number) => this.supplyWarehouseStates.get(entityId),
      setWarehouseState: (entityId: number, state: SupplyWarehouseState) => {
        this.supplyWarehouseStates.set(entityId, state);
      },
      getTruckState: (entityId: number) => this.supplyTruckStates.get(entityId),
      setTruckState: (entityId: number, state: SupplyTruckState) => {
        this.supplyTruckStates.set(entityId, state);
      },
      depositCredits: (side: string, amount: number) => {
        this.depositSideCredits(side, amount);
      },
      getSupplyTruckDepositBoost: (truck: MapEntity, profile: SupplyTruckProfile) => {
        if (profile.upgradedSupplyBoost <= 0) {
          return 0;
        }
        const side = this.normalizeSide(truck.side);
        if (!side) {
          return 0;
        }
        return this.hasSideUpgradeCompleted(side, 'UPGRADE_AMERICASUPPLYLINES')
          ? profile.upgradedSupplyBoost
          : 0;
      },
      moveEntityTo: (entityId: number, targetX: number, targetZ: number) => {
        this.submitCommand({ type: 'moveTo', entityId, targetX, targetZ });
      },
      destroyEntity: (entityId: number) => {
        this.markEntityDestroyed(entityId, -1);
      },
      normalizeSide: (side: string | undefined) => this.normalizeSide(side),
    };

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (entity.supplyTruckProfile) {
        // Source parity: WorkerAIUpdate runs supply-truck logic only while not in dozer tasks.
        if (entity.dozerAIProfile
          && (this.pendingConstructionActions.has(entity.id) || this.pendingRepairActions.has(entity.id))) {
          continue;
        }
        if (!this.isChinookAvailableForSupplying(entity)) {
          continue;
        }
        updateSupplyTruckImpl(entity, entity.supplyTruckProfile, supplyChainContext);
      }
    }
  }

  /**
   * Enable skirmish AI for a side.
   * Source parity: AIPlayer is created when map starts with AI players.
   */
  enableSkirmishAI(side: string): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide || this.skirmishAIStates.has(normalizedSide)) {
      return;
    }

    const aiState = createSkirmishAIStateImpl(normalizedSide);
    this.skirmishAIStates.set(normalizedSide, aiState);
  }

  /**
   * Disable skirmish AI for a side.
   */
  disableSkirmishAI(side: string): void {
    this.skirmishAIStates.delete(this.normalizeSide(side));
  }

  private updateSkirmishAI(): void {
    if (this.skirmishAIStates.size === 0) {
      return;
    }

    const aiContext: SkirmishAIContext<MapEntity> = {
      frameCounter: this.frameCounter,
      spawnedEntities: this.spawnedEntities,
      getSideCredits: (side: string) => this.getSideCredits(side),
      submitCommand: (command) => this.submitCommand(command),
      getRelationship: (sideA: string, sideB: string) =>
        this.getTeamRelationshipBySides(sideA, sideB),
      normalizeSide: (side) => this.normalizeSide(side),
      hasProductionQueue: (entity: MapEntity) => entity.productionProfile !== null,
      isProducing: (entity: MapEntity) => entity.productionQueue.length > 0,
      getProducibleUnits: (entity: MapEntity) => {
        if (!entity.productionProfile) return [];
        // Source parity: producible units come from command set UNIT_BUILD buttons.
        const fromCommandSet = this.collectCommandSetTemplates(entity, ['UNIT_BUILD', 'DOZER_CONSTRUCT']);
        if (fromCommandSet.length > 0) return fromCommandSet;
        // Fallback to quantityModifiers for tests without command set data.
        return entity.productionProfile.quantityModifiers.map(qm => qm.templateName);
      },
      getWorldDimensions: () => {
        const hm = this.mapHeightmap;
        return hm ? { width: hm.worldWidth, depth: hm.worldDepth } : null;
      },
      getDozers: (side: string) => {
        const normalizedSide = this.normalizeSide(side);
        const result: MapEntity[] = [];
        for (const entity of this.spawnedEntities.values()) {
          if (entity.destroyed) continue;
          if (this.normalizeSide(entity.side) !== normalizedSide) continue;
          if (entity.templateName.toUpperCase().includes('DOZER')
            || entity.templateName.toUpperCase().includes('WORKER')) {
            result.push(entity);
          }
        }
        return result;
      },
      getBuildableStructures: (entity: MapEntity) => {
        if (!entity.productionProfile) return [];
        // Source parity: buildable structures come from command set DOZER_CONSTRUCT buttons.
        const fromCommandSet = this.collectCommandSetTemplates(entity, ['DOZER_CONSTRUCT']);
        if (fromCommandSet.length > 0) return fromCommandSet;
        // Fallback to quantityModifiers for tests without command set data.
        return entity.productionProfile.quantityModifiers
          .filter(qm => {
            const upper = qm.templateName.toUpperCase();
            return !upper.includes('UPGRADE') && !upper.includes('SCIENCE');
          })
          .map(qm => qm.templateName);
      },
      isDozerBusy: (entity: MapEntity) => {
        return entity.moving || entity.productionQueue.length > 0
          || this.pendingConstructionActions.has(entity.id);
      },
      getSidePowerBalance: (side: string) => {
        const ps = this.getSidePowerState(side);
        return ps.energyProduction - ps.energyConsumption + ps.powerBonus;
      },
      getResearchableUpgrades: (entity: MapEntity) => {
        if (!entity.productionProfile) return [];
        // Source parity: researchable upgrades come from PLAYER_UPGRADE command buttons.
        const fromCommandSet = this.collectCommandSetTemplates(entity, ['PLAYER_UPGRADE']);
        if (fromCommandSet.length > 0) return fromCommandSet;
        // Fallback for tests without command set data.
        return entity.productionProfile.quantityModifiers
          .filter(qm => qm.templateName.toUpperCase().includes('UPGRADE'))
          .map(qm => qm.templateName);
      },
      hasUpgradeCompleted: (side: string, upgradeName: string) => {
        return this.hasSideUpgradeCompleted(side, upgradeName);
      },
      getSciencePurchasePoints: (side: string) => {
        const normalizedSide = this.normalizeSide(side);
        if (!normalizedSide) return 0;
        return this.getSideRankStateMap(normalizedSide).sciencePurchasePoints;
      },
      getAvailableSciences: (side: string) => {
        const registry = this.iniDataRegistry;
        if (!registry) return [];
        const normalizedSide = this.normalizeSide(side);
        if (!normalizedSide) return [];
        const result: Array<{ name: string; cost: number }> = [];
        for (const scienceDef of iterAllScienceDefs(registry)) {
          const scienceName = scienceDef.name.trim().toUpperCase();
          if (!scienceName || scienceName === 'NONE') continue;
          if (!this.canSidePurchaseScience(normalizedSide, scienceName)) continue;
          const cost = this.getSciencePurchaseCost(scienceDef);
          result.push({ name: scienceName, cost });
        }
        return result;
      },
      getReadySpecialPowers: (side: string) => {
        return this.collectReadySpecialPowersForSide(side);
      },
    };

    for (const aiState of this.skirmishAIStates.values()) {
      updateSkirmishAIImpl(aiState, aiContext);
    }
  }

  private updateSellingEntities(): void {
    for (const [entityId, sellState] of this.sellingEntities.entries()) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity || entity.destroyed) {
        this.sellingEntities.delete(entityId);
        continue;
      }

      if (this.frameCounter - sellState.sellFrame >= SOURCE_FRAMES_TO_ALLOW_SCAFFOLD) {
        sellState.constructionPercent -= (100.0 / SOURCE_TOTAL_FRAMES_TO_SELL_OBJECT);
      }

      if (sellState.constructionPercent <= -50.0) {
        this.depositSideCredits(entity.side, this.resolveSellRefundAmount(entity));
        this.markEntityDestroyed(entity.id, -1);
        this.sellingEntities.delete(entityId);
      }
    }
  }

  private resolveSellRefundAmount(entity: MapEntity): number {
    const objectDef = this.resolveObjectDefByTemplateName(entity.templateName);
    if (!objectDef) {
      return 0;
    }

    const refundValue = readNumericField(objectDef.fields, ['RefundValue']) ?? 0;
    if (refundValue > 0) {
      return Math.max(0, Math.trunc(refundValue));
    }

    // Source parity subset: BuildAssistant::update() uses GlobalData::m_sellPercentage.
    const cost = this.resolveObjectBuildCost(objectDef, entity.side ?? '');
    const sellPercentage = this.config.sellPercentage;
    return Math.max(0, Math.trunc(cost * (sellPercentage >= 0 ? sellPercentage : SOURCE_DEFAULT_SELL_PERCENTAGE)));
  }

  private resolveConstructPlacementPositions(
    command: ConstructBuildingCommand,
    objectDef: ObjectDef,
  ): Array<readonly [number, number, number]> {
    const startX = command.targetPosition[0];
    const startZ = command.targetPosition[2];
    const startY = this.resolveGroundHeight(startX, startZ);

    const kindOf = this.normalizeKindOf(objectDef.kindOf);
    if (!command.lineEndPosition || !kindOf.has('LINEBUILD')) {
      return [[startX, startY, startZ]];
    }

    const endX = command.lineEndPosition[0];
    const endZ = command.lineEndPosition[2];
    const deltaX = endX - startX;
    const deltaZ = endZ - startZ;
    const length = Math.hypot(deltaX, deltaZ);
    if (length <= 0) {
      return [[startX, startY, startZ]];
    }

    const majorRadius = this.resolveObjectDefMajorRadius(objectDef);
    const tileSize = majorRadius > 0 ? majorRadius * 2 : MAP_XY_FACTOR;
    const directionX = deltaX / length;
    const directionZ = deltaZ / length;
    const tilesNeeded = Math.max(1, Math.trunc(length / tileSize) + 1);
    const positions: Array<readonly [number, number, number]> = [];
    for (let index = 0; index < tilesNeeded; index += 1) {
      const distance = Math.min(length, index * tileSize);
      const x = startX + directionX * distance;
      const z = startZ + directionZ * distance;
      const y = this.resolveGroundHeight(x, z);
      positions.push([x, y, z]);
    }

    return positions;
  }

  private resolveObjectDefMajorRadius(objectDef: ObjectDef): number {
    const obstacleGeometry = this.resolveObstacleGeometry(objectDef);
    if (obstacleGeometry && obstacleGeometry.majorRadius > 0) {
      return obstacleGeometry.majorRadius;
    }
    return MAP_XY_FACTOR / 2;
  }

  private spawnConstructedObject(
    constructor: MapEntity,
    objectDef: ObjectDef,
    worldPosition: readonly [number, number, number],
    angle: number,
  ): MapEntity | null {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return null;
    }

    const mapObject: MapObjectJSON = {
      templateName: objectDef.name,
      angle: THREE.MathUtils.radToDeg(angle),
      flags: 0,
      position: {
        x: worldPosition[0],
        y: worldPosition[2],
        z: worldPosition[1] - this.resolveGroundHeight(worldPosition[0], worldPosition[2]),
      },
      properties: {},
    };

    const created = this.createMapEntity(mapObject, objectDef, registry, this.mapHeightmap);
    if (constructor.side !== undefined) {
      created.side = constructor.side;
    }
    created.controllingPlayerToken = constructor.controllingPlayerToken;

    // Source parity: DozerAIUpdate::construct — start at 0% construction, health=1.
    const buildTimeFrames = this.resolveObjectBuildTimeFrames(objectDef);
    if (buildTimeFrames > 0) {
      created.constructionPercent = 0;
      created.buildTotalFrames = buildTimeFrames;
      created.builderId = constructor.id;
      created.health = 1;
      created.objectStatusFlags.add('UNDER_CONSTRUCTION');
      // Note: UNDER_CONSTRUCTION side effects are checked directly via objectStatusFlags.
      // Register dozer construction task.
      this.pendingConstructionActions.set(constructor.id, created.id);
      // Move dozer to building site.
      this.issueMoveTo(constructor.id, created.x, created.z);
    }

    this.addEntityToWorld(created);
    this.registerEntityEnergy(created);
    this.initializeMinefieldState(created);
    this.registerTunnelEntity(created);

    // Source parity: Eva CONSTRUCTION_COMPLETE fires when construction finishes,
    // not when the building is first placed.
    if (buildTimeFrames <= 0 && created.side) {
      this.emitEvaEvent('CONSTRUCTION_COMPLETE', created.side, 'own', created.id, objectDef.name);
    }

    // Source parity: SpecialPowerCreate::onBuildComplete — for instant-build buildings.
    // Normal dozer-built buildings fire this from completeConstruction().
    if (buildTimeFrames <= 0 && created.hasSpecialPowerCreate) {
      this.onBuildCompleteSpecialPowerCreate(created);
    }
    if (buildTimeFrames <= 0 && created.kindOf.has('STRUCTURE')) {
      this.onStructureConstructionComplete(constructor, created, false);
    }

    return created;
  }

  private resolveObjectDefByTemplateName(templateName: string): ObjectDef | null {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return null;
    }
    return findObjectDefByName(registry, templateName) ?? null;
  }

  private hasBehaviorModuleType(objectDef: ObjectDef, moduleTypeName: string): boolean {
    const normalizedModuleType = moduleTypeName.trim().toUpperCase();
    if (!normalizedModuleType) {
      return false;
    }

    let found = false;
    const visitBlock = (block: IniBlock): void => {
      if (found) {
        return;
      }
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleType = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleType === normalizedModuleType) {
          found = true;
          return;
        }
      }
      for (const child of block.blocks) {
        visitBlock(child);
      }
    };

    for (const block of objectDef.blocks) {
      visitBlock(block);
    }
    return found;
  }

  private resolveBeaconTemplateNameForSide(side: string): string | null {
    const normalizedSide = this.normalizeSide(side);
    const registry = this.iniDataRegistry;
    if (!normalizedSide || !registry) {
      return null;
    }

    const matchingFactions = Array.from(registry.factions.values())
      .filter((faction) => this.normalizeSide(faction.side ?? '') === normalizedSide)
      .sort((left, right) => left.name.localeCompare(right.name));
    for (const faction of matchingFactions) {
      const beaconTemplateName = readStringField(faction.fields, ['BeaconName']);
      if (beaconTemplateName && beaconTemplateName.toUpperCase() !== 'NONE') {
        return beaconTemplateName;
      }
    }

    return null;
  }

  private isBeaconEntity(entity: MapEntity): boolean {
    const entitySide = this.normalizeSide(entity.side);
    if (entitySide) {
      const beaconTemplateName = this.resolveBeaconTemplateNameForSide(entitySide);
      if (beaconTemplateName && this.areEquivalentTemplateNames(entity.templateName, beaconTemplateName)) {
        return true;
      }
    }
    return this.resolveEntityKindOfSet(entity).has('BEACON');
  }

  private resolveGroundHeight(worldX: number, worldZ: number): number {
    if (!this.mapHeightmap) {
      return 0;
    }
    return this.mapHeightmap.getInterpolatedHeight(worldX, worldZ);
  }

  private resolveEntityMajorRadius(entity: MapEntity): number {
    if (entity.geometryMajorRadius > 0) {
      return entity.geometryMajorRadius;
    }
    if (entity.obstacleGeometry && entity.obstacleGeometry.majorRadius > 0) {
      return entity.obstacleGeometry.majorRadius;
    }
    if (entity.pathDiameter > 0) {
      return (entity.pathDiameter * MAP_XY_FACTOR) / 2;
    }
    return MAP_XY_FACTOR / 2;
  }

  private clampWorldPositionToMapBounds(worldX: number, worldZ: number): [number, number] {
    if (!this.mapHeightmap) {
      return [worldX, worldZ];
    }

    const maxWorldX = Math.max(0, this.mapHeightmap.worldWidth - 0.0001);
    const maxWorldZ = Math.max(0, this.mapHeightmap.worldDepth - 0.0001);
    return [
      clamp(worldX, 0, maxWorldX),
      clamp(worldZ, 0, maxWorldZ),
    ];
  }

  private resolveEntityInteractionDistance(source: MapEntity, target: MapEntity): number {
    const sourceRadius = this.resolveEntityMajorRadius(source);
    const targetRadius = this.resolveEntityMajorRadius(target);
    const combined = sourceRadius + targetRadius;
    return combined > 0 ? combined : MAP_XY_FACTOR;
  }

  private isEntityContained(entity: MapEntity): boolean {
    return entity.parkingSpaceProducerId !== null
      || entity.helixCarrierId !== null
      || entity.garrisonContainerId !== null
      || entity.transportContainerId !== null
      || entity.tunnelContainerId !== null;
  }

  private isEntityContainedInGarrison(entity: MapEntity): boolean {
    return entity.garrisonContainerId !== null;
  }

  private collectContainedEntityIds(containerId: number): number[] {
    const entityIds = new Set<number>();
    const container = this.spawnedEntities.get(containerId);
    if (container?.parkingPlaceProfile) {
      for (const entityId of container.parkingPlaceProfile.occupiedSpaceEntityIds.values()) {
        entityIds.add(entityId);
      }
    }

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (
        entity.parkingSpaceProducerId === containerId
        || entity.helixCarrierId === containerId
        || entity.garrisonContainerId === containerId
        || entity.transportContainerId === containerId
        || entity.tunnelContainerId === containerId
      ) {
        entityIds.add(entity.id);
      }
    }

    return Array.from(entityIds.values()).sort((left, right) => left - right);
  }

  private countContainedRappellers(containerId: number): number {
    let count = 0;
    for (const passengerId of this.collectContainedEntityIds(containerId)) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (!passenger || passenger.destroyed) {
        continue;
      }
      if (this.resolveEntityKindOfSet(passenger).has('CAN_RAPPEL')) {
        count += 1;
      }
    }
    return count;
  }

  private resolveChinookCombatDropInitialDelayFrames(source: MapEntity): number {
    const profile = source.chinookAIProfile;
    if (!profile || !profile.waitForRopesToDrop) {
      return 0;
    }
    if (!Number.isFinite(profile.ropeDropSpeed) || profile.ropeDropSpeed <= 0) {
      return 0;
    }

    const groundY = this.resolveGroundHeight(source.x, source.z);
    const dropHeight = Math.max(0, (source.y - source.baseHeight) - groundY - profile.ropeFinalHeight);
    if (dropHeight <= 0) {
      return 0;
    }

    // Source parity approximation: rope speed is world-units/sec.
    const dropSpeedPerFrame = profile.ropeDropSpeed / LOGIC_FRAME_RATE;
    if (dropSpeedPerFrame <= 0) {
      return 0;
    }
    return Math.max(0, Math.ceil(dropHeight / dropSpeedPerFrame));
  }

  private resolveChinookCombatDropIntervalFrames(profile: ChinookAIProfile): number {
    const minFrames = Math.max(0, profile.perRopeDelayMinFrames);
    const maxFrames = Math.max(minFrames, profile.perRopeDelayMaxFrames);
    if (maxFrames <= minFrames) {
      return minFrames;
    }
    return this.gameRandom.nextRange(minFrames, maxFrames);
  }

  private resolveChinookRappelSpeedPerFrame(profile: ChinookAIProfile): number {
    if (!Number.isFinite(profile.rappelSpeed) || profile.rappelSpeed <= 0) {
      return 0;
    }
    return profile.rappelSpeed / LOGIC_FRAME_RATE;
  }

  private releaseEntityFromContainer(entity: MapEntity): void {
    if (entity.parkingSpaceProducerId !== null) {
      const parkingProducer = this.spawnedEntities.get(entity.parkingSpaceProducerId);
      if (parkingProducer?.parkingPlaceProfile) {
        parkingProducer.parkingPlaceProfile.occupiedSpaceEntityIds.delete(entity.id);
      }
      entity.parkingSpaceProducerId = null;
    }

    if (entity.helixCarrierId !== null) {
      const helixCarrier = this.spawnedEntities.get(entity.helixCarrierId);
      if (helixCarrier?.helixPortableRiderId === entity.id) {
        helixCarrier.helixPortableRiderId = null;
      }
      entity.helixCarrierId = null;
    }

    if (entity.garrisonContainerId !== null) {
      entity.garrisonContainerId = null;
      entity.canMove = true;
    }

    if (entity.transportContainerId !== null) {
      entity.transportContainerId = null;
      entity.healContainEnteredFrame = 0;
    }

    if (entity.tunnelContainerId !== null) {
      // Remove from the side's tunnel tracker passenger list.
      const tunnel = this.spawnedEntities.get(entity.tunnelContainerId);
      if (tunnel) {
        const tracker = this.resolveTunnelTracker(tunnel.side);
        if (tracker) {
          tracker.passengerIds.delete(entity.id);
        }
      }
      entity.tunnelContainerId = null;
      entity.tunnelEnteredFrame = 0;
      entity.objectStatusFlags.delete('DISABLED_HELD');
    }

    // Source parity: Object::onRemovedFrom — clear MASKED and UNSELECTABLE on release.
    entity.objectStatusFlags.delete('MASKED');
    entity.objectStatusFlags.delete('UNSELECTABLE');
  }

  private evacuateOneContainedRappeller(
    container: MapEntity,
    targetX: number,
    targetZ: number,
    targetObjectId: number | null,
  ): boolean {
    const isChinookCombatDrop = container.chinookAIProfile !== null
      && this.pendingCombatDropActions.has(container.id);
    for (const passengerId of this.collectContainedEntityIds(container.id)) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (!passenger || passenger.destroyed) continue;
      if (!this.resolveEntityKindOfSet(passenger).has('CAN_RAPPEL')) continue;

      this.releaseEntityFromContainer(passenger);
      passenger.x = container.x;
      passenger.z = container.z;
      passenger.y = Math.max(container.y, this.resolveGroundHeight(passenger.x, passenger.z) + passenger.baseHeight);
      this.updatePathfindPosCell(passenger);

      if (isChinookCombatDrop && container.chinookAIProfile) {
        passenger.objectStatusFlags.add('DISABLED_HELD');
        this.pendingChinookRappels.set(passenger.id, {
          sourceEntityId: container.id,
          targetObjectId,
          targetX,
          targetZ,
          descentSpeedPerFrame: this.resolveChinookRappelSpeedPerFrame(container.chinookAIProfile),
        });
      } else {
        this.issueDroppedPassengerCommand(passenger, targetX, targetZ, targetObjectId);
      }
      return true;
    }
    return false;
  }

  private evacuateContainedEntities(
    container: MapEntity,
    targetX: number,
    targetZ: number,
    targetObjectId: number | null,
  ): void {
    const passengerIds = this.collectContainedEntityIds(container.id);
    if (passengerIds.length === 0) {
      return;
    }

    for (const passengerId of passengerIds) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (!passenger || passenger.destroyed) {
        continue;
      }

      this.releaseEntityFromContainer(passenger);
      passenger.x = container.x;
      passenger.z = container.z;
      passenger.y = this.resolveGroundHeight(passenger.x, passenger.z) + passenger.baseHeight;
      this.updatePathfindPosCell(passenger);

      this.issueDroppedPassengerCommand(passenger, targetX, targetZ, targetObjectId);
    }
  }

  private issueDroppedPassengerCommand(
    passenger: MapEntity,
    targetX: number,
    targetZ: number,
    targetObjectId: number | null,
  ): void {
    const target = targetObjectId !== null ? this.spawnedEntities.get(targetObjectId) : null;
    if (
      target
      && !target.destroyed
      && this.getTeamRelationship(passenger, target) === RELATIONSHIP_ENEMIES
    ) {
      this.issueAttackEntity(passenger.id, target.id, 'PLAYER');
      if (passenger.attackTargetEntityId === null && passenger.canMove) {
        this.issueMoveTo(passenger.id, targetX, targetZ);
      }
      return;
    }

    if (passenger.canMove) {
      this.issueMoveTo(passenger.id, targetX, targetZ);
    }
  }

  private queueUnitProduction(entityId: number, unitTemplateName: string): boolean {
    const producer = this.spawnedEntities.get(entityId);
    if (!producer || producer.destroyed) {
      return false;
    }
    const productionProfile = producer.productionProfile;
    if (!productionProfile) {
      return false;
    }
    if (producer.productionQueue.length >= productionProfile.maxQueueEntries) {
      return false;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }
    const unitDef = findObjectDefByName(registry, unitTemplateName);
    if (!unitDef) {
      return false;
    }

    const producerSide = this.resolveEntityOwnerSide(producer);
    if (!producerSide) {
      return false;
    }
    if (this.isEntityScriptFactoryDisabled(producer)) {
      return false;
    }

    if (!this.canSideBuildUnitTemplate(producerSide, unitDef)) {
      return false;
    }
    if (!this.canEntityIssueBuildCommandForTemplate(producer, unitDef.name, ['UNIT_BUILD', 'DOZER_CONSTRUCT'])) {
      return false;
    }

    // Source parity: buildability/queue-limit checks must happen before spending money.
    const normalizedTemplateName = unitDef.name;
    const maxSimultaneousOfType = this.resolveMaxSimultaneousOfType(unitDef);
    if (maxSimultaneousOfType > 0) {
      const existingCount = this.countActiveEntitiesForMaxSimultaneousForSide(producerSide, unitDef);
      const queuedCount = this.isStructureObjectDef(unitDef)
        ? 0
        : this.countQueuedUnitsForMaxSimultaneousForSide(producerSide, unitDef);
      if (existingCount + queuedCount >= maxSimultaneousOfType) {
        return false;
      }
    }

    if (!this.hasAvailableParkingSpaceFor(producer, unitDef)) {
      return false;
    }

    // Source parity subset: build-cost modifiers from COSTMODIFIERUPGRADE are applied,
    // while full player handicap/faction cost tables are still pending ownership porting.
    const buildCost = this.resolveObjectBuildCost(unitDef, producerSide);
    if (buildCost > this.getSideCredits(producerSide)) {
      this.emitEvaEvent('INSUFFICIENT_FUNDS', producerSide, 'own');
      return false;
    }
    const withdrawn = this.withdrawSideCredits(producerSide, buildCost);
    if (withdrawn < buildCost) {
      return false;
    }

    const totalProductionFrames = this.resolveObjectBuildTimeFrames(unitDef);
    const productionQuantityTotal = this.resolveProductionQuantity(producer, normalizedTemplateName);
    const productionId = producer.productionNextId++;

    producer.productionQueue.push({
      type: 'UNIT',
      templateName: normalizedTemplateName,
      productionId,
      buildCost,
      totalProductionFrames,
      framesUnderConstruction: 0,
      percentComplete: 0,
      productionQuantityTotal,
      productionQuantityProduced: 0,
    });

    if (!this.reserveParkingDoorForQueuedUnit(producer, unitDef, productionId)) {
      this.removeProductionEntry(producer, productionId);
      this.depositSideCredits(producerSide, buildCost);
      return false;
    }

    return true;
  }

  private isEntityScriptFactoryDisabled(entity: MapEntity): boolean {
    return this.entityHasObjectStatus(entity, 'SCRIPT_DISABLED')
      || this.entityHasObjectStatus(entity, 'SCRIPT_UNPOWERED');
  }

  private canEntityIssueBuildCommandForTemplate(
    producer: MapEntity,
    templateName: string,
    allowedCommandTypes: readonly string[],
  ): boolean {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }

    // Source parity: BuildAssistant::isPossibleToMakeUnit scans the producer command set
    // for matching UNIT_BUILD/DOZER_CONSTRUCT buttons. Keep permissive fallback while
    // command-set data is absent in narrow tests.
    if (registry.commandSets.size === 0 || registry.commandButtons.size === 0) {
      return true;
    }

    const producerObjectDef = findObjectDefByName(registry, producer.templateName);
    if (!producerObjectDef) {
      return false;
    }
    const commandSetName = this.resolveEntityCommandSetName(producer, producerObjectDef);
    if (!commandSetName) {
      return false;
    }
    const commandSetDef = findCommandSetDefByName(registry, commandSetName);
    if (!commandSetDef) {
      return false;
    }

    const normalizedAllowedTypes = new Set<string>();
    for (const commandType of allowedCommandTypes) {
      normalizedAllowedTypes.add(this.normalizeCommandTypeNameForBuildCheck(commandType));
    }

    for (let buttonSlot = 1; buttonSlot <= 18; buttonSlot += 1) {
      const commandButtonName = readStringField(commandSetDef.fields, [String(buttonSlot)]);
      if (!commandButtonName) {
        continue;
      }

      const commandButtonDef = findCommandButtonDefByName(registry, commandButtonName);
      if (!commandButtonDef) {
        continue;
      }

      const buttonCommandType = this.normalizeCommandTypeNameForBuildCheck(
        commandButtonDef.commandTypeName
        ?? readStringField(commandButtonDef.fields, ['Command'])
        ?? '',
      );
      if (!normalizedAllowedTypes.has(buttonCommandType)) {
        continue;
      }

      const buttonTemplateName = readStringField(commandButtonDef.fields, ['Object'])
        ?? readStringField(commandButtonDef.fields, ['ThingTemplate']);
      if (!buttonTemplateName) {
        continue;
      }

      if (this.areEquivalentTemplateNames(buttonTemplateName, templateName)) {
        return true;
      }
    }

    return false;
  }

  private normalizeCommandTypeNameForBuildCheck(commandTypeName: string): string {
    const normalized = commandTypeName.trim().toUpperCase();
    if (!normalized) {
      return '';
    }
    if (normalized.startsWith('GUI_COMMAND_')) {
      return normalized.slice('GUI_COMMAND_'.length);
    }
    return normalized;
  }

  /**
   * Extract all template names producible via command set buttons of the given command types.
   * Source parity subset: scans the entity's command set for UNIT_BUILD / DOZER_CONSTRUCT /
   * PLAYER_UPGRADE buttons and returns the associated Object / Upgrade names.
   */
  private collectCommandSetTemplates(
    entity: MapEntity,
    allowedCommandTypes: readonly string[],
  ): string[] {
    const registry = this.iniDataRegistry;
    if (!registry) return [];

    const producerObjectDef = findObjectDefByName(registry, entity.templateName);
    if (!producerObjectDef) return [];

    const commandSetName = this.resolveEntityCommandSetName(entity, producerObjectDef);
    if (!commandSetName) return [];

    const commandSetDef = findCommandSetDefByName(registry, commandSetName);
    if (!commandSetDef) return [];

    const normalizedAllowedTypes = new Set<string>();
    for (const commandType of allowedCommandTypes) {
      normalizedAllowedTypes.add(this.normalizeCommandTypeNameForBuildCheck(commandType));
    }

    const result: string[] = [];
    for (let buttonSlot = 1; buttonSlot <= 18; buttonSlot += 1) {
      const commandButtonName = readStringField(commandSetDef.fields, [String(buttonSlot)]);
      if (!commandButtonName) continue;

      const commandButtonDef = findCommandButtonDefByName(registry, commandButtonName);
      if (!commandButtonDef) continue;

      const buttonCommandType = this.normalizeCommandTypeNameForBuildCheck(
        commandButtonDef.commandTypeName
        ?? readStringField(commandButtonDef.fields, ['Command'])
        ?? '',
      );
      if (!normalizedAllowedTypes.has(buttonCommandType)) continue;

      const templateName =
        readStringField(commandButtonDef.fields, ['Object'])
        ?? readStringField(commandButtonDef.fields, ['ThingTemplate'])
        ?? readStringField(commandButtonDef.fields, ['Upgrade']);
      if (templateName) {
        result.push(templateName);
      }
    }
    return result;
  }

  private hasAvailableParkingSpaceFor(producer: MapEntity, unitDef: ObjectDef): boolean {
    if (!this.shouldReserveParkingDoorWhenQueued(unitDef)) {
      return true;
    }

    return hasAvailableParkingSpaceImpl(
      producer.parkingPlaceProfile,
      producer.productionQueue,
      this.spawnedEntities,
    );
  }

  private shouldReserveParkingDoorWhenQueued(unitDef: ObjectDef): boolean {
    return shouldReserveParkingDoorWhenQueuedImpl(unitDef.kindOf);
  }

  private reserveParkingDoorForQueuedUnit(
    producer: MapEntity,
    unitDef: ObjectDef,
    productionId: number,
  ): boolean {
    if (!this.shouldReserveParkingDoorWhenQueued(unitDef)) {
      return true;
    }

    return reserveParkingDoorForQueuedUnitImpl(
      producer.parkingPlaceProfile,
      producer.productionQueue,
      this.spawnedEntities,
      productionId,
    );
  }

  private releaseParkingDoorReservationForProduction(producer: MapEntity, productionId: number): void {
    releaseParkingDoorReservationForProductionImpl(producer.parkingPlaceProfile, productionId);
  }

  private canSideBuildUnitTemplate(side: string, unitDef: ObjectDef): boolean {
    const buildableStatus = this.resolveBuildableStatus(unitDef);
    if (buildableStatus === 'NO') {
      return false;
    }
    if (buildableStatus === 'ONLY_BY_AI' && this.getSidePlayerType(side) !== 'COMPUTER') {
      return false;
    }
    if (buildableStatus === 'IGNORE_PREREQUISITES') {
      return true;
    }

    for (const prereqGroup of this.extractProductionPrerequisiteGroups(unitDef)) {
      if (prereqGroup.objectAlternatives.length > 0) {
        let objectSatisfied = false;
        for (const alternativeName of prereqGroup.objectAlternatives) {
          if (this.countActiveEntitiesOfTemplateForSide(side, alternativeName) > 0) {
            objectSatisfied = true;
            break;
          }
        }
        if (!objectSatisfied) {
          return false;
        }
      }

      if (prereqGroup.scienceRequirements.length > 0) {
        for (const requiredScience of prereqGroup.scienceRequirements) {
          if (!this.hasSideScience(side, requiredScience)) {
            return false;
          }
        }
      }
    }

    return true;
  }

  private resolveBuildableStatus(objectDef: ObjectDef): 'YES' | 'IGNORE_PREREQUISITES' | 'NO' | 'ONLY_BY_AI' {
    return resolveBuildableStatusImpl(objectDef, (value) => this.extractIniValueTokens(value));
  }

  private extractProductionPrerequisiteGroups(objectDef: ObjectDef): ProductionPrerequisiteGroup[] {
    return extractProductionPrerequisiteGroupsImpl(objectDef, (value) => this.extractIniValueTokens(value));
  }

  private getBuildFacilityTemplateNames(): Set<string> {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return new Set<string>();
    }
    if (this.buildFacilityTemplateNamesCache && this.buildFacilityTemplateNamesRegistry === registry) {
      return this.buildFacilityTemplateNamesCache;
    }

    const names = new Set<string>();
    for (const objectDef of registry.objects.values()) {
      for (const prereqGroup of this.extractProductionPrerequisiteGroups(objectDef)) {
        for (const alternativeName of prereqGroup.objectAlternatives) {
          names.add(alternativeName.trim().toUpperCase());
        }
      }
      const kindOf = this.normalizeKindOf(objectDef.kindOf);
      if (kindOf.has('COMMANDCENTER')) {
        names.add(objectDef.name.trim().toUpperCase());
      }
    }

    this.buildFacilityTemplateNamesCache = names;
    this.buildFacilityTemplateNamesRegistry = registry;
    return names;
  }

  private cancelUnitProduction(entityId: number, productionId: number): boolean {
    const producer = this.spawnedEntities.get(entityId);
    if (!producer || producer.destroyed) {
      return false;
    }

    const index = producer.productionQueue.findIndex((entry) => entry.type === 'UNIT' && entry.productionId === productionId);
    if (index < 0) {
      return false;
    }

    const [removed] = producer.productionQueue.splice(index, 1);
    if (removed) {
      const producerSide = this.resolveEntityOwnerSide(producer);
      if (removed.type === 'UNIT') {
        this.releaseParkingDoorReservationForProduction(producer, removed.productionId);
      }
      if (producerSide && removed.type === 'UPGRADE' && removed.upgradeType === 'PLAYER') {
        this.setSideUpgradeInProduction(producerSide, removed.upgradeName, false);
      }
      const refunded = removed.buildCost;
      if (producerSide) {
        this.depositSideCredits(producerSide, refunded);
      }
    }
    return true;
  }

  private queueUpgradeProduction(entityId: number, upgradeName: string): boolean {
    const producer = this.spawnedEntities.get(entityId);
    if (!producer || producer.destroyed) {
      return false;
    }
    const productionProfile = producer.productionProfile;
    if (!productionProfile) {
      return false;
    }
    if (producer.productionQueue.length >= productionProfile.maxQueueEntries) {
      return false;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }
    const upgradeDef = findUpgradeDefByName(registry, upgradeName);
    if (!upgradeDef) {
      return false;
    }

    const normalizedUpgradeName = upgradeDef.name.trim().toUpperCase();
    if (!normalizedUpgradeName || normalizedUpgradeName === 'NONE') {
      return false;
    }

    const producerSide = this.resolveEntityOwnerSide(producer);
    if (!producerSide) {
      return false;
    }

    const upgradeType = resolveUpgradeType(upgradeDef);
    const producerObjectDef = findObjectDefByName(registry, producer.templateName);
    const commandSetName = producerObjectDef
      ? this.resolveEntityCommandSetName(producer, producerObjectDef)
      : null;
    const hasExplicitCommandSet = commandSetName !== null;

    if (producer.productionQueue.some((entry) => entry.type === 'UPGRADE' && entry.upgradeName === normalizedUpgradeName)) {
      return false;
    }

    if (upgradeType === 'PLAYER') {
      if (hasExplicitCommandSet && !this.canEntityProduceUpgrade(producer, upgradeDef)) {
        return false;
      }

      if (this.hasSideUpgradeCompleted(producerSide, normalizedUpgradeName)) {
        return false;
      }
      if (this.hasSideUpgradeInProduction(producerSide, normalizedUpgradeName)) {
        return false;
      }
    } else if (upgradeType === 'OBJECT') {
      // Source parity: OBJECT upgrades usually require a matching command-set button.
      // Some upgrades intentionally change command sets (for example strategy-center command unlocks),
      // so allow queueing when the upgrade explicitly drives a CommandSetUpgrade path for this unit.
      const canTriggerCommandSetUpgrade = this.canUpgradeTriggerCommandSetForEntity(producer, normalizedUpgradeName);
      if (
        !this.canEntityProduceUpgrade(producer, upgradeDef)
        && !canTriggerCommandSetUpgrade
      ) {
        return false;
      }

      if (
        !canTriggerCommandSetUpgrade
        && !this.isEntityAffectedByUpgrade(producer, normalizedUpgradeName)
      ) {
        return false;
      }
      if (producer.completedUpgrades.has(normalizedUpgradeName)) {
        return false;
      }
    }

    const buildCost = resolveUpgradeBuildCost(upgradeDef);
    if (!this.canAffordUpgrade(producerSide, buildCost)) {
      this.emitEvaEvent('INSUFFICIENT_FUNDS', producerSide, 'own');
      return false;
    }
    const withdrawn = this.withdrawSideCredits(producerSide, buildCost);
    if (withdrawn < buildCost) {
      return false;
    }

    const totalProductionFrames = resolveUpgradeBuildTimeFrames(upgradeDef, LOGIC_FRAME_RATE);
    producer.productionQueue.push({
      type: 'UPGRADE',
      upgradeName: normalizedUpgradeName,
      productionId: producer.productionNextId++,
      buildCost,
      totalProductionFrames,
      framesUnderConstruction: 0,
      percentComplete: 0,
      upgradeType,
    });
    if (upgradeType === 'PLAYER') {
      this.setSideUpgradeInProduction(producerSide, normalizedUpgradeName, true);
    }

    return true;
  }

  private canAffordUpgrade(side: string, buildCost: number): boolean {
    // Source parity: UpgradeCenter::canAffordUpgrade in
    // Generals/Code/GameEngine/Source/Common/System/Upgrade.cpp returns false if
    // money < upgradeTemplate->calcCostToBuild(player), and nothing else.
    const normalizedSide = this.normalizeSide(side);
    return canAffordSideCreditsImpl(this.sideCredits, normalizedSide, buildCost);
  }

  private canEntityProduceUpgrade(
    producer: MapEntity,
    upgradeDef: UpgradeDef,
  ): boolean {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return false;
    }

    const producerObjectDef = findObjectDefByName(registry, producer.templateName);
    if (!producerObjectDef) {
      return false;
    }

    // Source parity: Object::canProduceUpgrade() checks the current command set for a
    // command button whose Upgrade field matches the requested upgrade.
    const commandSetName = this.resolveEntityCommandSetName(producer, producerObjectDef);
    if (!commandSetName) {
      // Source: Object::canProduceUpgrade returns false when a producer has no
      // discoverable command set; callers are expected to handle this explicitly.
      return false;
    }

    const commandSetDef = findCommandSetDefByName(registry, commandSetName);
    if (!commandSetDef) {
      return false;
    }

    const normalizedUpgradeName = upgradeDef.name.trim().toUpperCase();
    if (!normalizedUpgradeName || normalizedUpgradeName === 'NONE') {
      return false;
    }

    for (let buttonSlot = 1; buttonSlot <= 18; buttonSlot += 1) {
      const commandButtonName = readStringField(commandSetDef.fields, [String(buttonSlot)]);
      if (!commandButtonName) {
        continue;
      }

      const commandButtonDef = findCommandButtonDefByName(registry, commandButtonName);
      if (!commandButtonDef) {
        continue;
      }

      const commandUpgradeName = readStringField(commandButtonDef.fields, ['Upgrade'])?.trim().toUpperCase() ?? '';
      if (!commandUpgradeName || commandUpgradeName === 'NONE') {
        continue;
      }
      if (commandUpgradeName === normalizedUpgradeName) {
        return true;
      }
    }

    return false;
  }

  private canUpgradeTriggerCommandSetForEntity(entity: MapEntity, normalizedUpgradeName: string): boolean {
    const target = normalizedUpgradeName.trim().toUpperCase();
    if (!target || target === 'NONE') {
      return false;
    }

    for (const module of entity.upgradeModules) {
      if (module.moduleType !== 'COMMANDSETUPGRADE') {
        continue;
      }

      if (module.sourceUpgradeName === target) {
        return true;
      }
      if (module.triggeredBy.has(target)) {
        return true;
      }
    }

    return false;
  }

  private resolveEntityCommandSetName(entity: MapEntity, objectDef: ObjectDef): string | null {
    if (entity.commandSetStringOverride && entity.commandSetStringOverride !== 'NONE') {
      return entity.commandSetStringOverride;
    }

    const baseCommandSet = readStringField(objectDef.fields, ['CommandSet'])?.trim().toUpperCase() ?? '';
    if (!baseCommandSet || baseCommandSet === 'NONE') {
      return null;
    }
    return baseCommandSet;
  }

  private cancelUpgradeProduction(entityId: number, upgradeName: string): boolean {
    const producer = this.spawnedEntities.get(entityId);
    if (!producer || producer.destroyed) {
      return false;
    }

    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedUpgradeName) {
      return false;
    }

    const index = producer.productionQueue.findIndex(
      (entry) => entry.type === 'UPGRADE' && entry.upgradeName === normalizedUpgradeName,
    );
    if (index < 0) {
      return false;
    }

    const [removed] = producer.productionQueue.splice(index, 1);
    if (!removed || removed.type !== 'UPGRADE') {
      return false;
    }

    const producerSide = this.resolveEntityOwnerSide(producer);
    if (producerSide && removed.upgradeType === 'PLAYER') {
      this.setSideUpgradeInProduction(producerSide, removed.upgradeName, false);
    }
    if (producerSide) {
      this.depositSideCredits(producerSide, removed.buildCost);
    }
    return true;
  }

  private resolveObjectBuildTimeFrames(objectDef: ObjectDef): number {
    const buildTimeSeconds = readNumericField(objectDef.fields, ['BuildTime']) ?? 1;
    if (!Number.isFinite(buildTimeSeconds)) {
      return 0;
    }
    return Math.trunc(buildTimeSeconds * LOGIC_FRAME_RATE);
  }

  private resolveObjectBuildCost(objectDef: ObjectDef, side: string = ''): number {
    const buildCostRaw = readNumericField(objectDef.fields, ['BuildCost']) ?? 0;
    if (!Number.isFinite(buildCostRaw)) {
      return 0;
    }
    const normalizedSide = this.normalizeSide(side);
    const nextCost = this.applyKindOfProductionCostModifiers(buildCostRaw, normalizedSide, this.normalizeKindOf(objectDef.kindOf));
    return Math.max(0, Math.trunc(nextCost));
  }

  private resolveMaxSimultaneousOfType(objectDef: ObjectDef): number {
    return resolveMaxSimultaneousOfTypeImpl(objectDef, this.config.superweaponRestriction);
  }

  private isStructureObjectDef(objectDef: ObjectDef): boolean {
    return isStructureObjectDefImpl(objectDef);
  }

  private doesTemplateMatchMaxSimultaneousType(targetObjectDef: ObjectDef, candidateTemplateName: string): boolean {
    const registry = this.iniDataRegistry;
    return doesTemplateMatchMaxSimultaneousTypeImpl(
      targetObjectDef,
      candidateTemplateName,
      (leftTemplateName, rightTemplateName) => this.areEquivalentTemplateNames(leftTemplateName, rightTemplateName),
      (templateName) => (registry ? findObjectDefByName(registry, templateName) : undefined),
    );
  }

  private countActiveEntitiesForMaxSimultaneousForSide(side: string, targetObjectDef: ObjectDef): number {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return 0;
    }

    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      if (!this.doesTemplateMatchMaxSimultaneousType(targetObjectDef, entity.templateName)) {
        continue;
      }
      count += 1;
    }

    return count;
  }

  private countQueuedUnitsForMaxSimultaneousForSide(side: string, targetObjectDef: ObjectDef): number {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return 0;
    }

    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      for (const queueEntry of entity.productionQueue) {
        if (queueEntry.type !== 'UNIT') {
          continue;
        }
        if (this.doesTemplateMatchMaxSimultaneousType(targetObjectDef, queueEntry.templateName)) {
          count += 1;
        }
      }
    }

    return count;
  }

  private areEquivalentTemplateNames(leftTemplateName: string, rightTemplateName: string): boolean {
    const registry = this.iniDataRegistry;
    return areEquivalentTemplateNamesImpl(
      leftTemplateName,
      rightTemplateName,
      (templateName) => (registry ? findObjectDefByName(registry, templateName) : undefined),
      (value) => this.extractIniValueTokens(value),
    );
  }

  private countActiveEntitiesOfTemplateForSide(side: string, templateName: string): number {
    const normalizedSide = this.normalizeSide(side);
    const normalizedTemplateName = templateName.trim().toUpperCase();
    if (!normalizedSide || !normalizedTemplateName) {
      return 0;
    }

    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      if (!this.areEquivalentTemplateNames(entity.templateName, normalizedTemplateName)) {
        continue;
      }
      count += 1;
    }

    return count;
  }

  private resolveProductionQuantity(producer: MapEntity, templateName: string): number {
    return resolveProductionQuantityImpl(
      producer.productionProfile?.quantityModifiers,
      templateName,
      (leftTemplateName, rightTemplateName) => this.areEquivalentTemplateNames(leftTemplateName, rightTemplateName),
    );
  }

  private updateProduction(): void {
    for (const producer of this.spawnedEntities.values()) {
      if (producer.destroyed || producer.productionProfile === null) {
        continue;
      }

      this.updateQueueExitGate(producer);

      const production = producer.productionQueue[0];
      if (!production) {
        continue;
      }

      // Source parity: ThingTemplate::calcTimeToBuild — low power slows production.
      let productionRate = 1;
      const producerSide = this.normalizeSide(producer.side);
      if (producerSide) {
        const powerState = this.getSidePowerStateMap(producerSide);
        const totalProd = powerState.energyProduction + powerState.powerBonus;
        if (powerState.energyConsumption > 0 && totalProd < powerState.energyConsumption) {
          const energyPercent = totalProd / powerState.energyConsumption;
          const energyShort = Math.min(1, 1 - energyPercent);
          // m_LowEnergyPenaltyModifier = 0.4 from GlobalData
          productionRate = Math.max(0.2, 1 - energyShort * 0.4);
        }
      }
      production.framesUnderConstruction += productionRate;
      if (production.totalProductionFrames <= 0) {
        production.percentComplete = 100;
      } else {
        production.percentComplete = (production.framesUnderConstruction / production.totalProductionFrames) * 100;
      }

      if (production.percentComplete < 100) {
        continue;
      }

      if (production.type === 'UNIT') {
        this.completeUnitProduction(producer, production);
      } else if (production.type === 'UPGRADE') {
        this.completeUpgradeProduction(producer, production);
      }
    }
  }

  private updateQueueExitGate(producer: MapEntity): void {
    tickQueueExitGateImpl(producer);
  }

  private completeUnitProduction(producer: MapEntity, production: UnitProductionQueueEntry): void {
    if (!producer.queueProductionExitProfile) {
      this.removeProductionEntry(producer, production.productionId);
      return;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      this.removeProductionEntry(producer, production.productionId);
      return;
    }

    const unitDef = findObjectDefByName(registry, production.templateName);
    if (!unitDef) {
      this.removeProductionEntry(producer, production.productionId);
      return;
    }

    let shouldRemoveEntry = false;
    while (production.productionQuantityProduced < production.productionQuantityTotal) {
      const canExit = producer.queueProductionExitBurstRemaining > 0
        || producer.queueProductionExitDelayFramesRemaining === 0;
      if (!canExit) {
        break;
      }

      if (!this.canExitProducedUnitViaParking(producer, unitDef, production.productionId)) {
        break;
      }

      const produced = this.spawnProducedUnit(producer, unitDef, production.productionId);
      if (!produced) {
        shouldRemoveEntry = true;
        break;
      }

      production.productionQuantityProduced += 1;
      producer.queueProductionExitDelayFramesRemaining = producer.queueProductionExitProfile.exitDelayFrames;
      if (producer.queueProductionExitBurstRemaining > 0) {
        producer.queueProductionExitBurstRemaining -= 1;
      }
    }

    if (shouldRemoveEntry || production.productionQuantityProduced >= production.productionQuantityTotal) {
      this.removeProductionEntry(producer, production.productionId);
    }
  }

  private completeUpgradeProduction(producer: MapEntity, production: UpgradeProductionQueueEntry): void {
    const producerSide = this.resolveEntityOwnerSide(producer);
    if (production.upgradeType === 'PLAYER') {
      if (!producerSide) {
        this.removeProductionEntry(producer, production.productionId);
        return;
      }
      this.setSideUpgradeInProduction(producerSide, production.upgradeName, false);
      this.setSideUpgradeCompleted(producerSide, production.upgradeName, true);
      this.applyCompletedPlayerUpgrade(producerSide, production.upgradeName);
    } else {
      this.applyUpgradeToEntity(producer.id, production.upgradeName);
    }

    if (producerSide) {
      this.recordScriptCompletedUpgradeEvent(producerSide, production.upgradeName, producer.id);
    }

    // Source parity: Eva UPGRADE_COMPLETE fires when an upgrade finishes research.
    const upgradeSide = producerSide ?? producer.side;
    if (upgradeSide) {
      this.emitEvaEvent('UPGRADE_COMPLETE', upgradeSide, 'own', producer.id, production.upgradeName);
    }

    this.removeProductionEntry(producer, production.productionId);
  }

  private applyCompletedPlayerUpgrade(side: string, upgradeName: string): void {
    const normalizedSide = this.normalizeSide(side);
    if (!normalizedSide) {
      return;
    }

    const normalizedUpgradeName = upgradeName.trim().toUpperCase();
    if (!normalizedUpgradeName || normalizedUpgradeName === 'NONE') {
      return;
    }

    const registry = this.iniDataRegistry;
    if (registry) {
      const upgradeDef = findUpgradeDefByName(registry, normalizedUpgradeName);
      if (upgradeDef) {
        for (const module of this.extractUpgradeModulesFromBlocks(
          upgradeDef.blocks ?? [],
          normalizedUpgradeName,
        )) {
          if (module.moduleType === 'COSTMODIFIERUPGRADE') {
            // Source parity: COSTMODIFIERUPGRADE.cpp routes to
            // Player::addKindOfProductionCostChange on upgrade completion.
            this.applyCostModifierUpgradeToSide(normalizedSide, module);
          } else if (module.moduleType === 'GRANTSCIENCEUPGRADE') {
            // Source parity: GrantScienceUpgrade.cpp grants configured science at upgrade completion.
            this.grantSideScience(normalizedSide, module.grantScienceName);
          }
        }
      }
    }

    for (const entity of this.spawnedEntities.values()) {
      if (this.normalizeSide(entity.side) !== normalizedSide) {
        continue;
      }
      if (entity.destroyed) {
        continue;
      }
      // Skip side-global modules to avoid reapplying once per entity.
      this.executePendingUpgradeModules(entity.id, entity, true);
    }
  }

  private removeProductionEntry(producer: MapEntity, productionId: number): void {
    const index = producer.productionQueue.findIndex((entry) => entry.productionId === productionId);
    if (index >= 0) {
      const [removed] = producer.productionQueue.splice(index, 1);
      if (removed?.type === 'UNIT') {
        this.releaseParkingDoorReservationForProduction(producer, removed.productionId);
      }
    }
  }

  private canExitProducedUnitViaParking(
    producer: MapEntity,
    unitDef: ObjectDef,
    productionId: number,
  ): boolean {
    if (!this.shouldReserveParkingDoorWhenQueued(unitDef)) {
      return true;
    }

    return canExitProducedUnitViaParkingImpl(
      producer.parkingPlaceProfile,
      producer.productionQueue,
      this.spawnedEntities,
      productionId,
    );
  }

  /**
   * Spawn a new entity from a template name at the given world position.
   * Used by pilot eject and OCL pipeline.
   */
  private spawnEntityFromTemplate(
    templateName: string,
    worldX: number,
    worldZ: number,
    rotationY: number,
    side?: string,
  ): MapEntity | null {
    const registry = this.iniDataRegistry;
    if (!registry) return null;
    const objectDef = findObjectDefByName(registry, templateName);
    if (!objectDef) return null;

    const mapObject: MapObjectJSON = {
      templateName: objectDef.name,
      angle: THREE.MathUtils.radToDeg(rotationY),
      flags: 0,
      position: { x: worldX, y: worldZ, z: 0 },
      properties: {},
    };
    const entity = this.createMapEntity(mapObject, objectDef, registry, this.mapHeightmap);
    if (side !== undefined) {
      entity.side = side;
    }
    // Inherit controlling player from side.
    if (side) {
      entity.controllingPlayerToken = this.normalizeControllingPlayerToken(side);
    }
    this.addEntityToWorld(entity);
    this.registerEntityEnergy(entity);
    this.initializeMinefieldState(entity);
    this.registerTunnelEntity(entity);
    // Snap to terrain.
    if (this.mapHeightmap) {
      entity.y = this.mapHeightmap.getInterpolatedHeight(worldX, worldZ) ?? 0;
    }
    return entity;
  }

  private spawnProducedUnit(producer: MapEntity, unitDef: ObjectDef, productionId: number): MapEntity | null {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return null;
    }

    const spawnLocation = this.resolveQueueSpawnLocation(producer);
    if (!spawnLocation) {
      return null;
    }

    const mapObject: MapObjectJSON = {
      templateName: unitDef.name,
      angle: THREE.MathUtils.radToDeg(producer.rotationY),
      flags: 0,
      position: {
        x: spawnLocation.x,
        y: spawnLocation.z,
        z: spawnLocation.heightOffset,
      },
      properties: {},
    };
    const created = this.createMapEntity(mapObject, unitDef, registry, this.mapHeightmap);
    if (producer.side !== undefined) {
      created.side = producer.side;
    }
    created.controllingPlayerToken = producer.controllingPlayerToken;
    // Source parity: Object::m_producerID — track who created this unit (for UpgradeDie).
    created.producerEntityId = producer.id;

    if (!this.reserveParkingSpaceForProducedUnit(producer, created, unitDef, productionId)) {
      return null;
    }

    this.addEntityToWorld(created);
    this.registerEntityEnergy(created);
    this.initializeMinefieldState(created);
    this.registerTunnelEntity(created);
    this.applyQueueProductionExitPath(producer, created);

    // Source parity: Eva UNIT_READY fires when a unit exits the production queue.
    if (created.side) {
      this.emitEvaEvent('UNIT_READY', created.side, 'own', created.id, unitDef.name);
    }

    return created;
  }

  private reserveParkingSpaceForProducedUnit(
    producer: MapEntity,
    producedUnit: MapEntity,
    producedUnitDef: ObjectDef,
    productionId: number,
  ): boolean {
    if (!this.shouldReserveParkingDoorWhenQueued(producedUnitDef)) {
      return true;
    }

    if (!reserveParkingSpaceForProducedUnitImpl(
      producer.parkingPlaceProfile,
      producer.productionQueue,
      this.spawnedEntities,
      productionId,
      producedUnit.id,
    )) {
      return false;
    }

    producedUnit.parkingSpaceProducerId = producer.id;
    if (producer.containProfile?.moduleType === 'HELIX') {
      const producedKindOf = this.resolveEntityKindOfSet(producedUnit);
      if (producedKindOf.has('PORTABLE_STRUCTURE')) {
        const allowedPortableTemplates = producer.containProfile.portableStructureTemplateNames;
        const producedTemplateName = producedUnit.templateName.toUpperCase();
        const isTemplateAllowed =
          !allowedPortableTemplates || allowedPortableTemplates.length === 0 || allowedPortableTemplates.includes(producedTemplateName);
        // Source parity: HelixContain::addToContain/addToContainList only set
        // m_portableStructureID when it is INVALID_ID (first portable only).
        // (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Contain/HelixContain.cpp:252,270)
        if (producer.helixPortableRiderId === null && isTemplateAllowed) {
          producer.helixPortableRiderId = producedUnit.id;
        }
        producedUnit.helixCarrierId = producer.id;
      }
    }
    return true;
  }

  private resolveQueueSpawnLocation(producer: MapEntity): {
    x: number;
    z: number;
    heightOffset: number;
  } | null {
    return resolveQueueSpawnLocationImpl(producer, this.mapHeightmap);
  }

  /**
   * Source parity: DefaultProductionExitUpdate::exitObjectViaDoor —
   * builds an exit path: natural rally point first, then player rally
   * point.  The produced unit follows the full path in order.
   */
  private applyQueueProductionExitPath(producer: MapEntity, producedUnit: MapEntity): void {
    // Source parity: aircraft with JetAIUpdate skip normal exit pathing.
    // They stay PARKED at the airfield and await commands.
    if (producedUnit.jetAIProfile && producedUnit.jetAIState) {
      producedUnit.jetAIState.state = 'PARKED';
      producedUnit.jetAIState.allowAirLoco = false;
      producedUnit.jetAIState.producerX = producer.x;
      producedUnit.jetAIState.producerZ = producer.z;
      producedUnit.producerEntityId = producer.id;
      producedUnit.objectStatusFlags.delete('AIRBORNE_TARGET');
      return;
    }

    // Source parity: C++ only appends player rally point for ground-moving
    // units (ai->isDoingGroundMovement()).  Aircraft skip the rally point.
    const isGroundMover = !producedUnit.kindOf.has('AIRCRAFT');
    const exitPath = resolveQueueProductionExitPathImpl(
      producer,
      producedUnit.canMove,
      MAP_XY_FACTOR,
      isGroundMover,
    );
    if (exitPath.length === 0) {
      return;
    }
    // Issue moveTo to the first waypoint (natural rally point).
    this.issueMoveTo(producedUnit.id, exitPath[0]!.x, exitPath[0]!.z);
    // Append any additional waypoints (player rally point) to the path.
    if (exitPath.length > 1 && producedUnit.moving) {
      for (let i = 1; i < exitPath.length; i++) {
        producedUnit.movePath.push(exitPath[i]!);
      }
    }
  }

  private withdrawSideCredits(side: string | undefined, amount: number): number {
    const normalizedSide = this.normalizeSide(side);
    return withdrawSideCreditsImpl(this.sideCredits, normalizedSide, amount);
  }

  private depositSideCredits(side: string | undefined, amount: number): void {
    const normalizedSide = this.normalizeSide(side);
    depositSideCreditsImpl(this.sideCredits, normalizedSide, amount);
  }

  private issueMoveTo(
    entityId: number,
    targetX: number,
    targetZ: number,
    attackDistance = NO_ATTACK_DISTANCE,
    allowNoPathMove = false,
  ): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || !entity.canMove) return;
    // Source parity: Object::isMobile — KINDOF_IMMOBILE or any DISABLED state blocks movement.
    // C++ Object.cpp:2902 — isMobile() returns false when isDisabled() is true (any flag set).
    if (entity.isImmobile || this.isEntityDisabledForMovement(entity)) {
      return;
    }

    // Source parity: airborne aircraft fly point-to-point, skip A* pathfinding.
    const js = entity.jetAIState;
    if (js && js.allowAirLoco) {
      entity.moving = true;
      entity.movePath = [{ x: targetX, z: targetZ }];
      entity.pathIndex = 0;
      entity.moveTarget = { x: targetX, z: targetZ };
      entity.pathfindGoalCell = {
        x: Math.floor(targetX / PATHFIND_CELL_SIZE),
        z: Math.floor(targetZ / PATHFIND_CELL_SIZE),
      };
      return;
    }

    this.updatePathfindPosCell(entity);
    const path = this.findPath(entity.x, entity.z, targetX, targetZ, entity, attackDistance);
    if (path.length === 0) {
      if (allowNoPathMove) {
        entity.moving = true;
        entity.movePath = [{ x: targetX, z: targetZ }];
        entity.pathIndex = 0;
        entity.moveTarget = { x: targetX, z: targetZ };
        entity.pathfindGoalCell = {
          x: Math.floor(targetX / PATHFIND_CELL_SIZE),
          z: Math.floor(targetZ / PATHFIND_CELL_SIZE),
        };
        return;
      }

      entity.moving = false;
      entity.moveTarget = null;
      entity.movePath = [];
      entity.pathIndex = 0;
      entity.pathfindGoalCell = null;
      return;
    }

    entity.moving = true;
    entity.movePath = path;
    entity.pathIndex = 0;
    entity.moveTarget = entity.movePath[0]!;
    this.updatePathfindGoalCellFromPath(entity);
  }

  private setEntityRallyPoint(entityId: number, targetX: number, targetZ: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return;
    }
    entity.rallyPoint = { x: targetX, z: targetZ };
  }

  private issueAttackEntity(
    entityId: number,
    targetEntityId: number,
    commandSource: AttackCommandSource,
  ): void {
    const attacker = this.spawnedEntities.get(entityId);
    const target = this.spawnedEntities.get(targetEntityId);
    if (!attacker || !target) {
      return;
    }
    if (attacker.destroyed || target.destroyed) {
      return;
    }
    const weapon = attacker.attackWeapon;
    if (!weapon || weapon.primaryDamage <= 0) {
      return;
    }
    this.setEntityIgnoringStealthStatus(attacker, weapon.continueAttackRange > 0);
    if (!this.canAttackerTargetEntity(attacker, target, commandSource)) {
      this.setEntityIgnoringStealthStatus(attacker, false);
      return;
    }

    attacker.attackTargetEntityId = targetEntityId;
    attacker.attackOriginalVictimPosition = {
      x: target.x,
      z: target.z,
    };
    attacker.attackCommandSource = commandSource;

    const attackRange = weapon.attackRange;
    if (!attacker.canMove || attackRange <= 0) {
      attacker.moving = false;
      attacker.moveTarget = null;
      attacker.movePath = [];
      attacker.pathIndex = 0;
      attacker.pathfindGoalCell = null;
      return;
    }

    this.issueMoveTo(attacker.id, target.x, target.z, attackRange);
  }

  /**
   * Source parity: TransportAIUpdate::privateAttackObject — when a transport receives a
   * player-issued attack, propagate the attack to all contained passengers that are allowed
   * to fire from inside. (TransportAIUpdate.cpp lines 80-110)
   */
  private propagateTransportAttackToPassengers(
    transport: MapEntity,
    targetEntityId: number,
    commandSource: AttackCommandSource,
  ): void {
    // Source parity: only propagate for player/script commands, not passive acquire.
    // C++ TransportAIUpdate.cpp:74 — CMD_FROM_PLAYER || CMD_FROM_SCRIPT.
    if (commandSource !== 'PLAYER' && commandSource !== 'SCRIPT') return;
    const cp = transport.containProfile;
    if (!cp || !cp.passengersAllowedToFire) return;

    const target = this.spawnedEntities.get(targetEntityId);
    if (!target || target.destroyed) return;

    for (const passengerId of this.collectContainedEntityIds(transport.id)) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (!passenger || passenger.destroyed) continue;
      if (!passenger.attackWeapon || passenger.attackWeapon.primaryDamage <= 0) continue;

      // Source parity: skip disabled PORTABLE_STRUCTURE passengers (TransportAIUpdate.cpp:93-101).
      const kindOf = this.resolveEntityKindOfSet(passenger);
      if (kindOf.has('PORTABLE_STRUCTURE')) {
        if (
          this.entityHasObjectStatus(passenger, 'DISABLED_HACKED')
          || this.entityHasObjectStatus(passenger, 'DISABLED_EMP')
          || this.entityHasObjectStatus(passenger, 'DISABLED_SUBDUED')
          || this.entityHasObjectStatus(passenger, 'DISABLED_PARALYZED')
        ) {
          continue;
        }
      }

      if (!this.isPassengerAllowedToFireFromContainingObject(passenger, transport)) continue;

      // Set attack target directly — contained passengers don't move toward the target.
      passenger.attackTargetEntityId = targetEntityId;
      passenger.attackOriginalVictimPosition = { x: target.x, z: target.z };
      passenger.attackCommandSource = commandSource;
    }
  }

  private issueFireWeapon(
    entityId: number,
    weaponSlot: number,
    maxShotsToFire: number,
    targetObjectId: number | null,
    targetPosition: readonly [number, number, number] | null,
  ): void {
    const attacker = this.spawnedEntities.get(entityId);
    if (!attacker || attacker.destroyed) {
      return;
    }

    const normalizedWeaponSlot = this.normalizeWeaponSlot(Math.trunc(weaponSlot));
    if (normalizedWeaponSlot === null) {
      return;
    }
    attacker.forcedWeaponSlot = normalizedWeaponSlot;
    this.refreshEntityCombatProfiles(attacker);

    const weapon = attacker.attackWeapon;
    if (!weapon || weapon.primaryDamage <= 0) {
      return;
    }

    this.setEntityIgnoringStealthStatus(attacker, weapon.continueAttackRange > 0);
    attacker.attackCommandSource = 'PLAYER';
    attacker.attackTargetEntityId = null;
    attacker.attackOriginalVictimPosition = null;
    attacker.attackTargetPosition = null;
    attacker.preAttackFinishFrame = 0;

    // Source parity: MSG_DO_WEAPON sets a temporary weapon lock and shot counter.
    attacker.weaponLockStatus = 'LOCKED_TEMPORARILY';
    attacker.maxShotsRemaining = maxShotsToFire > 0 ? maxShotsToFire : 0;
    if (maxShotsToFire <= 0) {
      return;
    }

    if (targetObjectId !== null) {
      this.issueAttackEntity(entityId, targetObjectId, 'PLAYER');
      return;
    }

    if (targetPosition === null) {
      return;
    }

    const [targetX, , targetZ] = targetPosition;
    attacker.attackTargetPosition = { x: targetX, z: targetZ };

    // Source behavior for MSG_DO_WEAPON_AT_LOCATION sends a target location while some
    // commands also append an object ID for obstacle awareness. We only have positional
    // targeting here and select a victim dynamically from command-local state.
    const targetEntity = this.findFireWeaponTargetForPosition(attacker, targetX, targetZ);
    if (!targetEntity) {
      const attackRange = Math.max(0, weapon.attackRange);
      if (attacker.canMove) {
        this.issueMoveTo(entityId, targetX, targetZ, attackRange);
      }
      return;
    }
    this.issueAttackEntity(entityId, targetEntity.id, 'PLAYER');
  }

  /**
   * Source parity: FireWeaponPower::doSpecialPowerAtLocation — reloads ammo and
   * issues ai->aiAttackPosition(loc, maxShotsToFire, CMD_FROM_AI).
   */
  private issueFireWeaponAtPosition(
    entityId: number,
    targetX: number,
    targetZ: number,
    maxShotsToFire: number,
  ): void {
    const attacker = this.spawnedEntities.get(entityId);
    if (!attacker || attacker.destroyed) {
      return;
    }

    // Source parity: FireWeaponPower.cpp checks self->isDisabled() and returns early.
    if (attacker.objectStatusFlags.has('DISABLED_EMP')
      || attacker.objectStatusFlags.has('DISABLED_HACKED')
      || attacker.objectStatusFlags.has('DISABLED_SUBDUED')
      || attacker.objectStatusFlags.has('DISABLED_HELD')) {
      return;
    }

    // Source parity: FireWeaponPower reloads all ammo before firing.
    // C++ calls reloadAllAmmo(TRUE) across all weapon slots; we only track one.
    if (attacker.attackWeapon) {
      attacker.attackWeapon.currentClipAmmo = attacker.attackWeapon.clipSize;
    }

    // Issue attack at position using primary weapon slot (0).
    this.issueFireWeapon(entityId, 0, maxShotsToFire, null, [targetX, 0, targetZ]);
  }

  private findFireWeaponTargetForPosition(
    attacker: MapEntity,
    targetX: number,
    targetZ: number,
  ): MapEntity | null {
    const weapon = attacker.attackWeapon;
    if (!weapon) {
      return null;
    }

    const attackRange = Math.max(0, weapon.attackRange);
    const attackRangeSqr = attackRange * attackRange;
    let bestTarget: MapEntity | null = null;
    let bestDistanceSqr = Number.POSITIVE_INFINITY;

    for (const candidate of this.spawnedEntities.values()) {
      if (!candidate.canTakeDamage || candidate.destroyed) {
        continue;
      }
      if (candidate.id === attacker.id) {
        continue;
      }
      if (!this.canAttackerTargetEntity(attacker, candidate, attacker.attackCommandSource)) {
        continue;
      }
      const dx = candidate.x - targetX;
      const dz = candidate.z - targetZ;
      const distanceSqr = dx * dx + dz * dz;
      if (distanceSqr > attackRangeSqr) {
        continue;
      }
      if (distanceSqr >= bestDistanceSqr) {
        continue;
      }
      bestTarget = candidate;
      bestDistanceSqr = distanceSqr;
    }

    return bestTarget;
  }

  private clearAttackTarget(entityId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) {
      return;
    }
    entity.attackTargetEntityId = null;
    entity.attackTargetPosition = null;
    entity.attackOriginalVictimPosition = null;
    entity.attackCommandSource = 'AI';
    // Source parity: AIAttackState::onExit() — clear all attack flags on target release.
    this.setEntityAttackStatus(entity, false);
    entity.preAttackFinishFrame = 0;
    // Source parity: AIAttackState::onExit() — clear leech range mode for all weapons.
    // C++ file: AIStates.cpp:5714 — obj->clearLeechRangeModeForAllWeapons().
    entity.leechRangeActive = false;
    // Source parity: releaseWeaponLock on attack exit — temporary locks are cleared.
    this.releaseTemporaryWeaponLock(entity);
  }

  /**
   * Source parity: when maxShotsToFire is exhausted during combat-update, clear
   * the attack state and release the temporary weapon lock.
   */
  private clearMaxShotsAttackState(entity: MapEntity): void {
    entity.attackTargetEntityId = null;
    entity.attackTargetPosition = null;
    entity.attackOriginalVictimPosition = null;
    entity.attackCommandSource = 'AI';
    entity.maxShotsRemaining = 0;
    this.setEntityAttackStatus(entity, false);
    entity.preAttackFinishFrame = 0;
    this.releaseTemporaryWeaponLock(entity);
  }

  /**
   * Source parity: WeaponSet::releaseWeaponLock — temporary locks are released on
   * attack exit, new commands, or clip exhaustion. Permanent locks persist.
   */
  private releaseTemporaryWeaponLock(entity: MapEntity): void {
    if (entity.weaponLockStatus === 'LOCKED_TEMPORARILY') {
      entity.weaponLockStatus = 'NOT_LOCKED';
      entity.forcedWeaponSlot = null;
      this.refreshEntityCombatProfiles(entity);
    }
  }

  private stopEntity(entityId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity) return;

    this.updatePathfindPosCell(entity);
    entity.moving = false;
    entity.moveTarget = null;
    entity.movePath = [];
    entity.pathIndex = 0;
    entity.pathfindGoalCell = null;
    entity.preAttackFinishFrame = 0;
  }

  private updatePathfindGoalCellFromPath(entity: MapEntity): void {
    updatePathfindGoalCellFromPathImpl(entity, (worldX, worldZ) => this.worldToGrid(worldX, worldZ));
  }

  private updatePathfindPosCell(entity: MapEntity): void {
    updatePathfindPosCellImpl(entity, (worldX, worldZ) => this.worldToGrid(worldX, worldZ));
  }

  private findPath(
    startX: number,
    startZ: number,
    targetX: number,
    targetZ: number,
    mover?: MapEntity,
    attackDistance = NO_ATTACK_DISTANCE,
  ): VectorXZ[] {
    return findPathImpl(
      {
        config: this.config,
        mapHeightmap: this.mapHeightmap,
        navigationGrid: this.navigationGrid,
        spawnedEntities: this.spawnedEntities,
        worldToGrid: (worldX, worldZ) => this.worldToGrid(worldX, worldZ),
        gridFromIndex: (index) => this.gridFromIndex(index),
        gridToWorld: (cellX, cellZ) => this.gridToWorld(cellX, cellZ),
        isCellInBounds: (cellX, cellZ, nav) => this.isCellInBounds(cellX, cellZ, nav ?? this.navigationGrid),
        getTeamRelationship: (sourceEntity, targetEntity) => this.getTeamRelationship(sourceEntity, targetEntity),
        canCrushOrSquish: (sourceEntity, targetEntity) => this.canCrushOrSquish(sourceEntity, targetEntity),
        relationshipAllies: RELATIONSHIP_ALLIES,
      },
      startX,
      startZ,
      targetX,
      targetZ,
      mover,
      attackDistance,
    );
  }

  private buildNavigationGrid(mapData: MapDataJSON | null, heightmap: HeightmapGrid | null): NavigationGrid | null {
    if (!mapData || !heightmap) return null;

    const cellWidth = Math.max(1, heightmap.width - 1);
    const cellHeight = Math.max(1, heightmap.height - 1);
    const borderSize = Math.max(0, Math.floor(heightmap.borderSize));
    const logicalMinX = Math.min(borderSize, Math.max(0, cellWidth - 1));
    const logicalMinZ = Math.min(borderSize, Math.max(0, cellHeight - 1));
    let logicalMaxX = cellWidth - 1 - 2 * borderSize;
    let logicalMaxZ = cellHeight - 1 - 2 * borderSize;
    logicalMaxX = Math.max(logicalMinX, logicalMaxX);
    logicalMaxZ = Math.max(logicalMinZ, logicalMaxZ);

    const total = cellWidth * cellHeight;
    const terrainType = new Uint8Array(total);
    const blocked = new Uint8Array(total);
    const pinched = new Uint8Array(total);
    const bridge = new Uint8Array(total);
    const bridgePassable = new Uint8Array(total);
    const bridgeTransitions = new Uint8Array(total);
    const bridgeSegmentByCell = new Int32Array(total);
    bridgeSegmentByCell.fill(-1);
    this.bridgeSegments.clear();
    this.bridgeSegmentByControlEntity.clear();
    this.resetBridgeDamageStateChanges();

    const waterCells = this.buildWaterCellsFromTriggers(mapData, heightmap, cellWidth, cellHeight);
    const cliffBits = this.tryDecodeMapCliffState(mapData, heightmap);

    for (let z = 0; z < cellHeight; z++) {
      for (let x = 0; x < cellWidth; x++) {
        const index = z * cellWidth + x;
        if (waterCells[index]) {
          terrainType[index] = NAV_WATER;
          continue;
        }

        if (this.isCliffBitSet(cliffBits, x, z)) {
          terrainType[index] = NAV_CLIFF;
        } else {
          const zX1 = Math.min(x + 1, heightmap.width - 1);
          const zZ1 = Math.min(z + 1, heightmap.height - 1);
          const h00 = heightmap.getWorldHeight(x, z);
          const h10 = heightmap.getWorldHeight(zX1, z);
          const h01 = heightmap.getWorldHeight(x, zZ1);
          const h11 = heightmap.getWorldHeight(zX1, zZ1);
          const minHeight = Math.min(h00, h10, h01, h11);
          const maxHeight = Math.max(h00, h10, h01, h11);
          if (maxHeight - minHeight > CLIFF_HEIGHT_DELTA) {
            terrainType[index] = NAV_CLIFF;
          } else {
            terrainType[index] = NAV_CLEAR;
          }
        }
      }
    }

    // Expand cliff zones one cell to mark adjacent passable cells as pinched, then
    // convert those pinched clear cells to cliff and add a second pinched border around
    // every cliff cell, matching the source pathfinder's classifyMap sequence.
    const expand1 = new Uint8Array(total);
    for (let z = 0; z < cellHeight; z++) {
      for (let x = 0; x < cellWidth; x++) {
        const index = z * cellWidth + x;
        if (terrainType[index] !== NAV_CLIFF) {
          continue;
        }
        for (let kx = x - 1; kx <= x + 1; kx++) {
          for (let kz = z - 1; kz <= z + 1; kz++) {
            if (!this.isMapCellInBounds(kx, kz)) {
              continue;
            }
            const nIndex = kz * cellWidth + kx;
            if (terrainType[nIndex] === NAV_CLEAR) {
              expand1[nIndex] = 1;
            }
          }
        }
      }
    }
    for (let i = 0; i < total; i++) {
      if (terrainType[i] === NAV_CLEAR && expand1[i] === 1) {
        pinched[i] = 1;
      }
    }
    for (let i = 0; i < total; i++) {
      if (pinched[i] === 1 && terrainType[i] === NAV_CLEAR) {
        terrainType[i] = NAV_CLIFF;
      }
    }
    for (let z = 0; z < cellHeight; z++) {
      for (let x = 0; x < cellWidth; x++) {
        const index = z * cellWidth + x;
        if (!pinched[index]) {
          continue;
        }
        terrainType[index] = NAV_CLIFF;
        for (let kx = x - 1; kx <= x + 1; kx++) {
          for (let kz = z - 1; kz <= z + 1; kz++) {
            if (!this.isMapCellInBounds(kx, kz)) {
              continue;
            }
            const nIndex = kz * cellWidth + kx;
            if (terrainType[nIndex] === NAV_CLEAR) {
              pinched[nIndex] = 1;
            }
          }
        }
      }
    }

    const grid: NavigationGrid = {
      width: cellWidth,
      height: cellHeight,
      terrainType,
      blocked,
      pinched,
      bridge,
      bridgePassable,
      bridgeTransitions,
      bridgeSegmentByCell,
      zonePassable: new Uint8Array(
        Math.max(1, Math.ceil(cellWidth / PATHFIND_ZONE_BLOCK_SIZE))
        * Math.max(1, Math.ceil(cellHeight / PATHFIND_ZONE_BLOCK_SIZE)),
      ),
      zoneBlockWidth: Math.max(1, Math.ceil(cellWidth / PATHFIND_ZONE_BLOCK_SIZE)),
      zoneBlockHeight: Math.max(1, Math.ceil(cellHeight / PATHFIND_ZONE_BLOCK_SIZE)),
      logicalMinX,
      logicalMinZ,
      logicalMaxX,
      logicalMaxZ,
    };

    for (let i = 0; i < grid.zonePassable.length; i++) {
      grid.zonePassable[i] = 0;
    }

    this.applyBridgeOverlay(mapData, grid);

    for (let z = 0; z < grid.height; z++) {
      for (let x = 0; x < grid.width; x++) {
        const index = z * grid.width + x;
        if (terrainType[index] !== NAV_CLEAR || blocked[index] === 1) {
          continue;
        }

        let totalOpenCount = 0;
        let orthogonalOpenCount = 0;
        for (let kx = x - 1; kx <= x + 1; kx++) {
          for (let kz = z - 1; kz <= z + 1; kz++) {
            if (!this.isMapCellInBounds(kx, kz)) {
              continue;
            }
            if (kx === x && kz === z) {
              continue;
            }
            const adjacentIndex = kz * grid.width + kx;
            if (terrainType[adjacentIndex] === NAV_CLEAR && blocked[adjacentIndex] === 0) {
              totalOpenCount++;
              if (kx === x || kz === z) {
                orthogonalOpenCount++;
              }
            }
          }
        }
        if (orthogonalOpenCount < 2 || totalOpenCount < 4) {
          blocked[index] = 1;
        }
      }
    }

    // Match source behavior: clear cells orthogonally touching obstacles are pinched but not blocked.
    for (let z = 0; z < grid.height; z++) {
      for (let x = 0; x < grid.width; x++) {
        const index = z * grid.width + x;
        if (terrainType[index] !== NAV_CLEAR || blocked[index] === 1) {
          continue;
        }
        let touchesObstacle = false;
        for (let kx = x - 1; kx <= x + 1; kx++) {
          for (let kz = z - 1; kz <= z + 1; kz++) {
            if (!this.isMapCellInBounds(kx, kz)) {
              continue;
            }
            if (kx === x || kz === z) {
              const obstacleIndex = kz * grid.width + kx;
              if (blocked[obstacleIndex] === 1) {
                touchesObstacle = true;
                break;
              }
            }
          }
          if (touchesObstacle) {
            break;
          }
        }
        if (touchesObstacle) {
          pinched[index] = 1;
        }
      }
    }

    for (const entity of this.spawnedEntities.values()) {
      if (!entity.blocksPath || entity.obstacleFootprint <= 0) {
        continue;
      }
      if (entity.obstacleGeometry) {
        this.rasterizeObstacleGeometry(entity, grid);
      } else {
        const footprint = entity.obstacleFootprint;
        const [entityCellX, entityCellZ] = this.worldToGrid(entity.x, entity.z);
        if (entityCellX === null || entityCellZ === null) {
          continue;
        }
        for (let x = entityCellX - footprint; x <= entityCellX + footprint; x++) {
          for (let z = entityCellZ - footprint; z <= entityCellZ + footprint; z++) {
            this.markObstacleCell(x, z, grid);
          }
        }
      }
    }

    for (let z = 0; z < grid.height; z++) {
      for (let x = 0; x < grid.width; x++) {
        const index = z * grid.width + x;
        const terrain = terrainType[index] === NAV_IMPASSABLE || terrainType[index] === NAV_BRIDGE_IMPASSABLE
          ? false
          : blocked[index] !== 1;
        if (!terrain) {
          continue;
        }

        const blockX = Math.floor(x / PATHFIND_ZONE_BLOCK_SIZE);
        const blockY = Math.floor(z / PATHFIND_ZONE_BLOCK_SIZE);
        if (blockX < 0 || blockX >= grid.zoneBlockWidth || blockY < 0 || blockY >= grid.zoneBlockHeight) {
          continue;
        }
        grid.zonePassable[blockY * grid.zoneBlockWidth + blockX] = 1;
      }
    }

    return grid;
  }

  private tryDecodeMapCliffState(mapData: MapDataJSON, heightmap: HeightmapGrid): CliffStateBits | null {
    if (!mapData.cliffStateData) {
      return null;
    }

    const stride = mapData.cliffStateStride ?? Math.floor((heightmap.width + 7) / 8);
    if (!Number.isFinite(stride) || stride <= 0) {
      return null;
    }

    const bytes = base64ToUint8Array(mapData.cliffStateData);
    const requiredLength = heightmap.height * stride;
    if (bytes.length < requiredLength) {
      return null;
    }

    return { data: bytes, stride };
  }

  private isCliffBitSet(cliffBits: CliffStateBits | null, cellX: number, cellZ: number): boolean {
    if (!cliffBits) {
      return false;
    }
    const byteIndex = cellZ * cliffBits.stride + (cellX >> 3);
    if (byteIndex < 0 || byteIndex >= cliffBits.data.length) {
      return false;
    }
    const bitMask = 1 << (cellX & 0x7);
    return (cliffBits.data[byteIndex]! & bitMask) !== 0;
  }

  private applyBridgeOverlay(mapData: MapDataJSON, grid: NavigationGrid): void {
    const starts: Array<{ x: number; z: number; properties: Record<string, string>; entityId: number | null }> = [];
    const ends: Array<{ x: number; z: number; properties: Record<string, string>; entityId: number | null }> = [];

    for (const mapObject of mapData.objects) {
      const flags = mapObject.flags;
      if ((flags & (OBJECT_FLAG_BRIDGE_POINT1 | OBJECT_FLAG_BRIDGE_POINT2)) === 0) {
        continue;
      }

      const cellX = Math.floor(mapObject.position.x / MAP_XY_FACTOR);
      const cellZ = Math.floor(mapObject.position.y / MAP_XY_FACTOR);
      if (!this.isCellInBounds(cellX, cellZ, grid)) {
        continue;
      }

      if ((flags & OBJECT_FLAG_BRIDGE_POINT1) !== 0) {
        starts.push({
          x: cellX,
          z: cellZ,
          properties: mapObject.properties,
          entityId: this.findBridgeControlEntityId(cellX, cellZ, OBJECT_FLAG_BRIDGE_POINT1),
        });
      }
      if ((flags & OBJECT_FLAG_BRIDGE_POINT2) !== 0) {
        ends.push({
          x: cellX,
          z: cellZ,
          properties: mapObject.properties,
          entityId: this.findBridgeControlEntityId(cellX, cellZ, OBJECT_FLAG_BRIDGE_POINT2),
        });
      }
    }

    if (starts.length === 0 || ends.length === 0) {
      return;
    }

    const usedEnds = new Uint8Array(ends.length);
    for (const start of starts) {
      let bestIndex = -1;
      let bestDistance = Number.POSITIVE_INFINITY;
      for (let i = 0; i < ends.length; i++) {
        if (usedEnds[i] === 1) {
          continue;
        }
        const end = ends[i]!;
        const dx = end.x - start.x;
        const dz = end.z - start.z;
        const dist2 = dx * dx + dz * dz;
        if (dist2 < bestDistance) {
          bestDistance = dist2;
          bestIndex = i;
        }
      }

      if (bestIndex < 0) {
        continue;
      }
      const end = ends[bestIndex]!;
      usedEnds[bestIndex] = 1;
      const segmentId = this.bridgeSegments.size;
      const passable = this.resolveInitialBridgePassable(start.properties, end.properties);
      this.markBridgeSegment(start, end, segmentId, passable, grid);
    }
  }

  private findBridgeControlEntityId(cellX: number, cellZ: number, requiredFlag: number): number | null {
    for (const entity of this.spawnedEntities.values()) {
      if (((entity.bridgeFlags ?? 0) & requiredFlag) === 0) {
        continue;
      }
      if (entity.mapCellX === cellX && entity.mapCellZ === cellZ) {
        return entity.id;
      }
    }
    return null;
  }

  private resolveInitialBridgePassable(...propertySets: Array<Record<string, string>>): boolean {
    for (const properties of propertySets) {
      for (const [rawKey, rawValue] of Object.entries(properties)) {
        const key = rawKey.trim().toLowerCase();
        const value = rawValue.trim().toLowerCase();
        if (key.length === 0 || value.length === 0) {
          continue;
        }
        if (!/(bridge|destroy|broken|pass|state|repair|open|close|down|up)/.test(key)) {
          continue;
        }

        if (
          value.includes('down')
          || value.includes('destroyed')
          || value.includes('broken')
          || value.includes('closed')
          || value.includes('disabled')
          || value === '0'
          || value === 'false'
          || value === 'no'
        ) {
          return false;
        }
      }
    }

    return true;
  }

  private markBridgeSegment(
    start: { x: number; z: number; properties: Record<string, string>; entityId: number | null },
    end: { x: number; z: number; properties: Record<string, string>; entityId: number | null },
    segmentId: number,
    passable: boolean,
    grid: NavigationGrid,
  ): void {
    const cellIndices = new Set<number>();
    const transitionIndices = new Set<number>();
    let x = start.x;
    let z = start.z;
    const dx = Math.abs(end.x - start.x);
    const dz = Math.abs(end.z - start.z);
    const stepX = start.x < end.x ? 1 : -1;
    const stepZ = start.z < end.z ? 1 : -1;
    let err = dx - dz;

    while (true) {
      this.markBridgeCellRadius(x, z, 0, segmentId, passable, grid, cellIndices);
      if (x === end.x && z === end.z) {
        break;
      }
      const twoErr = 2 * err;
      if (twoErr > -dz) {
        err -= dz;
        x += stepX;
      }
      if (twoErr < dx) {
        err += dx;
        z += stepZ;
      }
    }

    this.markBridgeTransitionRadius(start.x, start.z, 0, segmentId, passable, grid, transitionIndices);
    this.markBridgeTransitionRadius(end.x, end.z, 0, segmentId, passable, grid, transitionIndices);

    this.bridgeSegments.set(segmentId, {
      passable,
      cellIndices: Array.from(cellIndices),
      transitionIndices: Array.from(transitionIndices),
    });
    if (start.entityId !== null) {
      this.bridgeSegmentByControlEntity.set(start.entityId, segmentId);
    }
    if (end.entityId !== null) {
      this.bridgeSegmentByControlEntity.set(end.entityId, segmentId);
    }
  }

  private markBridgeCellRadius(
    cellX: number,
    cellZ: number,
    radius: number,
    segmentId: number,
    passable: boolean,
    grid: NavigationGrid,
    cellIndices: Set<number>,
  ): void {
    for (let x = cellX - radius; x <= cellX + radius; x++) {
      for (let z = cellZ - radius; z <= cellZ + radius; z++) {
        if (!this.isCellInBounds(x, z, grid)) {
          continue;
        }
        const index = z * grid.width + x;
        const currentSegmentId = grid.bridgeSegmentByCell[index];
        if (currentSegmentId === undefined || currentSegmentId < 0) {
          grid.bridgeSegmentByCell[index] = segmentId;
        }
        grid.bridge[index] = 1;
        if (passable) {
          grid.bridgePassable[index] = 1;
        }
        cellIndices.add(index);
      }
    }
  }

  private markBridgeTransitionRadius(
    cellX: number,
    cellZ: number,
    radius: number,
    segmentId: number,
    passable: boolean,
    grid: NavigationGrid,
    transitionIndices: Set<number>,
  ): void {
    for (let x = cellX - radius; x <= cellX + radius; x++) {
      for (let z = cellZ - radius; z <= cellZ + radius; z++) {
        if (!this.isCellInBounds(x, z, grid)) {
          continue;
        }
        const index = z * grid.width + x;
        if (grid.bridge[index] === 1 && grid.bridgeSegmentByCell[index] === segmentId) {
          if (passable) {
            grid.bridgeTransitions[index] = 1;
          }
          transitionIndices.add(index);
        }
      }
    }
  }

  private buildWaterCellsFromTriggers(
    mapData: MapDataJSON,
    heightmap: HeightmapGrid,
    cellWidth = heightmap.width - 1,
    cellHeight = heightmap.height - 1,
  ): Uint8Array {
    const waterCells = new Uint8Array(cellWidth * cellHeight);
    const waterPolygons = mapData.triggers.filter((trigger) => trigger.isWaterArea || trigger.isRiver)
      .map((trigger) => ({
        points: trigger.points,
        minX: Math.min(...trigger.points.map((point) => point.x)),
        maxX: Math.max(...trigger.points.map((point) => point.x)),
        minZ: Math.min(...trigger.points.map((point) => point.y)),
        maxZ: Math.max(...trigger.points.map((point) => point.y)),
      }));

    for (let z = 0; z < cellHeight; z++) {
      for (let x = 0; x < cellWidth; x++) {
        const index = z * cellWidth + x;
        const worldX0 = x * PATHFIND_CELL_SIZE;
        const worldZ0 = z * PATHFIND_CELL_SIZE;
        const worldX1 = worldX0 + PATHFIND_CELL_SIZE;
        const worldZ1 = worldZ0 + PATHFIND_CELL_SIZE;
        if (
          this.isWaterAt(worldX0, worldZ0, waterPolygons)
          || this.isWaterAt(worldX1, worldZ0, waterPolygons)
          || this.isWaterAt(worldX1, worldZ1, waterPolygons)
          || this.isWaterAt(worldX0, worldZ1, waterPolygons)
        ) {
          waterCells[index] = 1;
        }
      }
    }

    return waterCells;
  }

  private isWaterAt(worldX: number, worldZ: number, polygons: Array<{ points: MapDataJSON['triggers'][number]['points']; minX: number; maxX: number; minZ: number; maxZ: number }>): boolean {
    for (const polygon of polygons) {
      if (worldX < polygon.minX || worldX > polygon.maxX || worldZ < polygon.minZ || worldZ > polygon.maxZ) {
        continue;
      }
      if (pointInPolygon(worldX, worldZ, polygon.points)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Source parity: TerrainLogic::isUnderwater — returns the water surface height at a world
   * position, or null if the position is not over water. Uses cached water polygon trigger data.
   * C++ file: TerrainLogic.cpp lines 2141-2171.
   */
  private getWaterHeightAt(worldX: number, worldZ: number): number | null {
    let bestHeight: number | null = null;
    for (const poly of this.waterPolygonData) {
      if (worldX < poly.minX || worldX > poly.maxX || worldZ < poly.minZ || worldZ > poly.maxZ) {
        continue;
      }
      if (pointInPolygon(worldX, worldZ, poly.points)) {
        // Source parity: C++ getWaterHandle returns the trigger with the highest waterZ.
        if (bestHeight === null || poly.waterHeight >= bestHeight) {
          bestHeight = poly.waterHeight;
        }
      }
    }
    return bestHeight;
  }

  private footprintInCells(
    category: ObjectCategory,
    objectDef?: ObjectDef,
    obstacleGeometry?: ObstacleGeometry | null,
  ): number {
    if (obstacleGeometry) {
      const maxRadius = Math.max(obstacleGeometry.majorRadius, obstacleGeometry.minorRadius);
      return Math.max(1, Math.ceil(maxRadius / MAP_XY_FACTOR));
    }

    const explicitFootprint = readNumericListField(
      objectDef?.fields ?? {},
      ['Footprint', 'FootPrint', 'Foundation', 'Size'],
    );
    if (explicitFootprint !== null) {
      const filtered = explicitFootprint.filter((value) => Number.isFinite(value));
      if (filtered.length === 0) {
        return 0;
      }
      const footprint = Math.max(...filtered);
      return Math.max(1, Math.round(Math.abs(footprint)));
    }

    switch (category) {
      case 'building':
        return 1;
      case 'air':
      case 'vehicle':
      case 'unknown':
      default:
        return 0;
    }
  }

  private resolvePathRadiusAndCenter(
    category: ObjectCategory,
    objectDef?: ObjectDef,
    obstacleGeometry?: ObstacleGeometry | null,
  ): { pathDiameter: number; pathfindCenterInCell: boolean } {
    if (!objectDef) {
      return { pathDiameter: 0, pathfindCenterInCell: true };
    }

    const geometryRadius = this.pathDiameterFromGeometryFields(objectDef);
    let maxRadius = geometryRadius;
    if (maxRadius === null && category === 'building') {
      const explicitFootprint = this.footprintInCells(category, objectDef, null);
      maxRadius = explicitFootprint * (MAP_XY_FACTOR * 0.5);
    }
    if (maxRadius === null) {
      if (obstacleGeometry) {
        maxRadius = Math.max(obstacleGeometry.majorRadius, obstacleGeometry.minorRadius);
      }
    }
    if (maxRadius === null || maxRadius <= 0) {
      return { pathDiameter: 0, pathfindCenterInCell: true };
    }

    let pathDiameter = 2 * maxRadius;
    if (pathDiameter > MAP_XY_FACTOR && pathDiameter < 2 * MAP_XY_FACTOR) {
      pathDiameter = 2 * MAP_XY_FACTOR;
    }

    let iRadius = Math.floor(pathDiameter / MAP_XY_FACTOR + 0.3);
    if (iRadius === 0) {
      iRadius = 1;
    }
    const center = (iRadius & 1) === 1;
    iRadius = Math.floor(iRadius / 2);
    const cappedCenter = iRadius > 2 ? true : center;
    iRadius = Math.min(iRadius, 2);
    if (iRadius <= 0) {
      return { pathDiameter: 0, pathfindCenterInCell: cappedCenter };
    }

    return { pathDiameter: iRadius, pathfindCenterInCell: cappedCenter };
  }

  private pathDiameterFromGeometryFields(objectDef: ObjectDef): number | null {
    const majorRadius = readNumericField(objectDef.fields, ['GeometryMajorRadius', 'MajorRadius']);
    const minorRadius = readNumericField(objectDef.fields, ['GeometryMinorRadius', 'MinorRadius', 'GeometryMajorRadius', 'MajorRadius']);
    if (majorRadius === null || minorRadius === null) {
      return null;
    }
    const resolvedMajor = Math.abs(majorRadius);
    const resolvedMinor = Math.abs(minorRadius);
    const maxRadius = Math.max(resolvedMajor, resolvedMinor);
    return Number.isFinite(maxRadius) ? maxRadius : null;
  }

  private worldToGrid(worldX: number, worldZ: number): [number | null, number | null] {
    if (!this.mapHeightmap) return [null, null];

    const maxWorldX = Math.max(0, this.mapHeightmap.worldWidth - 0.0001);
    const maxWorldZ = Math.max(0, this.mapHeightmap.worldDepth - 0.0001);
    const clampedX = clamp(worldX, 0, maxWorldX);
    const clampedZ = clamp(worldZ, 0, maxWorldZ);
    const gridX = Math.floor(clampedX / MAP_XY_FACTOR);
    const gridZ = Math.floor(clampedZ / MAP_XY_FACTOR);
    if (!this.isMapCellInBounds(gridX, gridZ)) return [null, null];
    return [gridX, gridZ];
  }

  private isMapCellInBounds(cellX: number, cellZ: number): boolean {
    if (!this.mapHeightmap) return false;
    const mapCellWidth = Math.max(1, this.mapHeightmap.width - 1);
    const mapCellHeight = Math.max(1, this.mapHeightmap.height - 1);
    return (
      cellX >= 0 &&
      cellX < mapCellWidth &&
      cellZ >= 0 &&
      cellZ < mapCellHeight
    );
  }

  private isCellInBounds(cellX: number, cellZ: number, nav: NavigationGrid | null = this.navigationGrid): boolean {
    if (!nav) {
      return false;
    }
    return (
      cellX >= 0 &&
      cellX < nav.width &&
      cellZ >= 0 &&
      cellZ < nav.height
    );
  }

  private gridFromIndex(index: number): [number, number] {
    if (!this.navigationGrid) return [0, 0];
    return [index % this.navigationGrid.width, Math.floor(index / this.navigationGrid.width)];
  }

  private gridToWorld(cellX: number, cellZ: number): VectorXZ {
    const halfCell = MAP_XY_FACTOR / 2;
    return {
      x: cellX * MAP_XY_FACTOR + halfCell,
      z: cellZ * MAP_XY_FACTOR + halfCell,
    };
  }

  private pixelToNDC(mouseX: number, mouseY: number, viewportWidth: number, viewportHeight: number): THREE.Vector2 | null {
    if (viewportWidth <= 0 || viewportHeight <= 0) return null;

    const x = (mouseX / viewportWidth) * 2 - 1;
    const y = -(mouseY / viewportHeight) * 2 + 1;
    return new THREE.Vector2(x, y);
  }

  // ── TurretAI implementation ──────────────────────────────────────────────

  /** Source parity: Alignment threshold ~2 degrees (0.035 radians) for turret firing. */
  private static readonly TURRET_ALIGN_THRESHOLD = 0.035;

  /**
   * Source parity: TurretAI::updateTurretAI — per-frame turret rotation.
   * Each turret tracks its current angle and smoothly rotates toward:
   *   - Attack target (if entity is attacking)
   *   - Natural angle (when idle, after recenter delay)
   */
  private updateTurretAI(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.turretProfiles.length === 0) continue;

      for (let ti = 0; ti < entity.turretProfiles.length; ti++) {
        const tp = entity.turretProfiles[ti]!;
        const ts = entity.turretStates[ti];
        if (!ts) continue;
        if (!tp.enabled) continue;

        // Determine if we have a target to aim at.
        let targetAngle: number | null = null;
        if (entity.attackTargetEntityId !== null) {
          const target = this.spawnedEntities.get(entity.attackTargetEntityId);
          if (target && !target.destroyed) {
            // Compute relative angle from entity to target in entity-local space.
            const dx = target.x - entity.x;
            const dz = target.z - entity.z;
            // World angle to target.
            const worldAngle = Math.atan2(dz, dx) + Math.PI / 2;
            // Turret angle is relative to body rotation.
            targetAngle = this.normalizeAngle(worldAngle - entity.rotationY);
          }
        } else if (entity.attackTargetPosition !== null) {
          const dx = entity.attackTargetPosition.x - entity.x;
          const dz = entity.attackTargetPosition.z - entity.z;
          const worldAngle = Math.atan2(dz, dx) + Math.PI / 2;
          targetAngle = this.normalizeAngle(worldAngle - entity.rotationY);
        }

        if (targetAngle !== null) {
          // AIM state — rotate toward target.
          ts.state = 'AIM';
          ts.holdUntilFrame = 0;
          if (tp.turnRate > 0) {
            const angleDiff = this.normalizeAngle(targetAngle - ts.currentAngle);
            if (Math.abs(angleDiff) <= tp.turnRate) {
              ts.currentAngle = targetAngle;
            } else {
              ts.currentAngle = this.normalizeAngle(
                ts.currentAngle + Math.sign(angleDiff) * tp.turnRate,
              );
            }
          } else {
            // Instant rotation.
            ts.currentAngle = targetAngle;
          }
        } else {
          // No target — transition through HOLD → RECENTER → IDLE.
          if (ts.state === 'AIM') {
            // Just lost target — enter hold.
            ts.state = 'HOLD';
            ts.holdUntilFrame = this.frameCounter + tp.recenterTimeFrames;
          }

          if (ts.state === 'HOLD') {
            if (this.frameCounter >= ts.holdUntilFrame) {
              ts.state = 'RECENTER';
            }
          }

          if (ts.state === 'RECENTER') {
            const angleDiff = this.normalizeAngle(tp.naturalAngle - ts.currentAngle);
            // Source parity: recenter at half turn rate (rateModifier = 0.5f).
            const recenterRate = tp.turnRate > 0 ? tp.turnRate * 0.5 : 999;
            if (Math.abs(angleDiff) <= recenterRate) {
              ts.currentAngle = tp.naturalAngle;
              ts.state = 'IDLE';
            } else {
              ts.currentAngle = this.normalizeAngle(
                ts.currentAngle + Math.sign(angleDiff) * recenterRate,
              );
            }
          }
        }
      }
    }
  }

  /**
   * Check whether an entity's turret(s) are aligned enough to fire the given weapon slot.
   * Returns true if no turret controls this slot, or if the controlling turret is aligned.
   */
  private isTurretAlignedForWeaponSlot(entity: MapEntity, weaponSlotIndex: number): boolean {
    for (let ti = 0; ti < entity.turretProfiles.length; ti++) {
      const tp = entity.turretProfiles[ti]!;
      if ((tp.controlledWeaponSlotsMask & (1 << weaponSlotIndex)) === 0) continue;
      // This turret controls this weapon slot.
      if (!tp.enabled) return false;
      if (tp.firesWhileTurning) return true;
      const ts = entity.turretStates[ti];
      if (!ts) return false;
      // Check alignment: turret must be in AIM state and angle must be close to target.
      if (ts.state !== 'AIM') return false;
      // Compute target angle for comparison.
      let targetAngle: number | null = null;
      if (entity.attackTargetEntityId !== null) {
        const target = this.spawnedEntities.get(entity.attackTargetEntityId);
        if (target && !target.destroyed) {
          const dx = target.x - entity.x;
          const dz = target.z - entity.z;
          const worldAngle = Math.atan2(dz, dx) + Math.PI / 2;
          targetAngle = this.normalizeAngle(worldAngle - entity.rotationY);
        }
      } else if (entity.attackTargetPosition !== null) {
        const dx = entity.attackTargetPosition.x - entity.x;
        const dz = entity.attackTargetPosition.z - entity.z;
        const worldAngle = Math.atan2(dz, dx) + Math.PI / 2;
        targetAngle = this.normalizeAngle(worldAngle - entity.rotationY);
      }
      if (targetAngle === null) return false;
      const angleDiff = Math.abs(this.normalizeAngle(targetAngle - ts.currentAngle));
      return angleDiff <= GameLogicSubsystem.TURRET_ALIGN_THRESHOLD;
    }
    // No turret controls this slot — firing is unrestricted.
    return true;
  }

  /** Normalize angle to [-PI, PI]. */
  private normalizeAngle(angle: number): number {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
  }

  private updateCombat(): void {
    updateCombatImpl({
      entities: this.spawnedEntities.values(),
      frameCounter: this.frameCounter,
      constants: {
        attackMinRangeDistanceSqrFudge: ATTACK_MIN_RANGE_DISTANCE_SQR_FUDGE,
        pathfindCellSize: PATHFIND_CELL_SIZE,
      },
      findEntityById: (entityId) => this.spawnedEntities.get(entityId) ?? null,
      findFireWeaponTargetForPosition: (attacker, targetX, targetZ) =>
        this.findFireWeaponTargetForPosition(attacker, targetX, targetZ),
      canEntityAttackFromStatus: (entity) => this.canEntityAttackFromStatus(entity),
      canAttackerTargetEntity: (attacker, target, commandSource) =>
        this.canAttackerTargetEntity(attacker, target, commandSource as AttackCommandSource),
      setEntityAttackStatus: (entity, isAttacking) => this.setEntityAttackStatus(entity, isAttacking),
      setEntityAimingWeaponStatus: (entity, isAiming) => this.setEntityAimingWeaponStatus(entity, isAiming),
      setEntityFiringWeaponStatus: (entity, isFiring) => this.setEntityFiringWeaponStatus(entity, isFiring),
      setEntityIgnoringStealthStatus: (entity, isIgnoringStealth) =>
        this.setEntityIgnoringStealthStatus(entity, isIgnoringStealth),
      refreshEntitySneakyMissWindow: (entity) => this.refreshEntitySneakyMissWindow(entity),
      issueMoveTo: (entityId, targetX, targetZ, attackDistance) =>
        this.issueMoveTo(entityId, targetX, targetZ, attackDistance),
      computeAttackRetreatTarget: (attacker, target, weapon) =>
        this.computeAttackRetreatTarget(attacker, target, weapon as AttackWeaponProfile),
      rebuildEntityScatterTargets: (entity) => this.rebuildEntityScatterTargets(entity),
      resolveWeaponPreAttackDelayFrames: (attacker, target, weapon) =>
        this.resolveWeaponPreAttackDelayFrames(attacker, target, weapon as AttackWeaponProfile),
      queueWeaponDamageEvent: (attacker, target, weapon) =>
        this.queueWeaponDamageEvent(attacker, target, weapon as AttackWeaponProfile),
      recordConsecutiveAttackShot: (attacker, targetEntityId) =>
        this.recordConsecutiveAttackShot(attacker, targetEntityId),
      resolveWeaponDelayFrames: (attacker, weapon) => this.resolveWeaponDelayFramesWithBonus(attacker, weapon as AttackWeaponProfile),
      resolveTargetAnchorPosition: (target) => ({
        x: (target as { mesh?: { position?: { x?: number } } }).mesh?.position?.x ?? target.x,
        z: (target as { mesh?: { position?: { z?: number } } }).mesh?.position?.z ?? target.z,
      }),
      isAttackLineOfSightBlocked: (attackerX, attackerZ, targetX, targetZ) =>
        this.isTerrainLineOfSightBlocked(attackerX, attackerZ, targetX, targetZ),
      clearMaxShotsAttackState: (attacker) =>
        this.clearMaxShotsAttackState(attacker),
      isTurretAlignedForFiring: (attacker) =>
        this.isTurretAlignedForWeaponSlot(attacker, 0), // Primary weapon slot.
    });
  }

  /**
   * Source parity: AIIdleState::update() / AIUpdateInterface::getNextMoodTarget() —
   * idle units scan for nearby enemies and auto-engage. Throttled to every
   * AUTO_TARGET_SCAN_RATE_FRAMES (2 seconds) per entity.
   */
  private updateIdleAutoTargeting(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }

      // Only scan combat-capable entities with weapons.
      if (!entity.attackWeapon) {
        continue;
      }

      // Source parity: skip disabled entities (paralyzed, EMP, hacked, unmanned).
      if (
        this.entityHasObjectStatus(entity, 'DISABLED_PARALYZED') ||
        this.entityHasObjectStatus(entity, 'DISABLED_EMP') ||
        this.entityHasObjectStatus(entity, 'DISABLED_HACKED') ||
        this.entityHasObjectStatus(entity, 'DISABLED_UNMANNED')
      ) {
        continue;
      }

      // Source parity: don't auto-acquire while already attacking or moving.
      if (entity.attackTargetEntityId !== null || entity.attackTargetPosition !== null) {
        continue;
      }
      if (entity.moving) {
        continue;
      }

      // Source parity: parked/reloading aircraft should not auto-acquire targets.
      // C++ JetAI state machine controls command dispatch; grounded jets are inert.
      const autoTargetJs = entity.jetAIState;
      if (autoTargetJs && (autoTargetJs.state === 'PARKED' || autoTargetJs.state === 'RELOAD_AMMO'
        || autoTargetJs.state === 'TAKING_OFF' || autoTargetJs.state === 'LANDING')) {
        continue;
      }

      // Source parity: ActiveBody::shouldRetaliate — skip if using a special ability.
      if (entity.objectStatusFlags.has('IS_USING_ABILITY')) {
        continue;
      }

      // Source parity: AIGuardRetaliate — immediate retaliation when attacked.
      // C++ BodyModule::getClearableLastAttacker() returns the last damage source;
      // guard/idle AI checks this EVERY FRAME and immediately retaliates, bypassing
      // the 2-second auto-target scan interval. This makes units feel responsive.
      if (entity.lastAttackerEntityId !== null) {
        const attackerId = entity.lastAttackerEntityId;
        entity.lastAttackerEntityId = null; // Source parity: clearLastAttacker().
        const attacker = this.spawnedEntities.get(attackerId);
        if (attacker && !attacker.destroyed
            && this.getTeamRelationship(entity, attacker) === RELATIONSHIP_ENEMIES
            && this.canAttackerTargetEntity(entity, attacker, 'AI')
            // Source parity: ActiveBody.cpp lines 783-786 — stealthed units skip
            // retaliation UNLESS they are detected (inside a detector's radius).
            && !(entity.objectStatusFlags.has('STEALTHED') && !entity.objectStatusFlags.has('DETECTED'))) {
          this.issueAttackEntity(entity.id, attacker.id, 'AI');
          continue;
        }
      }

      // Guarding entities use their own scan logic in updateGuardBehavior().
      if (entity.guardState !== 'NONE') {
        continue;
      }

      // Source parity: stealthed units do not auto-acquire targets (would break stealth).
      // C++ gates this on AutoAcquireEnemiesWhenIdle / AAS_Idle_Stealthed flag.
      if (entity.objectStatusFlags.has('STEALTHED')) {
        continue;
      }

      // Throttle scanning to once per AUTO_TARGET_SCAN_RATE_FRAMES.
      if (this.frameCounter < entity.autoTargetScanNextFrame) {
        continue;
      }
      entity.autoTargetScanNextFrame = this.frameCounter + AUTO_TARGET_SCAN_RATE_FRAMES;

      // Source parity: findClosestEnemy — C++ uses vision range for AI-controlled
      // units and weapon range for human-controlled units.
      const weapon = entity.attackWeapon;
      const entitySidePlayerType = this.getSidePlayerType(entity.side);
      const scanRange = entitySidePlayerType === 'HUMAN'
        ? weapon.attackRange
        : Math.max(weapon.attackRange, entity.visionRange);
      const scanRangeSqr = scanRange * scanRange;

      let bestTarget: MapEntity | null = null;
      let bestDistanceSqr = Number.POSITIVE_INFINITY;

      for (const candidate of this.spawnedEntities.values()) {
        if (candidate.destroyed || !candidate.canTakeDamage) {
          continue;
        }
        if (candidate.id === entity.id) {
          continue;
        }
        // Source parity: only auto-target enemies.
        if (this.getTeamRelationship(entity, candidate) !== RELATIONSHIP_ENEMIES) {
          continue;
        }
        // Source parity: stealthed units not auto-acquired unless detected.
        if (
          candidate.objectStatusFlags.has('STEALTHED') &&
          !candidate.objectStatusFlags.has('DETECTED')
        ) {
          continue;
        }
        if (!this.canAttackerTargetEntity(entity, candidate, 'AI')) {
          continue;
        }
        const dx = candidate.x - entity.x;
        const dz = candidate.z - entity.z;
        const distanceSqr = dx * dx + dz * dz;
        if (distanceSqr > scanRangeSqr) {
          continue;
        }
        if (distanceSqr < bestDistanceSqr) {
          bestTarget = candidate;
          bestDistanceSqr = distanceSqr;
        }
      }

      if (bestTarget) {
        this.issueAttackEntity(entity.id, bestTarget.id, 'AI');
      }
    }
  }

  // ── Source parity: AIGuardMachine — guard position/object behavior ──

  /**
   * Initialize guard-position mode for an entity. Moves it to the guard point
   * and enters the RETURNING state (mirrors C++ AIGuardState::onEnter → setState(AI_GUARD_RETURN)).
   */
  private initGuardPosition(entityId: number, targetX: number, targetZ: number, guardMode: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed || !entity.canMove) {
      return;
    }

    const isHuman = this.getSidePlayerType(entity.side) === 'HUMAN';
    const innerMod = isHuman ? GUARD_INNER_MODIFIER_HUMAN : GUARD_INNER_MODIFIER_AI;
    const outerMod = isHuman ? GUARD_OUTER_MODIFIER_HUMAN : GUARD_OUTER_MODIFIER_AI;

    entity.guardState = 'RETURNING';
    entity.guardPositionX = targetX;
    entity.guardPositionZ = targetZ;
    entity.guardObjectId = 0;
    entity.guardMode = guardMode;
    entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_RETURN_SCAN_RATE_FRAMES;
    entity.guardChaseExpireFrame = 0;
    entity.guardInnerRange = Math.max(0, entity.visionRange * innerMod);
    entity.guardOuterRange = Math.max(0, entity.visionRange * outerMod);

    // Move to the guard point.
    this.issueMoveTo(entityId, targetX, targetZ);
  }

  /**
   * Initialize guard-object mode for an entity. The entity follows and protects
   * the target object, treating its position as a dynamic guard point.
   */
  private initGuardObject(entityId: number, targetObjectId: number, guardMode: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed || !entity.canMove) {
      return;
    }
    const target = this.spawnedEntities.get(targetObjectId);
    if (!target || target.destroyed) {
      return;
    }

    const isHuman = this.getSidePlayerType(entity.side) === 'HUMAN';
    const innerMod = isHuman ? GUARD_INNER_MODIFIER_HUMAN : GUARD_INNER_MODIFIER_AI;
    const outerMod = isHuman ? GUARD_OUTER_MODIFIER_HUMAN : GUARD_OUTER_MODIFIER_AI;

    entity.guardState = 'RETURNING';
    entity.guardPositionX = target.x;
    entity.guardPositionZ = target.z;
    entity.guardObjectId = targetObjectId;
    entity.guardMode = guardMode;
    entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_RETURN_SCAN_RATE_FRAMES;
    entity.guardChaseExpireFrame = 0;
    entity.guardInnerRange = Math.max(0, entity.visionRange * innerMod);
    entity.guardOuterRange = Math.max(0, entity.visionRange * outerMod);

    // Move to the guarded object.
    this.issueMoveTo(entityId, target.x, target.z);
  }

  /**
   * Find the closest attackable enemy within the given range of a position.
   * Source parity: AIGuardMachine::lookForInnerTarget().
   */
  private findGuardTarget(
    entity: MapEntity,
    centerX: number,
    centerZ: number,
    range: number,
  ): MapEntity | null {
    const rangeSqr = range * range;
    let bestTarget: MapEntity | null = null;
    let bestDistanceSqr = Number.POSITIVE_INFINITY;

    for (const candidate of this.spawnedEntities.values()) {
      if (candidate.destroyed || !candidate.canTakeDamage) {
        continue;
      }
      if (candidate.id === entity.id) {
        continue;
      }
      if (this.getTeamRelationship(entity, candidate) !== RELATIONSHIP_ENEMIES) {
        continue;
      }
      // Source parity: GUARDMODE_GUARD_FLYING_UNITS_ONLY — only target air units.
      if (entity.guardMode === 2 && candidate.category !== 'air') {
        continue;
      }
      if (
        candidate.objectStatusFlags.has('STEALTHED') &&
        !candidate.objectStatusFlags.has('DETECTED')
      ) {
        continue;
      }
      if (!this.canAttackerTargetEntity(entity, candidate, 'AI')) {
        continue;
      }
      const dx = candidate.x - centerX;
      const dz = candidate.z - centerZ;
      const distanceSqr = dx * dx + dz * dz;
      if (distanceSqr > rangeSqr) {
        continue;
      }
      if (distanceSqr < bestDistanceSqr) {
        bestTarget = candidate;
        bestDistanceSqr = distanceSqr;
      }
    }

    return bestTarget;
  }

  /**
   * Resolve the current guard anchor position. For guard-object mode, this
   * follows the guarded entity. For guard-position, returns the fixed point.
   */
  private resolveGuardAnchorPosition(entity: MapEntity): { x: number; z: number } | null {
    if (entity.guardObjectId !== 0) {
      const guarded = this.spawnedEntities.get(entity.guardObjectId);
      if (!guarded || guarded.destroyed) {
        // Guarded object is gone — drop guard state.
        entity.guardState = 'NONE';
        return null;
      }
      entity.guardPositionX = guarded.x;
      entity.guardPositionZ = guarded.z;
    }
    return { x: entity.guardPositionX, z: entity.guardPositionZ };
  }

  // ── JetAI helpers ──

  /**
   * Source parity: check if entity has a clip-based weapon and is out of ammo.
   * C++ JetAIUpdate checks hasSpecialPowerClipAmmo / getSpecialPowerClipAmmo.
   */
  private isEntityOutOfClipAmmo(entity: MapEntity): boolean {
    const weapon = entity.attackWeapon;
    if (!weapon || weapon.clipSize <= 0) return false;
    return entity.attackAmmoInClip <= 0;
  }

  /**
   * Find the closest allied airfield (FS_AIRFIELD kindOf) with this entity's side.
   * Returns the entity or null if no suitable airfield exists.
   */
  private findSuitableAirfield(entity: MapEntity): MapEntity | null {
    let bestDist = Infinity;
    let bestAirfield: MapEntity | null = null;
    for (const candidate of this.spawnedEntities.values()) {
      if (candidate.destroyed) continue;
      if (!candidate.kindOf.has('FS_AIRFIELD')) continue;
      // Source parity: C++ uses PartitionFilterRelationship(jet, ALLOW_ALLIES).
      if (this.getTeamRelationship(entity, candidate) !== RELATIONSHIP_ALLIES) continue;
      // Skip airfields that are under construction or being sold.
      if (candidate.constructionPercent !== CONSTRUCTION_COMPLETE) continue;
      if (candidate.objectStatusFlags.has('SOLD')) continue;
      const dx = candidate.x - entity.x;
      const dz = candidate.z - entity.z;
      const dist = dx * dx + dz * dz;
      if (dist < bestDist) {
        bestDist = dist;
        bestAirfield = candidate;
      }
    }
    return bestAirfield;
  }

  /**
   * Transition a JetAI entity to a new state.
   */
  private jetAITransition(entity: MapEntity, js: JetAIRuntimeState, newState: JetAIState): void {
    js.state = newState;
    js.stateEnteredFrame = this.frameCounter;
  }

  /**
   * Source parity: JetAIUpdate::update — runs the flight state machine for all
   * aircraft with a JetAIUpdate behavior module.
   * States: PARKED → TAKING_OFF → AIRBORNE → RETURNING_FOR_LANDING → LANDING → RELOAD_AMMO → PARKED
   *         CIRCLING_DEAD_AIRFIELD (when producer destroyed while returning)
   */
  private updateJetAI(): void {
    const TAKEOFF_FRAMES = 30;
    const LANDING_FRAMES = 30;
    const NEAR_AIRFIELD_DIST_SQ = 400; // 20 world units squared

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const js = entity.jetAIState;
      const profile = entity.jetAIProfile;
      if (!js || !profile) continue;

      const framesInState = this.frameCounter - js.stateEnteredFrame;

      switch (js.state) {
        case 'PARKED': {
          // Airfield heals parked aircraft.
          if (entity.health < entity.maxHealth && entity.maxHealth > 0) {
            // Source parity: C++ uses ParkingPlaceBehavior with data-driven HealAmountPerSecond.
            // Simplified: ~15% max health/sec (0.5%/frame at 30fps) ≈ 6.7s full heal.
            const healRate = entity.maxHealth * 0.005;
            entity.health = Math.min(entity.maxHealth, entity.health + healRate);
          }

          // If there's a pending command, take off.
          if (js.pendingCommand) {
            this.jetAITransition(entity, js, 'TAKING_OFF');
            entity.objectStatusFlags.add('AIRBORNE_TARGET');
            js.allowAirLoco = false; // not yet airborne for movement
            entity.moving = false;
          }
          break;
        }

        case 'TAKING_OFF': {
          // Interpolate altitude from ground to cruise over TAKEOFF_FRAMES.
          const progress = Math.min(1, framesInState / TAKEOFF_FRAMES);
          if (this.mapHeightmap) {
            const terrainHeight = this.mapHeightmap.getInterpolatedHeight(entity.x, entity.z);
            const groundY = terrainHeight + entity.baseHeight;
            entity.y = groundY + js.cruiseHeight * progress;
          }

          if (framesInState >= TAKEOFF_FRAMES) {
            js.allowAirLoco = true;
            this.jetAITransition(entity, js, 'AIRBORNE');

            // Execute pending command.
            if (js.pendingCommand) {
              const cmd = js.pendingCommand;
              js.pendingCommand = null;
              if (cmd.type === 'moveTo') {
                this.issueMoveTo(entity.id, cmd.x, cmd.z);
              } else if (cmd.type === 'attackEntity') {
                this.issueAttackEntity(entity.id, cmd.targetId, 'PLAYER');
              }
            }

            // Start idle return timer if configured.
            if (profile.returnToBaseIdleFrames > 0) {
              js.returnToBaseFrame = this.frameCounter + profile.returnToBaseIdleFrames;
            }
          }
          break;
        }

        case 'AIRBORNE': {
          // Check ammo depletion → return to base.
          if (this.isEntityOutOfClipAmmo(entity)) {
            this.jetAITransition(entity, js, 'RETURNING_FOR_LANDING');
            js.useReturnLoco = profile.returnLocomotorSet !== '';
            this.clearAttackTarget(entity.id);
            entity.moving = false;
            // Issue moveTo toward producer/airfield.
            this.issueMoveTo(entity.id, js.producerX, js.producerZ);
            break;
          }

          // Check idle return timer.
          if (profile.returnToBaseIdleFrames > 0
            && js.returnToBaseFrame > 0
            && this.frameCounter >= js.returnToBaseFrame
            && !entity.moving
            && entity.attackTargetEntityId === null) {
            this.jetAITransition(entity, js, 'RETURNING_FOR_LANDING');
            js.useReturnLoco = profile.returnLocomotorSet !== '';
            this.issueMoveTo(entity.id, js.producerX, js.producerZ);
            break;
          }

          // Reset idle timer when given a new command.
          if (entity.moving || entity.attackTargetEntityId !== null) {
            if (profile.returnToBaseIdleFrames > 0) {
              js.returnToBaseFrame = this.frameCounter + profile.returnToBaseIdleFrames;
            }
          }

          // Manage attack locomotor switching.
          if (profile.attackLocomotorSet !== '' && entity.attackTargetEntityId !== null) {
            if (js.attackLocoExpireFrame === 0) {
              js.attackLocoExpireFrame = this.frameCounter + profile.attackLocoPersistFrames;
            }
          }
          if (js.attackLocoExpireFrame > 0 && this.frameCounter >= js.attackLocoExpireFrame
            && entity.attackTargetEntityId === null) {
            js.attackLocoExpireFrame = 0;
          }

          break;
        }

        case 'RETURNING_FOR_LANDING': {
          // Check if producer/airfield is dead.
          const producer = this.spawnedEntities.get(entity.producerEntityId);
          if (!producer || producer.destroyed) {
            // Try to find a new airfield.
            const newAirfield = this.findSuitableAirfield(entity);
            if (newAirfield) {
              js.producerX = newAirfield.x;
              js.producerZ = newAirfield.z;
              entity.producerEntityId = newAirfield.id;
              this.issueMoveTo(entity.id, js.producerX, js.producerZ);
            } else {
              this.jetAITransition(entity, js, 'CIRCLING_DEAD_AIRFIELD');
              js.circlingNextCheckFrame = this.frameCounter + 30;
              break;
            }
          }

          // Check if near airfield.
          const dxR = entity.x - js.producerX;
          const dzR = entity.z - js.producerZ;
          if (dxR * dxR + dzR * dzR <= NEAR_AIRFIELD_DIST_SQ) {
            this.jetAITransition(entity, js, 'LANDING');
            entity.moving = false;
            // Snap XZ to airfield.
            entity.x = js.producerX;
            entity.z = js.producerZ;
          }
          break;
        }

        case 'LANDING': {
          // Interpolate altitude from cruise to ground over LANDING_FRAMES.
          const landProgress = Math.min(1, framesInState / LANDING_FRAMES);
          if (this.mapHeightmap) {
            const terrainHeight = this.mapHeightmap.getInterpolatedHeight(entity.x, entity.z);
            const groundY = terrainHeight + entity.baseHeight;
            entity.y = groundY + js.cruiseHeight * (1 - landProgress);
          }

          if (framesInState >= LANDING_FRAMES) {
            js.allowAirLoco = false;
            entity.objectStatusFlags.delete('AIRBORNE_TARGET');

            // Determine if reload is needed.
            const weapon = entity.attackWeapon;
            if (weapon && weapon.clipSize > 0 && entity.attackAmmoInClip < weapon.clipSize) {
              this.jetAITransition(entity, js, 'RELOAD_AMMO');
              // Compute reload time proportional to ammo missing.
              const missingRatio = 1 - (entity.attackAmmoInClip / weapon.clipSize);
              const fullReloadFrames = weapon.clipReloadFrames > 0 ? weapon.clipReloadFrames : 30;
              js.reloadTotalFrames = Math.max(1, Math.trunc(fullReloadFrames * missingRatio));
              js.reloadDoneFrame = this.frameCounter + js.reloadTotalFrames;
            } else {
              this.jetAITransition(entity, js, 'PARKED');
            }
          }
          break;
        }

        case 'RELOAD_AMMO': {
          const weapon = entity.attackWeapon;
          if (weapon && weapon.clipSize > 0 && js.reloadTotalFrames > 0) {
            // Proportional clip refill: linearly restore ammo over reloadTotalFrames.
            const elapsed = this.frameCounter - js.stateEnteredFrame;
            const progress = Math.min(1, elapsed / js.reloadTotalFrames);
            const ammoAtStart = weapon.clipSize - Math.trunc(js.reloadTotalFrames * weapon.clipSize / Math.max(1, weapon.clipReloadFrames > 0 ? weapon.clipReloadFrames : 30));
            entity.attackAmmoInClip = Math.min(weapon.clipSize,
              Math.trunc(ammoAtStart + (weapon.clipSize - ammoAtStart) * progress));
          }

          if (this.frameCounter >= js.reloadDoneFrame) {
            // Fully refill.
            if (weapon && weapon.clipSize > 0) {
              entity.attackAmmoInClip = weapon.clipSize;
            }
            // If a command is pending, go straight to takeoff.
            if (js.pendingCommand) {
              this.jetAITransition(entity, js, 'TAKING_OFF');
              entity.objectStatusFlags.add('AIRBORNE_TARGET');
              js.allowAirLoco = false;
              entity.moving = false;
            } else {
              this.jetAITransition(entity, js, 'PARKED');
            }
          }
          break;
        }

        case 'CIRCLING_DEAD_AIRFIELD': {
          // Apply out-of-ammo damage per second.
          if (profile.outOfAmmoDamagePerSecond > 0) {
            const dmgPerFrame = entity.maxHealth * profile.outOfAmmoDamagePerSecond / LOGIC_FRAME_RATE;
            this.applyWeaponDamageAmount(null, entity, dmgPerFrame, 'UNRESISTABLE');
            if (entity.destroyed) continue;
          }

          // Check for new airfield every 30 frames.
          if (this.frameCounter >= js.circlingNextCheckFrame) {
            js.circlingNextCheckFrame = this.frameCounter + 30;
            const newAirfield = this.findSuitableAirfield(entity);
            if (newAirfield) {
              js.producerX = newAirfield.x;
              js.producerZ = newAirfield.z;
              entity.producerEntityId = newAirfield.id;
              this.jetAITransition(entity, js, 'RETURNING_FOR_LANDING');
              this.issueMoveTo(entity.id, js.producerX, js.producerZ);
            }
          }
          break;
        }
      }
    }
  }

  /**
   * Source parity: AIGuardMachine state updates — runs the guard state machine
   * for each guarding entity. States: IDLE → PURSUING → RETURNING → IDLE.
   */
  private updateGuardBehavior(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.guardState === 'NONE') {
        continue;
      }

      const anchor = this.resolveGuardAnchorPosition(entity);
      if (!anchor) {
        continue;
      }

      switch (entity.guardState) {
        case 'IDLE':
          this.updateGuardIdle(entity, anchor);
          break;
        case 'PURSUING':
          this.updateGuardPursuing(entity, anchor);
          break;
        case 'RETURNING':
          this.updateGuardReturning(entity, anchor);
          break;
      }
    }
  }

  /**
   * Guard IDLE state: entity is at the guard point. Periodically scan for enemies
   * within the inner guard range. If an enemy is found, engage and transition to PURSUING.
   * Source parity: AIGuardIdleState — scan rate is m_guardEnemyScanRate (0.5s).
   */
  private updateGuardIdle(entity: MapEntity, anchor: { x: number; z: number }): void {
    // Source parity: if guarding an object that has moved, return to it.
    if (entity.guardObjectId !== 0) {
      const dx = entity.x - anchor.x;
      const dz = entity.z - anchor.z;
      const followThreshold = PATHFIND_CELL_SIZE * 4;
      if (dx * dx + dz * dz > followThreshold * followThreshold) {
        entity.guardState = 'RETURNING';
        entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_RETURN_SCAN_RATE_FRAMES;
        this.issueMoveTo(entity.id, anchor.x, anchor.z);
        return;
      }
    }

    // Throttle scanning.
    if (this.frameCounter < entity.guardNextScanFrame) {
      return;
    }
    entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_SCAN_RATE_FRAMES;

    // Source parity: stealthed guarders don't auto-acquire.
    if (entity.objectStatusFlags.has('STEALTHED')) {
      return;
    }

    if (!entity.attackWeapon) {
      return;
    }

    const target = this.findGuardTarget(entity, anchor.x, anchor.z, entity.guardInnerRange);
    if (target) {
      // Source parity: GUARDMODE_GUARD_WITHOUT_PURSUIT — attack only within inner range, don't chase.
      entity.guardState = 'PURSUING';
      entity.guardChaseExpireFrame = this.frameCounter + GUARD_CHASE_UNIT_FRAMES;
      this.issueAttackEntity(entity.id, target.id, 'AI');
    }
  }

  /**
   * Guard PURSUING state: entity is chasing an enemy. Monitor for:
   * 1. Target dies/becomes invalid → RETURNING
   * 2. Target escapes outer range → RETURNING
   * 3. Chase timer expires → RETURNING
   * 4. GUARDMODE_GUARD_WITHOUT_PURSUIT — immediately return after inner-range target lost
   * Source parity: AIGuardOuterState.
   */
  private updateGuardPursuing(entity: MapEntity, anchor: { x: number; z: number }): void {
    const targetId = entity.attackTargetEntityId;
    const target = targetId !== null ? this.spawnedEntities.get(targetId) ?? null : null;

    // Target gone — return to guard point.
    if (!target || target.destroyed) {
      this.transitionGuardToReturning(entity, anchor);
      return;
    }

    // GUARD_WITHOUT_PURSUIT: no outer-range chase, return immediately if target escapes inner range.
    if (entity.guardMode === 1) {
      const dx = target.x - anchor.x;
      const dz = target.z - anchor.z;
      const innerRangeSqr = entity.guardInnerRange * entity.guardInnerRange;
      if (dx * dx + dz * dz > innerRangeSqr) {
        this.transitionGuardToReturning(entity, anchor);
        return;
      }
      return;
    }

    // Source parity: AI_GUARD_INNER fights without a time limit inside inner range.
    // AI_GUARD_OUTER starts a chase timer when the target is outside inner range.
    const dx = target.x - anchor.x;
    const dz = target.z - anchor.z;
    const targetDistSqr = dx * dx + dz * dz;
    const innerRangeSqr = entity.guardInnerRange * entity.guardInnerRange;
    const outerRangeSqr = entity.guardOuterRange * entity.guardOuterRange;

    if (targetDistSqr <= innerRangeSqr) {
      // Target is in inner range — fight indefinitely, reset chase timer.
      entity.guardChaseExpireFrame = this.frameCounter + GUARD_CHASE_UNIT_FRAMES;
      return;
    }

    // Target is outside inner range — check outer range and chase timer.
    if (targetDistSqr > outerRangeSqr) {
      this.transitionGuardToReturning(entity, anchor);
      return;
    }

    if (GUARD_CHASE_UNIT_FRAMES > 0 && this.frameCounter >= entity.guardChaseExpireFrame) {
      this.transitionGuardToReturning(entity, anchor);
      return;
    }
  }

  /**
   * Guard RETURNING state: entity is walking back to the guard point.
   * Periodically scan for enemies along the way (source parity: m_guardEnemyReturnScanRate).
   * Transition to IDLE once arrived.
   */
  private updateGuardReturning(entity: MapEntity, anchor: { x: number; z: number }): void {
    // Check if we've arrived at the guard point.
    if (!entity.moving) {
      const dx = entity.x - anchor.x;
      const dz = entity.z - anchor.z;
      const arrivalThreshold = PATHFIND_CELL_SIZE * 2;
      if (dx * dx + dz * dz <= arrivalThreshold * arrivalThreshold) {
        entity.guardState = 'IDLE';
        entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_SCAN_RATE_FRAMES;
        return;
      }
      // Not moving but not at guard point — re-issue move.
      this.issueMoveTo(entity.id, anchor.x, anchor.z);
    }

    // Source parity: scan for enemies during return at a slower rate.
    if (this.frameCounter < entity.guardNextScanFrame) {
      return;
    }
    entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_RETURN_SCAN_RATE_FRAMES;

    if (entity.objectStatusFlags.has('STEALTHED') || !entity.attackWeapon) {
      return;
    }

    const target = this.findGuardTarget(entity, anchor.x, anchor.z, entity.guardInnerRange);
    if (target) {
      entity.guardState = 'PURSUING';
      entity.guardChaseExpireFrame = this.frameCounter + GUARD_CHASE_UNIT_FRAMES;
      this.issueAttackEntity(entity.id, target.id, 'AI');
    }
  }

  /**
   * Transition a guarding entity back to RETURNING state: clear its attack target,
   * stop it, and issue a move back to the guard anchor position.
   */
  private transitionGuardToReturning(entity: MapEntity, anchor: { x: number; z: number }): void {
    this.clearAttackTarget(entity.id);
    entity.guardState = 'RETURNING';
    entity.guardNextScanFrame = this.frameCounter + GUARD_ENEMY_RETURN_SCAN_RATE_FRAMES;
    this.issueMoveTo(entity.id, anchor.x, anchor.z);
  }

  /**
   * Source parity: Weapon.cpp LOS check — trace a ray between two world positions
   * and check if terrain blocks line of sight. Uses heightmap sampling along the ray.
   */
  private isTerrainLineOfSightBlocked(
    fromX: number,
    fromZ: number,
    toX: number,
    toZ: number,
  ): boolean {
    const hm = this.mapHeightmap;
    if (!hm) return false;

    const fromHeight = hm.getInterpolatedHeight(fromX, fromZ) + 1.5; // unit eye height
    const toHeight = hm.getInterpolatedHeight(toX, toZ) + 1.5;

    const dx = toX - fromX;
    const dz = toZ - fromZ;
    const dist = Math.sqrt(dx * dx + dz * dz);
    if (dist < 1) return false;

    // Sample terrain height along the ray at ~2 world-unit intervals
    const steps = Math.min(Math.ceil(dist / 2), 100);
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const sampleX = fromX + dx * t;
      const sampleZ = fromZ + dz * t;
      const terrainHeight = hm.getInterpolatedHeight(sampleX, sampleZ);
      const rayHeight = fromHeight + (toHeight - fromHeight) * t;
      if (terrainHeight > rayHeight) {
        return true;
      }
    }
    return false;
  }

  private queueWeaponDamageEvent(attacker: MapEntity, target: MapEntity, weapon: AttackWeaponProfile): void {
    // Source parity: Object::getLastShotFiredFrame() — track last normal weapon fire for ExclusiveWeaponDelay.
    attacker.lastShotFiredFrame = this.frameCounter;
    const sourceX = attacker.x;
    const sourceZ = attacker.z;
    const targetX = target.x;
    const targetZ = target.z;

    let aimX = targetX;
    let aimZ = targetZ;
    let primaryVictimEntityId = weapon.damageDealtAtSelfPosition ? null : target.id;

    const sneakyOffset = this.resolveEntitySneakyTargetingOffset(target);
    if (sneakyOffset && primaryVictimEntityId !== null) {
      aimX += sneakyOffset.x;
      aimZ += sneakyOffset.z;
      // Source parity subset: WeaponTemplate::fireWeaponTemplate() converts sneaky-targeted
      // victim shots into position-shots using AIUpdateInterface::getSneakyTargetingOffset().
      primaryVictimEntityId = null;
    }

    if (attacker.attackScatterTargetsUnused.length > 0) {
      const randomPick = this.gameRandom.nextRange(0, attacker.attackScatterTargetsUnused.length - 1);
      const targetIndex = attacker.attackScatterTargetsUnused[randomPick];
      const scatterOffset = targetIndex === undefined ? null : weapon.scatterTargets[targetIndex];
      if (scatterOffset) {
        aimX += scatterOffset.x * weapon.scatterTargetScalar;
        aimZ += scatterOffset.z * weapon.scatterTargetScalar;
        primaryVictimEntityId = null;
      }

      attacker.attackScatterTargetsUnused[randomPick] = attacker.attackScatterTargetsUnused[attacker.attackScatterTargetsUnused.length - 1]!;
      attacker.attackScatterTargetsUnused.pop();
      // Source parity subset: Weapon::privateFireWeapon() consumes one ScatterTarget
      // offset per shot from a randomized "unused" list until reload rebuilds it.
      // Scatter terrain projection handled at impactY resolution (line uses heightmap).
    }

    let delivery: 'DIRECT' | 'PROJECTILE' | 'LASER' = 'DIRECT';
    let travelSpeed = weapon.weaponSpeed;
    if (weapon.projectileObjectName) {
      delivery = 'PROJECTILE';
      // Source parity: Weapon.cpp projectile branch notifies completion immediately when the
      // source object itself has SpecialPowerCompletionDie with a valid creator id.
      this.notifyScriptCompletedSpecialPowerOnProjectileFired(attacker);
      // Source parity subset: projectile weapons in WeaponTemplate::fireWeaponTemplate()
      // spawn ProjectileObject and defer damage to projectile update/collision.
      // We represent this as a deterministic delayed impact without spawning a full
      // projectile object graph yet.

      const scatterRadius = this.resolveProjectileScatterRadiusForTarget(weapon, target);
      if (scatterRadius > 0) {
        const randomizedScatterRadius = scatterRadius * this.gameRandom.nextFloat();
        const scatterAngleRadians = this.gameRandom.nextFloat() * (2 * Math.PI);
        aimX += randomizedScatterRadius * Math.cos(scatterAngleRadians);
        aimZ += randomizedScatterRadius * Math.sin(scatterAngleRadians);
        primaryVictimEntityId = null;
        // Source parity subset: projectile scatter path launches at a position (not victim object),
        // so impact no longer homes to the moving target.
        // Scatter terrain projection handled at impactY resolution below.
      }
      const sourceToAimDistance = Math.hypot(aimX - sourceX, aimZ - sourceZ);
      travelSpeed = this.resolveScaledProjectileTravelSpeed(weapon, sourceToAimDistance);
    } else if (weapon.laserName) {
      // Source parity: Weapon::fireWeaponTemplate() laser sub-branch.
      // Laser damage is always instant. If scatter moved the aim point outside the
      // weapon's damage radius, damageID becomes INVALID (ground shot / miss).
      delivery = 'LASER';
      const scatterDx = aimX - targetX;
      const scatterDz = aimZ - targetZ;
      const scatterDistSqr = scatterDx * scatterDx + scatterDz * scatterDz;
      const primaryRadiusSqr = weapon.primaryDamageRadius * weapon.primaryDamageRadius;
      const secondaryRadiusSqr = weapon.secondaryDamageRadius * weapon.secondaryDamageRadius;
      if (scatterDistSqr > Math.max(primaryRadiusSqr, secondaryRadiusSqr) && scatterDistSqr > 0) {
        // Scatter caused a miss — laser hits ground, no victim ID.
        primaryVictimEntityId = null;
      }
    } else {
      // Source parity: Weapon::fireWeaponTemplate delays direct-damage resolution by
      // distance / getWeaponSpeed().
    }

    const impactX = weapon.damageDealtAtSelfPosition ? sourceX : aimX;
    const impactZ = weapon.damageDealtAtSelfPosition ? sourceZ : aimZ;
    const heightmap = this.mapHeightmap;
    const impactY = heightmap ? heightmap.getInterpolatedHeight(impactX, impactZ) : 0;

    // Source parity: DumbProjectileBehavior::calcFlightPath() — compute cubic Bezier
    // arc control points and use arc length for travel time when arc params are present.
    let hasBezierArc = false;
    let bezierP1Y = 0;
    let bezierP2Y = 0;
    let bezierFirstPercentIndent = 0;
    let bezierSecondPercentIndent = 0;

    if (
      delivery === 'PROJECTILE' &&
      (weapon.projectileArcFirstHeight !== 0 || weapon.projectileArcSecondHeight !== 0 ||
       weapon.projectileArcFirstPercentIndent !== 0 || weapon.projectileArcSecondPercentIndent !== 0)
    ) {
      hasBezierArc = true;
      bezierFirstPercentIndent = weapon.projectileArcFirstPercentIndent;
      bezierSecondPercentIndent = weapon.projectileArcSecondPercentIndent;

      // Source parity: highestInterveningTerrain = max(terrain along line, P0.z, P3.z)
      let highestTerrain = Math.max(attacker.y, impactY);
      if (heightmap) {
        const terrainMax = estimateHighestTerrainAlongLine(
          heightmap, sourceX, sourceZ, impactX, impactZ, BEZIER_TERRAIN_SAMPLE_COUNT,
        );
        highestTerrain = Math.max(highestTerrain, terrainMax);
      }
      bezierP1Y = highestTerrain + weapon.projectileArcFirstHeight;
      bezierP2Y = highestTerrain + weapon.projectileArcSecondHeight;
    }

    const sourceToAimDistance = Math.hypot(aimX - sourceX, aimZ - sourceZ);
    let delayFrames: number;
    if (delivery === 'LASER') {
      // Source parity: laser damage is always instant — returns TheGameLogic->getFrame().
      delayFrames = 0;
    } else if (delivery === 'PROJECTILE') {
      let flightDistance: number;
      if (hasBezierArc) {
        // Source parity: flightDistance = BezierSegment::getApproximateLength()
        const p0x = sourceX, p0y = attacker.y, p0z = sourceZ;
        const p3x = impactX, p3y = impactY, p3z = impactZ;
        const dx = p3x - p0x, dy = p3y - p0y, dz = p3z - p0z;
        const dist = Math.hypot(dx, dy, dz);
        const nx = dist > 0 ? dx / dist : 0;
        const nz = dist > 0 ? dz / dist : 0;
        const p1x = p0x + nx * dist * bezierFirstPercentIndent;
        const p1z = p0z + nz * dist * bezierFirstPercentIndent;
        const p2x = p0x + nx * dist * bezierSecondPercentIndent;
        const p2z = p0z + nz * dist * bezierSecondPercentIndent;
        flightDistance = approximateCubicBezierArcLength3D(
          p0x, p0y, p0z,
          p1x, bezierP1Y, p1z,
          p2x, bezierP2Y, p2z,
          p3x, p3y, p3z,
          BEZIER_ARC_LENGTH_TOLERANCE, 0,
        );
      } else {
        flightDistance = sourceToAimDistance;
      }
      const travelFrames = flightDistance / travelSpeed;
      delayFrames = Math.max(1, Number.isFinite(travelFrames) && travelFrames >= 1
        ? Math.ceil(travelFrames) : 1);
    } else {
      const travelFrames = sourceToAimDistance / travelSpeed;
      delayFrames = Number.isFinite(travelFrames) && travelFrames >= 1
        ? Math.ceil(travelFrames) : 0;
    }

    // Source parity: Weapon::computeBonus() — apply damage and radius bonuses at fire time.
    const damageBonus = this.resolveWeaponDamageBonusMultiplier(attacker);
    const radiusBonus = this.resolveWeaponRadiusBonusMultiplier(attacker);
    const bonusedWeapon: AttackWeaponProfile = (damageBonus !== 1.0 || radiusBonus !== 1.0)
      ? {
        ...weapon,
        primaryDamage: weapon.primaryDamage * damageBonus,
        secondaryDamage: weapon.secondaryDamage * damageBonus,
        primaryDamageRadius: weapon.primaryDamageRadius * radiusBonus,
        secondaryDamageRadius: weapon.secondaryDamageRadius * radiusBonus,
      }
      : weapon;

    let missileAIProfile: MissileAIProfile | null = null;
    let missileAIState: MissileAIRuntimeState | null = null;
    let executeFrame = this.frameCounter + delayFrames;

    if (delivery === 'PROJECTILE' && weapon.projectileObjectName) {
      missileAIProfile = this.extractMissileAIProfile(weapon.projectileObjectName);
      if (missileAIProfile) {
        // Source parity: MissileAIUpdate owns flight and detonation timing.
        // Leave queued executeFrame far in the future until MissileAI transitions to KILL.
        executeFrame = Number.MAX_SAFE_INTEGER;

        // Source parity: projectileFireAtObjectOrPosition initializes heading from
        // launcher forward vector with positive-Z correction when target is above missile.
        let dirX = 0;
        let dirY = 0;
        let dirZ = 1;
        const launcherForward = this.resolveForwardUnitVector(attacker);
        const forwardLength = Math.hypot(launcherForward.x, launcherForward.z);
        if (forwardLength > 0) {
          dirX = launcherForward.x / forwardLength;
          dirZ = launcherForward.z / forwardLength;
        } else {
          const toTargetX = impactX - sourceX;
          const toTargetZ = impactZ - sourceZ;
          const toTargetLength = Math.hypot(toTargetX, toTargetZ);
          if (toTargetLength > 0) {
            dirX = toTargetX / toTargetLength;
            dirZ = toTargetZ / toTargetLength;
          }
        }

        const xyDistance = Math.max(1, Math.hypot(impactX - sourceX, impactZ - sourceZ));
        const deltaY = impactY - attacker.y;
        const zFactor = deltaY > 0 ? (deltaY / xyDistance) : 0;
        dirY += 2 * zFactor;

        const directionLength = Math.hypot(dirX, dirY, dirZ);
        if (directionLength > 0) {
          dirX /= directionLength;
          dirY /= directionLength;
          dirZ /= directionLength;
        } else {
          dirX = 0;
          dirY = 0;
          dirZ = 1;
        }

        const missileSpeed = missileAIProfile.useWeaponSpeed
          ? travelSpeed
          : (missileAIProfile.initialVelocity > 0 ? missileAIProfile.initialVelocity : travelSpeed);
        const speed = Number.isFinite(missileSpeed) && missileSpeed > 0 ? missileSpeed : travelSpeed;
        const trackingTarget = missileAIProfile.tryToFollowTarget && primaryVictimEntityId !== null;
        // Source parity: MissileAIUpdate::projectileFireAtObjectOrPosition adds an approach
        // height offset for coordinate shots when lock distance is enabled.
        const approachHeight = (!trackingTarget && missileAIProfile.distanceToTargetForLock > 0)
          ? 10.0
          : 0.0;

        missileAIState = {
          state: 'LAUNCH',
          stateEnteredFrame: this.frameCounter,
          currentX: sourceX,
          currentY: attacker.y,
          currentZ: sourceZ,
          prevX: sourceX,
          prevY: attacker.y,
          prevZ: sourceZ,
          velocityX: dirX * speed,
          velocityY: dirY * speed,
          velocityZ: dirZ * speed,
          speed,
          armed: false,
          fuelExpirationFrame: Number.MAX_SAFE_INTEGER,
          noTurnDistanceLeft: missileAIProfile.distanceToTravelBeforeTurning,
          trackingTarget,
          targetEntityId: trackingTarget ? primaryVictimEntityId : null,
          targetX: impactX,
          targetY: impactY + approachHeight,
          targetZ: impactZ,
          originalTargetX: impactX,
          originalTargetY: impactY,
          originalTargetZ: impactZ,
          travelDistance: 0,
          totalDistanceEstimate: Math.max(1, Math.hypot(impactX - sourceX, impactZ - sourceZ)),
        };
      }
    }

    const event: PendingWeaponDamageEvent = {
      sourceEntityId: attacker.id,
      primaryVictimEntityId,
      impactX,
      impactZ,
      executeFrame,
      delivery,
      weapon: bonusedWeapon,
      launchFrame: this.frameCounter,
      sourceX,
      sourceY: attacker.y,
      sourceZ,
      projectileVisualId: this.nextProjectileVisualId++,
      cachedVisualType: this.classifyWeaponVisualType(weapon),
      impactY,
      bezierP1Y,
      bezierP2Y,
      bezierFirstPercentIndent,
      bezierSecondPercentIndent,
      hasBezierArc,
      countermeasureDivertFrame: 0,
      countermeasureNoDamage: false,
      suppressImpactVisual: false,
      missileAIProfile,
      missileAIState,
    };

    // Emit muzzle flash visual event.
    this.emitWeaponFiredVisualEvent(attacker, weapon);

    if (delivery === 'LASER') {
      // Source parity: laser weapons always deal damage synchronously (instant hit).
      // createLaser() is called for the visual beam; damage is applied immediately.
      this.emitWeaponImpactVisualEvent(event);
      applyWeaponDamageEventImpl(this.createCombatDamageEventContext(), event);
      return;
    }

    if (delivery === 'DIRECT' && delayFrames <= 0) {
      // Source parity subset: WeaponTemplate::fireWeaponTemplate() applies non-projectile
      // damage immediately when delayInFrames < 1.0f instead of queuing delayed damage.
      this.emitWeaponImpactVisualEvent(event);
      applyWeaponDamageEventImpl(this.createCombatDamageEventContext(), event);
      return;
    }

    // Source parity: Weapon.cpp:1169-1177 — check victim for countermeasures at weapon fire time.
    // Only MISSILE projectiles (KINDOF_SMALL_MISSILE) can be diverted.
    // Source parity: supersonic jets cannot deploy countermeasures (too fast).
    if (delivery === 'PROJECTILE' && event.cachedVisualType === 'MISSILE' && primaryVictimEntityId !== null) {
      const victim = this.spawnedEntities.get(primaryVictimEntityId);
      if (victim && victim.countermeasuresState && victim.countermeasuresProfile
        && !victim.locomotorSets.has(LOCOMOTORSET_SUPERSONIC)) {
        this.reportMissileForCountermeasures(victim, event);
      }
    }

    this.pendingWeaponDamageEvents.push(event);
  }

  /**
   * Source parity: Weapon.cpp projectile fire path.
   * If the source object has SpecialPowerCompletionDie and a valid creator id,
   * notify the script completion list immediately when the projectile is fired.
   */
  private notifyScriptCompletedSpecialPowerOnProjectileFired(source: MapEntity): void {
    const profile = source.specialPowerCompletionDieProfiles[0];
    if (!profile) {
      return;
    }

    const normalizedSide = this.normalizeSide(source.side);
    if (!normalizedSide) {
      return;
    }

    const creatorId = Math.trunc(source.specialPowerCompletionCreatorId);
    if (creatorId <= 0) {
      return;
    }

    this.recordScriptCompletedSpecialPowerEvent(
      normalizedSide,
      profile.specialPowerTemplateName,
      creatorId,
    );
  }

  private classifyWeaponVisualType(weapon: AttackWeaponProfile): import('./types.js').ProjectileVisualType {
    // Source parity: weapon with LaserName is definitively a laser.
    if (weapon.laserName) return 'LASER';
    const name = weapon.name.toUpperCase();
    if (name.includes('MISSILE') || name.includes('ROCKET') || name.includes('PATRIOT')) return 'MISSILE';
    if (name.includes('ARTILLERY') || name.includes('CANNON') || name.includes('SHELL')
      || weapon.primaryDamageRadius > 10) return 'ARTILLERY';
    if (name.includes('LASER')) return 'LASER';
    return 'BULLET';
  }

  private emitWeaponFiredVisualEvent(attacker: MapEntity, weapon: AttackWeaponProfile): void {
    this.visualEventBuffer.push({
      type: 'WEAPON_FIRED',
      x: attacker.x,
      y: attacker.y + 1.5,
      z: attacker.z,
      radius: 0,
      sourceEntityId: attacker.id,
      projectileType: this.classifyWeaponVisualType(weapon),
    });
  }

  private emitWeaponImpactVisualEvent(event: PendingWeaponDamageEvent): void {
    const heightmap = this.mapHeightmap;
    const impactY = heightmap ? heightmap.getInterpolatedHeight(event.impactX, event.impactZ) : 0;
    this.visualEventBuffer.push({
      type: 'WEAPON_IMPACT',
      x: event.impactX,
      y: impactY,
      z: event.impactZ,
      radius: Math.max(event.weapon.primaryDamageRadius, 1),
      sourceEntityId: event.sourceEntityId,
      projectileType: this.classifyWeaponVisualType(event.weapon),
    });
  }

  private setEntityAttackStatus(entity: MapEntity, isAttacking: boolean): void {
    // Source parity: AIAttackState::onEnter() sets IS_ATTACKING and IGNORING_STEALTH
    // (if weapon has ContinueAttackRange > 0). onExit() clears all attack flags.
    if (isAttacking) {
      if (entity.attackSubState === 'IDLE') {
        // AIAttackState::onEnter()
        entity.attackSubState = 'APPROACHING';
        entity.objectStatusFlags.add('IS_ATTACKING');
        // IGNORING_STEALTH is set at attack entry by command handlers
        // (issueAttackEntity/issueFireWeapon); redundantly ensure it here for
        // auto-acquired targets that bypass those handlers.
        if (entity.attackWeapon && entity.attackWeapon.continueAttackRange > 0) {
          entity.objectStatusFlags.add('IGNORING_STEALTH');
        }
      }
    } else {
      if (entity.attackSubState !== 'IDLE') {
        // AIAttackState::onExit() — clear all attack status flags.
        entity.attackSubState = 'IDLE';
        entity.objectStatusFlags.delete('IS_ATTACKING');
        entity.objectStatusFlags.delete('IS_AIMING_WEAPON');
        entity.objectStatusFlags.delete('IS_FIRING_WEAPON');
        entity.objectStatusFlags.delete('IGNORING_STEALTH');
      }
    }
  }

  private setEntityAimingWeaponStatus(entity: MapEntity, isAiming: boolean): void {
    // Source parity: AIAttackAimAtTargetState::onEnter() sets IS_AIMING_WEAPON,
    // onExit() clears it.
    if (isAiming) {
      if (entity.attackSubState !== 'IDLE') {
        entity.attackSubState = 'AIMING';
        entity.objectStatusFlags.add('IS_AIMING_WEAPON');
      }
    } else {
      if (entity.attackSubState === 'AIMING') {
        entity.attackSubState = 'APPROACHING';
        entity.objectStatusFlags.delete('IS_AIMING_WEAPON');
      }
    }
  }

  private setEntityFiringWeaponStatus(entity: MapEntity, isFiring: boolean): void {
    // Source parity: AIAttackFireWeaponState::onEnter() sets IS_FIRING_WEAPON,
    // onExit() clears IS_FIRING_WEAPON and IGNORING_STEALTH.
    if (isFiring) {
      if (entity.attackSubState !== 'IDLE') {
        entity.attackSubState = 'FIRING';
        entity.objectStatusFlags.add('IS_FIRING_WEAPON');
      }
    } else {
      if (entity.attackSubState === 'FIRING') {
        // AIAttackFireWeaponState::onExit() → AIAttackAimAtTargetState::onEnter()
        entity.attackSubState = 'AIMING';
        entity.objectStatusFlags.delete('IS_FIRING_WEAPON');
        entity.objectStatusFlags.delete('IGNORING_STEALTH');
        entity.objectStatusFlags.add('IS_AIMING_WEAPON');
      }
    }
  }

  private setEntityIgnoringStealthStatus(entity: MapEntity, isIgnoringStealth: boolean): void {
    // Source parity: IGNORING_STEALTH is set by attack-state onEnter() (ContinueAttackRange > 0)
    // and cleared by fire-state onExit() and attack-state onExit().
    // Direct flag manipulation for compatibility with combat-update call sites.
    if (isIgnoringStealth) {
      entity.objectStatusFlags.add('IGNORING_STEALTH');
    } else {
      entity.objectStatusFlags.delete('IGNORING_STEALTH');
    }
  }

  private refreshEntitySneakyMissWindow(entity: MapEntity): void {
    // Source parity subset: JetAIUpdate::update() refreshes m_attackersMissExpireFrame while
    // OBJECT_STATUS_IS_ATTACKING is set on the object.
    refreshEntitySneakyMissWindowImpl(entity, this.frameCounter);
  }

  private entityHasSneakyTargetingOffset(entity: MapEntity): boolean {
    return entityHasSneakyTargetingOffsetImpl(entity, this.frameCounter);
  }

  private resolveEntitySneakyTargetingOffset(entity: MapEntity): VectorXZ | null {
    return resolveEntitySneakyTargetingOffsetImpl(entity, this.frameCounter, this.resolveForwardUnitVector(entity));
  }

  private resolveScaledProjectileTravelSpeed(weapon: AttackWeaponProfile, sourceToAimDistance: number): number {
    // Source parity subset: DumbProjectileBehavior::projectileFireAtObjectOrPosition()
    // scales launch speed from minimum-range to unmodified-attack-range distance.
    // Bezier arc length is used for actual flight distance in queueWeaponDamageEvent.
    return resolveScaledProjectileTravelSpeedImpl(
      weapon,
      sourceToAimDistance,
      ATTACK_RANGE_CELL_EDGE_FUDGE,
    );
  }

  private resolveProjectileScatterRadiusForTarget(weapon: AttackWeaponProfile, target: MapEntity): number {
    return resolveProjectileScatterRadiusForCategoryImpl(weapon, target.category);
  }

  private createCombatDamageEventContext(): CombatDamageEventContext<
    MapEntity,
    AttackWeaponProfile,
    PendingWeaponDamageEvent
  > {
    return {
      frameCounter: this.frameCounter,
      pendingEvents: this.pendingWeaponDamageEvents,
      entitiesById: this.spawnedEntities,
      resolveForwardUnitVector: (entity) => this.resolveForwardUnitVector(entity),
      resolveProjectilePointCollisionRadius: (entity) => resolveProjectilePointCollisionRadiusImpl(entity, MAP_XY_FACTOR),
      resolveProjectileIncidentalVictimForPointImpact: (
        projectileLauncher,
        weapon,
        intendedVictimId,
        impactX,
        impactZ,
      ) => resolveProjectileIncidentalVictimForPointImpactImpl(
        this.spawnedEntities.values(),
        intendedVictimId,
        impactX,
        impactZ,
        (candidate) => resolveProjectilePointCollisionRadiusImpl(candidate, MAP_XY_FACTOR),
        (candidate) => shouldProjectileCollideWithEntityImpl(
          projectileLauncher,
          weapon,
          candidate,
          intendedVictimId,
          (launcher) => this.resolveProjectileLauncherContainer(launcher),
          (entity) => this.resolveEntityKindOfSet(entity),
          (entity, kindOf, victimId) => isAirfieldReservedForProjectileVictimImpl(
            entity,
            kindOf,
            victimId,
            (entityId) => this.spawnedEntities.get(entityId) ?? null,
          ),
          (entity) => this.entityHasSneakyTargetingOffset(entity),
          (launcher, entity) => this.getTeamRelationship(launcher, entity),
          (side) => this.normalizeSide(side),
          (entity) => this.resolveEntityFenceWidth(entity),
          { allies: RELATIONSHIP_ALLIES, enemies: RELATIONSHIP_ENEMIES },
          {
            collideAllies: WEAPON_COLLIDE_ALLIES,
            collideEnemies: WEAPON_COLLIDE_ENEMIES,
            collideControlledStructures: WEAPON_COLLIDE_CONTROLLED_STRUCTURES,
            collideStructures: WEAPON_COLLIDE_STRUCTURES,
            collideShrubbery: WEAPON_COLLIDE_SHRUBBERY,
            collideProjectile: WEAPON_COLLIDE_PROJECTILE,
            collideWalls: WEAPON_COLLIDE_WALLS,
            collideSmallMissiles: WEAPON_COLLIDE_SMALL_MISSILES,
            collideBallisticMissiles: WEAPON_COLLIDE_BALLISTIC_MISSILES,
          },
        ),
      ),
      getTeamRelationship: (attacker, target) => this.getTeamRelationship(attacker, target),
      applyWeaponDamageAmount: (sourceEntityId, target, amount, damageType, weaponDeathType) =>
        this.applyWeaponDamageAmount(sourceEntityId, target, amount, damageType, weaponDeathType),
      canEntityAttackFromStatus: (entity) => this.canEntityAttackFromStatus(entity),
      canAttackerTargetEntity: (attacker, target, commandSource) =>
        this.canAttackerTargetEntity(attacker, target, commandSource as AttackCommandSource),
      isEntitySignificantlyAboveTerrain: (entity) => {
        // Source parity: Thing::isSignificantlyAboveTerrain — getHeightAboveTerrain() > 9.0.
        // C++ position is object base; browser port y includes baseHeight (center offset).
        const terrainY = this.resolveGroundHeight(entity.x, entity.z);
        return (entity.y - entity.baseHeight - terrainY) > SIGNIFICANTLY_ABOVE_TERRAIN_THRESHOLD;
      },
      resolveBoundingSphereRadius: (entity) => this.resolveBoundingSphereRadius(entity),
      masks: {
        affectsSelf: WEAPON_AFFECTS_SELF,
        affectsAllies: WEAPON_AFFECTS_ALLIES,
        affectsEnemies: WEAPON_AFFECTS_ENEMIES,
        affectsNeutrals: WEAPON_AFFECTS_NEUTRALS,
        killsSelf: WEAPON_KILLS_SELF,
        doesntAffectSimilar: WEAPON_DOESNT_AFFECT_SIMILAR,
        doesntAffectAirborne: WEAPON_DOESNT_AFFECT_AIRBORNE,
      },
      relationships: {
        allies: RELATIONSHIP_ALLIES,
        enemies: RELATIONSHIP_ENEMIES,
      },
      hugeDamageAmount: HUGE_DAMAGE_AMOUNT,
    };
  }

  /**
   * Source parity: MissileAIUpdate::update() — per-frame homing missile flight state machine.
   * Handles ignition delay, fuel lifetime, turn gating, lock distance detonation, and
   * target-follow behavior for projectile objects with MissileAIUpdate.
   */
  private updateMissileAIEvents(): void {
    for (const event of this.pendingWeaponDamageEvents) {
      if (event.delivery !== 'PROJECTILE') continue;
      if (event.executeFrame <= this.frameCounter) continue;
      const profile = event.missileAIProfile;
      const state = event.missileAIState;
      if (!profile || !state) continue;

      // Countermeasure diversion can swap victim to a flare entity. Rebind tracking target.
      if (event.countermeasureNoDamage && event.primaryVictimEntityId !== null
        && state.targetEntityId !== event.primaryVictimEntityId) {
        state.trackingTarget = true;
        state.targetEntityId = event.primaryVictimEntityId;
      }

      // Track moving target object when enabled, otherwise hold original target position.
      if (state.trackingTarget && state.targetEntityId !== null) {
        const tracked = this.spawnedEntities.get(state.targetEntityId);
        if (!tracked || tracked.destroyed) {
          // Source parity: MissileAIUpdate::airborneTargetGone() — run out of gas and enter KILL_SELF.
          state.trackingTarget = false;
          state.targetEntityId = null;
          state.fuelExpirationFrame = this.frameCounter;
          state.state = 'KILL_SELF';
          state.stateEnteredFrame = this.frameCounter;
          event.countermeasureNoDamage = true;
          event.primaryVictimEntityId = null;
          event.suppressImpactVisual = true;
          continue;
        }
        state.targetX = tracked.x;
        state.targetY = tracked.y;
        state.targetZ = tracked.z;
      } else {
        state.targetX = state.originalTargetX;
        state.targetY = state.originalTargetY;
        state.targetZ = state.originalTargetZ;
      }

      if (state.state === 'LAUNCH' && this.frameCounter - state.stateEnteredFrame >= profile.ignitionDelayFrames) {
        state.state = 'IGNITION';
        state.stateEnteredFrame = this.frameCounter;
      }

      if (state.state === 'IGNITION') {
        state.armed = true;
        state.fuelExpirationFrame = profile.fuelLifetimeFrames > 0
          ? this.frameCounter + profile.fuelLifetimeFrames
          : Number.MAX_SAFE_INTEGER;
        state.state = 'ATTACK_NOTURN';
        state.stateEnteredFrame = this.frameCounter;
      }

      if (state.state === 'ATTACK_NOTURN' && state.noTurnDistanceLeft <= 0) {
        state.state = 'ATTACK';
        state.stateEnteredFrame = this.frameCounter;
      }

      const fuelExpired = this.frameCounter >= state.fuelExpirationFrame;
      if (fuelExpired && profile.detonateOnNoFuel) {
        event.impactX = state.currentX;
        event.impactY = state.currentY;
        event.impactZ = state.currentZ;
        event.executeFrame = this.frameCounter;
        continue;
      }
      if (fuelExpired && !profile.detonateOnNoFuel && state.state !== 'KILL_SELF') {
        state.state = 'KILL_SELF';
        state.stateEnteredFrame = this.frameCounter;
        event.countermeasureNoDamage = true;
        event.primaryVictimEntityId = null;
        event.suppressImpactVisual = true;
      }
      if (state.state === 'KILL_SELF') {
        if (this.frameCounter - state.stateEnteredFrame >= profile.killSelfDelayFrames) {
          event.countermeasureNoDamage = true;
          event.primaryVictimEntityId = null;
          event.impactX = state.currentX;
          event.impactY = state.currentY;
          event.impactZ = state.currentZ;
          event.executeFrame = this.frameCounter;
        }
        continue;
      }

      const speed = Number.isFinite(state.speed) && state.speed > 0
        ? state.speed
        : Math.max(1, Math.hypot(state.velocityX, state.velocityY, state.velocityZ));

      let dirX = state.velocityX;
      let dirY = state.velocityY;
      let dirZ = state.velocityZ;
      const canTurn = (state.state === 'ATTACK' || state.state === 'KILL') && !fuelExpired;
      if (canTurn) {
        const toTargetX = state.targetX - state.currentX;
        const toTargetY = state.targetY - state.currentY;
        const toTargetZ = state.targetZ - state.currentZ;
        const toTargetLength = Math.hypot(toTargetX, toTargetY, toTargetZ);
        if (toTargetLength > 0) {
          const desiredDirX = toTargetX / toTargetLength;
          const desiredDirY = toTargetY / toTargetLength;
          const desiredDirZ = toTargetZ / toTargetLength;

          const maxTurnRate = state.state === 'KILL'
            ? Number.POSITIVE_INFINITY
            : profile.turnRatePerFrame;
          if (Number.isFinite(maxTurnRate) && maxTurnRate > 0) {
            const currentHeading = Math.atan2(state.velocityX, state.velocityZ);
            const desiredHeading = Math.atan2(desiredDirX, desiredDirZ);
            const headingDelta = this.normalizeAngle(desiredHeading - currentHeading);
            const clampedTurn = Math.max(-maxTurnRate, Math.min(maxTurnRate, headingDelta));
            const nextHeading = currentHeading + clampedTurn;
            const horizontal = Math.hypot(desiredDirX, desiredDirZ);
            const pitch = Math.atan2(desiredDirY, horizontal);
            dirX = Math.sin(nextHeading);
            dirY = Math.sin(pitch);
            dirZ = Math.cos(nextHeading);
          } else {
            dirX = desiredDirX;
            dirY = desiredDirY;
            dirZ = desiredDirZ;
          }
        }
      }

      const directionLength = Math.hypot(dirX, dirY, dirZ);
      if (directionLength > 0) {
        dirX /= directionLength;
        dirY /= directionLength;
        dirZ /= directionLength;
      } else {
        const fallbackX = state.targetX - state.currentX;
        const fallbackY = state.targetY - state.currentY;
        const fallbackZ = state.targetZ - state.currentZ;
        const fallbackLength = Math.hypot(fallbackX, fallbackY, fallbackZ);
        if (fallbackLength > 0) {
          dirX = fallbackX / fallbackLength;
          dirY = fallbackY / fallbackLength;
          dirZ = fallbackZ / fallbackLength;
        } else {
          dirX = 0;
          dirY = 0;
          dirZ = 1;
        }
      }

      state.prevX = state.currentX;
      state.prevY = state.currentY;
      state.prevZ = state.currentZ;

      state.velocityX = dirX * speed;
      state.velocityY = dirY * speed;
      state.velocityZ = dirZ * speed;
      state.currentX += state.velocityX;
      state.currentY += state.velocityY;
      state.currentZ += state.velocityZ;

      const distanceThisFrame = Math.hypot(
        state.currentX - state.prevX,
        state.currentY - state.prevY,
        state.currentZ - state.prevZ,
      );
      if (state.noTurnDistanceLeft > 0 && (state.state === 'ATTACK_NOTURN' || state.state === 'ATTACK')) {
        state.noTurnDistanceLeft -= distanceThisFrame;
      }
      state.travelDistance += distanceThisFrame;

      // Source parity: below world is silently destroyed.
      if (state.currentY < 0) {
        event.countermeasureNoDamage = true;
        event.impactX = state.currentX;
        event.impactY = state.currentY;
        event.impactZ = state.currentZ;
        event.executeFrame = this.frameCounter;
        continue;
      }

      event.impactX = state.targetX;
      event.impactY = state.targetY;
      event.impactZ = state.targetZ;

      if (state.armed) {
        // Source parity: DistanceToTargetForLock switches missiles into KILL.
        let lockDistance = profile.distanceToTargetForLock;
        if (lockDistance > 0 && !state.trackingTarget) {
          lockDistance *= 0.5;
        }
        const distanceToTarget2D = Math.hypot(state.targetX - state.currentX, state.targetZ - state.currentZ);
        const distanceToTarget3D = Math.hypot(
          state.targetX - state.currentX,
          state.targetY - state.currentY,
          state.targetZ - state.currentZ,
        );

        if (lockDistance > 0 && distanceToTarget2D <= lockDistance && state.state !== 'KILL') {
          // Source parity: coordinate-shot missiles dive to original target when lock range is reached.
          if (!state.trackingTarget) {
            state.targetX = state.originalTargetX;
            state.targetY = state.originalTargetY;
            state.targetZ = state.originalTargetZ;
          }
          state.state = 'KILL';
          state.stateEnteredFrame = this.frameCounter;
        }

        if (state.state === 'KILL') {
          if (distanceToTarget3D <= Math.max(1, speed)) {
            event.impactX = state.targetX;
            event.impactY = state.targetY;
            event.impactZ = state.targetZ;
            event.executeFrame = this.frameCounter;
          }
        } else if (lockDistance <= 0 && distanceToTarget3D <= Math.max(1, speed)) {
          event.impactX = state.targetX;
          event.impactY = state.targetY;
          event.impactZ = state.targetZ;
          event.executeFrame = this.frameCounter;
        }
      }
    }
  }

  /**
   * Source parity: DumbProjectileBehavior::update() / PhysicsBehavior collision detection.
   * For each in-flight projectile, interpolate the current position and check for
   * entity collisions using shouldProjectileCollideWithEntity(). If a collision is
   * detected before the pre-calculated impact frame, early-detonate the projectile
   * at the collision point.
   */
  private updateProjectileFlightCollisions(): void {
    for (const event of this.pendingWeaponDamageEvents) {
      if (event.delivery !== 'PROJECTILE') continue;
      if (event.executeFrame <= this.frameCounter) continue;
      const missileState = event.missileAIState;
      if (missileState && !missileState.armed) continue;

      // Interpolate current projectile position (or use MissileAI runtime position).
      let projX: number, projZ: number;
      if (missileState) {
        projX = missileState.currentX;
        projZ = missileState.currentZ;
      } else {
        const totalFrames = event.executeFrame - event.launchFrame;
        if (totalFrames <= 0) continue;

        const elapsed = this.frameCounter - event.launchFrame;
        const progress = Math.min(1, Math.max(0, elapsed / totalFrames));
        if (event.hasBezierArc) {
          const p0x = event.sourceX, p0z = event.sourceZ;
          const p3x = event.impactX, p3z = event.impactZ;
          const dx = p3x - p0x, dz = p3z - p0z;
          const dist = Math.hypot(dx, dz);
          const nx = dist > 0 ? dx / dist : 0;
          const nz = dist > 0 ? dz / dist : 0;
          const p1x = p0x + nx * dist * event.bezierFirstPercentIndent;
          const p1z = p0z + nz * dist * event.bezierFirstPercentIndent;
          const p2x = p0x + nx * dist * event.bezierSecondPercentIndent;
          const p2z = p0z + nz * dist * event.bezierSecondPercentIndent;
          projX = evaluateCubicBezier(progress, p0x, p1x, p2x, p3x);
          projZ = evaluateCubicBezier(progress, p0z, p1z, p2z, p3z);
        } else {
          projX = event.sourceX + (event.impactX - event.sourceX) * progress;
          projZ = event.sourceZ + (event.impactZ - event.sourceZ) * progress;
        }
      }

      const launcher = this.spawnedEntities.get(event.sourceEntityId);
      const weapon = event.weapon;

      // Check each entity for collision with the projectile's current position.
      for (const candidate of this.spawnedEntities.values()) {
        if (candidate.destroyed || !candidate.canTakeDamage) continue;
        // Skip the intended victim — damage will be applied at the final impact point.
        if (event.primaryVictimEntityId !== null && candidate.id === event.primaryVictimEntityId) continue;

        const collisionRadius = resolveProjectilePointCollisionRadiusImpl(candidate, MAP_XY_FACTOR);
        const dx = projX - candidate.x;
        const dz = projZ - candidate.z;
        const distSq = dx * dx + dz * dz;
        if (distSq > collisionRadius * collisionRadius) continue;

        // Verify this collision is valid per shouldProjectileCollideWithEntity rules.
        const shouldCollide = shouldProjectileCollideWithEntityImpl(
          launcher ?? null,
          weapon,
          candidate,
          event.primaryVictimEntityId,
          (l) => this.resolveProjectileLauncherContainer(l),
          (e) => this.resolveEntityKindOfSet(e),
          (entity, kindOf, victimId) => isAirfieldReservedForProjectileVictimImpl(
            entity, kindOf, victimId,
            (entityId) => this.spawnedEntities.get(entityId) ?? null,
          ),
          (e) => this.entityHasSneakyTargetingOffset(e),
          (l, e) => this.getTeamRelationship(l, e),
          (side) => this.normalizeSide(side),
          (e) => this.resolveEntityFenceWidth(e),
          { allies: RELATIONSHIP_ALLIES, enemies: RELATIONSHIP_ENEMIES },
          {
            collideAllies: WEAPON_COLLIDE_ALLIES,
            collideEnemies: WEAPON_COLLIDE_ENEMIES,
            collideControlledStructures: WEAPON_COLLIDE_CONTROLLED_STRUCTURES,
            collideStructures: WEAPON_COLLIDE_STRUCTURES,
            collideShrubbery: WEAPON_COLLIDE_SHRUBBERY,
            collideProjectile: WEAPON_COLLIDE_PROJECTILE,
            collideWalls: WEAPON_COLLIDE_WALLS,
            collideSmallMissiles: WEAPON_COLLIDE_SMALL_MISSILES,
            collideBallisticMissiles: WEAPON_COLLIDE_BALLISTIC_MISSILES,
          },
        );

        if (shouldCollide) {
          // Early-detonate: redirect impact to the collision point and resolve this frame.
          event.impactX = projX;
          event.impactZ = projZ;
          event.impactY = this.resolveGroundHeight(projX, projZ);
          event.executeFrame = this.frameCounter;
          // Redirect damage to the collided entity instead of the original victim.
          event.primaryVictimEntityId = candidate.id;
          break;
        }
      }
    }
  }

  private updatePendingWeaponDamage(): void {
    // Emit impact visual events for projectiles resolving this frame.
    for (const event of this.pendingWeaponDamageEvents) {
      if (event.executeFrame <= this.frameCounter) {
        // Source parity: MissileAIUpdate::doKillState — diverted missiles still detonate
        // visually but deal no damage. KILL_SELF teardown suppresses visuals.
        if (!event.suppressImpactVisual) {
          this.emitWeaponImpactVisualEvent(event);
        }

        // Source parity: countermeasure-diverted missiles — suppress damage and radii.
        if (event.countermeasureNoDamage) {
          event.weapon = {
            ...event.weapon,
            primaryDamage: 0,
            secondaryDamage: 0,
            primaryDamageRadius: 0,
            secondaryDamageRadius: 0,
          };
        }
      }
    }
    updatePendingWeaponDamageImpl(this.createCombatDamageEventContext());
  }

  private resolveProjectileLauncherContainer(projectileLauncher: MapEntity): MapEntity | null {
    // Source parity: Object::getContainedBy() — single containment pointer.
    // In our model containment is split across multiple ID fields; delegate to the
    // unified resolver.
    return this.resolveEntityContainingObject(projectileLauncher);
  }

  private resolveEntityBoundingRadius(entity: MapEntity): number {
    const geom = entity.obstacleGeometry;
    if (geom && geom.majorRadius > 0) {
      return Math.max(geom.majorRadius, geom.minorRadius);
    }
    return entity.nominalHeight / 2;
  }

  private resolveEntityKindOfSet(entity: MapEntity): Set<string> {
    const kindOf = new Set<string>();
    switch (entity.category) {
      case 'building':
        kindOf.add('STRUCTURE');
        break;
      case 'infantry':
        kindOf.add('INFANTRY');
        break;
      case 'air':
        kindOf.add('AIRCRAFT');
        break;
      case 'vehicle':
      default:
        break;
    }

    const registry = this.iniDataRegistry;
    if (!registry) {
      return kindOf;
    }
    const objectDef = findObjectDefByName(registry, entity.templateName);
    if (!objectDef) {
      return kindOf;
    }
    for (const flag of this.normalizeKindOf(objectDef.kindOf)) {
      kindOf.add(flag);
    }
    return kindOf;
  }

  private resolveEntityContainingObject(entity: MapEntity): MapEntity | null {
    // Source parity: Object::getContainedBy() — single m_containedBy pointer.
    // In our model, containment is tracked across multiple ID fields for different
    // container types. At most one will be non-null at any time (mutual exclusion).
    const containerId = entity.parkingSpaceProducerId
      ?? entity.helixCarrierId
      ?? entity.garrisonContainerId
      ?? entity.transportContainerId
      ?? entity.tunnelContainerId;

    if (containerId === null) {
      return null;
    }

    const container = this.spawnedEntities.get(containerId);
    if (!container || container.destroyed) {
      return null;
    }

    return container;
  }

  private isPassengerAllowedToFireFromContainingObject(
    entity: MapEntity,
    container: MapEntity,
  ): boolean {
    // Source parity:
    // - Object::isAbleToAttack() first gates attacks when container->isPassengerAllowedToFire() is false.
    //   (Generals/Code/GameEngine/Source/GameLogic/Object/Object.cpp:2865)
    // - WeaponSet::getAbleToUseWeaponAgainstTarget() checks container riders when allowed.
    //   (Generals/Code/GameEngine/Source/GameLogic/Object/WeaponSet.cpp:711)
    // - OpenContain recursively delegates to a parent container; OverlordContain redirect chains
    //   similarly in the engine.
    //   (OpenContain.cpp:1035, OverlordContain.cpp:99)
    return isPassengerAllowedToFireFromContainingObjectImpl(
      entity,
      container,
      (targetEntity) => this.resolveEntityKindOfSet(targetEntity),
      (targetEntity) => this.resolveEntityContainingObject(targetEntity),
      (targetEntity, statusName) => this.entityHasObjectStatus(targetEntity, statusName),
    );
  }

  private resolveEntityFenceWidth(entity: MapEntity): number {
    const registry = this.iniDataRegistry;
    if (!registry) {
      return 0;
    }
    const objectDef = findObjectDefByName(registry, entity.templateName);
    if (!objectDef) {
      return 0;
    }
    const fenceWidth = readNumericField(objectDef.fields, ['FenceWidth']) ?? 0;
    if (!Number.isFinite(fenceWidth) || fenceWidth <= 0) {
      return 0;
    }
    return fenceWidth;
  }

  /**
   * Source parity: SpawnBehavior::update — create/replace slaves on schedule.
   * Runs at LOGICFRAMES_PER_SECOND/2 rate in C++; we run every frame since the
   * scheduled replacement times already encode the delay.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Behavior/SpawnBehavior.cpp:322-400)
   */
  private updateSpawnBehaviors(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      const state = entity.spawnBehaviorState;
      if (!state || (state.profile.oneShot && state.oneShotCompleted)) {
        continue;
      }

      // Prune dead slaves from the tracking list.
      state.slaveIds = state.slaveIds.filter((slaveId) => {
        const slave = this.spawnedEntities.get(slaveId);
        return slave !== undefined && !slave.destroyed;
      });

      // Process scheduled replacements.
      while (
        state.slaveIds.length < state.profile.spawnNumber
        && state.replacementFrames.length > 0
      ) {
        const nextFrame = state.replacementFrames[0];
        if (nextFrame !== undefined && this.frameCounter > nextFrame) {
          state.replacementFrames.shift();
          this.createSpawnSlave(entity, state);
        } else {
          break;
        }
      }

      // Source parity: SpawnBehavior initializes m_replacementTimes once via
      // m_initialBurstTimesInited guard. The burst creates slaves immediately up
      // to initialBurst count, then schedules the rest with spawnReplaceDelay.
      if (
        !state.initialBurstApplied
        && state.slaveIds.length < state.profile.spawnNumber
        && state.replacementFrames.length === 0
      ) {
        state.initialBurstApplied = true;
        const deficit = state.profile.spawnNumber - state.slaveIds.length;
        for (let i = 0; i < deficit; i += 1) {
          if (state.profile.initialBurst > 0 && state.slaveIds.length < state.profile.initialBurst) {
            // Initial burst spawns immediately.
            this.createSpawnSlave(entity, state);
          } else {
            // Source parity: C++ schedules at listIndex (0, 1, 2...) when
            // m_initialBurst == 0, causing all spawns to fire on next update.
            // We schedule at frame 0 (always in the past) for the same effect.
            state.replacementFrames.push(0);
          }
        }
        if (state.profile.oneShot) {
          state.oneShotCompleted = true;
        }
      }

      // Source parity: attack forwarding for SPAWNS_ARE_THE_WEAPONS masters.
      if (entity.kindOf.has('SPAWNS_ARE_THE_WEAPONS') && !state.profile.slavesHaveFreeWill) {
        const masterTarget = entity.attackTargetEntityId;
        if (masterTarget !== null) {
          for (const slaveId of state.slaveIds) {
            const slave = this.spawnedEntities.get(slaveId);
            if (slave && !slave.destroyed && slave.attackTargetEntityId !== masterTarget) {
              slave.attackTargetEntityId = masterTarget;
              slave.attackTargetPosition = null;
            }
          }
        }
      }
    }
  }

  /**
   * Source parity: SpawnBehavior::createSpawn — spawn a slave unit and link it to the slaver.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Behavior/SpawnBehavior.cpp:620-700)
   */
  private createSpawnSlave(slaver: MapEntity, state: SpawnBehaviorState): void {
    if (state.slaveIds.length >= state.profile.spawnNumber) {
      return;
    }

    const templateNames = state.profile.spawnTemplateNames;
    if (templateNames.length === 0) {
      return;
    }
    const templateName = templateNames[state.templateNameIndex % templateNames.length]!;
    state.templateNameIndex = (state.templateNameIndex + 1) % templateNames.length;

    const slave = this.spawnEntityFromTemplate(
      templateName,
      slaver.x,
      slaver.z,
      slaver.rotationY,
      slaver.side,
    );
    if (!slave) {
      return;
    }

    // Source parity: SlavedUpdate::onEnslave — link slave to slaver.
    slave.slaverEntityId = slaver.id;
    state.slaveIds.push(slave.id);

    // Source parity: onEnslave marks slaves as UNSELECTABLE.
    slave.objectStatusFlags.add('UNSELECTABLE');

    // Source parity: randomize initial guard offset at guardMaxRange distance (on circle perimeter).
    const guardRange = slave.slavedUpdateProfile?.guardMaxRange ?? 30;
    if (guardRange > 0) {
      const angle = this.gameRandom.nextFloat() * Math.PI * 2;
      slave.slaveGuardOffsetX = Math.cos(angle) * guardRange;
      slave.slaveGuardOffsetZ = Math.sin(angle) * guardRange;
    }
  }

  /**
   * Source parity: SpawnBehavior::onDie — orphan or kill all slaves when the slaver dies.
   * If spawnedRequireSpawner is true, all living slaves are immediately killed.
   * Otherwise, slaves become orphaned (slaverEntityId = null).
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Behavior/SpawnBehavior.cpp:142-197)
   */
  private onSlaverDeath(slaver: MapEntity): void {
    const state = slaver.spawnBehaviorState;
    if (!state) {
      return;
    }

    for (const slaveId of state.slaveIds) {
      const slave = this.spawnedEntities.get(slaveId);
      if (!slave || slave.destroyed) {
        continue;
      }
      // Source parity: sdu->onSlaverDie() → stopSlavedEffects() — clear slaver link and flags.
      slave.slaverEntityId = null;
      slave.objectStatusFlags.delete('UNSELECTABLE');

      if (state.profile.spawnedRequireSpawner) {
        // Source parity: SpawnBehavior::onDie kills slaves when spawnedRequireSpawner.
        this.applyWeaponDamageAmount(null, slave, slave.health, 'UNRESISTABLE');
      } else {
        // Source parity: orphaned slave gets DISABLED_UNMANNED (crashes/dies on next update).
        slave.objectStatusFlags.add('DISABLED_UNMANNED');
      }
    }

    state.slaveIds = [];
    state.replacementFrames = [];
  }

  /**
   * Source parity: SpawnBehavior::onSpawnDeath — notify slaver that a slave died,
   * schedule replacement, and check aggregate health destruction.
   * (GeneralsMD/Code/GameEngine/Source/GameLogic/Object/Behavior/SpawnBehavior.cpp:754-783)
   */
  private onSlaveDeath(slave: MapEntity): void {
    const slaverId = slave.slaverEntityId;
    if (slaverId === null) {
      return;
    }
    const slaver = this.spawnedEntities.get(slaverId);
    if (!slaver || slaver.destroyed) {
      return;
    }
    const state = slaver.spawnBehaviorState;
    if (!state) {
      return;
    }

    // Remove from tracking.
    const index = state.slaveIds.indexOf(slave.id);
    if (index !== -1) {
      state.slaveIds.splice(index, 1);
    }

    // Schedule replacement (unless one-shot).
    if (!state.profile.oneShot || !state.oneShotCompleted) {
      state.replacementFrames.push(this.frameCounter + state.profile.spawnReplaceDelayFrames);
    }

    // Source parity: aggregate health — spawner dies when all slaves are dead.
    if (state.profile.aggregateHealth && state.slaveIds.length === 0) {
      this.applyWeaponDamageAmount(null, slaver, slaver.health, 'UNRESISTABLE');
    }
  }

  private updateWeaponIdleAutoReload(): void {
    // Source parity subset: FiringTracker::update() calls Object::reloadAllAmmo(TRUE),
    // forcing an immediate reload after sustained idle time.
    updateWeaponIdleAutoReloadImpl(this.spawnedEntities.values(), this.frameCounter);

    // Source parity: FiringTracker::update() — continuous-fire cooldown ticking.
    // When the cooldown frame elapses, cool down one step per LOGICFRAMES_PER_SECOND (30).
    this.updateFiringTrackerCooldowns();
  }

  /** Source parity: FiringTracker::update() — cooldown ticking once per second. */
  private updateFiringTrackerCooldowns(): void {
    const LOGICFRAMES_PER_SECOND = 30;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.continuousFireCooldownFrame === 0) continue;
      if (this.frameCounter <= entity.continuousFireCooldownFrame) continue;

      // Coast window has elapsed — cool down one step.
      if (
        entity.continuousFireState !== 'NONE'
        || entity.objectStatusFlags.has('CONTINUOUS_FIRE_SLOW')
      ) {
        this.continuousFireCoolDown(entity);
        // Source parity: reschedule cooldown tick 1 second later for the SLOW → NONE step.
        if (entity.objectStatusFlags.has('CONTINUOUS_FIRE_SLOW')) {
          entity.continuousFireCooldownFrame = this.frameCounter + LOGICFRAMES_PER_SECOND;
        }
      } else {
        // Fully cooled — stop ticking.
        entity.continuousFireCooldownFrame = 0;
      }
    }
  }

  private computeAttackRetreatTarget(
    attacker: MapEntity,
    target: MapEntity,
    weapon: AttackWeaponProfile,
  ): VectorXZ | null {
    // Source parity subset: Weapon::computeApproachTarget() retreats too-close attackers to a
    // point between minimum and maximum range.
    // TODO(C&C source parity): port angleOffset/aircraft-facing/terrain-clipping behavior.
    return computeAttackRetreatTargetImpl(attacker.x, attacker.z, target.x, target.z, weapon);
  }

  private resetEntityWeaponTimingState(entity: MapEntity): void {
    resetEntityWeaponTimingStateImpl(entity);
  }

  private rebuildEntityScatterTargets(entity: MapEntity): void {
    rebuildEntityScatterTargetsImpl(entity);
  }

  private resolveWeaponPreAttackDelayFrames(
    attacker: MapEntity,
    target: MapEntity,
    weapon: AttackWeaponProfile,
  ): number {
    const baseDelay = resolveWeaponPreAttackDelayFramesImpl(attacker, target.id, weapon);
    if (baseDelay <= 0) return 0;
    // Source parity: WeaponTemplate::getPreAttackDelay(bonus) *= PRE_ATTACK bonus.
    const preAttackBonus = this.resolveWeaponPreAttackBonusMultiplier(attacker);
    if (preAttackBonus === 1.0) return baseDelay;
    return Math.max(0, Math.floor(baseDelay * preAttackBonus));
  }

  /**
   * Source parity: FiringTracker::shotFired() — track consecutive shots, manage
   * continuous-fire speedup/cooldown state machine (NONE → MEAN → FAST).
   */
  private recordConsecutiveAttackShot(attacker: MapEntity, targetEntityId: number): void {
    const weapon = attacker.attackWeapon;
    if (!weapon) {
      recordConsecutiveAttackShotImpl(attacker, targetEntityId);
      return;
    }

    // Source parity: consecutive-shot counting with coast window for target switching.
    if (targetEntityId === attacker.consecutiveShotsTargetEntityId) {
      attacker.consecutiveShotsAtTarget += 1;
    } else if (this.frameCounter < attacker.continuousFireCooldownFrame) {
      // Switching targets within the coast window preserves the shot count.
      attacker.consecutiveShotsAtTarget += 1;
      attacker.consecutiveShotsTargetEntityId = targetEntityId;
    } else {
      attacker.consecutiveShotsAtTarget = 1;
      attacker.consecutiveShotsTargetEntityId = targetEntityId;
    }

    // Source parity: compute the "possible next shot frame" for coast-window calculation.
    // In C++, this comes from Weapon::m_whenWeCanFireAgain set inside privateFireWeapon()
    // which already includes the active bonus multiplier.
    const possibleNextShotFrame = this.frameCounter + this.resolveWeaponDelayFramesWithBonus(attacker, weapon);

    // Source parity: coast = time after next possible shot we stay in continuous-fire mode.
    const coast = weapon.continuousFireCoastFrames;
    if (coast > 0) {
      attacker.continuousFireCooldownFrame = possibleNextShotFrame + coast;
    } else {
      attacker.continuousFireCooldownFrame = 0;
    }

    // Source parity: FiringTracker state machine — speedUp/coolDown based on shot count.
    const shotsNeededOne = weapon.continuousFireOneShotsNeeded;
    const shotsNeededTwo = weapon.continuousFireTwoShotsNeeded;
    if (shotsNeededOne <= 0 && shotsNeededTwo <= 0) {
      return; // No continuous-fire config on this weapon.
    }

    const shots = attacker.consecutiveShotsAtTarget;
    const state = attacker.continuousFireState;

    if (state === 'MEAN') {
      if (shots < shotsNeededOne) {
        this.continuousFireCoolDown(attacker);
      } else if (shots > shotsNeededTwo) {
        this.continuousFireSpeedUp(attacker);
      }
    } else if (state === 'FAST') {
      if (shots < shotsNeededTwo) {
        this.continuousFireCoolDown(attacker);
      }
    } else {
      // NONE state — check if we should speed up.
      if (shots > shotsNeededOne) {
        this.continuousFireSpeedUp(attacker);
      }
    }
  }

  /**
   * Source parity: FiringTracker::speedUp() — step up one continuous-fire tier.
   * NONE → MEAN, MEAN → FAST (plays VoiceRapidFire). Flags are exclusive.
   */
  private continuousFireSpeedUp(entity: MapEntity): void {
    if (entity.continuousFireState === 'FAST') {
      return; // Already at max.
    }
    if (entity.continuousFireState === 'MEAN') {
      entity.continuousFireState = 'FAST';
      entity.objectStatusFlags.add('CONTINUOUS_FIRE_FAST');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_MEAN');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_SLOW');
    } else {
      // NONE → MEAN.
      entity.continuousFireState = 'MEAN';
      entity.objectStatusFlags.add('CONTINUOUS_FIRE_MEAN');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_FAST');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_SLOW');
    }
  }

  /**
   * Source parity: FiringTracker::coolDown() — drop to SLOW visual state (clears
   * both bonus conditions), then on next tick drop to NONE. Resets shot count.
   */
  private continuousFireCoolDown(entity: MapEntity): void {
    if (
      entity.continuousFireState === 'FAST'
      || entity.continuousFireState === 'MEAN'
    ) {
      // FAST or MEAN → SLOW visual (bonus removed, intermediate visual spin-down).
      entity.continuousFireState = 'NONE';
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_FAST');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_MEAN');
      entity.objectStatusFlags.add('CONTINUOUS_FIRE_SLOW');
      // Source parity: m_frameToStartCooldown is NOT zeroed here — update() ticks
      // again in LOGICFRAMES_PER_SECOND to clear the SLOW visual state.
    } else {
      // Already at NONE (or SLOW) — clear visual spin-down.
      entity.continuousFireState = 'NONE';
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_FAST');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_MEAN');
      entity.objectStatusFlags.delete('CONTINUOUS_FIRE_SLOW');
      entity.continuousFireCooldownFrame = 0;
    }
    entity.consecutiveShotsAtTarget = 0;
    entity.consecutiveShotsTargetEntityId = null;
  }

  /**
   * Source parity: resolve the effective rate-of-fire multiplier for the attacker's
   * current continuous-fire state from the weapon's per-weapon bonus config.
   */
  private resolveContinuousFireRateOfFireBonus(entity: MapEntity, weapon: AttackWeaponProfile): number {
    if (entity.continuousFireState === 'FAST') {
      return weapon.continuousFireFastRateOfFire;
    }
    if (entity.continuousFireState === 'MEAN') {
      return weapon.continuousFireMeanRateOfFire;
    }
    return 1.0;
  }

  /**
   * Source parity: Weapon::computeBonus() — resolve the effective bonus condition flags
   * for an entity, including veterancy, player upgrades, continuous-fire, and garrisoned state.
   * Returns the full condition bitmask to use with computeWeaponBonusField().
   */
  private resolveEntityWeaponBonusConditionFlags(entity: MapEntity): number {
    let flags = entity.weaponBonusConditionFlags;
    // Continuous-fire conditions are set dynamically per frame.
    if (entity.continuousFireState === 'MEAN') {
      flags |= WEAPON_BONUS_CONTINUOUS_FIRE_MEAN;
    } else if (entity.continuousFireState === 'FAST') {
      flags |= WEAPON_BONUS_CONTINUOUS_FIRE_FAST;
    }
    // Garrisoned condition if entity is contained inside a garrison.
    if (this.isEntityContainedInGarrison(entity)) {
      flags |= WEAPON_BONUS_GARRISONED;
    }
    return flags;
  }

  /**
   * Source parity: WeaponTemplate::getPrimaryDamage(bonus) — compute effective weapon damage
   * multiplied by the active DAMAGE bonus from the global weapon bonus table.
   */
  private resolveWeaponDamageBonusMultiplier(entity: MapEntity): number {
    const flags = this.resolveEntityWeaponBonusConditionFlags(entity);
    return computeWeaponBonusField(this.globalWeaponBonusTable, flags, WEAPON_BONUS_FIELD_DAMAGE);
  }

  /**
   * Source parity: WeaponTemplate::getAttackRange(bonus) — compute effective attack range
   * multiplied by the active RANGE bonus from the global weapon bonus table.
   */
  private resolveWeaponRangeBonusMultiplier(entity: MapEntity): number {
    const flags = this.resolveEntityWeaponBonusConditionFlags(entity);
    return computeWeaponBonusField(this.globalWeaponBonusTable, flags, WEAPON_BONUS_FIELD_RANGE);
  }

  /**
   * Source parity: WeaponTemplate::getDelayBetweenShots(bonus) — compute effective ROF bonus
   * multiplied by the active RATE_OF_FIRE bonus from the global weapon bonus table.
   */
  private resolveWeaponRateOfFireBonusMultiplier(entity: MapEntity): number {
    const flags = this.resolveEntityWeaponBonusConditionFlags(entity);
    return computeWeaponBonusField(this.globalWeaponBonusTable, flags, WEAPON_BONUS_FIELD_RATE_OF_FIRE);
  }

  /**
   * Source parity: WeaponTemplate::getPreAttackDelay(bonus) — compute effective pre-attack
   * delay multiplied by the active PRE_ATTACK bonus from the global weapon bonus table.
   */
  private resolveWeaponPreAttackBonusMultiplier(entity: MapEntity): number {
    const flags = this.resolveEntityWeaponBonusConditionFlags(entity);
    return computeWeaponBonusField(this.globalWeaponBonusTable, flags, WEAPON_BONUS_FIELD_PRE_ATTACK);
  }

  /**
   * Source parity: WeaponTemplate::getPrimaryDamageRadius(bonus) — compute effective damage
   * radius multiplied by the active RADIUS bonus from the global weapon bonus table.
   */
  private resolveWeaponRadiusBonusMultiplier(entity: MapEntity): number {
    const flags = this.resolveEntityWeaponBonusConditionFlags(entity);
    return computeWeaponBonusField(this.globalWeaponBonusTable, flags, WEAPON_BONUS_FIELD_RADIUS);
  }

  private resolveWeaponDelayFrames(weapon: AttackWeaponProfile): number {
    return resolveWeaponDelayFramesImpl(
      weapon,
      (minDelay, maxDelay) => this.gameRandom.nextRange(minDelay, maxDelay),
    );
  }

  /**
   * Source parity: Weapon::getDelayBetweenShots — resolve delay directly from a WeaponDef.
   * Used by FireWeaponWhenDamagedBehavior for per-weapon cooldown tracking.
   */
  private resolveWeaponDefDelayFrames(weaponDef: WeaponDef): number {
    const delayValues = readNumericList(weaponDef.fields['DelayBetweenShots']);
    const minDelayMs = delayValues[0] ?? 0;
    const maxDelayMs = delayValues[1] ?? minDelayMs;
    const minFrames = this.msToLogicFrames(minDelayMs);
    const maxFrames = Math.max(minFrames, this.msToLogicFrames(maxDelayMs));
    if (minFrames === maxFrames) return minFrames;
    return this.gameRandom.nextRange(minFrames, maxFrames);
  }

  /**
   * Source parity: WeaponTemplate::getDelayBetweenShots(bonus) — compute delay
   * and divide by the active RATE_OF_FIRE bonus multiplier.
   */
  private resolveWeaponDelayFramesWithBonus(attacker: MapEntity, weapon: AttackWeaponProfile): number {
    const baseDelay = this.resolveWeaponDelayFrames(weapon);
    // Source parity: combine per-weapon continuous-fire bonus with global table ROF bonus.
    const continuousFireBonus = this.resolveContinuousFireRateOfFireBonus(attacker, weapon);
    const globalRofBonus = this.resolveWeaponRateOfFireBonusMultiplier(attacker);
    // Additive accumulation: both bonuses contribute (globalRofBonus already includes 1.0 base).
    const totalRofBonus = continuousFireBonus + (globalRofBonus - 1.0);
    if (totalRofBonus <= 0 || totalRofBonus === 1.0) {
      return baseDelay;
    }
    // Source parity: REAL_TO_INT_FLOOR(delay / rofBonus).
    return Math.max(0, Math.floor(baseDelay / totalRofBonus));
  }

  private applyWeaponDamageAmount(
    sourceEntityId: number | null,
    target: MapEntity,
    amount: number,
    damageType: string,
    weaponDeathType?: string,
  ): void {
    // Source parity: InactiveBody::attemptDamage — only UNRESISTABLE triggers death.
    // Must check before canTakeDamage guard since InactiveBody has canTakeDamage=false.
    if (target.bodyType === 'INACTIVE') {
      if (target.destroyed) return;
      if (damageType.toUpperCase() === 'UNRESISTABLE') {
        target.health = 0;
        target.pendingDeathType = weaponDeathType || damageTypeToDeathType(damageType);
        if (!target.slowDeathState && !target.structureCollapseState) {
          this.tryBeginStructureCollapse(target) ||
            this.tryBeginSlowDeath(target, sourceEntityId ?? -1) ||
            this.markEntityDestroyed(target.id, sourceEntityId ?? -1);
        }
      }
      return;
    }
    if (!target.canTakeDamage || target.destroyed || !Number.isFinite(amount) || amount <= 0) {
      return;
    }
    // Source parity: ActiveBody::attemptDamage — indestructible bodies ignore all damage.
    if (target.isIndestructible) {
      return;
    }

    // Source parity: HiveStructureBody::attemptDamage — redirect certain damage types to slaves.
    // If PropagateDamageTypesToSlavesWhenExisting matches and slaves exist, redirect to closest.
    // If no slaves and SwallowDamageTypesIfSlavesNotExisting matches, silently ignore damage.
    if (target.bodyType === 'HIVE_STRUCTURE' && target.hiveStructureProfile) {
      const hiveProf = target.hiveStructureProfile;
      const upperDamageType = damageType.toUpperCase();
      if (hiveProf.propagateDamageTypes.has(upperDamageType)) {
        const state = target.spawnBehaviorState;
        // Source parity: HiveStructureBody.cpp:78-96 — only redirect if shooter exists.
        // C++ calls findObjectByID(sourceID), and if null falls through to normal damage.
        const shooter = sourceEntityId !== null ? this.spawnedEntities.get(sourceEntityId) ?? null : null;
        if (shooter && state) {
          const aliveSlaveIds = state.slaveIds.filter((id) => {
            const slave = this.spawnedEntities.get(id);
            return slave && !slave.destroyed;
          });
          if (aliveSlaveIds.length > 0) {
            // Source parity: HiveStructureBody.cpp:81 — getClosestSlave(shooter->getPosition()).
            let closestSlave: MapEntity | null = null;
            let closestDistSqr = Infinity;
            for (const slaveId of aliveSlaveIds) {
              const slave = this.spawnedEntities.get(slaveId)!;
              const dx = slave.x - shooter.x;
              const dz = slave.z - shooter.z;
              const distSqr = dx * dx + dz * dz;
              if (distSqr < closestDistSqr) {
                closestDistSqr = distSqr;
                closestSlave = slave;
              }
            }
            if (closestSlave) {
              this.applyWeaponDamageAmount(sourceEntityId, closestSlave, amount, damageType, weaponDeathType);
              return;
            }
          } else if (hiveProf.swallowDamageTypes.has(upperDamageType)) {
            // No slaves and damage type is swallowed — silently ignore.
            return;
          }
        }
        // Fall through to normal StructureBody damage if shooter is null or no redirect.
      }
    }

    // Source parity: UndeadBody::attemptDamage — on first life, if damage would kill,
    // cap pre-armor amount to (health - 1). After damage applied, trigger second life.
    // C++ file: UndeadBody.cpp:76-97. Conditions: not UNRESISTABLE, not second life,
    // amount >= health, and IsHealthDamagingDamage (excludes STATUS/SUBDUAL/KILLPILOT etc).
    let shouldStartSecondLife = false;
    let inputAmount = amount;
    if (
      target.bodyType === 'UNDEAD'
      && !target.undeadIsSecondLife
      && damageType.toUpperCase() !== 'UNRESISTABLE'
      && isHealthDamagingDamage(damageType)
      && amount >= target.health
    ) {
      inputAmount = Math.min(amount, target.health - 1);
      if (inputAmount <= 0) inputAmount = 0;
      shouldStartSecondLife = true;
    }

    // Source parity: HighlanderBody::attemptDamage — cap raw damage before armor adjustment
    // so health doesn't drop below 1, UNLESS damage type is UNRESISTABLE.
    // C++ caps damageInfo->in.m_amount (pre-armor) then calls ActiveBody::attemptDamage.
    if (target.bodyType === 'HIGHLANDER' && damageType.toUpperCase() !== 'UNRESISTABLE') {
      inputAmount = Math.min(inputAmount, target.health - 1);
      if (inputAmount <= 0) {
        return;
      }
    }

    let adjustedDamage = this.adjustDamageByArmorSet(target, inputAmount, damageType);
    if (adjustedDamage <= 0) {
      return;
    }

    // Source parity: ActiveBody::attemptDamage line 495-512 — subdual damage handling.
    // Subdual damage accumulates separately from health, is armor-adjusted but NOT
    // affected by battle plan scalar, and does NOT reduce health.
    if (isSubdualDamage(damageType)) {
      if (target.subdualDamageCap <= 0) {
        // Source parity: canBeSubdued() returns false when subdualDamageCap == 0.
        return;
      }
      const wasSubdued = target.currentSubdualDamage >= target.maxHealth;
      target.currentSubdualDamage = Math.min(
        target.currentSubdualDamage + adjustedDamage,
        target.subdualDamageCap,
      );
      target.currentSubdualDamage = Math.max(0, target.currentSubdualDamage);
      const nowSubdued = target.currentSubdualDamage >= target.maxHealth;
      // Source parity: onSubdualChange — set/clear DISABLED_SUBDUED status.
      if (wasSubdued !== nowSubdued) {
        if (nowSubdued && !target.kindOf.has('PROJECTILE')) {
          target.objectStatusFlags.add('DISABLED_SUBDUED');
        } else {
          target.objectStatusFlags.delete('DISABLED_SUBDUED');
        }
      }
      // Source parity: Object::notifySubdualDamage → SubdualDamageHelper::notifySubdualDamage.
      // Reset heal countdown and wake the helper when positive damage is applied.
      if (adjustedDamage > 0 && target.subdualDamageHealRate > 0) {
        target.subdualHealingCountdown = target.subdualDamageHealRate;
      }
      // Source parity: C++ ActiveBody::attemptDamage sets alreadyHandled=TRUE (skipping health change)
      // but does NOT return — it continues to record lastDamageInfo, lastDamageTimestamp, and
      // notifies onDamage callbacks (retaliation, stealth reveal, etc.).
      if (damageType !== 'HEALING') {
        this.recordScriptLastDamageInfo(target, sourceEntityId);
        this.recordPreferredLastAttacker(target, sourceEntityId);
        this.recordAttackedBySource(target, sourceEntityId);
        target.lastDamageFrame = this.frameCounter;
      }
      // Source parity: ActiveBody.cpp notifies Player::setAttackedBy even when damage is
      // subdual-only. We record attacked-by side state and emit existing EVA cues.
      if (target.side && target.kindOf.has('STRUCTURE') && target.kindOf.has('MP_COUNT_FOR_VICTORY')) {
        this.emitEvaEvent('BASE_UNDER_ATTACK', target.side, 'own', target.id);
      }
      return;
    }

    // Source parity: Body::applyDamageScalar — multiply by battle plan armor scalar.
    if (target.battlePlanDamageScalar !== 1.0) {
      adjustedDamage = Math.max(0, adjustedDamage * target.battlePlanDamageScalar);
    }

    // Source parity: ImmortalBody::internalChangeHealth — clamp delta so health never drops below 1.
    // C++ overrides internalChangeHealth (post-armor), so this is correctly placed post-armor.
    if (target.bodyType === 'IMMORTAL') {
      adjustedDamage = Math.min(adjustedDamage, target.health - 1);
      if (adjustedDamage <= 0) {
        return;
      }
    }

    // Source parity: track body damage state transitions for SupplyWarehouseCripplingBehavior.
    const oldDamageState = target.supplyWarehouseCripplingProfile
      ? calcBodyDamageState(target.health, target.maxHealth)
      : 0 as BodyDamageState;

    target.health = Math.max(0, target.health - adjustedDamage);

    // Source parity: SupplyWarehouseCripplingBehavior::onBodyDamageStateChange.
    if (target.supplyWarehouseCripplingProfile && target.health > 0) {
      const newDamageState = calcBodyDamageState(target.health, target.maxHealth);
      if (oldDamageState !== newDamageState) {
        this.supplyWarehouseCripplingOnStateChange(target, oldDamageState, newDamageState);
      }
    }

    // Source parity: UndeadBody::startSecondLife — after damage applied, transition to second life.
    // Sets new max health (full heal), SECOND_LIFE armor flag, and model condition.
    // C++ file: UndeadBody.cpp:101-143.
    if (shouldStartSecondLife && target.bodyType === 'UNDEAD' && !target.undeadIsSecondLife) {
      target.undeadIsSecondLife = true;
      target.maxHealth = target.undeadSecondLifeMaxHealth;
      target.initialHealth = target.undeadSecondLifeMaxHealth;
      target.health = target.maxHealth; // FULLY_HEAL
      target.armorSetFlagsMask |= ARMOR_SET_FLAG_SECOND_LIFE;
      target.modelConditionFlags.add('SECOND_LIFE');
      // TODO(PARITY): C++ startSecondLife fires a SlowDeathBehavior for transformation visual.
      // In C++ the slow death runs while the entity stays alive (model swap animation).
      // Our tryBeginSlowDeath marks entity as dead, so we skip it here. The SECOND_LIFE
      // model condition provides basic visual differentiation. Full parity requires a
      // "slow-death-while-alive" system for proper model transition animations.
    }

    // Source parity: ActiveBody::getLastDamageTimestamp — track last damage frame for stealth.
    // Healing damage does not update the timestamp (C++ checks m_damageType != DAMAGE_HEALING).
    if (damageType !== 'HEALING') {
      this.recordScriptLastDamageInfo(target, sourceEntityId);
      this.recordPreferredLastAttacker(target, sourceEntityId);
      this.recordAttackedBySource(target, sourceEntityId);
      target.lastDamageFrame = this.frameCounter;
    }

    // Source parity: onDamage resets heal timers for AutoHeal and BaseRegen.
    if (target.autoHealProfile && target.autoHealProfile.startHealingDelayFrames > 0) {
      target.autoHealDamageDelayUntilFrame = this.frameCounter + target.autoHealProfile.startHealingDelayFrames;
    }
    if (target.kindOf.has('STRUCTURE')) {
      target.baseRegenDelayUntilFrame = this.frameCounter + BASE_REGEN_DELAY_FRAMES;
      // Source parity: EVA — announce base under attack for important structures.
      if (target.side && target.kindOf.has('MP_COUNT_FOR_VICTORY')) {
        this.emitEvaEvent('BASE_UNDER_ATTACK', target.side, 'own', target.id);
      }
    }

    // Source parity: EMPUpdate — EMP damage type disables target for ~5 seconds.
    const normalizedDamageType = damageType.toUpperCase();
    if (normalizedDamageType === 'EMP' || normalizedDamageType === 'MICROWAVE') {
      const EMP_DISABLE_DURATION_FRAMES = 150; // ~5s at 30fps
      this.applyEmpDisable(target, EMP_DISABLE_DURATION_FRAMES);
    }

    // Source parity: PoisonedBehavior.onDamage — POISON damage starts/refreshes poison DoT.
    if (normalizedDamageType === 'POISON') {
      this.applyPoisonToEntity(target, adjustedDamage);
    }

    // Source parity: FlammableUpdate.onDamage — FLAME/PARTICLE_BEAM accumulates toward ignition.
    if (normalizedDamageType === 'FLAME' || normalizedDamageType === 'PARTICLE_BEAM') {
      this.applyFireDamageToEntity(target, adjustedDamage);
    }

    // Source parity: MinefieldBehavior::onDamage — recalculate virtual mines from health ratio.
    // Shooting a mine from outside causes sympathetic detonations.
    if (target.minefieldProfile && !target.mineIgnoreDamage) {
      this.mineOnDamage(target, sourceEntityId, normalizedDamageType);
    }

    // Source parity: FireWeaponWhenDamagedBehavior::onDamage — fire reaction weapons.
    if (target.fireWhenDamagedProfiles.length > 0) {
      this.fireWhenDamagedReaction(target, adjustedDamage);
    }

    // Source parity: SupplyWarehouseCripplingBehavior::onDamage — reset heal suppression.
    if (target.supplyWarehouseCripplingProfile) {
      this.supplyWarehouseCripplingOnDamage(target);
    }

    // Source parity: ProneUpdate::goProne() — damage adds to prone frame counter.
    // C++ truncates damage to Int before multiplying by ratio (Real→Int then Int*float→Int).
    if (target.proneDamageToFramesRatio !== null && adjustedDamage > 0) {
      const wasProne = target.proneFramesRemaining > 0;
      const truncatedDamage = Math.trunc(adjustedDamage);
      target.proneFramesRemaining += Math.floor(truncatedDamage * target.proneDamageToFramesRatio);
      if (!wasProne && target.proneFramesRemaining > 0) {
        target.objectStatusFlags.add('NO_ATTACK');
      }
    }

    if (target.health <= 0 && !target.destroyed && !target.slowDeathState && !target.structureCollapseState) {
      // Source parity: DamageInfo.in.m_deathType — set death cause for die module filtering.
      target.pendingDeathType = weaponDeathType || damageTypeToDeathType(damageType);
      // Source parity: DemoTrapUpdate::update() — detonate on kill if configured.
      if (target.demoTrapProfile?.detonateWhenKilled && !target.demoTrapDetonated) {
        this.detonateDemoTrap(target, target.demoTrapProfile);
        return; // detonateDemoTrap calls markEntityDestroyed
      }
      this.tryBeginStructureCollapse(target) ||
        this.tryBeginSlowDeath(target, sourceEntityId ?? -1) ||
        this.markEntityDestroyed(target.id, sourceEntityId ?? -1);
    }
  }

  /**
   * Source parity: BodyModule::m_lastDamageInfo source fields.
   * Persists attacker id/template/player-side snapshot for script condition queries.
   */
  private recordScriptLastDamageInfo(target: MapEntity, sourceEntityId: number | null): void {
    if (sourceEntityId === null || sourceEntityId === 0) {
      target.scriptLastDamageSourceEntityId = null;
      target.scriptLastDamageSourceTemplateName = null;
      target.scriptLastDamageSourceSide = null;
      return;
    }

    const source = this.spawnedEntities.get(sourceEntityId);
    if (!source) {
      target.scriptLastDamageSourceEntityId = null;
      target.scriptLastDamageSourceTemplateName = null;
      target.scriptLastDamageSourceSide = null;
      return;
    }

    target.scriptLastDamageSourceEntityId = sourceEntityId;
    target.scriptLastDamageSourceTemplateName = source.templateName.trim().toUpperCase();
    target.scriptLastDamageSourceSide = this.normalizeSide(source.side);
  }

  /**
   * Source parity: ActiveBody::attemptDamage chooses preferred attacker when multiple
   * damages happen in the same/next frame. Vehicle/infantry/structure sources win.
   */
  private recordPreferredLastAttacker(target: MapEntity, sourceEntityId: number | null): void {
    if (sourceEntityId === null || sourceEntityId === 0) {
      return;
    }

    const source = this.spawnedEntities.get(sourceEntityId);
    if (!source) {
      return;
    }

    const withinPriorityWindow =
      target.lastDamageFrame === this.frameCounter
      || target.lastDamageFrame === this.frameCounter - 1;
    if (!withinPriorityWindow || target.lastAttackerEntityId === null) {
      target.lastAttackerEntityId = sourceEntityId;
      return;
    }

    const current = this.spawnedEntities.get(target.lastAttackerEntityId);
    if (!current || this.isPreferredRetaliationSource(source)) {
      target.lastAttackerEntityId = sourceEntityId;
    }
  }

  /**
   * Source parity: ActiveBody::attemptDamage → Player::setAttackedBy.
   * Records attacker side notification even for subdual-only damage.
   */
  private recordAttackedBySource(target: MapEntity, sourceEntityId: number | null): void {
    if (sourceEntityId === null || sourceEntityId === 0) {
      return;
    }
    const source = this.spawnedEntities.get(sourceEntityId);
    if (!source) {
      return;
    }
    const targetSide = this.normalizeSide(target.side);
    const sourceSide = this.normalizeSide(source.side);
    if (!targetSide || !sourceSide) {
      return;
    }
    let attackedBy = this.sideAttackedBy.get(targetSide);
    if (!attackedBy) {
      attackedBy = new Set<string>();
      this.sideAttackedBy.set(targetSide, attackedBy);
    }
    attackedBy.add(sourceSide);
    this.sideAttackedFrame.set(targetSide, this.frameCounter);
  }

  private isPreferredRetaliationSource(source: MapEntity): boolean {
    return source.kindOf.has('VEHICLE')
      || source.kindOf.has('INFANTRY')
      || source.kindOf.has('STRUCTURE');
  }

  private adjustDamageByArmorSet(target: MapEntity, amount: number, damageType: string): number {
    return adjustDamageByArmorSetImpl(target, amount, damageType);
  }

  // ── SlowDeathBehavior implementation ──────────────────────────────────────

  private fireWhenDamagedReaction(entity: MapEntity, actualDamageDealt: number): void {
    const bodyState = calcBodyDamageState(entity.health, entity.maxHealth);
    for (const profile of entity.fireWhenDamagedProfiles) {
      if (actualDamageDealt < profile.damageAmount) continue;
      // Source parity: Weapon::getStatus() == READY_TO_FIRE — check per-weapon cooldown.
      if (this.frameCounter < profile.reactionNextFireFrame[bodyState]) continue;
      const weaponName = profile.reactionWeapons[bodyState];
      if (!weaponName) continue;
      const weaponDef = this.iniDataRegistry?.getWeapon(weaponName);
      if (!weaponDef) continue;
      this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);
      // Source parity: Weapon::privateFireWeapon sets m_whenWeCanFireAgain = now + delayBetweenShots.
      profile.reactionNextFireFrame[bodyState] = this.frameCounter + this.resolveWeaponDefDelayFrames(weaponDef);
    }
  }

  private updateFireWhenDamagedContinuous(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.fireWhenDamagedProfiles.length === 0) continue;
      const bodyState = calcBodyDamageState(entity.health, entity.maxHealth);
      for (const profile of entity.fireWhenDamagedProfiles) {
        // Source parity: Weapon::getStatus() == READY_TO_FIRE — check per-weapon cooldown.
        if (this.frameCounter < profile.continuousNextFireFrame[bodyState]) continue;
        const weaponName = profile.continuousWeapons[bodyState];
        if (!weaponName) continue;
        const weaponDef = this.iniDataRegistry?.getWeapon(weaponName);
        if (!weaponDef) continue;
        this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);
        // Source parity: Weapon::privateFireWeapon sets m_whenWeCanFireAgain = now + delayBetweenShots.
        profile.continuousNextFireFrame[bodyState] = this.frameCounter + this.resolveWeaponDefDelayFrames(weaponDef);
      }
    }
  }

  // ── FireWeaponUpdate implementation ─────────────────────────────────────

  /**
   * Source parity: FireWeaponUpdate::update() — autonomous weapon fire at own position.
   * Fires a weapon at the entity's feet every frame the weapon is ready.
   */
  private updateFireWeaponUpdate(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.fireWeaponUpdateProfiles.length === 0) continue;
      // Source parity: no firing while UNDER_CONSTRUCTION.
      if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) continue;

      for (let i = 0; i < entity.fireWeaponUpdateProfiles.length; i++) {
        const profile = entity.fireWeaponUpdateProfiles[i]!;
        const nextFireFrame = entity.fireWeaponUpdateNextFireFrames[i] ?? 0;

        // Source parity: initial delay — skip if not yet past the delay frame.
        if (this.frameCounter < nextFireFrame) continue;

        // Source parity: ExclusiveWeaponDelay — if the entity fired a normal weapon recently, skip.
        if (profile.exclusiveWeaponDelayFrames > 0) {
          if (this.frameCounter < entity.lastShotFiredFrame + profile.exclusiveWeaponDelayFrames) {
            continue;
          }
        }

        // Resolve weapon def and fire at own position.
        const weaponDef = this.iniDataRegistry?.getWeapon(profile.weaponName);
        if (!weaponDef) continue;

        this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);

        // Source parity: Weapon::privateFireWeapon sets m_whenWeCanFireAgain.
        // Re-resolve per shot so weapons with random delay ranges re-roll each time.
        entity.fireWeaponUpdateNextFireFrames[i] = this.frameCounter + this.resolveWeaponDefDelayFrames(weaponDef);
      }
    }
  }

  // ── OCLUpdate implementation ────────────────────────────────────────────

  /**
   * Source parity: OCLUpdate::update() — periodic Object Creation List spawning.
   * Fires an OCL at the entity's position on a randomized timer.
   * When disabled, the timer is paused by pushing nextCreationFrame forward.
   */
  private updateOCLUpdate(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.oclUpdateProfiles.length === 0) continue;

      // Source parity: OCLUpdate::getDisabledTypesToProcess returns DISABLEDMASK_ALL.
      // When disabled, push the timer back by one frame each frame (pausing it).
      // C++ Object::isDisabled checks all disabled bits; we check the ones actively tracked.
      const isDisabled = entity.objectStatusFlags.has('DISABLED_EMP')
        || entity.objectStatusFlags.has('DISABLED_HACKED')
        || entity.objectStatusFlags.has('DISABLED_SUBDUED')
        || entity.objectStatusFlags.has('DISABLED_UNDERPOWERED');

      for (let i = 0; i < entity.oclUpdateProfiles.length; i++) {
        const profile = entity.oclUpdateProfiles[i]!;

        if (isDisabled) {
          // Source parity: OCLUpdate::update — disabled path increments m_nextCreationFrame.
          entity.oclUpdateNextCreationFrames[i] = (entity.oclUpdateNextCreationFrames[i] ?? 0) + 1;
          continue;
        }

        // Source parity: OCLUpdate::shouldCreate — check timer and UNDER_CONSTRUCTION.
        const nextCreationFrame = entity.oclUpdateNextCreationFrames[i] ?? 0;
        if (this.frameCounter < nextCreationFrame) continue;
        if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) continue;

        // Source parity: first time shouldCreate passes, just set the timer (don't spawn).
        if (!entity.oclUpdateTimerStarted[i]) {
          entity.oclUpdateTimerStarted[i] = true;
          const delay = this.gameRandom.nextRange(profile.minDelayFrames, profile.maxDelayFrames);
          entity.oclUpdateNextCreationFrames[i] = this.frameCounter + delay;
          continue;
        }

        // Timer has elapsed — set next creation frame and execute OCL.
        const delay = this.gameRandom.nextRange(profile.minDelayFrames, profile.maxDelayFrames);
        entity.oclUpdateNextCreationFrames[i] = this.frameCounter + delay;

        this.executeOCL(profile.oclName, entity);
      }
    }
  }

  // ── WeaponBonusUpdate implementation ────────────────────────────────────

  /**
   * Source parity: WeaponBonusUpdate::update() — aura-based weapon bonus application.
   * Scans for allied entities within range and applies a temporary weapon bonus condition.
   * Also applies to passengers inside containers (garrisons, transports).
   */
  private updateWeaponBonusUpdate(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.weaponBonusUpdateProfiles.length === 0) continue;

      for (let i = 0; i < entity.weaponBonusUpdateProfiles.length; i++) {
        const profile = entity.weaponBonusUpdateProfiles[i]!;
        const nextPulseFrame = entity.weaponBonusUpdateNextPulseFrames[i] ?? 0;
        if (this.frameCounter < nextPulseFrame) continue;

        // Set next pulse.
        entity.weaponBonusUpdateNextPulseFrames[i] = this.frameCounter + profile.bonusDelayFrames;

        const rangeSqr = profile.bonusRange * profile.bonusRange;

        // Scan all allies in range.
        for (const target of this.spawnedEntities.values()) {
          if (target.destroyed || target.slowDeathState || target.structureCollapseState) continue;
          // Source parity: PartitionFilterRelationship ALLOW_ALLIES.
          if (!this.areEntitiesAllied(entity, target)) continue;
          // Source parity: PartitionFilterAlive.
          if (target.health <= 0) continue;

          // Range check (FROM_CENTER_2D).
          const dx = target.x - entity.x;
          const dz = target.z - entity.z;
          if (dx * dx + dz * dz > rangeSqr) continue;

          // Source parity: individual kindOf check (not in partition query to reach container contents).
          if (this.matchesKindOfFilter(target, profile.requiredKindOf, profile.forbiddenKindOf)) {
            this.applyTempWeaponBonus(target, profile.bonusConditionFlag, profile.bonusDurationFrames);
          }

          // Source parity: also apply to contained passengers (garrisons, transports).
          if (target.containProfile) {
            for (const pid of this.collectContainedEntityIds(target.id)) {
              const passenger = this.spawnedEntities.get(pid);
              if (!passenger || passenger.destroyed) continue;
              if (this.matchesKindOfFilter(passenger, profile.requiredKindOf, profile.forbiddenKindOf)) {
                this.applyTempWeaponBonus(passenger, profile.bonusConditionFlag, profile.bonusDurationFrames);
              }
            }
          }
        }
      }
    }
  }

  /**
   * Source parity: isKindOfMulti — check required ALL match and forbidden NONE match.
   */
  private matchesKindOfFilter(entity: MapEntity, required: Set<string>, forbidden: Set<string>): boolean {
    // ALL required flags must be present.
    for (const k of required) {
      if (!entity.kindOf.has(k)) return false;
    }
    // NO forbidden flags may be present.
    for (const k of forbidden) {
      if (entity.kindOf.has(k)) return false;
    }
    return true;
  }

  /**
   * Source parity: TempWeaponBonusHelper::doTempWeaponBonus — apply or refresh a temp bonus.
   * If the entity has a different temp bonus, clears it first.
   */
  private applyTempWeaponBonus(target: MapEntity, flag: number, durationFrames: number): void {
    // Clear any different bonus first.
    if (target.tempWeaponBonusFlag !== 0 && target.tempWeaponBonusFlag !== flag) {
      target.weaponBonusConditionFlags &= ~target.tempWeaponBonusFlag;
      target.tempWeaponBonusFlag = 0;
    }
    // Set or refresh.
    target.weaponBonusConditionFlags |= flag;
    target.tempWeaponBonusFlag = flag;
    target.tempWeaponBonusExpiryFrame = this.frameCounter + durationFrames;
  }

  /**
   * Source parity: TempWeaponBonusHelper::update — clear expired temp weapon bonuses.
   */
  private updateTempWeaponBonusExpiry(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.tempWeaponBonusFlag === 0) continue;
      if (this.frameCounter >= entity.tempWeaponBonusExpiryFrame) {
        entity.weaponBonusConditionFlags &= ~entity.tempWeaponBonusFlag;
        entity.tempWeaponBonusFlag = 0;
        entity.tempWeaponBonusExpiryFrame = 0;
      }
    }
  }

  /**
   * Source parity: Check if two entities are allied (same side or allies relationship).
   */
  private areEntitiesAllied(a: MapEntity, b: MapEntity): boolean {
    if (a === b) return true;
    return this.getTeamRelationship(a, b) === RELATIONSHIP_ALLIES;
  }

  // ── PointDefenseLaserUpdate implementation ──────────────────────────────

  /**
   * Source parity: PointDefenseLaserUpdate::update() — autonomous anti-projectile defense.
   * Scans for in-flight enemy projectiles (SMALL_MISSILE, BALLISTIC_MISSILE, etc.)
   * and intercepts them by removing the pending damage event.
   */
  private updatePointDefenseLaser(): void {
    // Source parity fix: prevent multiple PDLs from both tracking the same projectile.
    const interceptedThisFrame = new Set<number>();

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.pointDefenseLaserProfile;
      if (!profile) continue;
      // Source parity: disabled/sold/under-construction entities cannot defend.
      if (!this.canEntityAttackFromStatus(entity)) continue;

      // Resolve the PDL weapon's fire range and delay.
      const pdlWeaponDef = this.iniDataRegistry?.getWeapon(profile.weaponName);
      if (!pdlWeaponDef) continue;
      const fireRangeRaw = readNumericField(pdlWeaponDef.fields, ['AttackRange', 'Range']) ?? 0;
      const fireRange = Math.max(0, fireRangeRaw);
      const fireRangeSqr = fireRange * fireRange;
      const scanRangeSqr = profile.scanRange * profile.scanRange;

      // Try to fire at current target.
      if (entity.pdlTargetProjectileVisualId !== 0) {
        if (interceptedThisFrame.has(entity.pdlTargetProjectileVisualId)) {
          entity.pdlTargetProjectileVisualId = 0;
        } else {
          const targetEvent = this.findPendingProjectileByVisualId(entity.pdlTargetProjectileVisualId);
          if (targetEvent) {
            const projPos = this.interpolateProjectilePosition(targetEvent);
            if (projPos) {
              const dx = projPos.x - entity.x;
              const dz = projPos.z - entity.z;
              const distSqr = dx * dx + dz * dz;
              if (distSqr <= fireRangeSqr) {
                // Target in weapon range — try to fire.
                if (this.frameCounter >= entity.pdlNextShotFrame) {
                  interceptedThisFrame.add(entity.pdlTargetProjectileVisualId);
                  this.interceptProjectileEvent(entity, targetEvent, profile);
                  const delayFrames = this.resolveWeaponDefDelayFrames(pdlWeaponDef);
                  entity.pdlNextShotFrame = this.frameCounter + delayFrames;
                  entity.pdlTargetProjectileVisualId = 0;
                  continue;
                }
                // Weapon on cooldown — keep tracking.
                continue;
              } else if (distSqr <= scanRangeSqr) {
                // Still in scan range but not fire range — keep tracking.
                continue;
              }
            }
          }
          // Target gone or out of range — clear and rescan.
          entity.pdlTargetProjectileVisualId = 0;
        }
      }

      // Periodic expensive scan for new targets.
      if (this.frameCounter < entity.pdlNextScanFrame) continue;
      entity.pdlNextScanFrame = this.frameCounter + profile.scanRate;

      let bestPrimaryId = 0;
      let bestPrimaryDistSqr = Infinity;
      let bestSecondaryId = 0;
      let bestSecondaryDistSqr = Infinity;

      for (const event of this.pendingWeaponDamageEvents) {
        if (event.delivery !== 'PROJECTILE') continue;
        if (event.executeFrame <= this.frameCounter) continue;
        if (interceptedThisFrame.has(event.projectileVisualId)) continue;
        // Source parity: only intercept enemy projectiles.
        const sourceEntity = this.spawnedEntities.get(event.sourceEntityId);
        if (!sourceEntity) continue;
        if (this.getTeamRelationship(entity, sourceEntity) !== RELATIONSHIP_ENEMIES) continue;

        // Resolve projectile kindOf from the weapon's ProjectileObject template.
        const projectileKindOf = this.resolveProjectileTemplateKindOf(event.weapon);

        // Determine if this projectile matches primary or secondary targets.
        let isPrimary = false;
        let isSecondary = false;
        if (profile.primaryTargetKindOf.size > 0) {
          for (const kind of profile.primaryTargetKindOf) {
            if (projectileKindOf.has(kind)) { isPrimary = true; break; }
          }
        }
        if (!isPrimary && profile.secondaryTargetKindOf.size > 0) {
          for (const kind of profile.secondaryTargetKindOf) {
            if (projectileKindOf.has(kind)) { isSecondary = true; break; }
          }
        }
        if (!isPrimary && !isSecondary) continue;

        // Interpolate projectile position and check distance.
        const projPos = this.interpolateProjectilePosition(event);
        if (!projPos) continue;
        const dx = projPos.x - entity.x;
        const dz = projPos.z - entity.z;
        const distSqr = dx * dx + dz * dz;
        if (distSqr > scanRangeSqr) continue;

        if (isPrimary && distSqr < bestPrimaryDistSqr) {
          bestPrimaryDistSqr = distSqr;
          bestPrimaryId = event.projectileVisualId;
        } else if (isSecondary && distSqr < bestSecondaryDistSqr) {
          bestSecondaryDistSqr = distSqr;
          bestSecondaryId = event.projectileVisualId;
        }
      }

      // Source parity: prefer primary in-range > secondary in-range.
      entity.pdlTargetProjectileVisualId = bestPrimaryId || bestSecondaryId;

      // Source parity: "1 frame can make a big difference so fire ASAP!" — fire immediately
      // after scan instead of waiting for the next frame (C++ PointDefenseLaserUpdate::update).
      if (entity.pdlTargetProjectileVisualId !== 0 && this.frameCounter >= entity.pdlNextShotFrame) {
        const targetEvent = this.findPendingProjectileByVisualId(entity.pdlTargetProjectileVisualId);
        if (targetEvent) {
          const projPos = this.interpolateProjectilePosition(targetEvent);
          if (projPos) {
            const dx = projPos.x - entity.x;
            const dz = projPos.z - entity.z;
            if (dx * dx + dz * dz <= fireRangeSqr) {
              interceptedThisFrame.add(entity.pdlTargetProjectileVisualId);
              this.interceptProjectileEvent(entity, targetEvent, profile);
              entity.pdlNextShotFrame = this.frameCounter + this.resolveWeaponDefDelayFrames(pdlWeaponDef);
              entity.pdlTargetProjectileVisualId = 0;
            }
          }
        }
      }
    }
  }

  /**
   * Find a pending projectile event by its visual ID.
   */
  private findPendingProjectileByVisualId(visualId: number): PendingWeaponDamageEvent | null {
    for (const event of this.pendingWeaponDamageEvents) {
      if (event.projectileVisualId === visualId) return event;
    }
    return null;
  }

  /**
   * Interpolate the current position of an in-flight projectile event.
   */
  private interpolateProjectilePosition(event: PendingWeaponDamageEvent): { x: number; z: number } | null {
    if (event.missileAIState) {
      return { x: event.missileAIState.currentX, z: event.missileAIState.currentZ };
    }
    const totalFrames = event.executeFrame - event.launchFrame;
    if (totalFrames <= 0) return null;
    const elapsed = this.frameCounter - event.launchFrame;
    const progress = Math.min(1, Math.max(0, elapsed / totalFrames));

    let projX: number, projZ: number;
    if (event.hasBezierArc) {
      const p0x = event.sourceX, p0z = event.sourceZ;
      const p3x = event.impactX, p3z = event.impactZ;
      const dx = p3x - p0x, dz = p3z - p0z;
      const dist = Math.hypot(dx, dz);
      const nx = dist > 0 ? dx / dist : 0;
      const nz = dist > 0 ? dz / dist : 0;
      const p1x = p0x + nx * dist * event.bezierFirstPercentIndent;
      const p1z = p0z + nz * dist * event.bezierFirstPercentIndent;
      const p2x = p0x + nx * dist * event.bezierSecondPercentIndent;
      const p2z = p0z + nz * dist * event.bezierSecondPercentIndent;
      projX = evaluateCubicBezier(progress, p0x, p1x, p2x, p3x);
      projZ = evaluateCubicBezier(progress, p0z, p1z, p2z, p3z);
    } else {
      projX = event.sourceX + (event.impactX - event.sourceX) * progress;
      projZ = event.sourceZ + (event.impactZ - event.sourceZ) * progress;
    }
    return { x: projX, z: projZ };
  }

  /**
   * Resolve the kindOf set of a weapon's projectile template.
   * Caches results to avoid repeated INI lookups.
   */
  private projectileKindOfCache = new Map<string, Set<string>>();

  private resolveProjectileTemplateKindOf(weapon: AttackWeaponProfile): Set<string> {
    const templateName = weapon.projectileObjectName;
    if (!templateName) return EMPTY_KINDOF_SET;

    const cached = this.projectileKindOfCache.get(templateName);
    if (cached) return cached;

    const registry = this.iniDataRegistry;
    if (!registry) return EMPTY_KINDOF_SET;

    const objectDef = findObjectDefByName(registry, templateName);
    if (!objectDef) return EMPTY_KINDOF_SET;

    const kindOf = this.normalizeKindOf(objectDef.kindOf);
    this.projectileKindOfCache.set(templateName, kindOf);
    return kindOf;
  }

  /**
   * Intercept a projectile event: remove it from pending events and emit visual event.
   */
  private interceptProjectileEvent(
    defender: MapEntity,
    event: PendingWeaponDamageEvent,
    _profile: PointDefenseLaserProfile,
  ): void {
    // Remove the event from pending weapon damage events.
    const idx = this.pendingWeaponDamageEvents.indexOf(event);
    if (idx >= 0) {
      this.pendingWeaponDamageEvents.splice(idx, 1);
    }

    // Emit visual event for the interception (laser beam from defender to projectile).
    const projPos = this.interpolateProjectilePosition(event);
    this.visualEventBuffer.push({
      type: 'WEAPON_FIRED',
      x: defender.x,
      y: defender.y + 1.5,
      z: defender.z,
      radius: 0,
      sourceEntityId: defender.id,
      projectileType: 'LASER',
    });
    if (projPos) {
      this.visualEventBuffer.push({
        type: 'WEAPON_IMPACT',
        x: projPos.x,
        y: this.resolveGroundHeight(projPos.x, projPos.z),
        z: projPos.z,
        radius: 2,
        sourceEntityId: defender.id,
        projectileType: 'LASER',
      });
    }
  }

  // ── ProneUpdate implementation ─────────────────────────────────────────

  /**
   * Source parity: ProneUpdate::update() — per-frame countdown.
   * Decrements proneFramesRemaining each frame. When counter reaches 0,
   * clears NO_ATTACK status and restores animation state.
   */
  private updateProneEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.proneFramesRemaining <= 0) continue;
      entity.proneFramesRemaining--;
      if (entity.proneFramesRemaining <= 0) {
        // Source parity: ProneUpdate::stopProneEffects() — clear PRONE model condition and NO_ATTACK.
        entity.objectStatusFlags.delete('NO_ATTACK');
        if (entity.animationState === 'PRONE') {
          entity.animationState = 'IDLE';
        }
      }
    }
  }

  // ── HordeUpdate implementation ─────────────────────────────────────────

  /**
   * Source parity: HordeUpdate::update() — periodic spatial scan to detect
   * nearby matching units. When enough units are grouped, sets HORDE weapon
   * bonus condition, granting damage/rate bonuses. Also evaluates NATIONALISM
   * and FANATICISM bonuses if the player has those upgrades.
   */

  /**
   * Source parity: EnemyNearUpdate::update — periodic scan for nearby enemies.
   * Sets/clears entity.enemyNearDetected based on whether an enemy exists within visionRange.
   * C++ file: EnemyNearUpdate.cpp lines 65-107.
   */
  private updateEnemyNear(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.enemyNearScanDelayFrames <= 0) continue;

      // Source parity: countdown-based scan delay (decrements each frame, resets on scan).
      if (entity.enemyNearNextScanCountdown > 0) {
        entity.enemyNearNextScanCountdown--;
        continue;
      }
      // Reset countdown for next scan.
      entity.enemyNearNextScanCountdown = entity.enemyNearScanDelayFrames;

      // Source parity: TheAI->findClosestEnemy(getObject(), visionRange, AI::CAN_SEE).
      // Simplified: scan for any enemy entity within vision range.
      const visionRange = entity.visionRange;
      if (visionRange <= 0) {
        entity.enemyNearDetected = false;
        continue;
      }
      const rangeSqr = visionRange * visionRange;
      let foundEnemy = false;
      for (const candidate of this.spawnedEntities.values()) {
        if (candidate.id === entity.id || candidate.destroyed) continue;
        if (!candidate.canTakeDamage) continue;
        if (this.getTeamRelationship(entity, candidate) !== RELATIONSHIP_ENEMIES) continue;
        const dx = candidate.x - entity.x;
        const dz = candidate.z - entity.z;
        if (dx * dx + dz * dz <= rangeSqr) {
          foundEnemy = true;
          break;
        }
      }
      entity.enemyNearDetected = foundEnemy;
    }
  }

  /**
   * Source parity: CheckpointUpdate::update — gate opens for allies, closes for enemies.
   * C++ file: CheckpointUpdate.cpp lines 107-171.
   * Scans for allies and enemies within vision range, adjusts geometry to allow/block passage.
   */
  private updateCheckpoints(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const prof = entity.checkpointProfile;
      if (!prof) continue;

      // Save previous state for change detection.
      const wasAllyNear = entity.checkpointAllyNear;
      const wasEnemyNear = entity.checkpointEnemyNear;

      // Source parity: C++ lines 78-95 — temporarily restore full minor radius during scan
      // to prevent oscillation when the gate is partially open and units are at the boundary.
      const geom = entity.obstacleGeometry;
      const savedMinorRadius = geom ? geom.minorRadius : 0;
      if (geom) {
        geom.minorRadius = entity.checkpointMaxMinorRadius;
      }

      // Source parity: C++ line 71 — always scan (delay code effectively disabled with `|| TRUE`).
      const visionRange = entity.visionRange;
      if (visionRange > 0) {
        const rangeSqr = visionRange * visionRange;
        let foundEnemy = false;
        let foundAlly = false;
        for (const candidate of this.spawnedEntities.values()) {
          if (candidate.id === entity.id || candidate.destroyed) continue;
          if (!candidate.canTakeDamage) continue;
          const dx = candidate.x - entity.x;
          const dz = candidate.z - entity.z;
          if (dx * dx + dz * dz > rangeSqr) continue;
          const relationship = this.getTeamRelationship(entity, candidate);
          if (relationship === RELATIONSHIP_ENEMIES) foundEnemy = true;
          else if (relationship === RELATIONSHIP_ALLIES) foundAlly = true;
          if (foundEnemy && foundAlly) break;
        }
        entity.checkpointEnemyNear = foundEnemy;
        entity.checkpointAllyNear = foundAlly;
      } else {
        entity.checkpointEnemyNear = false;
        entity.checkpointAllyNear = false;
      }

      // Restore the actual minor radius after scan.
      if (geom) {
        geom.minorRadius = savedMinorRadius;
      }

      const open = !entity.checkpointEnemyNear && entity.checkpointAllyNear;

      // Source parity: C++ lines 153-161 — gradually shrink/expand minor radius.
      // When open: shrink to 0 (units can pass through). When closed: expand to max.
      if (geom) {
        if (open) {
          if (geom.minorRadius > 0) {
            geom.minorRadius = Math.max(0, geom.minorRadius - 0.333);
          }
        } else {
          if (geom.minorRadius < entity.checkpointMaxMinorRadius) {
            geom.minorRadius = Math.min(entity.checkpointMaxMinorRadius, geom.minorRadius + 0.333);
          }
        }
      }
    }
  }

  /**
   * Source parity: GrantUpgradeCreate — apply upgrade to entity or its controlling side.
   * C++ file: GrantUpgradeCreate.cpp lines 93-109 / 124-140.
   * Note: entity may not yet be in spawnedEntities when called from createMapEntity,
   * so we apply directly to the entity struct instead of going through applyUpgradeToEntity.
   */
  private applyGrantUpgradeCreate(entity: MapEntity, prof: GrantUpgradeCreateProfile): void {
    // Check if upgrade is a PLAYER upgrade by looking at the UpgradeDef.
    const registry = this.iniDataRegistry;
    if (registry) {
      const upgradeDef = findUpgradeDefByName(registry, prof.upgradeName);
      if (upgradeDef) {
        const upgradeType = readStringField(upgradeDef.fields, ['Type'])?.trim().toUpperCase() ?? 'OBJECT';
        if (upgradeType === 'PLAYER') {
          // Grant as a side-level upgrade.
          const side = this.resolveEntityOwnerSide(entity);
          if (side) {
            this.setSideUpgradeCompleted(side, prof.upgradeName, true);
            this.applyCompletedPlayerUpgrade(side, prof.upgradeName);
          }
          return;
        }
      }
    }
    // Grant as an object-level upgrade directly on the entity struct.
    // Can't use applyUpgradeToEntity() because entity may not be in spawnedEntities yet.
    const normalizedUpgrade = prof.upgradeName.trim().toUpperCase();
    entity.completedUpgrades.add(normalizedUpgrade);
  }

  /**
   * Source parity: UpgradeDie::onDie — remove upgrade from producer when this entity dies.
   * C++ file: UpgradeDie.cpp lines 58-87.
   */
  private executeUpgradeDieModules(entity: MapEntity): void {
    for (const prof of entity.upgradeDieProfiles) {
      // Apply DieMuxData filtering.
      if (prof.deathTypes !== null && prof.deathTypes.size > 0) {
        if (!prof.deathTypes.has(entity.pendingDeathType)) continue;
      }
      // ExemptStatus — entity must NOT have any of these flags.
      let exempt = false;
      for (const status of prof.exemptStatus) {
        if (entity.objectStatusFlags.has(status)) { exempt = true; break; }
      }
      if (exempt) continue;
      // RequiredStatus — entity must have ALL of these flags.
      let missingRequired = false;
      for (const status of prof.requiredStatus) {
        if (!entity.objectStatusFlags.has(status)) { missingRequired = true; break; }
      }
      if (missingRequired) continue;

      // Find producer and remove upgrade.
      if (entity.producerEntityId === 0) continue;
      const producer = this.spawnedEntities.get(entity.producerEntityId);
      if (!producer || producer.destroyed) continue;
      if (producer.completedUpgrades.has(prof.upgradeName)) {
        this.removeEntityUpgrade(producer, prof.upgradeName);
      }
    }
  }

  private updateHorde(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.hordeProfile;
      if (!profile) continue;

      // Source parity: periodic expensive scan (staggered per entity).
      if (this.frameCounter < entity.hordeNextCheckFrame) continue;
      entity.hordeNextCheckFrame = this.frameCounter + profile.updateRate;

      const wasInHorde = entity.isInHorde;
      let join = false;
      let trueHordeMember = false;

      // Count nearby matching units (including self count implicitly via >= minCount-1).
      let nearbyCount = 0;
      const scanRangeSqr = profile.minDist * profile.minDist;
      const rubOffRadiusSqr = profile.rubOffRadius * profile.rubOffRadius;
      let nearbyTrueHordeMember = false;

      for (const candidate of this.spawnedEntities.values()) {
        if (candidate === entity) continue;
        if (candidate.destroyed || candidate.slowDeathState || candidate.structureCollapseState) continue;

        // Source parity: PartitionFilterHordeMember checks.
        // Must have HordeUpdate module.
        if (!candidate.hordeProfile) continue;

        // Source parity: ExactMatch check — same template name.
        if (profile.exactMatch && entity.templateName !== candidate.templateName) continue;

        // Source parity: KindOf filter — candidate must match ALL required kindOf flags.
        // C++ uses isKindOfMulti() with KINDOFMASK_NONE which requires all bits in mustBeSet.
        if (profile.kindOf.size > 0) {
          let allMatch = true;
          for (const k of profile.kindOf) {
            if (!candidate.kindOf.has(k)) {
              allMatch = false;
              break;
            }
          }
          if (!allMatch) continue;
        }

        // Source parity: AlliesOnly filter.
        if (profile.alliesOnly) {
          const rel = this.getTeamRelationshipBySides(
            entity.side ?? '',
            candidate.side ?? '',
          );
          if (rel !== RELATIONSHIP_ALLIES) continue;
        }

        // Distance check.
        const dx = candidate.x - entity.x;
        const dz = candidate.z - entity.z;
        const distSqr = dx * dx + dz * dz;
        if (distSqr > scanRangeSqr) continue;

        nearbyCount++;

        // Source parity: rub-off check — if any nearby matching unit is a true horde member
        // within rubOffRadius, we inherit horde status even without enough count.
        if (candidate.isTrueHordeMember && distSqr <= rubOffRadiusSqr) {
          nearbyTrueHordeMember = true;
        }
      }

      // Source parity: minCount includes self, so check >= minCount - 1 neighbors.
      if (nearbyCount >= profile.minCount - 1) {
        join = true;
        trueHordeMember = true;
      } else if (nearbyTrueHordeMember) {
        // Source parity: rub-off inheritance — close enough to a true member.
        join = true;
      }

      entity.isInHorde = join;
      entity.isTrueHordeMember = trueHordeMember;

      // Source parity: AIUpdateInterface::evaluateMoraleBonus() — always recalculate
      // and write the correct flags (C++ is idempotent, not gated on change detection).
      if (join) {
        entity.weaponBonusConditionFlags |= WEAPON_BONUS_HORDE;
      } else {
        entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_HORDE;
        entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_NATIONALISM;
        entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_FANATICISM;
      }

      // Source parity: NATIONALISM/FANATICISM bonuses require horde + allowedNationalism + player science.
      if (join) {
        if (profile.allowedNationalism) {
          const sideSciences = this.getSideScienceSet(this.normalizeSide(entity.side ?? ''));
          const hasNationalism = sideSciences.has('SCIENCE_NATIONALISM')
            || sideSciences.has('NATIONALISM');
          const hasFanaticism = sideSciences.has('SCIENCE_FANATICISM')
            || sideSciences.has('FANATICISM');
          if (hasNationalism) {
            entity.weaponBonusConditionFlags |= WEAPON_BONUS_NATIONALISM;
            if (hasFanaticism) {
              entity.weaponBonusConditionFlags |= WEAPON_BONUS_FANATICISM;
            } else {
              entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_FANATICISM;
            }
          } else {
            entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_NATIONALISM;
            entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_FANATICISM;
          }
        } else {
          // Source parity: allowedNationalism=false forces nationalism/fanaticism off.
          entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_NATIONALISM;
          entity.weaponBonusConditionFlags &= ~WEAPON_BONUS_FANATICISM;
        }
      }
    }
  }

  // ── DemoTrapUpdate implementation ────────────────────────────────────────

  /**
   * Source parity: DemoTrapUpdate::update() — periodic proximity scan.
   * In proximity mode, scans nearby entities; detonates when an enemy
   * enters the trigger range (unless friendlies are blocking).
   */
  private updateDemoTraps(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.demoTrapProfile;
      if (!profile || entity.demoTrapDetonated) continue;

      // Source parity: skip while under construction or sold.
      if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION') ||
          entity.objectStatusFlags.has('SOLD')) {
        continue;
      }

      // Not in proximity mode → dormant, skip scanning.
      if (!entity.demoTrapProximityMode) continue;

      // Scan throttle.
      if (this.frameCounter < entity.demoTrapNextScanFrame) continue;
      entity.demoTrapNextScanFrame = this.frameCounter + Math.max(1, profile.scanFrames);

      // Proximity scan.
      const rangeSq = profile.triggerDetonationRange * profile.triggerDetonationRange;
      let shallDetonate = false;

      for (const other of this.spawnedEntities.values()) {
        if (other === entity) continue;
        if (other.destroyed || other.slowDeathState || other.structureCollapseState) continue;

        // Source parity: isEffectivelyDead().
        if (other.health <= 0) continue;

        // IgnoreTargetTypes filter.
        if (profile.ignoreKindOf.size > 0) {
          let skip = false;
          for (const k of profile.ignoreKindOf) {
            if (other.kindOf.has(k)) { skip = true; break; }
          }
          if (skip) continue;
        }

        // Source parity: partition manager pre-filters by range. Only consider
        // entities within the trigger range for both detonation and friendly blocking.
        const dx = entity.x - other.x;
        const dz = entity.z - other.z;
        const distSq = dx * dx + dz * dz;
        if (distSq > rangeSq) continue;

        // Source parity (ZH): dozer with DISARM weapon that is actively attacking → skip.
        if (other.kindOf.has('DOZER') && other.objectStatusFlags.has('IS_ATTACKING')) {
          continue;
        }

        // Relationship check — we want to know if entity considers other to be enemy.
        const rel = this.getTeamRelationship(entity, other);
        if (rel !== RELATIONSHIP_ENEMIES) {
          if (!profile.friendlyDetonation) {
            // Non-enemy in range blocks detonation entirely.
            shallDetonate = false;
            break;
          }
          // friendlyDetonation=true → skip non-enemies, keep looking.
          continue;
        }

        // Source parity: don't detonate on anything airborne.
        if (other.kindOf.has('AIRCRAFT') && other.category === 'air') continue;

        shallDetonate = true;
        if (profile.friendlyDetonation) break; // no need to check for friendlies
      }

      if (shallDetonate) {
        this.detonateDemoTrap(entity, profile);
      }
    }
  }

  /**
   * Source parity: DemoTrapUpdate::detonate() — fire temp weapon, kill self.
   */
  private detonateDemoTrap(entity: MapEntity, profile: DemoTrapProfile): void {
    entity.demoTrapDetonated = true;

    // Fire detonation weapon at own position (if not under construction/sold).
    if (!entity.objectStatusFlags.has('UNDER_CONSTRUCTION') &&
        !entity.objectStatusFlags.has('SOLD')) {
      if (profile.detonationWeaponName) {
        const weaponDef = this.iniDataRegistry?.getWeapon(profile.detonationWeaponName);
        if (weaponDef) {
          this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);
        }
      }
    }

    // Kill the trap.
    this.markEntityDestroyed(entity.id, entity.id);
  }

  // ── RebuildHoleBehavior implementation ──────────────────────────────────────

  /**
   * Source parity: RebuildHoleExposeDie::onDie — create a rebuild hole when a building
   * with the RebuildHoleExposeDie module is destroyed.
   */
  private tryCreateRebuildHoleOnDeath(entity: MapEntity, attackerId: number): void {
    const profile = entity.rebuildHoleExposeDieProfile;
    if (!profile) return;

    // Source parity: no hole if building was still under construction.
    if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) return;
    // Source parity: no hole if player is neutral or inactive.
    if (!entity.side) return;
    const playerType = this.sidePlayerTypes.get(this.normalizeSide(entity.side) ?? '');
    if (!playerType) return;

    const registry = this.iniDataRegistry;
    if (!registry) return;

    // Spawn the hole object at the building's position with the building's orientation.
    const hole = this.spawnEntityFromTemplate(
      profile.holeName,
      entity.x,
      entity.z,
      entity.rotationY,
      entity.side,
    );
    if (!hole) return;

    // Source parity: set hole max health from profile.
    if (profile.holeMaxHealth > 0) {
      hole.maxHealth = profile.holeMaxHealth;
      hole.initialHealth = profile.holeMaxHealth;
      hole.health = profile.holeMaxHealth;
      hole.canTakeDamage = true;
    }

    // Source parity: copy geometry info from building to hole (preserves pathfinding footprint).
    if (entity.obstacleGeometry) {
      hole.obstacleGeometry = { ...entity.obstacleGeometry };
    }

    // Source parity: RebuildHoleBehavior::startRebuildProcess — store rebuild template
    // and start the worker respawn timer.
    if (hole.rebuildHoleProfile) {
      hole.rebuildHoleSpawnerEntityId = entity.id;
      hole.rebuildHoleRebuildTemplateName = entity.templateName;
      // Start worker respawn countdown.
      hole.rebuildHoleWorkerWaitCounter = hole.rebuildHoleProfile.workerRespawnDelay;
    }

    // Source parity: TransferAttackers — redirect all AI attacks from building to hole.
    if (profile.transferAttackers) {
      for (const other of this.spawnedEntities.values()) {
        if (other.destroyed || other.id === entity.id) continue;
        if (other.attackTargetEntityId === entity.id) {
          other.attackTargetEntityId = hole.id;
        }
      }
    }
  }

  /**
   * Source parity: RebuildHoleBehavior::update() — per-frame lifecycle management
   * for rebuild holes. Manages worker spawn timer, health regen, worker/reconstruction
   * death detection, and reconstruction completion.
   */
  private updateRebuildHoles(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.rebuildHoleProfile;
      if (!profile) continue;
      // Only holes with an active rebuild template participate.
      if (!entity.rebuildHoleRebuildTemplateName) continue;

      const worker = entity.rebuildHoleWorkerEntityId !== 0
        ? this.spawnedEntities.get(entity.rebuildHoleWorkerEntityId)
        : null;
      const reconstructing = entity.rebuildHoleReconstructingEntityId !== 0
        ? this.spawnedEntities.get(entity.rebuildHoleReconstructingEntityId)
        : null;

      // Source parity: C++ update() checks deaths FIRST, then spawn/regen, completion LAST.

      // ── Check for worker death — respawn (C++ line 195-205) ──
      if (entity.rebuildHoleWorkerEntityId !== 0
        && (!worker || worker.destroyed)) {
        entity.rebuildHoleWorkerEntityId = 0;
        entity.rebuildHoleWorkerWaitCounter = profile.workerRespawnDelay;
        // Source parity: newWorkerRespawnProcess always unmasks unconditionally.
        entity.rebuildHoleMasked = false;
        entity.objectStatusFlags.delete('MASKED');
        entity.objectStatusFlags.delete('UNSELECTABLE');
      }

      // ── Check for reconstruction death — restart cycle (C++ line 208-226) ──
      if (entity.rebuildHoleReconstructingEntityId !== 0
        && (!reconstructing || reconstructing.destroyed)) {
        // Reconstruction building died — destroy worker and restart.
        const currentWorker = entity.rebuildHoleWorkerEntityId !== 0
          ? this.spawnedEntities.get(entity.rebuildHoleWorkerEntityId)
          : null;
        if (currentWorker && !currentWorker.destroyed) {
          this.markEntityDestroyed(currentWorker.id, -1);
        }
        entity.rebuildHoleWorkerEntityId = 0;
        entity.rebuildHoleReconstructingEntityId = 0;
        entity.rebuildHoleWorkerWaitCounter = profile.workerRespawnDelay;
        // Source parity: newWorkerRespawnProcess always unmasks unconditionally.
        entity.rebuildHoleMasked = false;
        entity.objectStatusFlags.delete('MASKED');
        entity.objectStatusFlags.delete('UNSELECTABLE');
      }

      // ── Worker spawn countdown (C++ line 228-298) ──
      if (entity.rebuildHoleWorkerWaitCounter > 0) {
        entity.rebuildHoleWorkerWaitCounter--;
        if (entity.rebuildHoleWorkerWaitCounter <= 0) {
          this.rebuildHoleSpawnWorker(entity, profile);
        }
      }

      // ── Hole passive health regeneration (C++ line 300-316) ──
      if (entity.health < entity.maxHealth && profile.holeHealthRegenPercentPerSecond > 0) {
        // Source parity: (regenPercent / 30fps) * maxHealth per frame.
        const healPerFrame = (profile.holeHealthRegenPercentPerSecond / 30) * entity.maxHealth;
        entity.health = Math.min(entity.maxHealth, entity.health + healPerFrame);
      }

      // ── Check for reconstruction completion (C++ line 319-336 — checked LAST) ──
      const reconFinal = entity.rebuildHoleReconstructingEntityId !== 0
        ? this.spawnedEntities.get(entity.rebuildHoleReconstructingEntityId)
        : null;
      if (reconFinal && !reconFinal.destroyed
        && reconFinal.constructionPercent === CONSTRUCTION_COMPLETE) {
        // Reconstruction is done — destroy worker and hole.
        const finalWorker = entity.rebuildHoleWorkerEntityId !== 0
          ? this.spawnedEntities.get(entity.rebuildHoleWorkerEntityId)
          : null;
        if (finalWorker && !finalWorker.destroyed) {
          this.markEntityDestroyed(finalWorker.id, -1);
        }
        entity.rebuildHoleWorkerEntityId = 0;
        entity.rebuildHoleReconstructingEntityId = 0;
        this.markEntityDestroyed(entity.id, -1);
        continue;
      }
    }
  }

  /**
   * Source parity: RebuildHoleBehavior::update() — spawn worker and start/resume construction.
   */
  private rebuildHoleSpawnWorker(hole: MapEntity, profile: RebuildHoleBehaviorProfile): void {
    const registry = this.iniDataRegistry;
    if (!registry) return;

    // Spawn worker at hole position.
    const worker = this.spawnEntityFromTemplate(
      profile.workerObjectName,
      hole.x,
      hole.z,
      hole.rotationY,
      hole.side,
    );
    if (!worker) return;

    hole.rebuildHoleWorkerEntityId = worker.id;
    // Source parity: worker is unselectable.
    worker.objectStatusFlags.add('UNSELECTABLE');

    // Resolve the rebuild template.
    const rebuildDef = findObjectDefByName(registry, hole.rebuildHoleRebuildTemplateName);
    if (!rebuildDef) return;

    let reconstructing = hole.rebuildHoleReconstructingEntityId !== 0
      ? this.spawnedEntities.get(hole.rebuildHoleReconstructingEntityId)
      : null;

    if (!reconstructing || reconstructing.destroyed) {
      // Start new construction at hole position.
      reconstructing = this.spawnConstructedObject(
        worker,
        rebuildDef,
        [hole.x, 0, hole.z],
        hole.rotationY,
      );
      if (!reconstructing) return;

      // Source parity: mark as RECONSTRUCTING (no cost refund on cancel).
      reconstructing.objectStatusFlags.add('RECONSTRUCTING');
      hole.rebuildHoleReconstructingEntityId = reconstructing.id;
    } else {
      // Resume existing construction with the new worker.
      reconstructing.builderId = worker.id;
      this.pendingConstructionActions.set(worker.id, reconstructing.id);
    }

    // Source parity: mask hole during active reconstruction (invisible to UI/AI).
    hole.rebuildHoleMasked = true;
    hole.objectStatusFlags.add('MASKED');
    hole.objectStatusFlags.add('UNSELECTABLE');

    // Source parity: transfer attacks from hole to reconstruction building.
    for (const other of this.spawnedEntities.values()) {
      if (other.destroyed || other.id === hole.id) continue;
      if (other.attackTargetEntityId === hole.id) {
        other.attackTargetEntityId = reconstructing.id;
      }
    }
  }

  /**
   * Source parity: WanderAIUpdate::update — when idle, move to a random nearby position.
   * C++ file: WanderAIUpdate.cpp — used by civilian units, animals, etc.
   * C++ uses GameLogicRandomValue(5, 50) offset for both x and y.
   */
  private updateWanderAI(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (!entity.hasWanderAI) continue;
      if (!entity.canMove || entity.isImmobile) continue;
      if (this.isEntityDisabledForMovement(entity)) continue;

      // Source parity: isIdle() — only wander when entity has no current activity.
      const isIdle = !entity.moving
        && entity.attackTargetEntityId === null
        && entity.guardState === 'NONE';
      if (!isIdle) continue;

      // NOTE: C++ parity bug — offset is always positive, entities drift southeast over time.
      // C++ source (WanderAIUpdate.cpp:58-59) uses GameLogicRandomValue(5, 50) for both axes.
      const offsetX = this.gameRandom.nextRange(5, 50);
      const offsetZ = this.gameRandom.nextRange(5, 50);
      const destX = entity.x + offsetX;
      const destZ = entity.z + offsetZ;
      this.issueMoveTo(entity.id, destX, destZ);
    }
  }

  /**
   * Source parity: FloatUpdate::update — snaps entities with FloatUpdateProfile to the water
   * surface height each frame. C++ file: FloatUpdate.cpp lines 107-120.
   * C++ also applies visual bobbing (yaw/pitch sine oscillation) which is render-only.
   */
  private updateFloatEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (!entity.floatUpdateProfile?.enabled) continue;

      const waterHeight = this.getWaterHeightAt(entity.x, entity.z);
      if (waterHeight === null) continue;

      // Source parity: C++ sets pos->z = waterZ (raw ground position).
      // TS entity.y = waterHeight + baseHeight (center position including baseHeight offset).
      entity.y = waterHeight + entity.baseHeight;
    }
  }

  /**
   * Source parity: AutoDepositUpdate::update() — C++ lines 117-155.
   * Periodic cash deposits when deposit timer elapses. Skips neutral and under-construction.
   * On first timer elapse, enables the capture bonus flag (m_initialized / m_awardInitialCaptureBonus).
   */
  private updateAutoDeposit(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.autoDepositProfile;
      if (!profile) continue;

      // Source parity: C++ line 120 — check if deposit timer has elapsed.
      if (this.frameCounter < entity.autoDepositNextFrame) continue;

      // Source parity: C++ lines 122-127 — on first deposit frame, enable capture bonus.
      if (!entity.autoDepositInitialized) {
        entity.autoDepositCaptureBonusPending = true;
        entity.autoDepositInitialized = true;
      }

      // Source parity: C++ line 128 — reset deposit timer regardless of other checks.
      entity.autoDepositNextFrame = this.frameCounter + profile.depositFrames;

      // Source parity: C++ line 130 — skip if neutral-controlled or zero deposit.
      if (this.isEntityNeutralControlled(entity) || profile.depositAmount <= 0) continue;

      // Source parity: C++ line 134 — skip if under construction.
      if (entity.constructionPercent !== CONSTRUCTION_COMPLETE) continue;

      // Deposit money to controlling side.
      this.depositSideCredits(entity.side, profile.depositAmount);
    }
  }

  /**
   * Source parity: AutoDepositUpdate::awardInitialCaptureBonus() — C++ lines 91-113.
   * Called when a building with AutoDeposit changes ownership to a non-neutral player.
   * Awards the one-time initial capture bonus if pending.
   */
  private awardAutoDepositCaptureBonus(entity: MapEntity): void {
    const profile = entity.autoDepositProfile;
    if (!profile) return;

    // Source parity: C++ line 93 — reset deposit timer on capture.
    entity.autoDepositNextFrame = this.frameCounter + profile.depositFrames;

    // Source parity: C++ line 94 — only award if bonus is pending and > 0.
    if (!entity.autoDepositCaptureBonusPending || profile.initialCaptureBonus <= 0) return;

    this.depositSideCredits(entity.side, profile.initialCaptureBonus);
    entity.autoDepositCaptureBonusPending = false;
  }

  /**
   * Source parity: DynamicShroudClearingRangeUpdate::update() — C++ lines 205-286.
   * Animates shroud clearing range through states: NOT_STARTED → GROWING → SUSTAINING → SHRINKING → DONE → SLEEPING.
   * Uses deadline-based state machine with countdown timer.
   */
  private updateDynamicShroud(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const prof = entity.dynamicShroudProfile;
      if (!prof) continue;
      if (entity.dynamicShroudState === 'SLEEPING') continue;

      const countdown = entity.dynamicShroudStateCountdown;

      // Source parity: C++ lines 223-231 — determine state from countdown vs deadlines.
      if (countdown <= 0 || this.frameCounter > entity.dynamicShroudDoneForeverFrame) {
        entity.dynamicShroudState = 'DONE';
      } else if (countdown <= entity.dynamicShroudShrinkStartDeadline) {
        entity.dynamicShroudState = 'SHRINKING';
      } else if (countdown <= entity.dynamicShroudSustainDeadline) {
        entity.dynamicShroudState = 'SUSTAINING';
      } else if (countdown <= entity.dynamicShroudGrowStartDeadline) {
        entity.dynamicShroudState = 'GROWING';
      }
      // else remains NOT_STARTED

      // Source parity: C++ lines 233-269 — update clearing range based on state.
      switch (entity.dynamicShroudState) {
        case 'NOT_STARTED':
          // Waiting for growDelay to elapse.
          break;
        case 'GROWING': {
          // Source parity: C++ line 246 — grow by nativeClearingRange / growTime per frame.
          const growTime = Math.max(1, prof.growTime);
          entity.dynamicShroudCurrentClearingRange += entity.dynamicShroudNativeClearingRange / growTime;
          if (entity.dynamicShroudCurrentClearingRange >= entity.dynamicShroudNativeClearingRange) {
            entity.dynamicShroudCurrentClearingRange = entity.dynamicShroudNativeClearingRange;
            entity.dynamicShroudState = 'SUSTAINING';
          }
          break;
        }
        case 'SUSTAINING':
          // Source parity: C++ line 253 — hold at native clearing range.
          entity.dynamicShroudCurrentClearingRange = entity.dynamicShroudNativeClearingRange;
          break;
        case 'SHRINKING': {
          // Source parity: C++ line 259 — shrink by (native - finalVision) / shrinkTime per frame.
          const shrinkTime = Math.max(1, prof.shrinkTime);
          entity.dynamicShroudCurrentClearingRange -=
            (entity.dynamicShroudNativeClearingRange - prof.finalVision) / shrinkTime;
          if (entity.dynamicShroudCurrentClearingRange < prof.finalVision) {
            entity.dynamicShroudCurrentClearingRange = prof.finalVision;
          }
          break;
        }
        case 'DONE':
          // Source parity: C++ line 265 — clamp to final vision.
          entity.dynamicShroudCurrentClearingRange = prof.finalVision;
          break;
      }

      // Source parity: C++ line 271 — decrement countdown every frame.
      if (entity.dynamicShroudStateCountdown > 0) {
        entity.dynamicShroudStateCountdown--;
      }

      // Source parity: C++ lines 275-284 — apply vision change at intervals.
      if (entity.dynamicShroudChangeIntervalCountdown > 0) {
        entity.dynamicShroudChangeIntervalCountdown--;
      } else {
        // Reset interval timer based on current state.
        entity.dynamicShroudChangeIntervalCountdown =
          entity.dynamicShroudState === 'GROWING' ? prof.growInterval : prof.changeInterval;
        // Apply the vision range change.
        entity.visionRange = entity.dynamicShroudCurrentClearingRange;
        // Source parity: C++ line 281-283 — transition to SLEEPING after final update in DONE state.
        if (entity.dynamicShroudState === 'DONE') {
          entity.dynamicShroudState = 'SLEEPING';
        }
      }
    }
  }

  /**
   * Source parity: SlavedUpdate::update() — slave follows master with priority system.
   * Priority: emergency repair > attack > scout > idle repair > guard.
   * Runs at SLAVED_UPDATE_RATE (every ~8 frames).
   */
  private updateSlavedEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (!entity.slavedUpdateProfile) continue;
      if (entity.slaverEntityId === null) continue;

      // Source parity: throttled update rate.
      if (this.frameCounter < entity.slavedNextUpdateFrame) continue;
      entity.slavedNextUpdateFrame = this.frameCounter + SLAVED_UPDATE_RATE;

      const profile = entity.slavedUpdateProfile;
      const master = this.spawnedEntities.get(entity.slaverEntityId);

      // Source parity: if master is dead or DISABLED_UNMANNED, disable slave.
      if (!master || master.destroyed || master.objectStatusFlags.has('DISABLED_UNMANNED')) {
        entity.slaverEntityId = null;
        entity.objectStatusFlags.delete('UNSELECTABLE');
        entity.objectStatusFlags.add('DISABLED_UNMANNED');
        // Source parity: slave goes idle / crashes (flying drones).
        entity.attackTargetEntityId = null;
        entity.attackTargetPosition = null;
        entity.moveTarget = null;
        entity.moving = false;
        continue;
      }

      // Source parity: clear drone spotting each tick — slave must re-earn it.
      master.weaponBonusConditionFlags &= ~WEAPON_BONUS_DRONE_SPOTTING;

      // Source parity: repair logic — heal master if below health threshold.
      const masterHealthPercent = master.maxHealth > 0 ? (master.health / master.maxHealth) * 100 : 100;
      const needsEmergencyRepair = profile.repairRatePerSecond > 0
        && profile.repairWhenBelowHealthPercent > 0
        && masterHealthPercent <= profile.repairWhenBelowHealthPercent;

      if (needsEmergencyRepair) {
        this.slavedDoRepair(entity, master, profile);
        continue;
      }

      // Source parity: attack logic — move near master's target.
      if (profile.attackRange > 0 && master.attackTargetEntityId !== null) {
        const target = this.spawnedEntities.get(master.attackTargetEntityId);
        if (target && !target.destroyed) {
          this.slavedDoAttack(entity, master, target, profile);
          continue;
        }
      }

      // Source parity: scout logic — move ahead toward master's destination.
      if (profile.scoutRange > 0 && master.moveTarget !== null) {
        const destX = master.moveTarget.x;
        const destZ = master.moveTarget.z;
        const dx = destX - master.x;
        const dz = destZ - master.z;
        const distToDest = Math.sqrt(dx * dx + dz * dz);
        // Only scout if destination is far enough from master (> half guard range).
        if (distToDest > (profile.guardMaxRange / 2)) {
          this.slavedDoScout(entity, master, destX, destZ, profile);
          continue;
        }
      }

      // Source parity: idle repair — heal master if not at full health.
      if (profile.repairRatePerSecond > 0 && master.health < master.maxHealth) {
        this.slavedDoRepair(entity, master, profile);
        continue;
      }

      // Source parity: guard logic — stay near master.
      this.slavedDoGuard(entity, master, profile);
    }
  }

  /** Source parity: SlavedUpdate::doRepairLogic — simplified: heal master per frame. */
  private slavedDoRepair(slave: MapEntity, master: MapEntity, profile: SlavedUpdateProfile): void {
    const dx = master.x - slave.x;
    const dz = master.z - slave.z;
    const dist = Math.sqrt(dx * dx + dz * dz);

    // Move toward master if too far.
    if (dist > SLAVE_CLOSE_ENOUGH) {
      slave.moveTarget = { x: master.x, z: master.z };
      slave.attackTargetEntityId = null;
      slave.attackTargetPosition = null;
    }

    // Source parity: heal master at repairRatePerSecond / LOGIC_FRAMES_PER_SECOND per frame.
    // Apply healing on every frame (not just throttled ticks) for smoother repair.
    if (dist <= SLAVE_CLOSE_ENOUGH * 2) {
      const healPerFrame = profile.repairRatePerSecond / 30;
      if (healPerFrame > 0) {
        master.health = Math.min(master.maxHealth, master.health + healPerFrame);
      }
    }
  }

  /** Source parity: SlavedUpdate::doAttackLogic — move near master's target, grant drone spotting. */
  private slavedDoAttack(
    slave: MapEntity, master: MapEntity, target: MapEntity, profile: SlavedUpdateProfile,
  ): void {
    // Calculate position near target, clamped to attackRange from master.
    let goalX = target.x;
    let goalZ = target.z;

    const dx = goalX - master.x;
    const dz = goalZ - master.z;
    const distToTarget = Math.sqrt(dx * dx + dz * dz);
    if (distToTarget > profile.attackRange && distToTarget > 0) {
      const scale = profile.attackRange / distToTarget;
      goalX = master.x + dx * scale;
      goalZ = master.z + dz * scale;
    }

    // Add wander offset.
    if (profile.attackWanderRange > 0) {
      const angle = this.gameRandom.nextFloat() * Math.PI * 2;
      const dist = this.gameRandom.nextFloat() * profile.attackWanderRange;
      goalX += Math.cos(angle) * dist;
      goalZ += Math.sin(angle) * dist;
    }

    slave.moveTarget = { x: goalX, z: goalZ };

    // Source parity: grant DRONE_SPOTTING bonus if slave is close enough to target.
    if (profile.distToTargetToGrantRangeBonus > 0) {
      const sdx = target.x - slave.x;
      const sdz = target.z - slave.z;
      const slaveDist = Math.sqrt(sdx * sdx + sdz * sdz);
      if (slaveDist <= profile.distToTargetToGrantRangeBonus) {
        master.weaponBonusConditionFlags |= WEAPON_BONUS_DRONE_SPOTTING;
      }
    }
  }

  /** Source parity: SlavedUpdate::doScoutLogic — move ahead toward master's destination. */
  private slavedDoScout(
    slave: MapEntity, master: MapEntity, destX: number, destZ: number, profile: SlavedUpdateProfile,
  ): void {
    let goalX = destX;
    let goalZ = destZ;

    const dx = goalX - master.x;
    const dz = goalZ - master.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    if (dist > profile.scoutRange && dist > 0) {
      const scale = profile.scoutRange / dist;
      goalX = master.x + dx * scale;
      goalZ = master.z + dz * scale;
    }

    if (profile.scoutWanderRange > 0) {
      const angle = this.gameRandom.nextFloat() * Math.PI * 2;
      const wanderDist = this.gameRandom.nextFloat() * profile.scoutWanderRange;
      goalX += Math.cos(angle) * wanderDist;
      goalZ += Math.sin(angle) * wanderDist;
    }

    slave.moveTarget = { x: goalX, z: goalZ };
    slave.attackTargetEntityId = null;
    slave.attackTargetPosition = null;
  }

  /** Source parity: SlavedUpdate::doGuardLogic — stay near pinned position around master. */
  private slavedDoGuard(slave: MapEntity, master: MapEntity, profile: SlavedUpdateProfile): void {
    const guardRange = profile.guardMaxRange || 30;
    const leash = STRAY_MULTIPLIER * guardRange;

    // Source parity: stray check — if beyond leash distance from master, force return.
    const masterDx = slave.x - master.x;
    const masterDz = slave.z - master.z;
    const masterDist = Math.sqrt(masterDx * masterDx + masterDz * masterDz);

    if (masterDist > leash) {
      // Beyond leash — pick new guard offset and move back.
      if (profile.guardMaxRange > 0) {
        const angle = this.gameRandom.nextFloat() * Math.PI * 2;
        slave.slaveGuardOffsetX = Math.cos(angle) * guardRange;
        slave.slaveGuardOffsetZ = Math.sin(angle) * guardRange;
      }
      const newPinnedX = master.x + slave.slaveGuardOffsetX;
      const newPinnedZ = master.z + slave.slaveGuardOffsetZ;
      slave.moveTarget = { x: newPinnedX, z: newPinnedZ };
      slave.attackTargetEntityId = null;
      slave.attackTargetPosition = null;
      return;
    }

    // Source parity: idle guard — if far from pinned position, move toward it.
    const pinnedX = master.x + slave.slaveGuardOffsetX;
    const pinnedZ = master.z + slave.slaveGuardOffsetZ;
    const dx = slave.x - pinnedX;
    const dz = slave.z - pinnedZ;
    const dist = Math.sqrt(dx * dx + dz * dz);

    if (dist > SLAVE_CLOSE_ENOUGH) {
      slave.moveTarget = { x: pinnedX, z: pinnedZ };
      slave.attackTargetEntityId = null;
      slave.attackTargetPosition = null;
    }
  }
  // ── Source parity: CountermeasuresBehavior ──

  /**
   * Source parity: CountermeasuresBehavior::reportMissileForCountermeasures —
   * called at weapon-fire time when a SMALL_MISSILE targets a unit with countermeasures.
   * Rolls evasion probability and marks the missile for diversion if successful.
   */
  private reportMissileForCountermeasures(victim: MapEntity, event: PendingWeaponDamageEvent): void {
    const profile = victim.countermeasuresProfile!;
    const state = victim.countermeasuresState!;

    // Source parity: track all incoming missiles.
    state.incomingMissiles++;

    // Source parity: only divert if countermeasures are available or active (can redirect to).
    if (state.availableCountermeasures + state.activeCountermeasures <= 0) return;

    // Source parity: roll evasion probability using deterministic game RNG.
    if (this.gameRandom.nextFloat() >= profile.evasionRate) return;

    // Source parity: track successful diversions.
    state.divertedMissiles++;

    // Mark the missile for future diversion.
    event.countermeasureDivertFrame = this.frameCounter + profile.missileDecoyFrames;

    // Source parity: if this is the first threat, start the reaction timer.
    if (state.activeCountermeasures === 0 && state.reactionFrame === 0) {
      state.reactionFrame = this.frameCounter + profile.reactionFrames;
    }
  }

  /**
   * Source parity: CountermeasuresBehavior::update — per-frame countermeasure state machine.
   * Manages volley launching, flare cleanup, and auto-reload.
   */
  private updateCountermeasures(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.countermeasuresProfile;
      const state = entity.countermeasuresState;
      if (!profile || !state) continue;

      // Source parity: clean up dead/expired flares (runs regardless of airborne).
      for (let i = state.flareIds.length - 1; i >= 0; i--) {
        const flareId = state.flareIds[i]!;
        const flare = this.spawnedEntities.get(flareId);
        if (!flare || flare.destroyed) {
          state.flareIds.splice(i, 1);
          state.activeCountermeasures--;
        }
      }

      // Source parity: volley launching only when airborne.
      if (entity.category !== 'air') continue;

      // Source parity: first volley — reaction timer fires on exact frame.
      if (state.reactionFrame !== 0 && this.frameCounter === state.reactionFrame) {
        this.launchCountermeasureVolley(entity, profile, state);
        state.nextVolleyFrame = this.frameCounter + profile.framesBetweenVolleys;
        state.reactionFrame = 0;
      }

      // Source parity: subsequent volleys — fire on exact frame.
      if (state.nextVolleyFrame !== 0 && this.frameCounter === state.nextVolleyFrame
        && state.availableCountermeasures > 0) {
        this.launchCountermeasureVolley(entity, profile, state);
        state.nextVolleyFrame = this.frameCounter + profile.framesBetweenVolleys;
      }

      // Source parity: auto-reload when all countermeasures spent and reloadFrames > 0.
      if (state.availableCountermeasures === 0 && profile.reloadFrames > 0) {
        if (state.reloadFrame === 0) {
          state.reloadFrame = this.frameCounter + profile.reloadFrames;
        } else if (this.frameCounter >= state.reloadFrame) {
          state.availableCountermeasures = profile.numberOfVolleys * profile.volleySize;
          state.reloadFrame = 0;
        }
      }
    }
  }

  /**
   * Source parity: CountermeasuresBehavior::launchVolley — spawn flare objects.
   * Flares are spawned at the aircraft's position with velocity-based offsets.
   */
  private launchCountermeasureVolley(
    aircraft: MapEntity,
    profile: CountermeasuresProfile,
    state: CountermeasuresState,
  ): void {
    const count = Math.min(profile.volleySize, state.availableCountermeasures);
    if (count <= 0) return;

    for (let i = 0; i < count; i++) {
      // Source parity: distribute flares across the volley arc.
      // ratio = i / (N-1) * 2 - 1 ranges from -1..+1; single flare = 0.
      const ratio = count > 1 ? (i / (count - 1)) * 2 - 1 : 0;
      const arcAngle = ratio * profile.volleyArcAngle;

      // Source parity: flare is spawned at aircraft position with backward offset.
      const facingAngle = aircraft.rotationY + Math.PI + arcAngle;
      const offsetDist = 5.0; // small backward offset for visual separation
      const flareX = aircraft.x + Math.sin(facingAngle) * offsetDist;
      const flareZ = aircraft.z + Math.cos(facingAngle) * offsetDist;

      // Try to spawn from INI template; fall back to creating a minimal tracked entity.
      const flare = profile.flareTemplateName
        ? this.spawnEntityFromTemplate(profile.flareTemplateName, flareX, flareZ, 0, aircraft.side)
        : null;

      if (flare) {
        // Source parity: flares have a short lifetime.
        if (flare.lifetimeDieFrame === null) {
          flare.lifetimeDieFrame = this.frameCounter + 90; // ~3s fallback
        }
        state.flareIds.push(flare.id);
      } else {
        // No INI template available — track as a virtual flare position.
        // Create a minimal entity manually using nextId.
        const flareId = this.nextId++;
        state.flareIds.push(flareId);
        // Virtual flare — no physical entity, tracked by ID only.
        // Expires after ~3 seconds (cleanup loop handles null lookups).
      }
      state.activeCountermeasures++;
      state.availableCountermeasures--;
    }
  }

  /**
   * Source parity: CountermeasuresBehavior — process missile diversions.
   * Called during pending weapon damage update to redirect diverted missiles.
   */
  private processCountermeasureDiversions(): void {
    for (const event of this.pendingWeaponDamageEvents) {
      if (event.countermeasureDivertFrame === 0) continue;
      if (this.frameCounter < event.countermeasureDivertFrame) continue;
      if (event.countermeasureNoDamage) continue; // already diverted

      // Source parity: MissileAIUpdate — set noDamage and redirect to nearest flare.
      event.countermeasureNoDamage = true;
      event.countermeasureDivertFrame = 0; // one-shot

      // Find the victim's closest flare to redirect to.
      const victim = event.primaryVictimEntityId !== null
        ? this.spawnedEntities.get(event.primaryVictimEntityId)
        : null;
      if (!victim?.countermeasuresState) continue;

      const state = victim.countermeasuresState;
      let closestFlareId: number | null = null;
      let closestDistSqr = Infinity;

      // Source parity: search from end of flareIds (most recent), limited to volleySize.
      const profile = victim.countermeasuresProfile;
      const searchLimit = Math.min(state.flareIds.length, profile?.volleySize ?? state.flareIds.length);
      for (let i = state.flareIds.length - 1; i >= state.flareIds.length - searchLimit; i--) {
        const flareId = state.flareIds[i]!;
        const flare = this.spawnedEntities.get(flareId);
        if (!flare || flare.destroyed) continue;
        const dx = flare.x - victim.x;
        const dz = flare.z - victim.z;
        const distSqr = dx * dx + dz * dz;
        if (distSqr < closestDistSqr) {
          closestDistSqr = distSqr;
          closestFlareId = flareId;
        }
      }

      if (closestFlareId !== null) {
        // Redirect missile impact to flare position.
        const flare = this.spawnedEntities.get(closestFlareId)!;
        event.impactX = flare.x;
        event.impactZ = flare.z;
        event.primaryVictimEntityId = closestFlareId;
        if (event.missileAIState) {
          event.missileAIState.trackingTarget = true;
          event.missileAIState.targetEntityId = closestFlareId;
        }
      }
    }
  }

  /**
   * Source parity: PilotFindVehicleUpdate::update() — AI-only pilot vehicle-seeking behavior.
   * Scans for nearest same-side VEHICLE within range, auto-enters if found.
   * Falls back to moving toward base center once if no vehicle found.
   */
  private updatePilotFindVehicle(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.pilotFindVehicleProfile;
      if (!profile) continue;

      // Source parity: AI-only behavior — human-controlled pilots don't auto-seek vehicles.
      const side = entity.side ? this.normalizeSide(entity.side) : null;
      if (side) {
        const playerType = this.sidePlayerTypes.get(side);
        if (!playerType || playerType === 'HUMAN') continue;
      }

      // Source parity: if already navigating to a target, check arrival.
      if (entity.pilotFindVehicleTargetId !== null) {
        const target = this.spawnedEntities.get(entity.pilotFindVehicleTargetId);
        // Re-validate target.
        if (!target || target.destroyed
          || (target.side ? this.normalizeSide(target.side) : null) !== side
          || !this.isPilotVehicleTargetEligible(entity, target)) {
          entity.pilotFindVehicleTargetId = null;
        } else {
          const dx = entity.x - target.x;
          const dz = entity.z - target.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist <= 15) {
            // Source parity: PilotFindVehicleUpdate + ActionManager::canEnterObject.
            // Pilots with VeterancyCrateCollide(IsPilot=Yes) use collide execution path.
            const crateProfile = entity.crateCollideProfile;
            if (crateProfile?.crateType === 'VETERANCY' && crateProfile.isPilot) {
              // Keep target locked so executeCrateVeterancy can enforce "goal object" parity.
              entity.pilotFindVehicleTargetId = target.id;
              this.executeGeneralCrateBehavior(entity, target);
            } else {
              this.enterTransport(entity, target);
            }
            entity.pilotFindVehicleTargetId = null;
            continue;
          }
          // Still en route — don't re-scan.
          continue;
        }
      }

      // Source parity: only scan when idle (not moving, not attacking).
      if (entity.moving || entity.moveTarget !== null ||
          entity.attackTargetEntityId !== null || entity.attackTargetPosition !== null) {
        continue;
      }

      // Source parity: scan rate throttle.
      if (this.frameCounter < entity.pilotFindVehicleNextScanFrame) continue;
      entity.pilotFindVehicleNextScanFrame = this.frameCounter + Math.max(1, profile.scanFrames);

      // Scan for nearest same-side vehicle within range.
      const scanRangeSq = profile.scanRange * profile.scanRange;
      let closestVehicle: MapEntity | null = null;
      let closestDistSq = Infinity;

      for (const candidate of this.spawnedEntities.values()) {
        if (candidate.destroyed || candidate.slowDeathState || candidate.structureCollapseState) continue;
        if (candidate.id === entity.id) continue;
        if (candidate.category !== 'vehicle') continue;

        // Source parity: must be same side.
        const candidateSide = candidate.side ? this.normalizeSide(candidate.side) : null;
        if (candidateSide !== side) continue;

        // Source parity: health check — reject vehicles below minHealth ratio.
        if (candidate.maxHealth > 0 &&
            candidate.health < candidate.maxHealth * profile.minHealth) {
          continue;
        }

        // Source parity: PilotFindVehicleUpdate::scanClosestTarget uses collide
        // modules (wouldLikeToCollideWith) to validate targets.
        if (!this.isPilotVehicleTargetEligible(entity, candidate)) continue;

        const dx = candidate.x - entity.x;
        const dz = candidate.z - entity.z;
        const distSq = dx * dx + dz * dz;
        if (distSq > scanRangeSq) continue;
        if (distSq < closestDistSq) {
          closestDistSq = distSq;
          closestVehicle = candidate;
        }
      }

      if (closestVehicle) {
        // Source parity: ai->aiEnter(upgradeUnit, CMD_FROM_AI) — navigate to vehicle.
        this.issueMoveTo(entity.id, closestVehicle.x, closestVehicle.z);
        entity.pilotFindVehicleTargetId = closestVehicle.id;
        entity.pilotFindVehicleDidMoveToBase = false;
      } else if (!entity.pilotFindVehicleDidMoveToBase) {
        // Source parity: move to base center one time when no vehicle found.
        const baseCenter = this.resolveAiBaseCenter(side);
        if (baseCenter) {
          this.issueMoveTo(entity.id, baseCenter.x, baseCenter.z);
          entity.pilotFindVehicleDidMoveToBase = true;
        }
      }
    }
  }

  /**
   * Source parity: PilotFindVehicleUpdate::scanClosestTarget + ActionManager::canEnterObject.
   * Pilot auto-entry should only consider targets accepted by pilot collide behavior
   * (VeterancyCrateCollide with IsPilot=Yes).
   */
  private isPilotVehicleTargetEligible(pilot: MapEntity, target: MapEntity): boolean {
    if (target.destroyed) return false;

    const crateProfile = pilot.crateCollideProfile;
    if (!crateProfile || crateProfile.crateType !== 'VETERANCY' || !crateProfile.isPilot) {
      // Fallback: non-pilot collide units still use transport entry path.
      return true;
    }

    // Reuse base crate eligibility checks.
    if (!this.isCrateCollideEligible(pilot, target)) return false;

    // Veterancy target must be trainable and not already max-level.
    if (!target.experienceProfile) return false;
    if (target.experienceState.currentLevel >= LEVEL_HEROIC) return false;

    // C++ parity: pilots cannot "enter" airborne units.
    const terrainY = this.resolveGroundHeight(target.x, target.z);
    if ((target.y - target.baseHeight - terrainY) > SIGNIFICANTLY_ABOVE_TERRAIN_THRESHOLD) {
      return false;
    }

    // C++ parity: pilot-only veterancy requires same-player target.
    const pilotSide = pilot.side ? this.normalizeSide(pilot.side) : null;
    const targetSide = target.side ? this.normalizeSide(target.side) : null;
    if (!pilotSide || !targetSide || pilotSide !== targetSide) {
      return false;
    }

    return true;
  }

  /**
   * Source parity: AIPlayer::computeCenterAndRadiusOfBase — computes the centroid
   * of all buildings owned by the given side.
   */
  private resolveAiBaseCenter(side: string | null): { x: number; z: number } | null {
    if (!side) return null;
    let totalX = 0;
    let totalZ = 0;
    let count = 0;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.category !== 'building') continue;
      const entitySide = entity.side ? this.normalizeSide(entity.side) : null;
      if (entitySide !== side) continue;
      totalX += entity.x;
      totalZ += entity.z;
      count++;
    }
    if (count === 0) return null;
    return { x: totalX / count, z: totalZ / count };
  }

  /**
   * Source parity: Player::isSupplySourceSafe / AIPlayer::isSupplySourceSafe.
   * Human players have no AI module in C++, so they return true.
   */
  private isScriptSupplySourceSafe(normalizedSide: string, minSupplies: number): boolean {
    if (this.getSidePlayerType(normalizedSide) !== 'COMPUTER') {
      return true;
    }

    const warehouse = this.findScriptSupplySourceForSide(normalizedSide, minSupplies);
    if (!warehouse) {
      return true;
    }

    const warehouseRadius = this.resolveEntityMajorRadius(warehouse);
    return this.isScriptLocationSafeForSupplySource(normalizedSide, warehouse.x, warehouse.z, warehouseRadius);
  }

  /**
   * Source parity: AIPlayer::findSupplyCenter(minimumCash).
   */
  private findScriptSupplySourceForSide(normalizedSide: string, minimumCash: number): MapEntity | null {
    const baseCenter = this.resolveAiBaseCenter(normalizedSide);
    const enemyCenter = this.resolveScriptEnemyBaseCenter(normalizedSide);
    const supplyCenterCloseDistance = 20 * PATHFIND_CELL_SIZE;

    let requiredCash = Math.max(0, Math.trunc(minimumCash));
    do {
      let bestWarehouse: MapEntity | null = null;
      let bestDistSqr = 0;

      for (const entity of this.spawnedEntities.values()) {
        if (entity.destroyed) continue;
        if (!entity.kindOf.has('STRUCTURE') || !entity.kindOf.has('SUPPLY_SOURCE')) continue;
        if (!entity.supplyWarehouseProfile) continue;

        const warehouseState = this.supplyWarehouseStates.get(entity.id);
        if (!warehouseState) continue;
        const availableCash = warehouseState.currentBoxes * DEFAULT_SUPPLY_BOX_VALUE;
        if (availableCash < requiredCash) continue;

        const entitySide = this.normalizeSide(entity.side);
        if (entitySide && this.getTeamRelationshipBySides(normalizedSide, entitySide) === RELATIONSHIP_ENEMIES) {
          continue;
        }

        // Source parity: skip warehouses that already have an owned cash generator nearby.
        const nearbyRadius = supplyCenterCloseDistance + this.resolveEntityMajorRadius(entity);
        const nearbyRadiusSq = nearbyRadius * nearbyRadius;
        let hasNearbySupplyCenter = false;
        for (const nearby of this.spawnedEntities.values()) {
          if (nearby.destroyed) continue;
          if (!nearby.kindOf.has('CASH_GENERATOR')) continue;
          if (this.normalizeSide(nearby.side) !== normalizedSide) continue;
          const dx = nearby.x - entity.x;
          const dz = nearby.z - entity.z;
          if (dx * dx + dz * dz <= nearbyRadiusSq) {
            hasNearbySupplyCenter = true;
            break;
          }
        }
        if (hasNearbySupplyCenter) continue;

        const dxBase = baseCenter ? entity.x - baseCenter.x : 0;
        const dzBase = baseCenter ? entity.z - baseCenter.z : 0;
        const distSqr = dxBase * dxBase + dzBase * dzBase;

        if (enemyCenter) {
          const dxEnemy = entity.x - enemyCenter.x;
          const dzEnemy = entity.z - enemyCenter.z;
          const enemyDistSqr = dxEnemy * dxEnemy + dzEnemy * dzEnemy;
          // Source parity: reject expansions that are too close to enemy compared to own base.
          if (distSqr * 0.4 > enemyDistSqr * 0.6) {
            continue;
          }
        }

        if (!bestWarehouse || bestDistSqr > distSqr) {
          bestWarehouse = entity;
          bestDistSqr = distSqr;
        }
      }

      if (bestWarehouse) {
        return bestWarehouse;
      }

      requiredCash = Math.trunc(requiredCash / 2);
    } while (requiredCash > 100);

    return null;
  }

  private resolveScriptEnemyBaseCenter(normalizedSide: string): { x: number; z: number } | null {
    let bestEnemySide: string | null = null;
    let bestEnemyWeight = Number.NEGATIVE_INFINITY;
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const entitySide = this.normalizeSide(entity.side);
      if (!entitySide || entitySide === normalizedSide) continue;
      if (this.getTeamRelationshipBySides(normalizedSide, entitySide) !== RELATIONSHIP_ENEMIES) continue;
      let weight = 1;
      if (entity.kindOf.has('STRUCTURE')) weight += 3;
      if (entity.kindOf.has('MP_COUNT_FOR_VICTORY')) weight += 2;
      if (weight > bestEnemyWeight) {
        bestEnemyWeight = weight;
        bestEnemySide = entitySide;
      }
    }
    return this.resolveAiBaseCenter(bestEnemySide);
  }

  /**
   * Source parity: AIPlayer::isLocationSafe.
   */
  private isScriptLocationSafeForSupplySource(
    normalizedSide: string,
    centerX: number,
    centerZ: number,
    sourceRadius: number,
  ): boolean {
    const supplyCenterSafeRadius = 250 + sourceRadius;
    for (const enemy of this.spawnedEntities.values()) {
      if (enemy.destroyed) continue;
      const enemySide = this.normalizeSide(enemy.side);
      if (!enemySide) continue;
      if (this.getTeamRelationshipBySides(normalizedSide, enemySide) !== RELATIONSHIP_ENEMIES) {
        continue;
      }
      if (enemy.kindOf.has('HARVESTER') || enemy.kindOf.has('DOZER')) {
        continue;
      }
      if (
        enemy.objectStatusFlags.has('STEALTHED')
        && !enemy.objectStatusFlags.has('DETECTED')
        && !enemy.objectStatusFlags.has('DISGUISED')
      ) {
        continue;
      }

      const dx = enemy.x - centerX;
      const dz = enemy.z - centerZ;
      const range = supplyCenterSafeRadius + this.resolveEntityMajorRadius(enemy);
      if (dx * dx + dz * dz <= range * range) {
        return false;
      }
    }
    return true;
  }

  // ── Source parity: ToppleUpdate ──

  /** Angular limit before bounce/stop (~88.9 degrees). */
  private static readonly TOPPLE_ANGULAR_LIMIT = Math.PI / 2 - Math.PI / 64;
  /** Below this velocity, stop bouncing. */
  private static readonly TOPPLE_VELOCITY_BOUNCE_LIMIT = 0.01;

  // ═══════════════════════════════════════════════════════════════════════
  // SpecialAbilityUpdate — unit special ability state machine
  // ═══════════════════════════════════════════════════════════════════════

  /**
   * Source parity: SpecialAbilityUpdate::initiateIntentToDoSpecialPower —
   * begins the special ability state machine for an entity.
   */
  private initiateSpecialAbility(
    entityId: number,
    targetEntityId: number | null,
    targetX: number | null,
    targetZ: number | null,
  ): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) return;
    const profile = entity.specialAbilityProfile;
    const state = entity.specialAbilityState;
    if (!profile || !state) return;

    // Stop current movement/combat — ability takes priority.
    // Must happen before setting active=true so cancelActiveSpecialAbility doesn't cancel the new ability.
    this.cancelEntityCommandPathActions(entityId);

    // Store target.
    state.targetEntityId = targetEntityId;
    state.targetX = targetX;
    state.targetZ = targetZ;
    state.noTargetCommand = targetEntityId === null && targetX === null;
    state.withinStartAbilityRange = false;
    state.prepFrames = 0;
    state.animFrames = 0;
    state.persistentTriggerCount = 0;
    state.active = true;

    // Source parity: SpecialAbilityUpdate::initiateIntentToDoSpecialPower — always reset
    // packingState to PACKED, then conditionally advance to UNPACKED.
    state.packingState = 'PACKED';
    if (profile.unpackTimeFrames === 0 || (profile.skipPackingWithNoTarget && state.noTargetCommand)) {
      state.packingState = 'UNPACKED';
    }
  }

  /**
   * Source parity: SpecialAbilityUpdate::update() — per-frame state machine.
   */
  private updateSpecialAbility(): void {
    for (const entity of this.spawnedEntities.values()) {
      const profile = entity.specialAbilityProfile;
      const state = entity.specialAbilityState;
      if (!profile || !state || !state.active) continue;

      // Source parity: isEffectivelyDead check — clean up ability on dying entity.
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) {
        this.finishSpecialAbility(entity, false);
        continue;
      }

      // ── Target validation ──
      if (state.targetEntityId !== null) {
        const target = this.spawnedEntities.get(state.targetEntityId);
        if (!target || target.destroyed || target.slowDeathState || target.structureCollapseState) {
          // Target died — abort.
          this.finishSpecialAbility(entity, false);
          continue;
        }
      }

      // ── Handle pack/unpack animation timers ──
      if (state.animFrames > 0) {
        state.animFrames--;
        if (state.animFrames <= 0) {
          if (state.packingState === 'UNPACKING') {
            state.packingState = 'UNPACKED';
            if (profile.flipOwnerAfterUnpacking) {
              entity.rotationY += Math.PI;
            }
          } else if (state.packingState === 'PACKING') {
            state.packingState = 'PACKED';
            if (profile.flipOwnerAfterPacking) {
              entity.rotationY += Math.PI;
            }
            // Packing complete → finish ability.
            this.finishSpecialAbility(entity, true);
            continue;
          }
        } else {
          continue; // Still animating.
        }
      }

      // ── Preparation countdown ──
      if (state.prepFrames > 0) {
        // Source parity: abort if target moved beyond abort range.
        if (!this.continueSpecialAbilityPreparation(entity, profile, state)) {
          this.startSpecialAbilityPacking(entity, profile, state, false);
          continue;
        }

        // Source parity: pre-trigger un-stealth.
        if (profile.loseStealthOnTrigger && profile.preTriggerUnstealthFrames > 0
          && state.prepFrames <= profile.preTriggerUnstealthFrames) {
          entity.detectedUntilFrame = Math.max(
            entity.detectedUntilFrame,
            this.frameCounter + profile.preTriggerUnstealthFrames,
          );
        }

        state.prepFrames--;
        if (state.prepFrames <= 0) {
          this.triggerSpecialAbilityEffect(entity, profile, state);

          // Source parity: persistent mode — reset prep for next trigger.
          if (profile.persistentPrepFrames > 0) {
            state.prepFrames = profile.persistentPrepFrames;
            state.persistentTriggerCount++;
            continue;
          }

          // Non-persistent: start packing.
          this.startSpecialAbilityPacking(entity, profile, state, true);
        }
        continue;
      }

      // ── Approach phase: move within StartAbilityRange ──
      if (!state.withinStartAbilityRange) {
        if (this.isWithinSpecialAbilityRange(entity, state, profile.startAbilityRange)) {
          state.withinStartAbilityRange = true;
        } else {
          this.approachSpecialAbilityTarget(entity, state);
          continue;
        }
      }

      // ── Unpack phase ──
      if (state.packingState === 'PACKED') {
        this.startSpecialAbilityUnpacking(entity, profile, state);
        continue;
      }

      // ── Start preparation after unpacked ──
      if (state.packingState === 'UNPACKED') {
        // Source parity: IS_USING_ABILITY is set at start of preparation, not initiation.
        entity.objectStatusFlags.add('IS_USING_ABILITY');
        state.prepFrames = profile.preparationFrames > 0 ? profile.preparationFrames : 1;
        continue;
      }
    }
  }

  /**
   * Source parity: Check if entity is within range of its special ability target.
   */
  private isWithinSpecialAbilityRange(
    entity: MapEntity,
    state: SpecialAbilityRuntimeState,
    range: number,
  ): boolean {
    if (state.noTargetCommand) return true;
    let tx: number;
    let tz: number;
    if (state.targetEntityId !== null) {
      const target = this.spawnedEntities.get(state.targetEntityId);
      if (!target) return true;
      tx = target.x;
      tz = target.z;
    } else if (state.targetX !== null && state.targetZ !== null) {
      tx = state.targetX;
      tz = state.targetZ;
    } else {
      return true;
    }
    const dx = entity.x - tx;
    const dz = entity.z - tz;
    return dx * dx + dz * dz <= range * range;
  }

  /**
   * Source parity: Move entity toward its special ability target.
   */
  private approachSpecialAbilityTarget(
    entity: MapEntity,
    state: SpecialAbilityRuntimeState,
  ): void {
    if (entity.moving) return; // Already moving.
    if (state.targetEntityId !== null) {
      const target = this.spawnedEntities.get(state.targetEntityId);
      if (target && !target.destroyed) {
        this.issueMoveTo(entity.id, target.x, target.z);
      }
    } else if (state.targetX !== null && state.targetZ !== null) {
      this.issueMoveTo(entity.id, state.targetX, state.targetZ);
    }
  }

  /**
   * Source parity: Start the unpack animation.
   */
  private startSpecialAbilityUnpacking(
    entity: MapEntity,
    profile: SpecialAbilityProfile,
    state: SpecialAbilityRuntimeState,
  ): void {
    if (profile.unpackTimeFrames <= 0) {
      state.packingState = 'UNPACKED';
      return;
    }
    state.packingState = 'UNPACKING';
    const variation = profile.packUnpackVariationFactor > 0
      ? 1.0 + (this.gameRandom.nextFloat() * 2 - 1) * profile.packUnpackVariationFactor
      : 1.0;
    state.animFrames = Math.max(1, Math.round(profile.unpackTimeFrames * variation));
    // Stop movement during unpack.
    entity.moving = false;
    entity.movePath = [];
    entity.moveTarget = null;
  }

  /**
   * Source parity: Start the pack animation.
   */
  private startSpecialAbilityPacking(
    entity: MapEntity,
    profile: SpecialAbilityProfile,
    state: SpecialAbilityRuntimeState,
    _success: boolean,
  ): void {
    if (profile.packTimeFrames <= 0 ||
        (profile.skipPackingWithNoTarget && state.noTargetCommand)) {
      // No packing needed — finish immediately.
      this.finishSpecialAbility(entity, _success);
      return;
    }
    state.packingState = 'PACKING';
    const variation = profile.packUnpackVariationFactor > 0
      ? 1.0 + (this.gameRandom.nextFloat() * 2 - 1) * profile.packUnpackVariationFactor
      : 1.0;
    state.animFrames = Math.max(1, Math.round(profile.packTimeFrames * variation));
  }

  /**
   * Source parity: continuePreparation — check abort conditions during preparation.
   * Returns false if the ability should be aborted.
   */
  private continueSpecialAbilityPreparation(
    entity: MapEntity,
    profile: SpecialAbilityProfile,
    state: SpecialAbilityRuntimeState,
  ): boolean {
    const HUGE_DISTANCE = 10000000.0;
    if (profile.abilityAbortRange < HUGE_DISTANCE) {
      if (!this.isWithinSpecialAbilityRange(entity, state, profile.abilityAbortRange)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Source parity: triggerAbilityEffect — execute the ability's actual effect.
   * Delegates to the existing special-power-effects infrastructure via lastSpecialPowerDispatch.
   */
  private triggerSpecialAbilityEffect(
    entity: MapEntity,
    profile: SpecialAbilityProfile,
    state: SpecialAbilityRuntimeState,
  ): void {
    // Source parity: LoseStealthOnTrigger.
    if (profile.loseStealthOnTrigger) {
      entity.detectedUntilFrame = Math.max(
        entity.detectedUntilFrame,
        this.frameCounter + LOGIC_FRAME_RATE * 2,
      );
    }

    // Source parity: award XP for triggering.
    if (profile.awardXPForTriggering > 0 && entity.experienceProfile) {
      const xpResult = addExperiencePointsImpl(
        entity.experienceState,
        entity.experienceProfile,
        profile.awardXPForTriggering,
        false,
      );
      if (xpResult.didLevelUp) {
        this.onEntityLevelUp(entity, xpResult.oldLevel, xpResult.newLevel);
      }
    }

    // Execute the effect based on the last dispatch record.
    const dispatch = entity.lastSpecialPowerDispatch;
    if (!dispatch) return;

    const effectContext = this.createSpecialPowerEffectContext();
    const sourceSide = entity.side ?? '';

    if (state.targetEntityId !== null) {
      // Object-targeted ability: cash hack, defector, etc.
      const module = entity.specialPowerModules.get(profile.specialPowerTemplateName);
      if (!module) return;
      const effectCategory = resolveEffectCategoryImpl(module.moduleType);
      switch (effectCategory) {
        case 'CASH_HACK':
          executeCashHackImpl({
            sourceEntityId: entity.id,
            sourceSide,
            targetEntityId: state.targetEntityId,
            amountToSteal: module.cashHackMoneyAmount > 0
              ? module.cashHackMoneyAmount : DEFAULT_CASH_HACK_AMOUNT,
          }, effectContext);
          break;
        case 'DEFECTOR':
          executeDefectorImpl({
            sourceEntityId: entity.id,
            sourceSide,
            targetEntityId: state.targetEntityId,
          }, effectContext);
          break;
      }
    } else if (state.targetX !== null && state.targetZ !== null) {
      // Position-targeted ability.
      const module = entity.specialPowerModules.get(profile.specialPowerTemplateName);
      if (!module) return;
      const effectCategory = resolveEffectCategoryImpl(module.moduleType);
      switch (effectCategory) {
        case 'AREA_DAMAGE':
          executeAreaDamageImpl({
            sourceEntityId: entity.id,
            sourceSide,
            targetX: state.targetX,
            targetZ: state.targetZ,
            radius: module.areaDamageRadius > 0 ? module.areaDamageRadius : DEFAULT_AREA_DAMAGE_RADIUS,
            damage: module.areaDamageAmount > 0 ? module.areaDamageAmount : DEFAULT_AREA_DAMAGE_AMOUNT,
            damageType: 'EXPLOSION',
          }, effectContext);
          break;
        case 'EMP_PULSE':
          executeEmpPulseImpl({
            sourceEntityId: entity.id,
            sourceSide,
            targetX: state.targetX,
            targetZ: state.targetZ,
            radius: module.areaDamageRadius > 0 ? module.areaDamageRadius : DEFAULT_EMP_RADIUS,
            damage: module.areaDamageAmount > 0 ? module.areaDamageAmount : DEFAULT_EMP_DAMAGE,
          }, effectContext);
          break;
      }
    }
    // No-target abilities have their effects triggered inline (e.g., cash bounty already handled).
  }

  /**
   * Source parity: finishAbility + onExit — clean up after ability completion or abort.
   */
  private finishSpecialAbility(entity: MapEntity, _success: boolean): void {
    const profile = entity.specialAbilityProfile;
    const state = entity.specialAbilityState;
    if (!state) return;

    state.active = false;
    state.targetEntityId = null;
    state.targetX = null;
    state.targetZ = null;
    state.prepFrames = 0;
    state.animFrames = 0;
    state.withinStartAbilityRange = false;
    state.noTargetCommand = false;
    state.persistentTriggerCount = 0;

    // Source parity: onExit sets m_packingState = STATE_NONE.
    // We use 'PACKED' as the idle representation since initiateSpecialAbility always resets it.
    state.packingState = 'PACKED';

    entity.objectStatusFlags.delete('IS_USING_ABILITY');

    // Source parity: flee after completion.
    // C++ uses forward (facing) direction when flip flags are set, backward otherwise.
    if (_success && profile && profile.fleeRangeAfterCompletion > 0) {
      const fleeDist = profile.fleeRangeAfterCompletion;
      const flipped = profile.flipOwnerAfterUnpacking || profile.flipOwnerAfterPacking;
      const fleeAngle = flipped ? entity.rotationY : entity.rotationY + Math.PI;
      const fleeX = entity.x + Math.cos(fleeAngle) * fleeDist;
      const fleeZ = entity.z + Math.sin(fleeAngle) * fleeDist;
      this.issueMoveTo(entity.id, fleeX, fleeZ);
    }
  }

  /**
   * Source parity: ToppleUpdate::applyTopplingForce() — initiate topple on an entity.
   * Called from crush collisions or damage application for topple-enabled entities.
   */
  private applyTopplingForce(entity: MapEntity, dirX: number, dirZ: number, speed: number): void {
    const profile = entity.toppleProfile;
    if (!profile) return;
    if (entity.toppleState !== 'NONE') return; // already toppling
    // Source parity: isEffectivelyDead() guard — don't topple dead/dying entities.
    if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) return;

    // Normalize direction.
    const len = Math.sqrt(dirX * dirX + dirZ * dirZ);
    if (len < 0.001) return;

    let normDirX = dirX / len;
    let normDirZ = dirZ / len;

    // Source parity: ToppleLeftOrRightOnly — constrain topple direction to perpendicular
    // to the entity's current orientation (for fence-like objects).
    if (profile.toppleLeftOrRightOnly) {
      const facingX = Math.sin(entity.rotationY);
      const facingZ = -Math.cos(entity.rotationY);
      const dot = normDirX * facingX + normDirZ * facingZ;
      // Remove the forward/backward component, keeping only the left/right component.
      normDirX -= dot * facingX;
      normDirZ -= dot * facingZ;
      const sideLen = Math.sqrt(normDirX * normDirX + normDirZ * normDirZ);
      if (sideLen < 0.001) return;
      normDirX /= sideLen;
      normDirZ /= sideLen;
    }

    entity.toppleDirX = normDirX;
    entity.toppleDirZ = normDirZ;
    entity.toppleSpeed = speed;
    entity.toppleAngularVelocity = speed * profile.initialVelocityPercent;
    entity.toppleAngularAccumulation = 0;
    entity.toppleState = 'TOPPLING';

    // Source parity: KillWhenStartToppling — instant death.
    if (profile.killWhenStartToppling) {
      this.markEntityDestroyed(entity.id, -1);
      return;
    }

    // Source parity: remove from pathfinder on topple start.
    entity.blocksPath = false;
  }

  /**
   * Source parity: ToppleUpdate::update() — per-frame angular rotation and bounce.
   */
  // ── Source parity: SupplyWarehouseCripplingBehavior ──

  /**
   * Source parity: SupplyWarehouseCripplingBehavior::onDamage — reset heal suppression timer.
   */
  private supplyWarehouseCripplingOnDamage(entity: MapEntity): void {
    const profile = entity.supplyWarehouseCripplingProfile!;
    entity.swCripplingHealSuppressedUntilFrame = this.frameCounter + profile.selfHealSuppressionFrames;
    entity.swCripplingNextHealFrame = entity.swCripplingHealSuppressedUntilFrame;
  }

  /**
   * Source parity: SupplyWarehouseCripplingBehavior::onBodyDamageStateChange — toggle dock.
   * REALLYDAMAGED (2) = cripple dock; exit from REALLYDAMAGED = re-enable dock.
   */
  private supplyWarehouseCripplingOnStateChange(
    entity: MapEntity,
    oldState: BodyDamageState,
    newState: BodyDamageState,
  ): void {
    const REALLYDAMAGED: BodyDamageState = 2;
    if (newState === REALLYDAMAGED && !entity.swCripplingDockDisabled) {
      entity.swCripplingDockDisabled = true;
    } else if (oldState === REALLYDAMAGED && entity.swCripplingDockDisabled) {
      entity.swCripplingDockDisabled = false;
    }
  }

  /**
   * Source parity: SupplyWarehouseCripplingBehavior::update() — periodic self-heal.
   * Healing is suppressed for selfHealSuppressionFrames after each damage event.
   * Once suppression expires, heals selfHealAmount every selfHealDelayFrames.
   * Stops when entity reaches full health.
   */
  private updateSupplyWarehouseCrippling(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.supplyWarehouseCripplingProfile;
      if (!profile) continue;
      // No healing needed if at full health.
      if (entity.health >= entity.maxHealth) continue;
      // Still suppressed from recent damage.
      if (this.frameCounter < entity.swCripplingHealSuppressedUntilFrame) continue;
      // Not yet time for next heal tick.
      if (this.frameCounter < entity.swCripplingNextHealFrame) continue;

      // Schedule next heal.
      entity.swCripplingNextHealFrame = this.frameCounter + profile.selfHealDelayFrames;

      // Apply healing.
      const oldDamageState = calcBodyDamageState(entity.health, entity.maxHealth);
      entity.health = Math.min(entity.maxHealth, entity.health + profile.selfHealAmount);
      const newDamageState = calcBodyDamageState(entity.health, entity.maxHealth);

      // Check if healing caused a state transition (e.g. REALLYDAMAGED → DAMAGED).
      if (oldDamageState !== newDamageState) {
        this.supplyWarehouseCripplingOnStateChange(entity, oldDamageState, newDamageState);
      }
    }
  }

  private updateToppleEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.toppleState === 'NONE' || entity.toppleState === 'DONE') continue;
      const profile = entity.toppleProfile;
      if (!profile) continue;

      const ANGULAR_LIMIT = GameLogicSubsystem.TOPPLE_ANGULAR_LIMIT;
      const BOUNCE_LIMIT = GameLogicSubsystem.TOPPLE_VELOCITY_BOUNCE_LIMIT;

      // Source parity: cap velocity at limit to prevent overshoot.
      let curVelToUse = entity.toppleAngularVelocity;
      if (entity.toppleAngularAccumulation + curVelToUse > ANGULAR_LIMIT) {
        curVelToUse = ANGULAR_LIMIT - entity.toppleAngularAccumulation;
      }

      entity.toppleAngularAccumulation += curVelToUse;

      // Source parity: bounce/stop only when hitting limit with positive velocity.
      if (entity.toppleAngularAccumulation >= ANGULAR_LIMIT && entity.toppleAngularVelocity > 0) {
        entity.toppleAngularAccumulation = ANGULAR_LIMIT;

        // Source parity: reverse velocity and apply bounce damping.
        entity.toppleAngularVelocity *= -profile.bounceVelocityPercent;

        if (Math.abs(entity.toppleAngularVelocity) < BOUNCE_LIMIT) {
          // Source parity: topple complete — velocity too small to bounce.
          entity.toppleAngularVelocity = 0;
          entity.toppleState = 'DONE';
          if (profile.killWhenFinishedToppling) {
            this.markEntityDestroyed(entity.id, -1);
          }
        } else {
          entity.toppleState = 'BOUNCING';
        }
      } else {
        // Source parity: acceleration only applied during falling, not during bouncing.
        entity.toppleAngularVelocity += entity.toppleSpeed * profile.initialAccelPercent;
      }
    }
  }

  /**
   * Source parity: ActiveBody::setDamageState — force a body damage state by
   * mutating health thresholds (ratio * maxHealth - 1).
   */
  private setEntityBodyDamageState(entity: MapEntity, newState: BodyDamageState): void {
    if (entity.maxHealth <= 0) {
      return;
    }

    const oldState = calcBodyDamageState(entity.health, entity.maxHealth);
    let ratio = 1.0;
    if (newState === 1) {
      ratio = UNIT_DAMAGED_THRESH;
    } else if (newState === 2) {
      ratio = UNIT_REALLY_DAMAGED_THRESH;
    } else if (newState === 3) {
      ratio = 0.0;
    }

    let desiredHealth = entity.maxHealth * ratio - 1;
    if (desiredHealth < 0) {
      desiredHealth = 0;
    }
    entity.health = Math.min(entity.maxHealth, desiredHealth);

    const nextState = calcBodyDamageState(entity.health, entity.maxHealth);
    if (entity.supplyWarehouseCripplingProfile && entity.health > 0 && oldState !== nextState) {
      this.supplyWarehouseCripplingOnStateChange(entity, oldState, nextState);
    }

    // Source parity: structures in BODY_RUBBLE disable collisions.
    if (nextState === 3 && entity.kindOf.has('STRUCTURE')) {
      entity.noCollisions = true;
    }
  }

  /**
   * Source parity: TensileFormationUpdate::initLinks — initialize up to 4
   * nearest tensile members and cache their relative tensors.
   */
  private initTensileFormationLinks(entity: MapEntity, state: TensileFormationRuntimeState): void {
    state.linksInited = true;

    let closestDistance = 99999.9;
    for (const other of this.spawnedEntities.values()) {
      if (other.id === entity.id) continue;
      if (other.destroyed) continue;
      if (!other.tensileFormationProfile || !other.tensileFormationState) continue;

      const dx = other.x - entity.x;
      const dz = other.z - entity.z;
      const distance = Math.hypot(dx, dz);
      if (distance > 1000.0) continue;

      // Source parity: keep only monotonically closer entries while iterating.
      if (distance < closestDistance) {
        closestDistance = distance;
        for (let i = 3; i > 0; i--) {
          state.links[i] = state.links[i - 1]!;
        }
        state.links[0] = { id: other.id, tensorX: dx, tensorZ: dz };
      }
    }

    entity.rotationY = this.gameRandom.nextFloat() * Math.PI * 2 - Math.PI;
  }

  /**
   * Source parity: TensileFormationUpdate::propagateDislodgement — set nearby and linked
   * members to BODY_DAMAGED.
   */
  private propagateTensileDislodgement(entity: MapEntity, state: TensileFormationRuntimeState): void {
    for (const other of this.spawnedEntities.values()) {
      if (other.destroyed) continue;
      if (!other.tensileFormationProfile || !other.tensileFormationState) continue;
      const dx = other.x - entity.x;
      const dz = other.z - entity.z;
      if (dx * dx + dz * dz > 100.0 * 100.0) continue;
      this.setEntityBodyDamageState(other, 1);
    }

    for (const link of state.links) {
      if (!link || link.id === 0) continue;
      const other = this.spawnedEntities.get(link.id);
      if (!other || other.destroyed) continue;
      this.setEntityBodyDamageState(other, 1);
    }
  }

  /**
   * Source parity: TerrainLogic::getGroundHeight(..., normal) equivalent used by
   * TensileFormationUpdate to compute slope.
   */
  private sampleGroundNormal(x: number, z: number): { x: number; z: number; up: number } {
    const hm = this.mapHeightmap;
    if (!hm) {
      return { x: 0, z: 0, up: 1 };
    }
    const e = 1.0;
    const hL = hm.getInterpolatedHeight(x - e, z);
    const hR = hm.getInterpolatedHeight(x + e, z);
    const hD = hm.getInterpolatedHeight(x, z - e);
    const hU = hm.getInterpolatedHeight(x, z + e);

    const dHx = (hR - hL) / (2 * e);
    const dHz = (hU - hD) / (2 * e);

    // Parametric surface normal for y = h(x,z): (-dh/dx, -dh/dz, 1)
    let nx = -dHx;
    let nz = -dHz;
    let ny = 1.0;
    const len = Math.hypot(nx, nz, ny);
    if (len > 1e-6) {
      nx /= len;
      nz /= len;
      ny /= len;
    } else {
      nx = 0;
      nz = 0;
      ny = 1;
    }
    return { x: nx, z: nz, up: ny };
  }

  /**
   * Source parity: TensileFormationUpdate::update — avalanche-style sliding and
   * tensor coupling between nearby formation members.
   */
  private updateTensileFormation(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.tensileFormationProfile;
      const state = entity.tensileFormationState;
      if (!profile || !state) continue;
      if (state.done) continue;

      if (!state.linksInited) {
        this.initTensileFormationLinks(entity, state);
      }

      if (!state.enabled) {
        const bodyState = calcBodyDamageState(entity.health, entity.maxHealth);
        if (bodyState >= 1) {
          state.enabled = true;
          // TODO(C&C source parity): pathfinder removeWallFromMyFootprint + CrackSound audio event.
        } else {
          if (this.frameCounter < state.nextWakeFrame) {
            continue;
          }
          state.nextWakeFrame = this.frameCounter + 30;
          continue;
        }
      }

      state.life += 1;
      if (state.life > 300) {
        entity.modelConditionFlags.delete('MOVING');
        entity.modelConditionFlags.delete('FREEFALL');
        entity.modelConditionFlags.delete('POST_COLLAPSE');
        this.setEntityBodyDamageState(entity, 3);
        // TODO(C&C source parity): pathfinder createWallFromMyFootprint and module sleep forever.
        state.done = true;
        continue;
      }

      if (state.life % 30 === 29) {
        this.propagateTensileDislodgement(entity, state);
      }

      const prevSurfaceY = entity.y - entity.baseHeight;
      const normal = this.sampleGroundNormal(entity.x, entity.z);
      const steepness = 1.0 - normal.up;
      const slopeScale = 0.3 + steepness;
      state.inertiaX += normal.x * slopeScale;
      state.inertiaZ += normal.z * slopeScale;
      state.inertiaX *= 0.95;
      state.inertiaZ *= 0.95;

      let newX = entity.x + state.inertiaX;
      let newZ = entity.z + state.inertiaZ;
      let newSurfaceY = Math.min(state.lowestSlideElevation, this.resolveGroundHeight(newX, newZ));

      for (const link of state.links) {
        if (!link || link.id === 0) continue;
        const other = this.spawnedEntities.get(link.id);
        if (!other || other.destroyed) continue;

        const desiredX = other.x - link.tensorX;
        const desiredZ = other.z - link.tensorZ;

        newX = newX * 0.93 + desiredX * 0.07;
        newZ = newZ * 0.93 + desiredZ * 0.07;
        newSurfaceY = Math.min(state.lowestSlideElevation, this.resolveGroundHeight(newX, newZ));
      }

      entity.modelConditionFlags.add('POST_COLLAPSE');
      if (state.life < 200) {
        entity.modelConditionFlags.add('MOVING');
      } else {
        entity.modelConditionFlags.delete('MOVING');
      }

      if (Math.abs(prevSurfaceY - newSurfaceY) > 0.2 && state.life < 100) {
        entity.modelConditionFlags.add('FREEFALL');
      } else {
        entity.modelConditionFlags.delete('FREEFALL');
      }

      state.lowestSlideElevation = newSurfaceY;
      entity.x = newX;
      entity.z = newZ;
      entity.y = newSurfaceY + entity.baseHeight;
      this.updatePathfindPosCell(entity);
    }
  }

  /**
   * Source parity: DeployStyleAIUpdate::update() — per-frame deploy state machine.
   * Transitions: READY_TO_MOVE ↔ DEPLOY ↔ READY_TO_ATTACK ↔ UNDEPLOY ↔ READY_TO_MOVE.
   * Timer-based: DEPLOY finishes after unpackTime, UNDEPLOY finishes after packTime.
   * Reversal: mid-deploy/undeploy can be reversed at current progress frame.
   */
  private updateDeployStyleEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.deployStyleProfile;
      if (!profile) continue;

      const isTryingToAttack = entity.attackTargetEntityId !== null || entity.attackTargetPosition !== null;
      const isTryingToMove = entity.moving || entity.moveTarget !== null;

      // Check timer expiry for DEPLOY/UNDEPLOY transitions.
      if (entity.deployFrameToWait !== 0 && this.frameCounter >= entity.deployFrameToWait) {
        if (entity.deployState === 'DEPLOY') {
          this.setDeployState(entity, 'READY_TO_ATTACK');
        } else if (entity.deployState === 'UNDEPLOY') {
          this.setDeployState(entity, 'READY_TO_MOVE');
        }
      }

      // Source parity: If trying to attack (or idle auto-target will engage), deploy.
      if (isTryingToAttack) {
        switch (entity.deployState) {
          case 'READY_TO_MOVE':
            this.setDeployState(entity, 'DEPLOY');
            break;
          case 'READY_TO_ATTACK':
            // Already deployed — let combat system handle attacking.
            break;
          case 'DEPLOY':
            // Still deploying — wait for timer.
            break;
          case 'UNDEPLOY':
            // Reverse the undeploy.
            if (entity.deployFrameToWait !== 0) {
              this.reverseDeployTransition(entity, 'DEPLOY', profile.unpackTimeFrames);
            }
            break;
        }
      } else if (isTryingToMove) {
        // Source parity: If trying to move, undeploy.
        switch (entity.deployState) {
          case 'READY_TO_MOVE':
            // Already mobile — movement system handles it.
            break;
          case 'READY_TO_ATTACK':
            this.setDeployState(entity, 'UNDEPLOY');
            break;
          case 'DEPLOY':
            // Reverse the deploy.
            if (entity.deployFrameToWait !== 0) {
              // Source parity: C++ setMyState(UNDEPLOY, TRUE) uses getUnpackTime() for both reversal directions.
              this.reverseDeployTransition(entity, 'UNDEPLOY', profile.unpackTimeFrames);
            }
            break;
          case 'UNDEPLOY':
            // Still undeploying — wait for timer.
            break;
        }
      }

      // Source parity: Block movement during DEPLOY/UNDEPLOY/READY_TO_ATTACK.
      if (entity.deployState !== 'READY_TO_MOVE') {
        entity.moving = false;
      }
    }
  }

  private setDeployState(entity: MapEntity, state: DeployState): void {
    const profile = entity.deployStyleProfile;
    if (!profile) return;
    entity.deployState = state;
    switch (state) {
      case 'DEPLOY':
        entity.deployFrameToWait = this.frameCounter + profile.unpackTimeFrames;
        entity.objectStatusFlags.delete('DEPLOYED');
        break;
      case 'UNDEPLOY':
        entity.deployFrameToWait = this.frameCounter + profile.packTimeFrames;
        entity.objectStatusFlags.delete('DEPLOYED');
        break;
      case 'READY_TO_ATTACK':
        entity.deployFrameToWait = 0;
        entity.objectStatusFlags.add('DEPLOYED');
        break;
      case 'READY_TO_MOVE':
        entity.deployFrameToWait = 0;
        entity.objectStatusFlags.delete('DEPLOYED');
        // Source parity: re-enable movement if a pending move target exists.
        if (entity.moveTarget !== null && entity.movePath.length > 0) {
          entity.moving = true;
        }
        break;
    }
  }

  private reverseDeployTransition(entity: MapEntity, newState: DeployState, totalFrames: number): void {
    const framesLeft = Math.max(0, entity.deployFrameToWait - this.frameCounter);
    entity.deployState = newState;
    entity.deployFrameToWait = this.frameCounter + (totalFrames - framesLeft);
  }

  /**
   * Source parity: GenerateMinefieldBehavior::onDie — spawn mines around entity on death.
   * Implements border-only circular placement (most common use case).
   */
  private tryGenerateMinefieldOnDeath(entity: MapEntity): void {
    const profile = entity.generateMinefieldProfile;
    if (!profile || entity.generateMinefieldDone) return;
    if (!profile.generateOnlyOnDeath) return;
    entity.generateMinefieldDone = true;

    const registry = this.iniDataRegistry;
    if (!registry) return;
    const mineObjDef = findObjectDefByName(registry, profile.mineName);
    if (!mineObjDef) return;

    // Source parity: get mine radius from geometry for spacing.
    const mineGeom = this.resolveObstacleGeometry(mineObjDef);
    const mineRadius = mineGeom
      ? Math.max(mineGeom.majorRadius, mineGeom.minorRadius)
      : MAP_XY_FACTOR * 0.5;
    const mineDiameter = Math.max(1, mineRadius * 2);

    const radius = profile.distanceAroundObject;
    if (radius <= 0) return;

    // Source parity: circular border placement.
    const circumference = 2 * Math.PI * radius;
    const numMines = Math.max(1, Math.ceil(circumference / mineDiameter));
    const angleInc = (2 * Math.PI) / numMines;

    for (let i = 0; i < numMines; i++) {
      const angle = i * angleInc;
      const mineX = entity.x + radius * Math.cos(angle);
      const mineZ = entity.z + radius * Math.sin(angle);
      const rotation = this.gameRandom.nextFloat() * Math.PI * 2 - Math.PI;
      this.spawnEntityFromTemplate(profile.mineName, mineX, mineZ, rotation, entity.side);
    }
  }

  /**
   * Source parity: CreateCrateDie::onDie — spawn a salvage crate near the dying entity.
   * C++ uses CrateSystem template lookup with weighted chance selection; we simplify
   * to spawning the CrateData template directly within 5 units of the death location.
   */
  private trySpawnCrateOnDeath(entity: MapEntity, attackerId: number): void {
    const profile = entity.createCrateDieProfile;
    if (!profile) return;

    // Source parity: no crate for killing allies.
    if (attackerId >= 0) {
      const attacker = this.spawnedEntities.get(attackerId);
      if (attacker && this.getEntityRelationship(attacker.id, entity.id) === 'allies') {
        return;
      }
    }

    // Source parity: findPositionAround with maxRadius=5 (circular distribution).
    const angle = this.gameRandom.nextFloat() * Math.PI * 2;
    const radius = this.gameRandom.nextFloat() * 5;
    const offsetX = Math.cos(angle) * radius;
    const offsetZ = Math.sin(angle) * radius;
    const crateX = entity.x + offsetX;
    const crateZ = entity.z + offsetZ;
    const rotation = this.gameRandom.nextFloat() * Math.PI * 2 - Math.PI;

    this.spawnEntityFromTemplate(profile.crateTemplateName, crateX, crateZ, rotation, entity.side);
  }

  private tryBeginSlowDeath(entity: MapEntity, attackerId: number): boolean {
    if (entity.slowDeathProfiles.length === 0) return false;

    // Collect applicable profiles with their weights.
    const candidates: { index: number; weight: number }[] = [];
    for (let i = 0; i < entity.slowDeathProfiles.length; i++) {
      const profile = entity.slowDeathProfiles[i]!;
      if (!this.isSlowDeathApplicable(entity, profile)) continue;
      // Source parity: overkill bonus = (overkillDamage / maxHealth) * bonusPerOverkillPercent.
      // C++ uses fraction (0.0–1.0+), not percentage. Simplified: overkill = -health.
      const overkillFraction = entity.maxHealth > 0 ? -entity.health / entity.maxHealth : 0;
      const overkillBonus = Math.floor(overkillFraction * profile.modifierBonusPerOverkillPercent);
      const weight = Math.max(1, profile.probabilityModifier + overkillBonus);
      candidates.push({ index: i, weight });
    }
    if (candidates.length === 0) return false;

    // Source parity: weighted random selection among applicable profiles.
    const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
    let roll = this.gameRandom.nextRange(1, totalWeight);
    let selectedIndex = candidates[0]!.index;
    for (const candidate of candidates) {
      roll -= candidate.weight;
      if (roll <= 0) {
        selectedIndex = candidate.index;
        break;
      }
    }

    const profile = entity.slowDeathProfiles[selectedIndex]!;

    // Calculate frame timings.
    const sinkDelay = profile.sinkDelay + (profile.sinkDelayVariance > 0
      ? this.gameRandom.nextRange(0, profile.sinkDelayVariance) : 0);
    const destructionDelay = profile.destructionDelay + (profile.destructionDelayVariance > 0
      ? this.gameRandom.nextRange(0, profile.destructionDelayVariance) : 0);
    const sinkFrame = this.frameCounter + sinkDelay;
    const destructionFrame = this.frameCounter + Math.max(1, destructionDelay);

    // Source parity: midpoint is randomly placed between 35-65% of destruction time.
    const midpointBegin = Math.floor(destructionDelay * SLOW_DEATH_BEGIN_MIDPOINT_RATIO);
    const midpointEnd = Math.floor(destructionDelay * SLOW_DEATH_END_MIDPOINT_RATIO);
    const midpointFrame = this.frameCounter + (midpointBegin < midpointEnd
      ? this.gameRandom.nextRange(midpointBegin, midpointEnd) : midpointBegin);

    entity.slowDeathState = {
      profileIndex: selectedIndex,
      sinkFrame,
      midpointFrame,
      destructionFrame,
      midpointExecuted: false,
    };

    // Source parity: mark AI as dead — prevent further combat, production, movement.
    entity.animationState = 'DIE';
    entity.canTakeDamage = false;
    entity.attackTargetEntityId = null;
    entity.attackTargetPosition = null;
    entity.attackOriginalVictimPosition = null;
    entity.attackCommandSource = 'AI';
    entity.attackSubState = 'IDLE';
    entity.moving = false;
    entity.moveTarget = null;
    entity.movePath = [];
    entity.pathIndex = 0;
    entity.pathfindGoalCell = null;

    // Unregister energy while dying.
    this.unregisterEntityEnergy(entity);
    // Cancel production and pending actions.
    this.cancelEntityCommandPathActions(entity.id);
    this.cancelAndRefundAllProductionOnDeath(entity);

    // Source parity: deselect for all players.
    entity.selected = false;

    // Execute INITIAL phase.
    this.executeSlowDeathPhase(entity, profile, 0);

    // Source parity: NeutronMissileSlowDeathBehavior — initialize blast state when slow death activates.
    if (entity.neutronMissileSlowDeathProfile) {
      const nmProfile = entity.neutronMissileSlowDeathProfile;
      entity.neutronMissileSlowDeathState = {
        activationFrame: 0, // Will be set to actual frame on first update tick.
        completedBlasts: nmProfile.blasts.map(() => false),
        completedScorchBlasts: nmProfile.blasts.map(() => false),
      };
    }

    // Source parity: HelicopterSlowDeathBehavior — initialize spiral crash state.
    if (entity.helicopterSlowDeathProfiles.length > 0) {
      // Find first applicable helicopter death profile.
      for (let hpi = 0; hpi < entity.helicopterSlowDeathProfiles.length; hpi++) {
        const heliProfile = entity.helicopterSlowDeathProfiles[hpi]!;
        if (!this.isDieModuleApplicable(entity, heliProfile)) continue;
        entity.helicopterSlowDeathState = {
          forwardAngle: entity.rotationY,
          forwardSpeed: heliProfile.spiralOrbitForwardSpeed,
          verticalVelocity: 0,
          selfSpin: heliProfile.minSelfSpin,
          selfSpinTowardsMax: true,
          lastSelfSpinUpdateFrame: this.frameCounter,
          orbitDirection: 1, // Always left (C++ line 213).
          hitGroundFrame: 0,
          profileIndex: hpi,
        };
        break;
      }
    }

    // Source parity: JetSlowDeathBehavior — initialize jet crash state.
    // C++ onDie: if on ground → instant destroy with ground OCL; if airborne → slow death.
    if (entity.jetSlowDeathProfiles.length > 0) {
      for (let jpi = 0; jpi < entity.jetSlowDeathProfiles.length; jpi++) {
        const jetProfile = entity.jetSlowDeathProfiles[jpi]!;
        if (!this.isDieModuleApplicable(entity, jetProfile)) continue;

        // C++ parity: isSignificantlyAboveTerrain check (height > 9.0).
        const terrainY = this.resolveGroundHeight(entity.x, entity.z) + entity.baseHeight;
        const heightAbove = entity.y - terrainY;

        if (heightAbove <= 9.0) {
          // On ground: instant destroy with ground OCL (C++ line 157-169).
          // C++ calls destroyObject directly — does NOT go through SlowDeathBehavior.
          for (const oclName of jetProfile.oclOnGroundDeath) {
            this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
          }
          // Immediate destruction — C++ parity: TheGameLogic->destroyObject(us).
          entity.slowDeathState = null;
          this.markEntityDestroyed(entity.id, -1);
        } else {
          // Airborne: initialize jet slow death state (C++ beginSlowDeath lines 185-221).
          entity.jetSlowDeathState = {
            deathFrame: this.frameCounter,
            groundFrame: 0,
            rollRate: jetProfile.rollRate,
            rollAngle: 0,
            pitchAngle: 0,
            forwardSpeed: entity.currentSpeed > 0 ? entity.currentSpeed / LOGIC_FRAME_RATE : entity.speed / LOGIC_FRAME_RATE,
            forwardAngle: entity.rotationY,
            verticalVelocity: 0,
            secondaryExecuted: false,
            profileIndex: jpi,
          };

          // Execute initial death OCLs (C++ line 193-194).
          for (const oclName of jetProfile.oclInitialDeath) {
            this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
          }
        }
        break;
      }
    }

    return true;
  }

  /**
   * Source parity: DieMuxData::isDieApplicable — check if a slow death profile matches.
   */
  private isSlowDeathApplicable(entity: MapEntity, profile: SlowDeathProfile): boolean {
    return this.isDieModuleApplicable(entity, profile);
  }

  /**
   * Source parity: SlowDeathBehavior::doPhaseStuff — execute OCLs and weapons for a death phase.
   * @param phaseIndex 0=INITIAL, 1=MIDPOINT, 2=FINAL
   */
  private executeSlowDeathPhase(entity: MapEntity, profile: SlowDeathProfile, phaseIndex: number): void {
    // Execute ONE random OCL from this phase's list.
    const oclList = profile.phaseOCLs[phaseIndex as 0 | 1 | 2];
    if (oclList && oclList.length > 0) {
      const idx = oclList.length === 1 ? 0 : this.gameRandom.nextRange(0, oclList.length - 1);
      this.executeOCL(oclList[idx]!, entity);
    }

    // Fire ONE random weapon from this phase's list.
    const weaponList = profile.phaseWeapons[phaseIndex as 0 | 1 | 2];
    if (weaponList && weaponList.length > 0) {
      const idx = weaponList.length === 1 ? 0 : this.gameRandom.nextRange(0, weaponList.length - 1);
      const weaponName = weaponList[idx]!;
      const weaponDef = this.iniDataRegistry?.getWeapon(weaponName);
      if (weaponDef) {
        this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);
      }
    }
  }

  // ── StructureCollapseUpdate implementation ────────────────────────────────

  /**
   * Source parity: StructureCollapseUpdate::onDie — initiate building collapse sequence.
   * Checks DieMuxData, marks AI as dead, deselects, and begins the collapse.
   * Returns true if collapse was started (entity persists during collapse).
   */
  private tryBeginStructureCollapse(entity: MapEntity): boolean {
    const profile = entity.structureCollapseProfile;
    if (!profile) return false;
    if (!this.isDieModuleApplicable(entity, profile)) return false;

    // Source parity: StructureCollapseUpdate::onDie — AIUpdateInterface::markAsDead + deselect.
    // Prevent further combat, production, movement during collapse.
    entity.animationState = 'DIE';
    entity.canTakeDamage = false;
    entity.attackTargetEntityId = null;
    entity.attackTargetPosition = null;
    entity.attackOriginalVictimPosition = null;
    entity.attackCommandSource = 'AI';
    entity.attackSubState = 'IDLE';
    entity.moving = false;
    entity.moveTarget = null;
    entity.movePath = [];
    entity.pathIndex = 0;
    entity.pathfindGoalCell = null;
    entity.selected = false;

    // Unregister energy while collapsing.
    this.unregisterEntityEnergy(entity);
    this.cancelEntityCommandPathActions(entity.id);
    this.cancelAndRefundAllProductionOnDeath(entity);

    // Source parity: beginStructureCollapse — randomize collapse delay, fire INITIAL OCLs.
    const collapseFrame = this.frameCounter +
      (profile.minCollapseDelay >= profile.maxCollapseDelay
        ? profile.minCollapseDelay
        : this.gameRandom.nextRange(profile.minCollapseDelay, profile.maxCollapseDelay));

    entity.structureCollapseState = {
      state: 'WAITING',
      collapseFrame,
      burstFrame: 0,
      currentHeight: 0,
      collapseVelocity: 0,
    };

    // Execute INITIAL phase OCLs.
    this.executeStructureCollapsePhase(entity, profile, 0); // SCPHASE_INITIAL

    return true;
  }

  /**
   * Source parity: StructureCollapseUpdate::update — progress all active structure collapses.
   * Handles WAITING → COLLAPSING → DONE state transitions with gravity-based sinking.
   */
  private updateStructureCollapseEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (!entity.structureCollapseState || entity.destroyed) continue;
      const state = entity.structureCollapseState;
      const profile = entity.structureCollapseProfile;
      if (!profile) {
        this.markEntityDestroyed(entity.id, -1);
        continue;
      }

      if (state.state === 'WAITING') {
        // Source parity: dramatic pause — building shudders (visual-only in C++).
        // Transition to COLLAPSING when collapseFrame is reached.
        if (this.frameCounter >= state.collapseFrame) {
          state.state = 'COLLAPSING';
          // Execute BURST phase OCLs at transition.
          this.executeStructureCollapsePhase(entity, profile, 2); // SCPHASE_BURST
          // Schedule next burst.
          state.burstFrame = this.frameCounter +
            (profile.minBurstDelay >= profile.maxBurstDelay
              ? profile.minBurstDelay
              : this.gameRandom.nextRange(profile.minBurstDelay, profile.maxBurstDelay));
        }
      }

      if (state.state === 'COLLAPSING') {
        // Source parity: gravity-based collapse — velocity increases, height decreases.
        // C++ line 213-214: m_currentHeight -= m_collapseVelocity;
        //                    m_collapseVelocity -= m_gravity * (1.0 - collapseDamping);
        // With m_gravity = -1.0f: velocity += (1.0 - damping) per frame, height -= velocity.
        state.currentHeight -= state.collapseVelocity;
        state.collapseVelocity -= STRUCTURE_COLLAPSE_GRAVITY * (1.0 - profile.collapseDamping);

        // Source parity: periodic burst OCLs during collapse.
        if (this.frameCounter >= state.burstFrame) {
          if (profile.bigBurstFrequency > 0 &&
              this.gameRandom.nextRange(1, profile.bigBurstFrequency) === 1) {
            this.executeStructureCollapsePhase(entity, profile, 2); // SCPHASE_BURST
          } else {
            this.executeStructureCollapsePhase(entity, profile, 1); // SCPHASE_DELAY
          }
          // Schedule next burst.
          state.burstFrame += (profile.minBurstDelay >= profile.maxBurstDelay
            ? profile.minBurstDelay
            : this.gameRandom.nextRange(profile.minBurstDelay, profile.maxBurstDelay));
        }

        // Source parity: done when building has sunk below ground.
        // C++ line 241: if (currentHeight + templateGeometry.maxHeightAbovePosition <= 0)
        const structHeight = entity.obstacleGeometry?.height ?? 10;
        if (state.currentHeight + structHeight <= 0) {
          state.state = 'DONE';
          // Execute FINAL phase OCLs.
          this.executeStructureCollapsePhase(entity, profile, 3); // SCPHASE_FINAL
          // Source parity: in C++, building stays as rubble with POST_COLLAPSE model condition.
          // In our system, destroy the entity since we don't have permanent rubble rendering.
          entity.structureCollapseState = null;
          this.markEntityDestroyed(entity.id, -1);
        }
      }
    }
  }

  /**
   * Source parity: StructureCollapseUpdate::doPhaseStuff — execute OCLs for a collapse phase.
   * Unlike SlowDeath's single-OCL selection, StructureCollapse picks a non-duplicate random
   * subset of OCLs from the phase list. C++ uses buildNonDupRandomIndexList with count=1 default.
   * @param phaseIndex 0=INITIAL, 1=DELAY, 2=BURST, 3=FINAL
   */
  private executeStructureCollapsePhase(
    entity: MapEntity,
    profile: StructureCollapseProfile,
    phaseIndex: number,
  ): void {
    const oclList = profile.phaseOCLs[phaseIndex as 0 | 1 | 2 | 3];
    if (!oclList || oclList.length === 0) return;
    // Source parity: C++ defaults oclCount[phase] = 1 — execute one random OCL per phase.
    const idx = oclList.length === 1 ? 0 : this.gameRandom.nextRange(0, oclList.length - 1);
    this.executeOCL(oclList[idx]!, entity);
  }

  /**
   * Source parity: EMPUpdate::update — grow EMP pulse, fire disable attack at fade frame,
   * self-destruct at end of lifetime. C++ file: EMPUpdate.cpp.
   */
  private updateEmpEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.empUpdateProfile;
      if (!profile) continue;

      // Lazy-initialize runtime state on first update.
      if (!entity.empUpdateState) {
        entity.empUpdateState = {
          dieFrame: this.frameCounter + profile.lifetimeFrames,
          fadeFrame: this.frameCounter + profile.startFadeFrame,
          disableAttackFired: false,
        };
        // Source parity: random orientation at creation.
        entity.rotationY = this.gameRandom.nextFloat() * Math.PI * 2 - Math.PI;
      }

      const state = entity.empUpdateState;

      // Source parity: at fade frame, fire the disable attack once.
      if (!state.disableAttackFired && this.frameCounter >= state.fadeFrame) {
        state.disableAttackFired = true;
        this.doEmpDisableAttack(entity, profile);
      }

      // Source parity: at die frame, self-destruct the EMP pulse object.
      if (this.frameCounter >= state.dieFrame) {
        this.markEntityDestroyed(entity.id, -1);
      }
    }
  }

  /**
   * Source parity: EMPUpdate::doDisableAttack — scan nearby entities and apply DISABLED_EMP.
   * Filters: skip self, skip infantry (unless SPAWNS_ARE_THE_WEAPONS), skip EMP_HARDENED,
   * skip own buildings if doesNotAffectMyOwnBuildings, kill airborne aircraft.
   */
  private doEmpDisableAttack(empEntity: MapEntity, profile: EMPUpdateProfile): void {
    const radiusSq = profile.effectRadius * profile.effectRadius;

    for (const victim of this.spawnedEntities.values()) {
      if (victim.id === empEntity.id) continue;
      if (victim.destroyed || victim.slowDeathState || victim.structureCollapseState) continue;
      if (victim.health <= 0) continue;

      // Distance check (2D).
      const dx = victim.x - empEntity.x;
      const dz = victim.z - empEntity.z;
      if (dx * dx + dz * dz > radiusSq) continue;

      const kindOf = victim.kindOf;

      // Source parity: skip infantry (unless SPAWNS_ARE_THE_WEAPONS like Overlord).
      if (kindOf.has('INFANTRY') && !kindOf.has('SPAWNS_ARE_THE_WEAPONS')) continue;

      // Source parity: VictimRequiredKindOf / VictimForbiddenKindOf filtering.
      if (profile.victimRequiredKindOf.size > 0) {
        let hasRequired = false;
        for (const req of profile.victimRequiredKindOf) {
          if (kindOf.has(req)) { hasRequired = true; break; }
        }
        if (!hasRequired) continue;
      }
      if (profile.victimForbiddenKindOf.size > 0) {
        let hasForbidden = false;
        for (const forbid of profile.victimForbiddenKindOf) {
          if (kindOf.has(forbid)) { hasForbidden = true; break; }
        }
        if (hasForbidden) continue;
      }

      // Source parity: doesNotAffectMyOwnBuildings — skip own structures.
      if (profile.doesNotAffectMyOwnBuildings && kindOf.has('STRUCTURE')) {
        if (empEntity.side && victim.side === empEntity.side) continue;
      }

      // Source parity: skip non-faction structures (neutral buildings like tech buildings).
      if (kindOf.has('STRUCTURE') && !victim.side) continue;

      // Source parity: aircraft that are airborne → kill them (not just disable).
      // EMP_HARDENED only protects airborne aircraft from the kill effect (C++ line 264).
      if (kindOf.has('AIRCRAFT') && victim.objectStatusFlags.has('AIRBORNE_TARGET')) {
        if (kindOf.has('EMP_HARDENED')) continue;
        this.applyWeaponDamageAmount(null, victim, victim.maxHealth, 'UNRESISTABLE');
        continue;
      }

      // Apply DISABLED_EMP for the configured duration.
      if (profile.disabledDurationFrames > 0) {
        this.applyEmpDisable(victim, profile.disabledDurationFrames);
      }
    }
  }

  /**
   * Source parity: SmartBombTargetHomingUpdate::update — each frame, interpolate falling
   * object's XZ position toward its target while it remains significantly above terrain.
   * C++ file: SmartBombTargetHomingUpdate.cpp lines 76-111.
   */
  private updateSmartBombHoming(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.smartBombProfile;
      if (!profile) continue;
      const state = entity.smartBombState;
      if (!state || !state.targetReceived) continue;

      // Source parity: if not significantly above terrain, don't course-correct.
      const terrainY = this.resolveGroundHeight(entity.x, entity.z);
      if ((entity.y - entity.baseHeight - terrainY) <= SIGNIFICANTLY_ABOVE_TERRAIN_THRESHOLD) continue;

      // Source parity: blend current position toward target.
      const statusCoeff = Math.max(0, Math.min(1, profile.courseCorrectionScalar));
      const targetCoeff = 1.0 - statusCoeff;

      entity.x = state.targetX * targetCoeff + entity.x * statusCoeff;
      entity.z = state.targetZ * targetCoeff + entity.z * statusCoeff;
      // entity.y (vertical) is NOT modified — projectile continues natural descent.
    }
  }

  /**
   * Source parity: SmartBombTargetHomingUpdate::SetTargetPosition — sets the target
   * for a smart bomb entity to home toward.
   */
  setSmartBombTarget(entityId: number, targetX: number, targetZ: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || !entity.smartBombProfile) return;
    entity.smartBombState = {
      targetReceived: true,
      targetX,
      targetZ,
    };
  }

  /**
   * Source parity: DynamicGeometryInfoUpdate::update — per-frame geometry interpolation
   * with optional delay, transition, and reverse. C++ file: DynamicGeometryInfoUpdate.cpp lines 117-186.
   */
  private updateDynamicGeometry(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const profile = entity.dynamicGeometryProfile;
      if (!profile) continue;

      // Lazy-init runtime state.
      if (!entity.dynamicGeometryState) {
        entity.dynamicGeometryState = {
          delayCountdown: Math.max(profile.initialDelayFrames, 1),
          started: false,
          finished: false,
          timeActive: 0,
          initialHeight: profile.initialHeight,
          initialMajorRadius: profile.initialMajorRadius,
          initialMinorRadius: profile.initialMinorRadius,
          finalHeight: profile.finalHeight,
          finalMajorRadius: profile.finalMajorRadius,
          finalMinorRadius: profile.finalMinorRadius,
          reverseAtTransitionTime: profile.reverseAtTransitionTime,
        };
      }

      const state = entity.dynamicGeometryState;
      if (state.finished) continue;

      if (!state.started) {
        state.delayCountdown--;
        if (state.delayCountdown > 0) continue;
        state.started = true;
      }

      // Interpolate geometry based on ratio.
      const transitionTime = Math.max(profile.transitionTimeFrames, 1);
      const ratio = state.timeActive / transitionTime;

      const newHeight = state.initialHeight + (ratio * (state.finalHeight - state.initialHeight));
      const newMajor = state.initialMajorRadius + (ratio * (state.finalMajorRadius - state.initialMajorRadius));
      const newMinor = state.initialMinorRadius + (ratio * (state.finalMinorRadius - state.initialMinorRadius));

      // Apply new geometry to entity's obstacle geometry.
      // Source parity: C++ calls getGeometryInfo() unconditionally; skip if no geometry.
      if (!entity.obstacleGeometry) continue;
      entity.obstacleGeometry.height = newHeight;
      entity.obstacleGeometry.majorRadius = newMajor;
      entity.obstacleGeometry.minorRadius = newMinor;

      state.timeActive++;

      // Check if transition complete.
      if (state.timeActive > transitionTime) {
        if (state.reverseAtTransitionTime) {
          // Source parity: C++ reads from immutable data-> (profile) for the swap.
          state.timeActive = 0;
          state.reverseAtTransitionTime = false;
          state.initialHeight = profile.finalHeight;
          state.initialMajorRadius = profile.finalMajorRadius;
          state.initialMinorRadius = profile.finalMinorRadius;
          state.finalHeight = profile.initialHeight;
          state.finalMajorRadius = profile.initialMajorRadius;
          state.finalMinorRadius = profile.initialMinorRadius;
        } else {
          state.finished = true;
        }
      }
    }
  }

  /**
   * Source parity: FireOCLAfterWeaponCooldownUpdate::update — tracks weapon firing and
   * fires OCL when weapon stops after enough consecutive shots.
   * C++ file: FireOCLAfterWeaponCooldownUpdate.cpp lines 102-183.
   *
   * Simplified: uses entity.attackTargetEntityId presence and nextAttackFrame timing to
   * detect consecutive shots and firing cessation.
   */
  private updateFireOCLAfterCooldown(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.fireOCLAfterCooldownProfiles.length === 0) continue;

      // Lazy-init states to match profiles.
      if (entity.fireOCLAfterCooldownStates.length !== entity.fireOCLAfterCooldownProfiles.length) {
        entity.fireOCLAfterCooldownStates = entity.fireOCLAfterCooldownProfiles.map(() => ({
          valid: false,
          consecutiveShots: 0,
          startFrame: 0,
        }));
      }

      for (let i = 0; i < entity.fireOCLAfterCooldownProfiles.length; i++) {
        const profile = entity.fireOCLAfterCooldownProfiles[i]!;
        const state = entity.fireOCLAfterCooldownStates[i]!;

        // Track whether the entity is actively firing its weapon this frame.
        const isFiring = entity.attackTargetEntityId !== null && entity.nextAttackFrame > 0;

        if (isFiring) {
          // Entity is actively attacking — count shots via nextAttackFrame transitions.
          if (!state.valid) {
            // Just started firing.
            state.consecutiveShots = 1;
            state.startFrame = this.frameCounter;
          } else if (entity.nextAttackFrame === this.frameCounter) {
            // A new shot is firing this frame.
            state.consecutiveShots++;
          }
        } else if (state.valid && state.consecutiveShots >= profile.minShotsRequired) {
          // Entity stopped firing — fire OCL if enough shots.
          this.fireOCLAfterCooldown(entity, profile, state);
        }

        state.valid = isFiring;
      }
    }
  }

  /**
   * Source parity: FireOCLAfterWeaponCooldownUpdate::fireOCL — create OCL with
   * firing-duration-scaled lifetime.
   */
  private fireOCLAfterCooldown(
    entity: MapEntity,
    profile: FireOCLAfterWeaponCooldownProfile,
    state: FireOCLAfterWeaponCooldownState,
  ): void {
    // Source parity: FireOCLAfterWeaponCooldownUpdate::fireOCL — compute scaled lifetime
    // based on firing duration: seconds * oclLifetimePerSecond * 0.001, clamped to oclMaxFrames.
    const firingDurationFrames = this.frameCounter - state.startFrame;
    const firingSeconds = firingDurationFrames / LOGIC_FRAME_RATE;
    const scaledSeconds = firingSeconds * profile.oclLifetimePerSecond * 0.001;
    let oclFrames = Math.trunc(scaledSeconds * LOGIC_FRAME_RATE);
    // Source parity: C++ unconditionally clamps with MIN(oclFrames, m_oclMaxFrames).
    oclFrames = Math.min(oclFrames, profile.oclMaxFrames);

    this.executeOCL(profile.oclName, entity, oclFrames > 0 ? oclFrames : undefined);

    state.consecutiveShots = 0;
    state.startFrame = 0;
  }

  /**
   * Source parity: LeafletDropBehavior::update — delayed radius-based disable that only affects
   * enemy infantry and vehicles. C++ fires on first update after delay, then also fires on death.
   */
  private updateLeafletDropEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.leafletDropProfile;
      if (!profile) continue;

      // Lazy-initialize runtime state.
      if (!entity.leafletDropState) {
        entity.leafletDropState = {
          startFrame: this.frameCounter + profile.delayFrames,
          fired: false,
        };
      }

      const state = entity.leafletDropState;
      if (state.fired) continue;
      if (this.frameCounter < state.startFrame) continue;

      // Fire the disable attack.
      state.fired = true;
      this.doLeafletDisableAttack(entity, profile);
    }
  }

  /**
   * Source parity: LeafletDropBehavior::doDisableAttack — scan nearby enemy infantry+vehicles
   * and apply DISABLED_EMP for the configured duration.
   */
  private doLeafletDisableAttack(source: MapEntity, profile: LeafletDropProfile): void {
    const radiusSq = profile.affectRadius * profile.affectRadius;

    for (const victim of this.spawnedEntities.values()) {
      if (victim.id === source.id) continue;
      if (victim.destroyed || victim.slowDeathState || victim.structureCollapseState) continue;
      if (victim.health <= 0) continue;

      // Source parity: only INFANTRY or VEHICLE.
      if (!victim.kindOf.has('INFANTRY') && !victim.kindOf.has('VEHICLE')) continue;

      // Source parity: only ENEMIES.
      if (this.getTeamRelationship(source, victim) !== RELATIONSHIP_ENEMIES) continue;

      // Distance check.
      const dx = victim.x - source.x;
      const dz = victim.z - source.z;
      if (dx * dx + dz * dz > radiusSq) continue;

      if (profile.disabledDurationFrames > 0) {
        this.applyEmpDisable(victim, profile.disabledDurationFrames);
      }
    }
  }

  /**
   * Source parity: HijackerUpdate::update — per-frame position/veterancy sync for hijackers
   * hidden inside vehicles. Ejects hijacker when vehicle is destroyed.
   */
  private updateHijackerEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const state = entity.hijackerState;
      if (!state || !state.isInVehicle) continue;

      const vehicle = this.spawnedEntities.get(state.targetId);

      if (vehicle && !vehicle.destroyed) {
        // Vehicle alive — sync position and veterancy.
        entity.x = vehicle.x;
        entity.y = vehicle.y;
        entity.z = vehicle.z;
        state.ejectX = vehicle.x;
        state.ejectY = vehicle.y;
        state.ejectZ = vehicle.z;

        // Source parity: isSignificantlyAboveTerrain — height > 9.0 above terrain.
        const terrainY = this.mapHeightmap?.getInterpolatedHeight(vehicle.x, vehicle.z) ?? 0;
        state.wasTargetAirborne = (vehicle.y - terrainY) > 9.0;

        // Bidirectional veterancy sync (always use higher).
        const hijackerVet = entity.experienceState.currentLevel;
        const vehicleVet = vehicle.experienceState.currentLevel;
        if (hijackerVet !== vehicleVet) {
          const highestVet = Math.max(hijackerVet, vehicleVet);
          entity.experienceState.currentLevel = highestVet;
          vehicle.experienceState.currentLevel = highestVet;
        }
      } else {
        // Vehicle destroyed — eject hijacker.
        entity.x = state.ejectX;
        entity.y = state.ejectY;
        entity.z = state.ejectZ;
        entity.objectStatusFlags.delete('NO_COLLISIONS');
        entity.objectStatusFlags.delete('MASKED');
        entity.objectStatusFlags.delete('UNSELECTABLE');

        // Reset state.
        entity.hijackerState = null;

        // Cancel any stale movement targets.
        this.cancelEntityCommandPathActions(entity.id);
      }
    }
  }

  /**
   * Source parity: LifetimeUpdate::update — destroy entities when their lifetime expires.
   * C++ calls object->kill() which applies unresistable damage equal to maxHealth.
   */
  private updateLifetimeEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      if (entity.lifetimeDieFrame === null) continue;
      if (this.frameCounter < entity.lifetimeDieFrame) continue;
      // Source parity: kill() applies DAMAGE_UNRESISTABLE at maxHealth amount.
      // This triggers the normal death pipeline (SlowDeath, death OCLs, etc.).
      this.applyWeaponDamageAmount(null, entity, entity.maxHealth, 'UNRESISTABLE');
    }
  }

  /**
   * Source parity: SpyVisionSpecialPower — expire temporary fog-of-war reveals.
   * When a spy vision reveal expires, remove the looker from the fog grid.
   */
  private updateTemporaryVisionReveals(): void {
    const grid = this.fogOfWarGrid;
    if (!grid) return;
    for (let i = this.temporaryVisionReveals.length - 1; i >= 0; i--) {
      const reveal = this.temporaryVisionReveals[i]!;
      if (this.frameCounter >= reveal.expiryFrame) {
        grid.removeLooker(reveal.playerIndex, reveal.worldX, reveal.worldZ, reveal.radius);
        this.temporaryVisionReveals.splice(i, 1);
      }
    }
  }

  /**
   * Source parity: RadarUpdate::update — tracks the radar dish extension animation timer.
   * When the extension time elapses, marks the extension as complete.
   * Actual radar functionality is managed via player radarCount in the upgrade system.
   */
  private updateRadarExtension(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (!entity.radarUpdateProfile) continue;
      if (entity.radarExtendComplete) continue;
      if (entity.radarExtendDoneFrame === 0) continue;
      if (this.frameCounter > entity.radarExtendDoneFrame) {
        entity.radarExtendComplete = true;
        entity.radarExtendDoneFrame = 0;
      }
    }
  }

  /**
   * Source parity: PowerPlantUpdate::update — transitions UPGRADING → UPGRADED when timer expires.
   * C++ PowerPlantUpdate.cpp lines 111-121.
   */
  private updatePowerPlantUpdate(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const state = entity.powerPlantUpdateState;
      if (!state || state.upgradeFinishFrame === 0) continue;
      if (this.frameCounter >= state.upgradeFinishFrame) {
        entity.modelConditionFlags.delete('POWER_PLANT_UPGRADING');
        entity.modelConditionFlags.add('POWER_PLANT_UPGRADED');
        state.upgradeFinishFrame = 0;
      }
    }
  }

  /**
   * Source parity: DeletionUpdate::update — silently remove entities when their deletion
   * timer expires. Unlike LifetimeUpdate, this calls destroyObject (instant removal,
   * no death pipeline, no death OCLs, no score tracking).
   */
  private updateDeletionEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (entity.deletionDieFrame === null) continue;
      if (this.frameCounter < entity.deletionDieFrame) continue;
      // Source parity: destroyObject — instant silent removal (NOT kill).
      this.silentDestroyEntity(entity.id);
    }
  }

  /**
   * Source parity: HeightDieUpdate::update — kill entities that fall below
   * targetHeight above terrain. Used for aircraft crashing, projectile cleanup.
   * C++ checks object.z < terrainHeight + targetHeightAboveTerrain.
   */
  private updateHeightDieEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState) continue;
      const prof = entity.heightDieProfile;
      if (!prof) continue;

      // Source parity: skip if contained (inside transport).
      // C++ line 131: m_lastPosition is still updated while contained.
      if (this.isEntityContained(entity)) {
        entity.heightDieLastY = entity.y;
        continue;
      }

      // Source parity: InitialDelay — don't check until delay expires.
      if (entity.heightDieActiveFrame === 0) {
        entity.heightDieActiveFrame = this.frameCounter + prof.initialDelayFrames;
        entity.heightDieLastY = entity.y;
      }
      if (this.frameCounter < entity.heightDieActiveFrame) continue;

      // Source parity: HeightDieUpdate.cpp:144-154 — OnlyWhenMovingDown check.
      // If entity is not moving downward, skip the height-death check but NOT the lastY update.
      const currentY = entity.y;
      let directionOK = true;
      if (prof.onlyWhenMovingDown && currentY >= entity.heightDieLastY) {
        directionOK = false;
      }

      // Source parity: calculate height above terrain.
      const terrainY = this.resolveGroundHeight(entity.x, entity.z);
      let targetHeight = terrainY + prof.targetHeight;

      // Source parity: HeightDieUpdate.cpp:160-221 — TargetHeightIncludesStructures
      // raises targetHeight based on bridge layers and nearby STRUCTURE entities.
      if (prof.targetHeightIncludesStructures) {
        // TODO(C&C source parity): bridge/pathfind layer height checks (lines 160-169).
        // Scan nearby structures and raise target height above the tallest one.
        // C++ uses getBoundingCircleRadius(): SPHERE/CYLINDER=majorRadius, BOX=sqrt(major²+minor²).
        const geom = entity.obstacleGeometry;
        let scanRange: number;
        if (!geom) {
          scanRange = entity.baseHeight;
        } else if (geom.type === 'BOX') {
          scanRange = Math.sqrt(geom.majorRadius * geom.majorRadius + geom.minorRadius * geom.minorRadius);
        } else {
          scanRange = geom.majorRadius;
        }
        const scanRangeSqr = scanRange * scanRange;
        let tallestStructureHeight = 0;
        for (const candidate of this.spawnedEntities.values()) {
          if (candidate.id === entity.id || candidate.destroyed) continue;
          if (!candidate.kindOf.has('STRUCTURE')) continue;
          const dx = candidate.x - entity.x;
          const dz = candidate.z - entity.z;
          if (dx * dx + dz * dz > scanRangeSqr) continue;
          const structHeight = candidate.obstacleGeometry?.height ?? 0;
          if (structHeight > tallestStructureHeight) {
            tallestStructureHeight = structHeight;
          }
        }
        if (tallestStructureHeight > prof.targetHeight) {
          targetHeight = tallestStructureHeight + terrainY;
        }
      }

      // Source parity: C++ line 224 — death check gated on directionOK.
      if (directionOK) {
        // Source parity: C++ uses raw pos->z (entity.y), not adjusted by baseHeight.
        if (entity.y < targetHeight) {
          // Source parity: C++ line 229 — snap if configured, or if entity position is below terrain.
          // C++ compares pos->z (raw entity position) against terrainHeightAtPos (not minus baseHeight).
          if (prof.snapToGroundOnDeath || entity.y < terrainY) {
            entity.y = terrainY + entity.baseHeight;
          }
          // Source parity: kill via UNRESISTABLE damage (same as LifetimeUpdate).
          this.applyWeaponDamageAmount(null, entity, entity.maxHealth, 'UNRESISTABLE');
        }
      }

      // Source parity: C++ line 266 — always update lastPosition at end of update.
      entity.heightDieLastY = currentY;
    }
  }

  /**
   * Source parity: StickyBombUpdate::update — track sticky bomb positions and handle
   * target death. C++ file: StickyBombUpdate.cpp lines 166-216.
   */
  private updateStickyBombs(): void {
    for (const bomb of this.spawnedEntities.values()) {
      if (bomb.destroyed || !bomb.stickyBombProfile || bomb.stickyBombTargetId === 0) continue;

      const target = this.spawnedEntities.get(bomb.stickyBombTargetId);
      if (!target || target.destroyed) {
        // C++ parity: if target dies, destroy bomb silently (detonation handled
        // by checkAndDetonateBoobyTrap in the target's death path).
        this.silentDestroyEntity(bomb.id);
        continue;
      }

      // Track target position.
      if (target.kindOf.has('IMMOBILE')) {
        // Buildings: keep bomb at current XZ, ground level (for mine-clearing units).
        // Z is unchanged — stays where initially placed.
      } else {
        // Mobile targets: follow target position + offsetZ.
        bomb.x = target.x;
        bomb.z = target.z;
        // bomb.y would be target.y + offsetZ if we had vertical positioning.
      }
    }
  }

  /**
   * Source parity: StickyBombUpdate::detonate — fire geometry-scaled damage and kill bomb.
   * C++ file: StickyBombUpdate.cpp lines 231-286.
   * Called from checkAndDetonateBoobyTrap (target dies) or directly for remote detonation.
   * The actual damage is applied in executeStickyBombDetonationDamage, called from
   * markEntityDestroyed to handle both explicit detonation and LifetimeUpdate death.
   */
  private detonateStickyBomb(bombId: number): void {
    const bomb = this.spawnedEntities.get(bombId);
    if (!bomb || bomb.destroyed || !bomb.stickyBombProfile) return;

    // Kill the bomb — markEntityDestroyed will call executeStickyBombDetonationDamage.
    this.markEntityDestroyed(bomb.id, bomb.id);
  }

  /**
   * Execute sticky bomb geometry-scaled damage. Called from markEntityDestroyed
   * so it fires both when the bomb is explicitly detonated and when it dies from
   * LifetimeUpdate. C++ file: StickyBombUpdate.cpp lines 231-286.
   */
  private executeStickyBombDetonationDamage(bomb: MapEntity): void {
    const prof = bomb.stickyBombProfile;
    if (!prof || bomb.stickyBombTargetId === 0) return;

    const targetId = bomb.stickyBombTargetId;
    // Clear target ID before applying damage to prevent infinite recursion:
    // detonation damage may kill the target → target death → checkAndDetonateBoobyTrap
    // → would find this bomb again if targetId wasn't cleared.
    bomb.stickyBombTargetId = 0;

    const target = this.spawnedEntities.get(targetId);

    // Geometry-based damage: weapon damage radius scales with target bounding circle.
    if (prof.geometryBasedDamageWeaponName && target && !target.destroyed) {
      const weaponDef = this.iniDataRegistry?.getWeapon(prof.geometryBasedDamageWeaponName);
      if (weaponDef) {
        const primaryDamage = readNumericField(weaponDef.fields, ['PrimaryDamage']) ?? 0;
        const primaryDamageRadius = readNumericField(weaponDef.fields, ['PrimaryDamageRadius']) ?? 0;
        const damageType = readStringField(weaponDef.fields, ['DamageType'])?.toUpperCase() ?? 'EXPLOSION';
        const targetRadius = target.obstacleGeometry?.majorRadius ?? 0;
        const baseRadius = primaryDamageRadius + targetRadius;
        const radiusSq = baseRadius * baseRadius;

        for (const victim of this.spawnedEntities.values()) {
          if (victim.destroyed || !victim.canTakeDamage) continue;
          const dx = victim.x - target.x;
          const dz = victim.z - target.z;
          if (dx * dx + dz * dz <= radiusSq) {
            this.applyWeaponDamageAmount(bomb.id, victim, primaryDamage, damageType);
          }
        }
      }
    }

    // Clear BOOBY_TRAPPED status on the target.
    if (bomb.kindOf.has('BOOBY_TRAP') && target && !target.destroyed) {
      target.objectStatusFlags.delete('BOOBY_TRAPPED');
    }
  }

  /**
   * Source parity: Object::checkAndDetonateBoobyTrap — find and detonate sticky bombs
   * attached to a target entity. Called when target dies, enters container, etc.
   * C++ file: Object.cpp lines 934-975.
   */
  private checkAndDetonateBoobyTrap(targetId: number): void {
    const target = this.spawnedEntities.get(targetId);
    if (!target?.objectStatusFlags.has('BOOBY_TRAPPED')) return;

    for (const bomb of this.spawnedEntities.values()) {
      if (bomb.destroyed || !bomb.stickyBombProfile) continue;
      if (bomb.stickyBombTargetId !== targetId) continue;
      if (!bomb.kindOf.has('BOOBY_TRAP')) continue;

      // Source parity: C++ Object.cpp line 966 — "Friends don't touch friends' boobies."
      // Don't detonate if the dying target is now an ally of the bomb's owner (e.g., after defection).
      if (this.getTeamRelationshipBySides(bomb.side ?? '', target.side ?? '') === RELATIONSHIP_ALLIES) {
        continue;
      }

      this.detonateStickyBomb(bomb.id);
      break; // One detonation per call.
    }
  }

  /**
   * Source parity: TheGameLogic::destroyObject — silently remove an entity without
   * triggering the death pipeline. No visual events, EVA, XP, crates, death OCLs, etc.
   * Used by DeletionUpdate for transient objects (debris, particle emitters, trails).
   */
  private silentDestroyEntity(entityId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) return;

    // Still unregister energy and clean up references.
    this.unregisterEntityEnergy(entity);
    this.cancelEntityCommandPathActions(entityId);
    this.railedTransportStateByEntityId.delete(entityId);
    this.supplyWarehouseStates.delete(entityId);
    this.supplyTruckStates.delete(entityId);
    this.disableOverchargeForEntity(entity);
    this.sellingEntities.delete(entityId);
    this.disabledHackedStatusByEntityId.delete(entityId);
    this.disabledEmpStatusByEntityId.delete(entityId);
    this.battlePlanParalyzedUntilFrame.delete(entityId);

    // Clean up pending actions referencing this entity.
    for (const [sourceId, pendingAction] of this.pendingEnterObjectActions.entries()) {
      if (pendingAction.targetObjectId === entityId) {
        this.pendingEnterObjectActions.delete(sourceId);
      }
    }
    for (const [dockerId, pendingAction] of this.pendingRepairDockActions.entries()) {
      if (pendingAction.dockObjectId === entityId || dockerId === entityId) {
        this.pendingRepairDockActions.delete(dockerId);
      }
    }
    for (const [sourceId, targetBuildingId] of this.pendingGarrisonActions.entries()) {
      if (targetBuildingId === entityId) {
        this.pendingGarrisonActions.delete(sourceId);
      }
    }
    for (const [sourceId, targetTransportId] of this.pendingTransportActions.entries()) {
      if (targetTransportId === entityId) {
        this.pendingTransportActions.delete(sourceId);
      }
    }
    for (const [sourceId, targetTunnelId] of this.pendingTunnelActions.entries()) {
      if (targetTunnelId === entityId) {
        this.pendingTunnelActions.delete(sourceId);
      }
    }
    for (const [sourceId, pendingAction] of this.pendingCombatDropActions.entries()) {
      if (sourceId === entityId) {
        this.clearChinookCombatDropIgnoredObstacle(sourceId);
        this.pendingCombatDropActions.delete(sourceId);
        this.abortPendingChinookRappels(sourceId);
        this.clearPendingChinookCommands(sourceId);
        continue;
      }
      if (pendingAction.targetObjectId === entityId) {
        pendingAction.targetObjectId = null;
        this.clearChinookCombatDropIgnoredObstacle(sourceId);
      }
    }
    for (const [passengerId, pendingRappel] of this.pendingChinookRappels.entries()) {
      if (passengerId === entityId || pendingRappel.sourceEntityId === entityId) {
        this.pendingChinookRappels.delete(passengerId);
        continue;
      }
      if (pendingRappel.targetObjectId === entityId) {
        pendingRappel.targetObjectId = null;
      }
    }
    for (const [dozerId, targetBuildingId] of this.pendingConstructionActions.entries()) {
      if (targetBuildingId === entityId) {
        this.pendingConstructionActions.delete(dozerId);
      }
    }

    // Remove upgrades (cleans up side state like radar/power counts).
    const completedUpgradeNames = Array.from(entity.completedUpgrades.values());
    for (const completedUpgradeName of completedUpgradeNames) {
      this.removeEntityUpgrade(entity, completedUpgradeName);
    }

    // Mark as destroyed — no death animation, no dying renderable state.
    entity.destroyed = true;
    entity.moving = false;
    entity.moveTarget = null;
    entity.movePath = [];
    entity.pathIndex = 0;
    entity.pathfindGoalCell = null;
    entity.attackTargetEntityId = null;
    entity.attackTargetPosition = null;
    entity.attackOriginalVictimPosition = null;
    entity.attackCommandSource = 'AI';
    entity.attackSubState = 'IDLE';
    entity.lastAttackerEntityId = null;
    this.onObjectDestroyed(entityId);
  }

  /**
   * Source parity: SlowDeathBehavior::update — progress all active slow death sequences.
   * Handles sinking, midpoint phase, and final destruction timing.
   */
  private updateSlowDeathEntities(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (!entity.slowDeathState || entity.destroyed) continue;
      const state = entity.slowDeathState;
      const profile = entity.slowDeathProfiles[state.profileIndex];
      if (!profile) {
        // Profile missing — fall through to immediate destruction.
        this.markEntityDestroyed(entity.id, -1);
        continue;
      }

      // Source parity: sink the entity below terrain.
      if (profile.sinkRate > 0 && this.frameCounter >= state.sinkFrame) {
        entity.y -= profile.sinkRate;
        // Altitude check: destroy when sunk below threshold.
        if (entity.y <= profile.destructionAltitude) {
          this.executeSlowDeathPhase(entity, profile, 2); // FINAL
          entity.slowDeathState = null;
          this.markEntityDestroyed(entity.id, -1);
          continue;
        }
      }

      // Source parity: midpoint phase — execute once at the midpoint frame.
      if (!state.midpointExecuted && this.frameCounter >= state.midpointFrame) {
        this.executeSlowDeathPhase(entity, profile, 1); // MIDPOINT
        state.midpointExecuted = true;
      }

      // Source parity: destruction frame — execute final phase and destroy.
      // C++ parity: helicopter/jet slow death behaviors call base SlowDeathBehavior::update() for
      // FX/OCL phases but override the destruction timing with their own ground-hit + delay logic.
      // Skip the base timer destruction when these sub-behaviors are actively managing the death.
      if (this.frameCounter >= state.destructionFrame
        && !entity.helicopterSlowDeathState && !entity.jetSlowDeathState) {
        this.executeSlowDeathPhase(entity, profile, 2); // FINAL
        entity.slowDeathState = null;
        this.markEntityDestroyed(entity.id, -1);
        continue;
      }

      // Source parity: NeutronMissileSlowDeathBehavior::update — timed blast waves.
      // Runs after base SlowDeathBehavior logic, only while slow death is activated.
      const nmState = entity.neutronMissileSlowDeathState;
      const nmProfile = entity.neutronMissileSlowDeathProfile;
      if (nmState && nmProfile) {
        // Record activation frame on first tick (C++ m_activationFrame set once).
        if (nmState.activationFrame === 0) {
          nmState.activationFrame = this.frameCounter;
        }
        const elapsed = this.frameCounter - nmState.activationFrame;
        for (let bi = 0; bi < nmProfile.blasts.length; bi++) {
          const blast = nmProfile.blasts[bi]!;
          if (!blast.enabled) continue;
          // Fire damage blast if delay has elapsed.
          if (!nmState.completedBlasts[bi] && elapsed > blast.delay) {
            this.doNeutronMissileBlast(entity, blast);
            nmState.completedBlasts[bi] = true;
          }
          // Fire scorch blast (visual burned condition) if scorch delay has elapsed.
          if (!nmState.completedScorchBlasts[bi] && elapsed > blast.scorchDelay) {
            this.doNeutronMissileScorchBlast(entity, blast);
            nmState.completedScorchBlasts[bi] = true;
          }
        }
      }
    }
  }

  /**
   * Source parity: NeutronMissileSlowDeathBehavior::doBlast — fire a single blast wave.
   * Scans entities in outerRadius, applies damage with inner/outer falloff, and topples.
   */
  private doNeutronMissileBlast(missile: MapEntity, blast: NeutronMissileBlastInfo): void {
    if (blast.outerRadius <= 0) return;
    const outerSqr = blast.outerRadius * blast.outerRadius;
    for (const other of this.spawnedEntities.values()) {
      if (other.destroyed) continue;
      // Source parity: C++ iterateObjectsInRange(FROM_CENTER_2D) for range check.
      const dx = other.x - missile.x;
      const dz = other.z - missile.z;
      const distSqr2D = dx * dx + dz * dz;
      if (distSqr2D > outerSqr) continue;
      // Source parity: C++ uses forceVector.length() (3D) for damage falloff.
      const dy = other.y - missile.y;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      // Source parity: topple with NO_BOUNCE | NO_FX (simplified — our topple doesn't have options).
      if (blast.toppleSpeed > 0) {
        this.applyTopplingForce(other, dx, dz, blast.toppleSpeed);
      }

      // Source parity: damage falloff — full maxDamage inside innerRadius,
      // linear interpolation to minDamage at outerRadius.
      let damage: number;
      if (dist <= blast.innerRadius) {
        damage = blast.maxDamage;
      } else {
        const percent = 1.0 - ((dist - blast.innerRadius) / (blast.outerRadius - blast.innerRadius + 0.01));
        damage = blast.maxDamage * percent;
        if (damage < blast.minDamage) damage = blast.minDamage;
      }
      if (damage > 0) {
        this.applyWeaponDamageAmount(missile.id, other, damage, 'EXPLOSION', 'EXPLODED');
      }
    }
  }

  /**
   * Source parity: NeutronMissileSlowDeathBehavior::doScorchBlast — visual burning effect.
   * Scans entities in outerRadius and sets MODELCONDITION_BURNED (visual only in our port).
   */
  private doNeutronMissileScorchBlast(missile: MapEntity, blast: NeutronMissileBlastInfo): void {
    if (blast.outerRadius <= 0) return;
    const outerSqr = blast.outerRadius * blast.outerRadius;
    for (const other of this.spawnedEntities.values()) {
      if (other.destroyed) continue;
      // Source parity: C++ does NOT skip self — missile gets scorched too.
      const dx = other.x - missile.x;
      const dz = other.z - missile.z;
      if (dx * dx + dz * dz > outerSqr) continue;
      // Source parity: set MODELCONDITION_BURNED on affected entities.
      // In the original, this visually chars trees/structures.
      other.objectStatusFlags.add('BURNED');
    }
  }

  /**
   * Source parity: HelicopterSlowDeathBehavior::update — per-frame spiral orbit,
   * self-spin, gravity descent, ground hit detection, and final explosion.
   * C++ file: HelicopterSlowDeathUpdate.cpp lines 285-498.
   */
  private updateHelicopterSlowDeath(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const hs = entity.helicopterSlowDeathState;
      if (!hs) continue;

      // Look up the profile that was selected at init time.
      const profile = entity.helicopterSlowDeathProfiles[hs.profileIndex];
      if (!profile) continue;

      // ── Still airborne ──
      if (hs.hitGroundFrame === 0) {
        // Self-spin: rotate the entity body (visual rotation).
        entity.rotationY += hs.selfSpin * hs.orbitDirection;

        // Self-spin rate oscillation: ping-pong between minSelfSpin and maxSelfSpin.
        if (profile.selfSpinUpdateDelay > 0
          && this.frameCounter - hs.lastSelfSpinUpdateFrame > profile.selfSpinUpdateDelay) {
          const spinIncrement = profile.selfSpinUpdateAmount / LOGIC_FRAME_RATE;
          if (hs.selfSpinTowardsMax) {
            hs.selfSpin += spinIncrement;
            if (hs.selfSpin >= profile.maxSelfSpin) {
              hs.selfSpin = profile.maxSelfSpin;
              hs.selfSpinTowardsMax = false;
            }
          } else {
            hs.selfSpin -= spinIncrement;
            if (hs.selfSpin <= profile.minSelfSpin) {
              hs.selfSpin = profile.minSelfSpin;
              hs.selfSpinTowardsMax = true;
            }
          }
          hs.lastSelfSpinUpdateFrame = this.frameCounter;
        }

        // Forward motion along spiral orbit direction.
        entity.x += Math.cos(hs.forwardAngle) * hs.forwardSpeed;
        entity.z += Math.sin(hs.forwardAngle) * hs.forwardSpeed;

        // Turn the spiral orbit angle.
        hs.forwardAngle += profile.spiralOrbitTurnRate * hs.orbitDirection;

        // Damp forward speed.
        hs.forwardSpeed *= profile.spiralOrbitForwardSpeedDamping;

        // Gravity-based descent.
        // C++: locomotor maxLift = -gravity * (1 - fallHowFast).
        // Simplified: apply downward velocity proportional to fallHowFast.
        hs.verticalVelocity += HELICOPTER_GRAVITY * profile.fallHowFast;
        entity.y += hs.verticalVelocity;

        // Ground hit detection.
        const terrainY = this.resolveGroundHeight(entity.x, entity.z) + entity.baseHeight;
        if (entity.y <= terrainY + 1.0) {
          entity.y = terrainY;
          hs.hitGroundFrame = this.frameCounter;

          // Execute ground hit OCLs.
          for (const oclName of profile.oclHitGround) {
            this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
          }

          // C++ parity: copter->setDisabled(DISABLED_HELD) — freeze the entity on ground.
          entity.moving = false;
          entity.moveTarget = null;
          entity.movePath = [];
          entity.objectStatusFlags.add('DISABLED_HELD');
        }
      }

      // ── On the ground: wait for final explosion ──
      if (hs.hitGroundFrame > 0
        && this.frameCounter - hs.hitGroundFrame > profile.delayFromGroundToFinalDeath) {
        // Execute final explosion OCLs.
        for (const oclName of profile.oclFinalBlowUp) {
          this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
        }

        // Spawn rubble object.
        if (profile.finalRubbleObject) {
          this.spawnEntityFromTemplate(
            profile.finalRubbleObject, entity.x, entity.z, entity.rotationY, entity.side);
        }

        // Destroy the helicopter.
        entity.helicopterSlowDeathState = null;
        entity.slowDeathState = null;
        this.markEntityDestroyed(entity.id, -1);
      }
    }
  }

  /**
   * Source parity: JetSlowDeathBehavior::update — jet crash with roll, forward motion,
   * multi-stage FX timeline. C++ file: JetSlowDeathBehavior.cpp lines 226-310.
   */
  private updateJetSlowDeath(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const js = entity.jetSlowDeathState;
      if (!js) continue;

      const profile = entity.jetSlowDeathProfiles[js.profileIndex];
      if (!profile) continue;

      // C++ parity: roll rate application and decay happen unconditionally (outside if/else).
      // Roll continues even after ground impact, creating a tumbling effect.
      js.rollAngle += js.rollRate;
      js.rollRate *= profile.rollRateDelta;

      // ── Still airborne ──
      if (js.groundFrame === 0) {
        // Forward motion: jet keeps flying in the direction it was headed at death.
        entity.x += Math.cos(js.forwardAngle) * js.forwardSpeed;
        entity.z += Math.sin(js.forwardAngle) * js.forwardSpeed;

        // Gravity descent (C++ setMaxLift(-gravity * (1 - fallHowFast))).
        // fallHowFast=1 → full fall, fallHowFast=0 → slow fall.
        js.verticalVelocity += HELICOPTER_GRAVITY * profile.fallHowFast;
        entity.y += js.verticalVelocity;

        // Secondary OCL timer (C++ line 292-301). Delay of 0 fires on first frame.
        if (!js.secondaryExecuted
          && this.frameCounter - js.deathFrame >= profile.delaySecondaryFromInitialDeath) {
          for (const oclName of profile.oclSecondary) {
            this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
          }
          js.secondaryExecuted = true;
        }

        // Ground hit detection.
        const terrainY = this.resolveGroundHeight(entity.x, entity.z) + entity.baseHeight;
        if (entity.y <= terrainY + 1.0) {
          entity.y = terrainY;
          js.groundFrame = this.frameCounter;

          // Execute ground hit OCLs (C++ line 276-277).
          for (const oclName of profile.oclHitGround) {
            this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
          }

          // C++ parity: freeze the entity on ground (DISABLED_HELD).
          entity.moving = false;
          entity.moveTarget = null;
          entity.movePath = [];
          entity.objectStatusFlags.add('DISABLED_HELD');
        }
      } else {
        // ── On the ground: wait for final explosion (C++ if/else with airborne) ──
        // Apply pitch rotation after ground impact (C++ physics->setPitchRate).
        js.pitchAngle += profile.pitchRate;

        if (this.frameCounter - js.groundFrame >= profile.delayFinalBlowUpFromHitGround) {
          // Execute final explosion OCLs (C++ line 306-307).
          for (const oclName of profile.oclFinalBlowUp) {
            this.executeOCL(oclName, entity, undefined, entity.x, entity.z);
          }

          // Destroy the jet.
          entity.jetSlowDeathState = null;
          entity.slowDeathState = null;
          this.markEntityDestroyed(entity.id, -1);
        }
      }
    }
  }

  /**
   * Source parity: CleanupHazardUpdate::update — passive scan for CLEANUP_HAZARD entities
   * and auto-attack them. C++ file: CleanupHazardUpdate.cpp lines 131-293.
   */
  private updateCleanupHazard(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || !entity.cleanupHazardProfile) continue;
      const profile = entity.cleanupHazardProfile;

      // Initialize state on first tick.
      if (!entity.cleanupHazardState) {
        entity.cleanupHazardState = {
          bestTargetId: 0,
          nextScanFrame: 0,
          inRange: false,
          nextShotAvailableFrame: 0,
        };
      }
      const state = entity.cleanupHazardState;

      // Skip if entity is busy with a player-issued command.
      if (entity.attackTargetEntityId !== null && entity.attackCommandSource === 'PLAYER') continue;

      // Countdown between scans.
      if (state.nextScanFrame > 0) {
        state.nextScanFrame--;
        // Try to fire at existing target while waiting.
        this.cleanupHazardFireWhenReady(entity, profile, state);
        continue;
      }
      state.nextScanFrame = profile.scanFrames;

      // Scan for closest CLEANUP_HAZARD entity within range.
      const target = this.scanCleanupHazardTarget(entity, profile);
      if (target) {
        state.bestTargetId = target.id;
        this.cleanupHazardFireWhenReady(entity, profile, state);
      } else {
        state.bestTargetId = 0;
      }
    }
  }

  /**
   * Source parity: CleanupHazardUpdate::scanClosestTarget — find the nearest CLEANUP_HAZARD
   * entity within scan range.
   */
  private scanCleanupHazardTarget(entity: MapEntity, profile: CleanupHazardProfile): MapEntity | null {
    let bestTarget: MapEntity | null = null;
    let bestDistSq = profile.scanRange * profile.scanRange;

    for (const candidate of this.spawnedEntities.values()) {
      if (candidate.destroyed || candidate.id === entity.id) continue;
      const kindOf = this.resolveEntityKindOfSet(candidate);
      if (!kindOf.has('CLEANUP_HAZARD')) continue;
      const dx = candidate.x - entity.x;
      const dz = candidate.z - entity.z;
      const distSq = dx * dx + dz * dz;
      if (distSq < bestDistSq) {
        bestDistSq = distSq;
        bestTarget = candidate;
      }
    }
    return bestTarget;
  }

  /**
   * Source parity: CleanupHazardUpdate::fireWhenReady — attack the tracked target if idle.
   */
  private cleanupHazardFireWhenReady(
    entity: MapEntity,
    profile: CleanupHazardProfile,
    state: CleanupHazardState,
  ): void {
    if (state.bestTargetId === 0) return;
    const target = this.spawnedEntities.get(state.bestTargetId);
    if (!target || target.destroyed) {
      state.bestTargetId = 0;
      state.inRange = false;
      return;
    }

    // Range check — use active weapon's attack range.
    const fireRange = entity.attackWeapon?.attackRange ?? profile.scanRange;
    const dx = target.x - entity.x;
    const dz = target.z - entity.z;
    const dist = Math.sqrt(dx * dx + dz * dz);

    if (dist < fireRange) {
      state.inRange = true;
    } else if (state.inRange) {
      // Was in range but target moved out — rescan.
      state.nextScanFrame = 0;
      state.bestTargetId = 0;
      state.inRange = false;
      return;
    }

    // C++ parity: m_nextShotAvailableInFrames cooldown check (line 241-246).
    if (state.nextShotAvailableFrame > this.frameCounter) return;

    // Fire if entity is idle (not already attacking something from player) and in range.
    if (state.inRange && (entity.attackTargetEntityId === null || entity.attackCommandSource === 'AI')) {
      // Source parity: CleanupHazardUpdate bypasses normal enemy relationship checks.
      // Directly apply weapon damage to the CLEANUP_HAZARD entity.
      const weapon = entity.attackWeapon;
      if (weapon && weapon.primaryDamage > 0) {
        this.applyWeaponDamageAmount(entity.id, target, weapon.primaryDamage, weapon.damageType);
        // C++ parity: apply weapon's DelayBetweenShots as per-shot cooldown.
        state.nextShotAvailableFrame = this.frameCounter + Math.max(1, weapon.minDelayFrames);
      }
    }
  }

  /**
   * Source parity: AssistedTargetingUpdate::isFreeToAssist — check if entity can accept
   * an assisted attack request. Returns true if the entity has an AssistedTargetingProfile
   * and is able to attack (weapon ready).
   * C++ file: AssistedTargetingUpdate.cpp lines 85-94.
   */
  isEntityFreeToAssist(entity: MapEntity): boolean {
    if (!entity.assistedTargetingProfile) return false;
    if (entity.destroyed) return false;
    if (!entity.attackWeapon) return false;
    // Source parity: checks isAbleToAttack() and weapon status READY_TO_FIRE.
    if (entity.attackCooldownRemaining > 0) return false;
    return true;
  }

  /**
   * Source parity: AssistedTargetingUpdate::assistAttack — an external unit tells this
   * entity to attack a target. Locks the assisted weapon slot and issues attack command.
   * C++ file: AssistedTargetingUpdate.cpp lines 98-114.
   */
  issueAssistedAttack(
    assistedEntityId: number,
    targetEntityId: number,
  ): void {
    const entity = this.spawnedEntities.get(assistedEntityId);
    const target = this.spawnedEntities.get(targetEntityId);
    if (!entity || !target) return;
    if (!entity.assistedTargetingProfile) return;
    if (entity.destroyed || target.destroyed) return;

    // Source parity: lock weapon and issue attack with clip limit.
    this.issueAttackEntity(entity.id, target.id, 'AI');
  }

  private markEntityDestroyed(entityId: number, attackerId: number): void {
    const entity = this.spawnedEntities.get(entityId);
    if (!entity || entity.destroyed) {
      return;
    }

    // Source parity: Object::m_hasDiedAlready — prevent re-entrant death pipeline.
    // Death effects (sticky bomb detonation, InstantDeathBehavior weapons) can kill other
    // entities, which may cascade back. Guard against processing the same entity twice.
    if (this.dyingEntityIds.has(entityId)) {
      return;
    }
    this.dyingEntityIds.add(entityId);

    // Source parity: TechBuildingBehavior::onDie — revert to neutral team instead of destroying.
    // C++ sets team to ThePlayerList->getNeutralPlayer()->getDefaultTeam() and clears MODELCONDITION_CAPTURED.
    // C++ does NOT restore health, but our engine would re-trigger death at 0 HP, so we restore to maxHealth.
    if (entity.techBuildingProfile) {
      this.dyingEntityIds.delete(entityId);
      // Unregister energy from current side.
      this.unregisterEntityEnergy(entity);
      // Revert to civilian/neutral side.
      entity.side = 'civilian';
      entity.controllingPlayerToken = this.normalizeControllingPlayerToken('civilian');
      // Restore full health to prevent re-death loop (pragmatic deviation from C++).
      entity.health = entity.maxHealth;
      return;
    }

    // Source parity: Object::onDie calls checkAndDetonateBoobyTrap before die modules.
    // C++ file: Object.cpp line 4575.
    this.checkAndDetonateBoobyTrap(entityId);

    // Source parity: StickyBombUpdate die module — if this entity IS a sticky bomb,
    // execute its detonation damage before the bomb is marked destroyed.
    // In C++, a die module calls StickyBombUpdate::detonate() on bomb death.
    if (entity.stickyBombProfile && entity.stickyBombTargetId !== 0) {
      this.executeStickyBombDetonationDamage(entity);
    }

    // Emit entity destroyed visual event.
    this.visualEventBuffer.push({
      type: 'ENTITY_DESTROYED',
      x: entity.x,
      y: entity.y,
      z: entity.z,
      radius: entity.category === 'building' ? 8 : 3,
      sourceEntityId: entityId,
      projectileType: 'BULLET',
    });

    // Source parity: EVA — announce building/unit loss.
    if (entity.side) {
      if (entity.kindOf.has('STRUCTURE') && entity.kindOf.has('MP_COUNT_FOR_VICTORY')) {
        this.emitEvaEvent('BUILDING_LOST', entity.side, 'own', entityId);
      } else if (entity.category === 'infantry' || entity.category === 'vehicle') {
        this.emitEvaEvent('UNIT_LOST', entity.side, 'own', entityId);
      }
    }

    // Unregister energy contribution before destruction.
    this.unregisterEntityEnergy(entity);

    // Source parity: award XP to killer on victim death.
    this.awardExperienceOnKill(entityId, attackerId);

    // Source parity: Player::addCashBounty — if the killer's player has cash bounty active,
    // award a percentage of the victim's build cost as credits.
    this.awardCashBountyOnKill(entity, attackerId);

    // Source parity: RebuildHoleExposeDie::onDie — create rebuild hole on building death.
    this.tryCreateRebuildHoleOnDeath(entity, attackerId);

    // Source parity: EjectPilotDie — eject pilot unit for VETERAN+ vehicles on death.
    this.tryEjectPilotOnDeath(entity);

    // Source parity: GenerateMinefieldBehavior::onDie — spawn mines on death.
    this.tryGenerateMinefieldOnDeath(entity);

    // Source parity: CreateObjectDie / SlowDeathBehavior — execute death OCLs.
    this.executeDeathOCLs(entity);

    // Source parity: InstantDeathBehavior::onDie — fire matching die module effects.
    this.executeInstantDeathModules(entity);

    // Source parity: FireWeaponWhenDeadBehavior::onDie — fire weapon on death with upgrade control.
    this.executeFireWeaponWhenDeadModules(entity);

    // Source parity: NeutronBlastBehavior::onDie — radius neutron blast on death.
    this.executeNeutronBlast(entity);

    // Source parity: BunkerBusterBehavior::onDie — kill garrisoned units in victim building.
    this.executeBunkerBuster(entity);

    // Source parity: FXListDie::onDie — trigger death FX for matching profiles.
    this.executeFXListDieModules(entity);

    // Source parity: CrushDie::onDie — set FRONTCRUSHED/BACKCRUSHED model conditions.
    this.executeCrushDie(entity, attackerId);

    // Source parity: DamDie::onDie — enable all WAVEGUIDE objects for flood wave.
    this.executeDamDieModules(entity);

    // Source parity: SpecialPowerCompletionDie::onDie — notify script engine of completion.
    this.executeSpecialPowerCompletionDieModules(entity);

    // Source parity: UpgradeDie::onDie — remove upgrade from producer on death.
    this.executeUpgradeDieModules(entity);

    // Source parity: CreateCrateDie::onDie — spawn salvage crate on death.
    this.trySpawnCrateOnDeath(entity, attackerId);

    // Source parity: SpawnBehavior::onDie — handle slaver death (orphan/kill slaves).
    this.onSlaverDeath(entity);
    // Source parity: Object::onDie → SpawnBehavior::onSpawnDeath — notify slaver of slave death.
    this.onSlaveDeath(entity);

    // Source parity: RebuildHoleBehavior::onDie — if a hole dies, destroy its worker.
    if (entity.rebuildHoleProfile && entity.rebuildHoleWorkerEntityId !== 0) {
      const worker = this.spawnedEntities.get(entity.rebuildHoleWorkerEntityId);
      if (worker && !worker.destroyed) {
        this.markEntityDestroyed(worker.id, -1);
      }
      entity.rebuildHoleWorkerEntityId = 0;
    }

    this.cancelEntityCommandPathActions(entityId);
    this.railedTransportStateByEntityId.delete(entityId);
    this.supplyWarehouseStates.delete(entityId);
    this.supplyTruckStates.delete(entityId);
    this.disableOverchargeForEntity(entity);
    this.sellingEntities.delete(entityId);
    this.disabledHackedStatusByEntityId.delete(entityId);
    this.disabledEmpStatusByEntityId.delete(entityId);
    this.battlePlanParalyzedUntilFrame.delete(entityId);
    // Source parity: if a Strategy Center is destroyed while a battle plan is active,
    // remove its bonuses from all entities on the side.
    if (entity.battlePlanState?.activePlan !== 'NONE' && entity.battlePlanState?.transitionStatus === 'ACTIVE') {
      this.applyBattlePlanBonuses(entity, entity.battlePlanState.activePlan, false);
    }
    for (const [sourceId, pendingAction] of this.pendingEnterObjectActions.entries()) {
      if (pendingAction.targetObjectId === entityId) {
        this.pendingEnterObjectActions.delete(sourceId);
      }
    }
    for (const [dockerId, pendingAction] of this.pendingRepairDockActions.entries()) {
      if (pendingAction.dockObjectId === entityId || dockerId === entityId) {
        this.pendingRepairDockActions.delete(dockerId);
      }
    }
    for (const [sourceId, targetBuildingId] of this.pendingGarrisonActions.entries()) {
      if (targetBuildingId === entityId) {
        this.pendingGarrisonActions.delete(sourceId);
      }
    }
    for (const [sourceId, targetTransportId] of this.pendingTransportActions.entries()) {
      if (targetTransportId === entityId) {
        this.pendingTransportActions.delete(sourceId);
      }
    }
    for (const [sourceId, targetTunnelId] of this.pendingTunnelActions.entries()) {
      if (targetTunnelId === entityId) {
        this.pendingTunnelActions.delete(sourceId);
      }
    }
    for (const [sourceId, pendingAction] of this.pendingCombatDropActions.entries()) {
      if (sourceId === entityId) {
        this.clearChinookCombatDropIgnoredObstacle(sourceId);
        this.pendingCombatDropActions.delete(sourceId);
        this.abortPendingChinookRappels(sourceId);
        this.clearPendingChinookCommands(sourceId);
        continue;
      }
      if (pendingAction.targetObjectId === entityId) {
        pendingAction.targetObjectId = null;
        this.clearChinookCombatDropIgnoredObstacle(sourceId);
      }
    }
    for (const [passengerId, pendingRappel] of this.pendingChinookRappels.entries()) {
      if (passengerId === entityId || pendingRappel.sourceEntityId === entityId) {
        this.pendingChinookRappels.delete(passengerId);
        continue;
      }
      if (pendingRappel.targetObjectId === entityId) {
        pendingRappel.targetObjectId = null;
      }
    }
    // Clear dozer construction tasks targeting this building.
    for (const [dozerId, targetBuildingId] of this.pendingConstructionActions.entries()) {
      if (targetBuildingId === entityId) {
        this.pendingConstructionActions.delete(dozerId);
      }
    }

    // Source parity: TunnelTracker::onTunnelDestroyed — cave-in if last tunnel.
    if (entity.containProfile?.moduleType === 'TUNNEL') {
      this.handleTunnelDestroyed(entity);
    }

    // Source parity: OpenContain::onDie — apply damage to contained units before releasing (C++ line 862-866).
    // processDamageToContained: percentDamage * maxHealth as UNRESISTABLE, deathType BURNED or NORMAL.
    if (entity.containProfile && entity.containProfile.moduleType !== 'TUNNEL'
        && entity.containProfile.damagePercentToUnits > 0) {
      this.processDamageToContained(entity);
    }

    // Source parity: Contain::onDie — release contained entities on container death.
    // Garrison, transport, helix, and overlord passengers are ejected at the container position.
    if (entity.containProfile && entity.containProfile.moduleType !== 'TUNNEL') {
      const passengerIds = this.collectContainedEntityIds(entityId);
      for (const passengerId of passengerIds) {
        const passenger = this.spawnedEntities.get(passengerId);
        if (passenger && !passenger.destroyed) {
          this.releaseEntityFromContainer(passenger);
        }
      }
    }

    const completedUpgradeNames = Array.from(entity.completedUpgrades.values());
    for (const completedUpgradeName of completedUpgradeNames) {
      this.removeEntityUpgrade(entity, completedUpgradeName);
    }
    this.cancelAndRefundAllProductionOnDeath(entity);
    entity.animationState = 'DIE';
    // Source parity: upgrade modules clean up side state via removeEntityUpgrade/onDelete parity.
    entity.destroyed = true;
    this.dyingEntityIds.delete(entityId);
    entity.moving = false;
    entity.moveTarget = null;
    entity.movePath = [];
    entity.pathIndex = 0;
    entity.pathfindGoalCell = null;
    entity.attackTargetEntityId = null;
    entity.attackTargetPosition = null;
    entity.attackOriginalVictimPosition = null;
    entity.attackCommandSource = 'AI';
    entity.attackSubState = 'IDLE';
    entity.leechRangeActive = false;
    entity.lastAttackerEntityId = null;
    entity.continuousFireState = 'NONE';
    entity.continuousFireCooldownFrame = 0;
    entity.objectStatusFlags.delete('CONTINUOUS_FIRE_SLOW');
    entity.objectStatusFlags.delete('CONTINUOUS_FIRE_MEAN');
    entity.objectStatusFlags.delete('CONTINUOUS_FIRE_FAST');
    this.pendingDyingRenderableStates.set(entityId, {
      state: this.makeRenderableEntityState(entity),
      expireFrame: this.frameCounter + 1,
    });
    this.onObjectDestroyed(entityId);
  }

  /**
   * Source parity: EjectPilotDie — eject a pilot unit when VETERAN+ vehicle is destroyed.
   * Only vehicle/air categories with the ejectPilotTemplateName set will eject.
   * The pilot inherits the vehicle's veterancy level.
   */
  private tryEjectPilotOnDeath(entity: MapEntity): void {
    if (!entity.ejectPilotTemplateName) return;
    if (entity.category !== 'vehicle' && entity.category !== 'air') return;

    // Source parity: Only VETERAN or higher eject a pilot.
    const vetLevel = entity.experienceState.currentLevel;
    if (vetLevel < entity.ejectPilotMinVeterancy) return;

    // Try to resolve the pilot unit template. The ejectPilotTemplateName
    // may be an OCL name rather than a direct unit template. Try to find
    // a matching infantry template first, falling back to a side-specific pilot.
    const registry = this.iniDataRegistry;
    if (!registry) return;

    // Convention: look for the OCL name as an object template first.
    // If not found, try side-prefixed variants (e.g., AmericaPilot, ChinaPilot).
    let pilotTemplateName = entity.ejectPilotTemplateName;
    let pilotDef = findObjectDefByName(registry, pilotTemplateName);
    if (!pilotDef && entity.side) {
      // Try conventional pilot name: <Side>Pilot (e.g., AmericaPilot)
      const sidePilot = entity.side + 'Pilot';
      pilotDef = findObjectDefByName(registry, sidePilot);
      if (pilotDef) pilotTemplateName = sidePilot;
    }
    if (!pilotDef) {
      // Try generic Pilot template
      pilotDef = findObjectDefByName(registry, 'Pilot');
      if (pilotDef) pilotTemplateName = 'Pilot';
    }
    if (!pilotDef) return;

    // Spawn the pilot at the vehicle's position.
    const pilotEntity = this.spawnEntityFromTemplate(
      pilotTemplateName,
      entity.x,
      entity.z,
      entity.rotationY,
      entity.side,
    );
    if (!pilotEntity) return;

    // Inherit veterancy.
    if (pilotEntity.experienceProfile) {
      pilotEntity.experienceState.currentLevel = vetLevel;
    }
  }

  /**
   * Source parity: CreateObjectDie / SlowDeathBehavior — extract death OCL entries from INI.
   * Scans modules for CreationList, GroundCreationList, or OCL fields that reference
   * ObjectCreationList definitions. Each entry includes DieMuxData fields for filtering.
   * C++ file: CreateObjectDie.cpp + DieModule.cpp (DieMuxData).
   */
  /**
   * Source parity: KeepObjectDie — check if object has a KeepObjectDie module.
   * When present, the object persists as wreckage after death instead of being removed.
   */
  private hasKeepObjectDie(objectDef: ObjectDef | undefined): boolean {
    if (!objectDef) return false;
    for (const block of objectDef.blocks) {
      if (block.type.toUpperCase() === 'BEHAVIOR') {
        const moduleName = block.name.split(/\s+/)[0]?.toUpperCase() ?? '';
        if (moduleName === 'KEEPOBJECTDIE') return true;
      }
    }
    return false;
  }

  private extractDeathOCLEntries(objectDef: ObjectDef | undefined): DeathOCLEntry[] {
    if (!objectDef) return [];
    const entries: DeathOCLEntry[] = [];
    const moduleBlocks = objectDef.blocks ?? [];
    for (const block of moduleBlocks) {
      const blockType = block.type.toUpperCase();
      if (blockType !== 'DIE' && blockType !== 'BEHAVIOR') continue;
      const moduleType = block.name.split(/\s+/)[0] ?? '';
      const upperModuleType = moduleType.toUpperCase();
      // CreateObjectDie, SlowDeathBehavior
      if (upperModuleType.includes('CREATEOBJECTDIE') || upperModuleType.includes('SLOWDEATH')) {
        // Parse DieMuxData fields.
        const deathTypes = new Set<string>();
        const deathTypesStr = readStringField(block.fields, ['DeathTypes']);
        if (deathTypesStr) {
          for (const token of deathTypesStr.toUpperCase().split(/\s+/)) {
            if (token) deathTypes.add(token);
          }
        }
        const veterancyLevels = new Set<string>();
        const vetStr = readStringField(block.fields, ['VeterancyLevels']);
        if (vetStr) {
          for (const token of vetStr.toUpperCase().split(/\s+/)) {
            if (token) veterancyLevels.add(token);
          }
        }
        const exemptStatus = new Set<string>();
        const exemptStr = readStringField(block.fields, ['ExemptStatus']);
        if (exemptStr) {
          for (const token of exemptStr.toUpperCase().split(/\s+/)) {
            if (token) exemptStatus.add(token);
          }
        }
        const requiredStatus = new Set<string>();
        const reqStr = readStringField(block.fields, ['RequiredStatus']);
        if (reqStr) {
          for (const token of reqStr.toUpperCase().split(/\s+/)) {
            if (token) requiredStatus.add(token);
          }
        }

        const oclName = readStringField(block.fields, [
          'CreationList', 'GroundCreationList', 'AirCreationList',
        ]);
        if (oclName) {
          entries.push({
            oclName: oclName.trim(),
            deathTypes, veterancyLevels, exemptStatus, requiredStatus,
          });
        }
        // SlowDeathBehavior can have OCL fields with phase names.
        // e.g., "OCL INITIAL OCLDestroyDebris"
        const oclFieldRaw = readStringField(block.fields, ['OCL']);
        if (oclFieldRaw) {
          const parts = oclFieldRaw.trim().split(/\s+/);
          const oclPart = parts.length > 1 ? parts[parts.length - 1]! : parts[0]!;
          if (oclPart) {
            entries.push({
              oclName: oclPart,
              deathTypes, veterancyLevels, exemptStatus, requiredStatus,
            });
          }
        }
      }
    }
    return entries;
  }

  /**
   * Source parity: ObjectCreationList::create — execute an OCL by name.
   * Resolves CreateObject nuggets and spawns entities.
   */
  private executeOCL(
    oclName: string,
    sourceEntity: MapEntity,
    lifetimeOverrideFrames?: number,
    targetX?: number,
    targetZ?: number,
  ): void {
    const registry = this.iniDataRegistry;
    if (!registry) return;
    const oclDef = registry.getObjectCreationList(oclName);
    if (!oclDef) return;

    for (const nugget of oclDef.blocks) {
      // OCL nuggets use block.type for the nugget kind (e.g., 'CreateObject', 'CreateDebris').
      // If type is empty, fall back to the first token of name.
      const nuggetType = (nugget.type || nugget.name.split(/\s+/)[0] || '').toUpperCase();
      if (nuggetType === 'CREATEOBJECT' || nuggetType === 'CREATEDEBRIS') {
        this.executeCreateObjectNugget(nugget, sourceEntity, lifetimeOverrideFrames);
      } else if (nuggetType === 'FIREWEAPON') {
        // Source parity: FireWeaponNugget::create — fires weapon at secondary (target) position.
        // C++ calls TheWeaponStore->createAndFireTempWeapon(m_weapon, primaryObj, secondary).
        this.executeFireWeaponNugget(nugget, sourceEntity, targetX, targetZ);
      }
      // DeliverPayload, Attack, ApplyRandomForce are omitted for now.
    }
  }

  /**
   * Source parity: GenericObjectCreationNugget::reallyCreate — spawn objects from an OCL nugget.
   */
  private executeCreateObjectNugget(nugget: IniBlock, sourceEntity: MapEntity, lifetimeOverrideFrames?: number): void {
    const registry = this.iniDataRegistry;
    if (!registry) return;

    // Parse ObjectNames field (space-separated list of template names).
    const objectNamesRaw = readStringField(nugget.fields, ['ObjectNames']);
    if (!objectNamesRaw) return;
    const objectNames = objectNamesRaw.trim().split(/\s+/).filter(Boolean);
    if (objectNames.length === 0) return;

    // Parse Count (default 1).
    const countRaw = readStringField(nugget.fields, ['Count', 'ObjectCount']);
    const count = Math.max(1, countRaw ? (parseInt(countRaw, 10) || 1) : 1);

    // Parse Offset as Coord3D (X Y Z in source).
    const offsetRaw = readStringField(nugget.fields, ['Offset']);
    let offsetX = 0;
    let offsetZ = 0;
    if (offsetRaw) {
      const parts = offsetRaw.trim().split(/\s+/);
      if (parts.length >= 1) offsetX = parseFloat(parts[0]!) || 0;
      if (parts.length >= 3) offsetZ = parseFloat(parts[2]!) || 0;
    }

    // Parse InheritsVeterancy.
    const inheritsVet = readStringField(nugget.fields, ['InheritsVeterancy'])?.toUpperCase() === 'YES';

    for (let i = 0; i < count; i++) {
      // Pick a random object from the list (deterministic via gameRandom).
      const templateName = objectNames[this.gameRandom.nextRange(0, objectNames.length - 1)]!;

      // Apply offset with some scatter for multiple spawns.
      const scatter = count > 1 ? (this.gameRandom.nextFloat() - 0.5) * 4 : 0;
      const spawnX = sourceEntity.x + offsetX + scatter;
      const spawnZ = sourceEntity.z + offsetZ + scatter;

      const spawned = this.spawnEntityFromTemplate(
        templateName,
        spawnX,
        spawnZ,
        sourceEntity.rotationY + (this.gameRandom.nextFloat() - 0.5) * 0.3,
        sourceEntity.side,
      );

      if (spawned) {
        if (inheritsVet) {
          spawned.experienceState.currentLevel = sourceEntity.experienceState.currentLevel;
        }
        // Source parity: track creator for mine lifecycle (MinefieldBehavior producer tracking).
        if (spawned.minefieldProfile) {
          spawned.mineCreatorId = sourceEntity.id;
        }
        // Source parity: ObjectCreationList::create passes oclFrames to override spawned object lifetime.
        if (lifetimeOverrideFrames !== undefined && lifetimeOverrideFrames > 0) {
          spawned.lifetimeDieFrame = this.frameCounter + lifetimeOverrideFrames;
        }
      }
    }
  }

  /**
   * Source parity: FireWeaponNugget::create — fire a weapon at a target position.
   * C++ creates a temporary weapon from the template and fires it at the secondary position.
   */
  private executeFireWeaponNugget(
    nugget: IniBlock,
    sourceEntity: MapEntity,
    targetX?: number,
    targetZ?: number,
  ): void {
    const registry = this.iniDataRegistry;
    if (!registry) return;

    const weaponName = readStringField(nugget.fields, ['Weapon']);
    if (!weaponName) return;

    const weaponDef = registry.getWeapon(weaponName);
    if (!weaponDef) return;

    // Fire at target position if provided, otherwise at source entity position.
    const fireX = targetX ?? sourceEntity.x;
    const fireZ = targetZ ?? sourceEntity.z;
    this.fireTemporaryWeaponAtPosition(sourceEntity, weaponDef, fireX, fireZ);
  }

  /**
   * Source parity: Execute all death OCLs for an entity.
   */
  private executeDeathOCLs(entity: MapEntity): void {
    for (const entry of entity.deathOCLEntries) {
      // Source parity: DieMuxData filtering for each CreateObjectDie module.
      if (!this.isDieModuleApplicable(entity, entry)) continue;
      this.executeOCL(entry.oclName, entity);
    }
  }

  /**
   * Source parity: InstantDeathBehavior::onDie — execute all matching die module effects.
   * Each profile checks DieMuxData filters (DeathTypes, VeterancyLevels, ExemptStatus,
   * RequiredStatus). Matching profiles fire one random OCL and one random Weapon.
   * C++ file: InstantDeathBehavior.cpp lines 123-175.
   */
  private executeInstantDeathModules(entity: MapEntity): void {
    for (const profile of entity.instantDeathProfiles) {
      if (!this.isDieModuleApplicable(entity, profile)) continue;

      // Fire one random OCL from the list.
      if (profile.oclNames.length > 0) {
        const idx = profile.oclNames.length === 1 ? 0
          : this.gameRandom.nextRange(0, profile.oclNames.length - 1);
        const oclName = profile.oclNames[idx];
        if (oclName) {
          this.executeOCL(oclName, entity);
        }
      }

      // Fire one random weapon from the list.
      if (profile.weaponNames.length > 0) {
        const idx = profile.weaponNames.length === 1 ? 0
          : this.gameRandom.nextRange(0, profile.weaponNames.length - 1);
        const weaponName = profile.weaponNames[idx];
        if (weaponName) {
          const weaponDef = this.iniDataRegistry?.getWeapon(weaponName);
          if (weaponDef) {
            this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);
          }
        }
      }
    }
  }

  /**
   * Source parity: FireWeaponWhenDeadBehavior::onDie — fire death weapon with
   * DieMuxData filtering and upgrade activation control.
   * C++ file: FireWeaponWhenDeadBehavior.cpp lines 84-118.
   */
  private executeFireWeaponWhenDeadModules(entity: MapEntity): void {
    for (const profile of entity.fireWeaponWhenDeadProfiles) {
      // Source parity: UpgradeMux — check if module is active.
      // StartsActive=Yes means active by default; TriggeredBy activates via upgrade.
      if (!profile.startsActive) {
        // Need at least one TriggeredBy upgrade to be present.
        if (profile.triggeredBy.length === 0) continue;
        const hasActivation = profile.triggeredBy.some(
          u => entity.completedUpgrades.has(u.toUpperCase()),
        );
        if (!hasActivation) continue;
      }

      // Source parity: ConflictsWithTriggeredBy — if any conflicting upgrade is present, skip.
      if (profile.conflictsWith.length > 0) {
        const hasConflict = profile.conflictsWith.some(
          u => entity.completedUpgrades.has(u.toUpperCase()),
        );
        if (hasConflict) continue;
      }

      // Source parity: skip if under construction (line 98).
      if (entity.objectStatusFlags.has('UNDER_CONSTRUCTION')) continue;

      // DieMuxData filtering.
      if (!this.isDieModuleApplicable(entity, profile)) continue;

      // Fire the death weapon.
      const weaponDef = this.iniDataRegistry?.getWeapon(profile.deathWeaponName);
      if (weaponDef) {
        this.fireTemporaryWeaponAtPosition(entity, weaponDef, entity.x, entity.z);
      }
    }
  }

  /**
   * Source parity: NeutronBlastBehavior::onDie — on death, scan a radius and:
   * - Kill infantry outright
   * - Kill all contained passengers in containers
   * - Kill CLIFF_JUMPER vehicles (combat bikes)
   * - Make other vehicles unmanned (DISABLED_UNMANNED + transfer to neutral team)
   * C++ file: NeutronBlastBehavior.cpp lines 66-162.
   */
  private executeNeutronBlast(entity: MapEntity): void {
    const profile = entity.neutronBlastProfile;
    if (!profile) return;

    const radiusSqr = profile.blastRadius * profile.blastRadius;

    for (const victim of this.spawnedEntities.values()) {
      if (victim.destroyed || victim.id === entity.id) continue;
      if (victim.slowDeathState || victim.structureCollapseState) continue;

      // Source parity: PartitionFilterAlive + PartitionFilterSameMapStatus.
      const dx = victim.x - entity.x;
      const dz = victim.z - entity.z;
      if (dx * dx + dz * dz > radiusSqr) continue;

      const victimKindOf = this.resolveEntityKindOfSet(victim);

      // Source parity: skip airborne aircraft if affectAirborne is false.
      if (!profile.affectAirborne) {
        if (victimKindOf.has('AIRCRAFT') || victim.objectStatusFlags.has('AIRBORNE_TARGET')) {
          continue;
        }
      }

      this.neutronBlastToObject(entity, victim, victimKindOf, profile);
    }
  }

  /**
   * Source parity: NeutronBlastBehavior::neutronBlastToObject — apply neutron effect to one victim.
   */
  private neutronBlastToObject(
    source: MapEntity,
    victim: MapEntity,
    victimKindOf: Set<string>,
    profile: NeutronBlastProfile,
  ): void {
    // Source parity: skip allies if affectAllies is false.
    if (!profile.affectAllies) {
      const rel = this.getEntityRelationship(source.id, victim.id);
      if (rel === 'allies') return;
    }

    // Kill infantry.
    if (victimKindOf.has('INFANTRY')) {
      this.applyWeaponDamageAmount(null, victim, victim.maxHealth, 'UNRESISTABLE');
    }

    // Kill all contained units (garrison, transport, helix, tunnel passengers).
    const containedIds = this.collectContainedEntityIds(victim.id);
    for (const passengerId of containedIds) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (passenger && !passenger.destroyed) {
        this.applyWeaponDamageAmount(null, passenger, passenger.maxHealth, 'UNRESISTABLE');
      }
    }

    // Vehicle special handling: kill pilots.
    if (victimKindOf.has('VEHICLE') && !victimKindOf.has('DRONE')) {
      if (victimKindOf.has('CLIFF_JUMPER')) {
        // Source parity: CLIFF_JUMPER vehicles (combat bikes) are killed outright.
        this.applyWeaponDamageAmount(null, victim, victim.maxHealth, 'UNRESISTABLE');
      } else {
        // Source parity: make vehicle unmanned — sets DISABLED_UNMANNED, transfers to neutral team.
        victim.objectStatusFlags.add('DISABLED_UNMANNED');
        // Clear attack state (C++ calls aiIdle).
        victim.attackTargetEntityId = null;
        victim.attackTargetPosition = null;
        if (victim.moving) {
          victim.moving = false;
          victim.moveTarget = null;
          victim.movePath = [];
          victim.pathIndex = 0;
          victim.pathfindGoalCell = null;
        }
        // Source parity: deselectObject + setTeam to neutral player.
        victim.isSelected = false;
        // Transfer to a neutral side by clearing ownership.
        this.unregisterEntityEnergy(victim);
        victim.side = '';
        victim.controllingPlayerToken = null;
      }
    }
  }

  /**
   * Source parity: BunkerBusterBehavior::update — each frame, capture the entity's attack
   * target as the bunker buster victim. C++ calls ai->getCurrentVictim().
   * C++ file: BunkerBusterBehavior.cpp lines 135-166.
   */
  private updateBunkerBusterTracking(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (!entity.bunkerBusterProfile || entity.destroyed) continue;
      if (entity.bunkerBusterVictimId !== null) continue;
      if (entity.attackTargetEntityId !== null) {
        entity.bunkerBusterVictimId = entity.attackTargetEntityId;
      }
    }
  }

  /**
   * Source parity: BunkerBusterBehavior::onDie → bustTheBunker — on death, kill all
   * garrisoned units inside the targeted building.
   * C++ file: BunkerBusterBehavior.cpp lines 184-248.
   *
   * - Checks upgrade gate (player must have UpgradeRequired)
   * - Finds victim by captured victimID
   * - If victim has bustable contain (garrison or tunnel):
   *   - OccupantDamageWeaponTemplate: force-exit then apply 100 damage per occupant
   *   - Otherwise: kill all contained outright
   * - Fires ShockwaveWeaponTemplate at victim position
   */
  /**
   * Source parity: OpenContain::processDamageToContained (C++ OpenContain.cpp line 1441).
   * Applies percentDamage * maxHealth as UNRESISTABLE damage to each contained unit.
   * If percentDamage == 1.0 and the unit survives (e.g., fireproof), force-kill it.
   * Death type: BURNED if burnedDeathToUnits, else NORMAL.
   */
  private processDamageToContained(container: MapEntity): void {
    const profile = container.containProfile;
    if (!profile || profile.damagePercentToUnits <= 0) return;
    const percentDamage = profile.damagePercentToUnits;
    const deathType = profile.burnedDeathToUnits ? 'BURNED' : undefined;
    const passengerIds = this.collectContainedEntityIds(container.id);
    for (const passengerId of passengerIds) {
      const passenger = this.spawnedEntities.get(passengerId);
      if (!passenger || passenger.destroyed) continue;
      const damage = passenger.maxHealth * percentDamage;
      this.applyWeaponDamageAmount(container.id, passenger, damage, 'UNRESISTABLE', deathType);
      // Source parity: if percentDamage == 1.0 and unit survived (fireproof), force kill (C++ line 1470-1471).
      if (percentDamage >= 1.0 && !passenger.destroyed && passenger.health > 0) {
        this.applyWeaponDamageAmount(container.id, passenger, passenger.health, 'UNRESISTABLE', deathType);
      }
    }
  }

  private executeBunkerBuster(entity: MapEntity): void {
    const profile = entity.bunkerBusterProfile;
    if (!profile) return;

    // Source parity: check upgrade gate (C++ line 188-193).
    if (profile.upgradeRequired) {
      if (!entity.side || !this.hasSideUpgradeCompleted(entity.side, profile.upgradeRequired)) {
        return;
      }
    }

    const victimId = entity.bunkerBusterVictimId;
    const victim = victimId !== null ? this.spawnedEntities.get(victimId) : undefined;

    // Source parity: check if victim has a bustable contain module (C++ line 207).
    // GarrisonContain, TunnelContain, and CaveContain return isBustable()=TRUE.
    // TransportContain, OverlordContain return FALSE.
    if (victim && !victim.destroyed) {
      const isBustable = victim.containProfile?.moduleType === 'GARRISON'
        || victim.containProfile?.moduleType === 'TUNNEL'
        || victim.containProfile?.moduleType === 'CAVE';
      if (isBustable) {
        // Collect passengers in this bustable container.
        const passengerIds: number[] = [];
        for (const candidate of this.spawnedEntities.values()) {
          if (candidate.destroyed) continue;
          if (candidate.garrisonContainerId === victimId
            || candidate.tunnelContainerId === victimId) {
            passengerIds.push(candidate.id);
          }
        }

        if (profile.occupantDamageWeaponName) {
          // Source parity: harmAndForceExitAllContained — release then damage each occupant (C++ line 211-218).
          const weaponDef = this.iniDataRegistry?.getWeapon(profile.occupantDamageWeaponName);
          const damageType = weaponDef
            ? (readStringField(weaponDef.fields, ['DamageType'])?.toUpperCase() ?? 'EXPLOSION')
            : 'EXPLOSION';
          const deathType = weaponDef
            ? (readStringField(weaponDef.fields, ['DeathType'])?.toUpperCase() || undefined)
            : undefined;
          for (const passengerId of passengerIds) {
            const passenger = this.spawnedEntities.get(passengerId);
            if (!passenger || passenger.destroyed) continue;
            // Source parity: removeFromContain(rider, true) — force exit.
            this.releaseEntityFromContainer(passenger);
            // Source parity: rider->attemptDamage(&damageInfo) with m_amount=100 (C++ line 217).
            this.applyWeaponDamageAmount(entity.id, passenger, 100, damageType, deathType);
          }
        } else {
          // Source parity: killAllContained() — release then kill outright (C++ line 221).
          for (const passengerId of passengerIds) {
            const passenger = this.spawnedEntities.get(passengerId);
            if (!passenger || passenger.destroyed) continue;
            this.releaseEntityFromContainer(passenger);
            this.applyWeaponDamageAmount(entity.id, passenger, passenger.maxHealth, 'UNRESISTABLE');
          }
        }
      }
    }

    // Source parity: fire shockwave weapon at victim position (C++ line 244-245).
    // C++: objectForFX = victim building (determines side for relationship filtering).
    // Shockwave fires even if victim was already destroyed — fall back to bomb position.
    if (profile.shockwaveWeaponName) {
      const shockwaveWeaponDef = this.iniDataRegistry?.getWeapon(profile.shockwaveWeaponName);
      if (shockwaveWeaponDef) {
        const shockwaveSource = (victim && !victim.destroyed) ? victim : entity;
        const shockwaveX = victim ? victim.x : entity.x;
        const shockwaveZ = victim ? victim.z : entity.z;
        this.fireTemporaryWeaponAtPosition(shockwaveSource, shockwaveWeaponDef, shockwaveX, shockwaveZ);
      }
    }
  }

  /**
   * Source parity: FXListDie::onDie — trigger death FX for matching FXListDie profiles.
   * C++ file: FXListDie.cpp — plays death effects with isDieApplicable filtering.
   * Emits visual events for the renderer to display particle/sound effects.
   */
  private executeFXListDieModules(entity: MapEntity): void {
    for (const profile of entity.fxListDieProfiles) {
      if (!this.isDieModuleApplicable(entity, profile)) continue;
      // Emit a death FX visual event for the renderer.
      // Source parity: C++ triggers FXList::doFXObj or FXList::doFXPos based on orientToObject.
      this.visualEventBuffer.push({
        type: 'ENTITY_DESTROYED',
        x: entity.x,
        y: entity.y,
        z: entity.z,
        radius: 0,
        sourceEntityId: entity.id,
        projectileType: 'GENERIC',
      });
    }
  }

  /**
   * Source parity: CrushDie::onDie — compute crush location and set model conditions.
   * C++ file: CrushDie.cpp lines 163-208.
   */
  private executeCrushDie(entity: MapEntity, attackerId: number): void {
    if (entity.crushDieProfiles.length === 0) return;

    for (const profile of entity.crushDieProfiles) {
      if (!this.isDieModuleApplicable(entity, profile)) continue;

      // Source parity: CrushDie.cpp line 169 — only for CRUSH damage type.
      if (entity.pendingDeathType !== 'CRUSHED') continue;

      const crusher = this.spawnedEntities.get(attackerId);
      // Source parity: CrushDie.cpp line 175 — if no crusher found, use TOTAL_CRUSH.
      const crushType = crusher
        ? this.crushLocationCheck(crusher, entity)
        : 'TOTAL';

      if (crushType === 'NONE') continue;

      // Source parity: CrushDie.cpp lines 195-204.
      entity.frontCrushed = crushType === 'TOTAL' || crushType === 'FRONT';
      entity.backCrushed = crushType === 'TOTAL' || crushType === 'BACK';

      if (entity.frontCrushed) entity.modelConditionFlags.add('FRONTCRUSHED');
      if (entity.backCrushed) entity.modelConditionFlags.add('BACKCRUSHED');
    }
  }

  /**
   * Source parity: DamDie::onDie — enable all WAVEGUIDE objects when dam dies.
   * C++ file: DamDie.cpp lines 91-106.
   */
  private executeDamDieModules(entity: MapEntity): void {
    if (entity.damDieProfiles.length === 0) {
      return;
    }

    let shouldEnableWaveGuides = false;
    for (const profile of entity.damDieProfiles) {
      if (this.isDieModuleApplicable(entity, profile)) {
        shouldEnableWaveGuides = true;
        break;
      }
    }
    if (!shouldEnableWaveGuides) {
      return;
    }

    for (const candidate of this.spawnedEntities.values()) {
      if (!candidate.kindOf.has('WAVEGUIDE')) {
        continue;
      }
      candidate.objectStatusFlags.delete('DISABLED_DEFAULT');
    }
  }

  /**
   * Source parity: SpecialPowerCompletionDie::onDie — notify ScriptEngine special-power completion list.
   * C++ file: SpecialPowerCompletionDie.cpp lines 56-74.
   */
  private executeSpecialPowerCompletionDieModules(entity: MapEntity): void {
    if (entity.specialPowerCompletionDieProfiles.length === 0) {
      return;
    }

    const normalizedSide = this.normalizeSide(entity.side);
    if (!normalizedSide) {
      return;
    }

    const creatorId = entity.specialPowerCompletionCreatorId;
    if (!Number.isFinite(creatorId) || Math.trunc(creatorId) <= 0) {
      return;
    }
    const normalizedCreatorId = Math.trunc(creatorId);

    for (const profile of entity.specialPowerCompletionDieProfiles) {
      if (!this.isDieModuleApplicable(entity, profile)) {
        continue;
      }
      this.recordScriptCompletedSpecialPowerEvent(
        normalizedSide,
        profile.specialPowerTemplateName,
        normalizedCreatorId,
      );
    }
  }

  /**
   * Source parity: crushLocationCheck — determine which end of the victim was closest to the crusher.
   * C++ file: CrushDie.cpp lines 49-145.
   * Returns 'TOTAL' | 'FRONT' | 'BACK' | 'NONE'.
   */
  private crushLocationCheck(crusher: MapEntity, victim: MapEntity): 'TOTAL' | 'FRONT' | 'BACK' | 'NONE' {
    // Source parity: victim's forward direction vector.
    // C++ uses getUnitDirectionVector2D(); our convention: dirX = cos(rotationY - PI/2), dirZ = sin(rotationY - PI/2).
    const dirX = Math.cos(victim.rotationY - Math.PI / 2);
    const dirZ = Math.sin(victim.rotationY - Math.PI / 2);

    // Source parity: CrushDie.cpp line 62 — offset = majorRadius * 0.5.
    const majorRadius = victim.obstacleGeometry ? victim.obstacleGeometry.majorRadius : 1.0;
    const offsetDist = majorRadius * 0.5;
    const offsetX = dirX * offsetDist;
    const offsetZ = dirZ * offsetDist;

    const crusherX = crusher.x;
    const crusherZ = crusher.z;
    const victimX = victim.x;
    const victimZ = victim.z;

    let result: 'TOTAL' | 'FRONT' | 'BACK' | 'NONE' = 'NONE';
    let bestDist = 99999;

    // Source parity: CrushDie.cpp lines 78-90 — check middle (TOTAL_CRUSH).
    if (!victim.frontCrushed && !victim.backCrushed) {
      const dx = victimX - crusherX;
      const dz = victimZ - crusherZ;
      const dist = dx * dx + dz * dz;
      result = 'TOTAL';
      bestDist = dist;
    }

    // Source parity: CrushDie.cpp lines 92-116 — check front point.
    if (!victim.frontCrushed) {
      const fx = victimX + offsetX;
      const fz = victimZ + offsetZ;
      const dx = fx - crusherX;
      const dz = fz - crusherZ;
      const dist = dx * dx + dz * dz;
      if (dist < bestDist) {
        result = victim.backCrushed ? 'TOTAL' : 'FRONT';
        bestDist = dist;
      }
    }

    // Source parity: CrushDie.cpp lines 118-142 — check back point.
    if (!victim.backCrushed) {
      const bx = victimX - offsetX;
      const bz = victimZ - offsetZ;
      const dx = bx - crusherX;
      const dz = bz - crusherZ;
      const dist = dx * dx + dz * dz;
      if (dist < bestDist) {
        result = victim.frontCrushed ? 'TOTAL' : 'BACK';
      }
    }

    return result;
  }

  /**
   * Source parity: DieMuxData::isDieApplicable — check if a die module should fire
   * based on death type, veterancy level, exempt/required status.
   * C++ file: DieModule.cpp lines 71-91.
   */
  private isDieModuleApplicable(entity: MapEntity, profile: {
    deathTypes: Set<string>;
    veterancyLevels: Set<string>;
    exemptStatus: Set<string>;
    requiredStatus: Set<string>;
  }): boolean {
    // Source parity: DieModule.cpp line 76 — wrong death type? punt.
    // C++ checks: getDeathTypeFlag(m_deathTypes, damageInfo->in.m_deathType).
    // If profile has DeathTypes, entity's actual death cause must be in the set.
    // Empty deathTypes set = ALL_DEATH_TYPES (accepts everything).
    if (profile.deathTypes.size > 0) {
      if (profile.deathTypes.has('NONE') && profile.deathTypes.size === 1) {
        return false; // Explicitly set to NONE — never fires.
      }
      // Source parity: ALL = all death types accepted (bitmask with all bits set in C++).
      if (!profile.deathTypes.has('ALL') && !profile.deathTypes.has(entity.pendingDeathType)) {
        return false;
      }
    }

    // VeterancyLevels filter (empty = all levels accepted).
    if (profile.veterancyLevels.size > 0) {
      const levelNames = ['REGULAR', 'VETERAN', 'ELITE', 'HEROIC'] as const;
      const entityLevel = levelNames[entity.experienceState.currentLevel] ?? 'REGULAR';
      if (!profile.veterancyLevels.has(entityLevel)) return false;
    }

    // ExemptStatus — entity must NOT have any of these flags.
    for (const status of profile.exemptStatus) {
      if (entity.objectStatusFlags.has(status)) return false;
    }

    // RequiredStatus — entity must have ALL of these flags.
    for (const status of profile.requiredStatus) {
      if (!entity.objectStatusFlags.has(status)) return false;
    }

    return true;
  }

  private isAnyDestroyDieProfileApplicable(entity: MapEntity): boolean {
    if (entity.destroyDieProfiles.length === 0) {
      return false;
    }
    for (const profile of entity.destroyDieProfiles) {
      if (this.isDieModuleApplicable(entity, profile)) {
        return true;
      }
    }
    return false;
  }

  // ── EVA Announcer system ──

  /** Default cooldown frames per EVA event type (~10 seconds at 30fps). */
  private static readonly EVA_DEFAULT_COOLDOWN = 300;
  /** Shorter cooldown for high-priority events (~3 seconds). */
  private static readonly EVA_SHORT_COOLDOWN = 90;

  /**
   * Source parity: Eva::setShouldPlay — emit an EVA event with cooldown suppression.
   */
  private emitEvaEvent(
    type: import('./types.js').EvaEventType,
    side: string,
    relationship: 'own' | 'ally' | 'enemy',
    entityId: number | null = null,
    detail: string | null = null,
  ): void {
    const cooldownKey = `${type}:${side}:${relationship}`;
    const nextAllowed = this.evaCooldowns.get(cooldownKey) ?? 0;
    if (this.frameCounter < nextAllowed) return;

    // Use shorter cooldown for urgent events.
    const isUrgent = type === 'BASE_UNDER_ATTACK' || type === 'SUPERWEAPON_LAUNCHED';
    const cooldown = isUrgent
      ? GameLogicSubsystem.EVA_SHORT_COOLDOWN
      : GameLogicSubsystem.EVA_DEFAULT_COOLDOWN;
    this.evaCooldowns.set(cooldownKey, this.frameCounter + cooldown);

    this.evaEventBuffer.push({ type, side, relationship, entityId, detail });
  }

  /**
   * Source parity: Eva::update — check for low power and emit EVA events.
   * Called once per frame from the main update loop.
   */
  private updateEva(): void {
    // Check low power for each side.
    for (const [side, powerState] of this.sidePowerBonus.entries()) {
      const balance = powerState.energyProduction - powerState.energyConsumption + powerState.powerBonus;
      if (balance < 0) {
        this.emitEvaEvent('LOW_POWER', side, 'own');
      }
    }

    // Source parity: Eva fires SUPERWEAPON_READY / SUPERWEAPON_DETECTED when
    // a superweapon countdown reaches zero for the first time.
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || !entity.kindOf.has('FS_SUPERWEAPON')) continue;
      for (const [, module] of entity.specialPowerModules) {
        const normalizedPower = module.specialPowerTemplateName.toUpperCase().replace(/\s+/g, '');
        const sharedFrame = this.sharedShortcutSpecialPowerReadyFrames.get(normalizedPower) ?? 0;
        if (sharedFrame > 0 && this.frameCounter === sharedFrame && entity.side) {
          this.emitEvaEvent('SUPERWEAPON_READY', entity.side, 'own', entity.id, module.specialPowerTemplateName);
          for (const [side] of this.sidePowerBonus.entries()) {
            if (side !== entity.side) {
              this.emitEvaEvent('SUPERWEAPON_DETECTED', side, 'enemy', entity.id, module.specialPowerTemplateName);
            }
          }
        }
      }
    }
  }

  /**
   * Source parity: ExperienceTracker::addExperiencePoints on killer,
   * using victim's ExperienceValue for their current level.
   * ActiveBody::onVeterancyLevelChanged applies health and armor bonuses.
   */
  private awardExperienceOnKill(victimId: number, attackerId: number): void {
    if (attackerId < 0) {
      return;
    }

    const victim = this.spawnedEntities.get(victimId);
    const attacker = this.spawnedEntities.get(attackerId);
    if (!victim || !attacker || attacker.destroyed) {
      return;
    }

    const victimProfile = victim.experienceProfile;
    if (!victimProfile) {
      return;
    }

    const attackerProfile = attacker.experienceProfile;
    if (!attackerProfile) {
      return;
    }

    // Source parity: no XP for killing allies.
    const victimSide = this.normalizeSide(victim.side);
    const attackerSide = this.normalizeSide(attacker.side);
    if (victimSide && attackerSide && victimSide === attackerSide) {
      return;
    }

    const xpGain = getExperienceValueImpl(victimProfile, victim.experienceState.currentLevel);
    if (xpGain <= 0) {
      return;
    }

    // Source parity: unit-level veterancy XP.
    const result = addExperiencePointsImpl(
      attacker.experienceState,
      attackerProfile,
      xpGain,
      true,
    );

    if (result.didLevelUp) {
      this.onEntityLevelUp(attacker, result.oldLevel, result.newLevel);
    }

    // Source parity: Player::addSkillPointsForKill — also award player-level rank points.
    // SkillPointValue defaults to ExperienceValue when not set in INI (USE_EXP_VALUE_FOR_SKILL_VALUE sentinel).
    if (attackerSide) {
      // No skill points for killing units under construction.
      if (!victim.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
        this.addPlayerSkillPoints(attackerSide, xpGain);
      }
    }
  }

  /**
   * Source parity: Player::addCashBounty — award credits to the killer's side
   * based on the victim's build cost multiplied by the side's cash bounty percentage.
   */
  private awardCashBountyOnKill(victim: MapEntity, attackerId: number): void {
    if (attackerId < 0) {
      return;
    }
    const attacker = this.spawnedEntities.get(attackerId);
    if (!attacker || attacker.destroyed) {
      return;
    }
    const attackerSide = this.normalizeSide(attacker.side);
    if (!attackerSide) {
      return;
    }
    // Source parity: no bounty for killing allies or own units.
    const victimSide = this.normalizeSide(victim.side);
    if (victimSide && victimSide === attackerSide) {
      return;
    }
    // Source parity: no bounty for partially-built structures.
    if (victim.objectStatusFlags.has('UNDER_CONSTRUCTION')) {
      return;
    }
    const bountyPercent = this.sideCashBountyPercent.get(attackerSide) ?? 0;
    if (bountyPercent <= 0) {
      return;
    }
    // Resolve the victim's build cost from its template.
    const objectDef = this.resolveObjectDefByTemplateName(victim.templateName);
    if (!objectDef) {
      return;
    }
    const buildCost = this.resolveObjectBuildCost(objectDef, victim.side ?? '');
    if (buildCost <= 0) {
      return;
    }
    // Source parity: REAL_TO_INT_CEIL rounding.
    const bountyAmount = Math.ceil(buildCost * bountyPercent);
    if (bountyAmount > 0) {
      this.depositSideCredits(attackerSide, bountyAmount);
    }
  }

  private onEntityLevelUp(entity: MapEntity, oldLevel: VeterancyLevel, newLevel: VeterancyLevel): void {
    // Source parity: apply health bonus (ActiveBody.cpp:1126-1134).
    const config = DEFAULT_VETERANCY_CONFIG;
    const { newHealth, newMaxHealth } = applyHealthBonusForLevelChangeImpl(
      oldLevel,
      newLevel,
      entity.health,
      entity.maxHealth,
      config,
    );
    entity.maxHealth = newMaxHealth;
    entity.initialHealth = newMaxHealth;
    entity.health = newHealth;

    // Source parity: update armor set flags for veterancy level (ActiveBody.cpp:1139-1159).
    const vetArmorFlags = resolveArmorSetFlagsForLevelImpl(newLevel);
    // Clear all veterancy armor flags then set the new one.
    entity.armorSetFlagsMask &= ~0x07; // Clear VETERAN | ELITE | HERO bits.
    entity.armorSetFlagsMask |= vetArmorFlags;

    // Source parity: Object::setVeterancyLevel — update weapon bonus condition flags.
    // Veterancy levels are mutually exclusive: only one of VETERAN/ELITE/HERO is active.
    const vetBonusMask = WEAPON_BONUS_VETERAN | WEAPON_BONUS_ELITE | WEAPON_BONUS_HERO;
    entity.weaponBonusConditionFlags &= ~vetBonusMask;
    if (newLevel === LEVEL_VETERAN) {
      entity.weaponBonusConditionFlags |= WEAPON_BONUS_VETERAN;
    } else if (newLevel === LEVEL_ELITE) {
      entity.weaponBonusConditionFlags |= WEAPON_BONUS_ELITE;
    } else if (newLevel === LEVEL_HEROIC) {
      entity.weaponBonusConditionFlags |= WEAPON_BONUS_HERO;
    }

    // Source parity: Object::setVeterancyLevel → refreshWeaponSet() — update weapon set
    // flags and recompute combat profiles (applies RANGE bonus from new veterancy level).
    const vetWeaponMask = WEAPON_SET_FLAG_VETERAN | WEAPON_SET_FLAG_ELITE | WEAPON_SET_FLAG_HERO;
    entity.weaponSetFlagsMask &= ~vetWeaponMask;
    if (newLevel === LEVEL_VETERAN) {
      entity.weaponSetFlagsMask |= WEAPON_SET_FLAG_VETERAN;
    } else if (newLevel === LEVEL_ELITE) {
      entity.weaponSetFlagsMask |= WEAPON_SET_FLAG_ELITE;
    } else if (newLevel === LEVEL_HEROIC) {
      entity.weaponSetFlagsMask |= WEAPON_SET_FLAG_HERO;
    }
    this.refreshEntityCombatProfiles(entity);
  }

  private cancelAndRefundAllProductionOnDeath(producer: MapEntity): void {
    if (producer.productionQueue.length === 0) {
      return;
    }

    // Source parity: ProductionUpdate::onDie() calls cancelAndRefundAllProduction(),
    // which iterates queue entries through cancel paths to restore player money/state.
    const productionLimit = 100;
    for (let i = 0; i < productionLimit && producer.productionQueue.length > 0; i += 1) {
      const producerSide = this.resolveEntityOwnerSide(producer);
      const production = producer.productionQueue[0];
      if (!production) {
        break;
      }

      if (producerSide && production.type === 'UPGRADE' && production.upgradeType === 'PLAYER') {
        this.setSideUpgradeInProduction(producerSide, production.upgradeName, false);
      }
      if (production.type === 'UNIT') {
        this.releaseParkingDoorReservationForProduction(producer, production.productionId);
      }

      if (producerSide) {
        this.depositSideCredits(producerSide, production.buildCost);
      }
      producer.productionQueue.shift();
    }
  }

  private finalizeDestroyedEntities(): void {
    const destroyedEntityIds: number[] = [];
    for (const entity of this.spawnedEntities.values()) {
      const destroyDieMatched = this.isAnyDestroyDieProfileApplicable(entity);
      if (entity.destroyed && (!entity.keepObjectOnDeath || destroyDieMatched)) {
        destroyedEntityIds.push(entity.id);
      }
    }

    if (destroyedEntityIds.length === 0) {
      return;
    }

    for (const entity of this.spawnedEntities.values()) {
      if (entity.attackTargetEntityId !== null && destroyedEntityIds.includes(entity.attackTargetEntityId)) {
        entity.attackTargetEntityId = null;
        entity.attackOriginalVictimPosition = null;
        entity.attackTargetPosition = null;
        entity.attackCommandSource = 'AI';
      }
    }

    for (const entityId of destroyedEntityIds) {
      const entity = this.spawnedEntities.get(entityId);
      if (!entity) {
        continue;
      }
      if (entity.parkingSpaceProducerId !== null) {
        const producer = this.spawnedEntities.get(entity.parkingSpaceProducerId);
        if (producer?.parkingPlaceProfile) {
          producer.parkingPlaceProfile.occupiedSpaceEntityIds.delete(entity.id);
        }
        entity.parkingSpaceProducerId = null;
      }
      if (entity.helixCarrierId !== null) {
        const carrier = this.spawnedEntities.get(entity.helixCarrierId);
        if (carrier?.helixPortableRiderId === entity.id) {
          carrier.helixPortableRiderId = null;
        }
        entity.helixCarrierId = null;
      }
      if (entity.helixPortableRiderId !== null) {
        entity.helixPortableRiderId = null;
      }
      if (entity.garrisonContainerId !== null) {
        entity.garrisonContainerId = null;
      }
      if (entity.transportContainerId !== null) {
        entity.transportContainerId = null;
      }
      if (entity.tunnelContainerId !== null) {
        // Remove from tunnel tracker passenger list on final cleanup.
        const tunnel = this.spawnedEntities.get(entity.tunnelContainerId);
        if (tunnel) {
          const tracker = this.resolveTunnelTracker(tunnel.side);
          if (tracker) tracker.passengerIds.delete(entity.id);
        }
        entity.tunnelContainerId = null;
      }
      this.removeEntityFromWorld(entityId);
      this.removeEntityFromSelection(entityId);
    }
  }

  private cleanupDyingRenderableStates(): void {
    for (const [entityId, pending] of this.pendingDyingRenderableStates.entries()) {
      if (this.frameCounter > pending.expireFrame) {
        this.pendingDyingRenderableStates.delete(entityId);
      }
    }
  }

  /**
   * Source parity: VictoryConditions.cpp — checks for defeat & victory.
   * Default skirmish mode: a side is defeated when it has zero non-excluded
   * entities remaining. C++ hasAnyObjects() counts ALL objects on the team
   * except projectiles, mines, and inert objects.
   */
  private checkVictoryConditions(): void {
    if (this.gameEndFrame !== null) {
      return; // Game already ended.
    }

    // Collect all active sides from playerSideByIndex.
    const activeSides = new Set<string>();
    for (const [, side] of this.playerSideByIndex) {
      if (!this.defeatedSides.has(side)) {
        activeSides.add(side);
      }
    }

    if (activeSides.size < 2) {
      return; // Need at least 2 sides for victory conditions.
    }

    // Check each active side for defeat — source parity: hasSinglePlayerBeenDefeated.
    const newlyDefeated: string[] = [];
    for (const side of activeSides) {
      if (this.hasSingleSideBeenDefeated(side)) {
        newlyDefeated.push(side);
      }
    }

    // Source parity: VictoryConditions::update() — on defeat: reveal map, kill remaining units.
    for (const side of newlyDefeated) {
      this.defeatedSides.add(side);
      this.revealEntireMapForSide(side);
      this.killRemainingEntitiesForSide(side);
    }

    // Source parity: Check if only one alliance remains.
    // Build alliance groups — two sides are in the same alliance if both
    // consider each other ALLIES (mutual relationship, like C++ areAllies).
    const remainingSides: string[] = [];
    for (const [, side] of this.playerSideByIndex) {
      if (!this.defeatedSides.has(side) && !remainingSides.includes(side)) {
        remainingSides.push(side);
      }
    }

    if (remainingSides.length === 0) {
      // Source parity: all sides eliminated simultaneously — game ends as draw.
      if (this.defeatedSides.size > 0) {
        this.gameEndFrame = this.frameCounter;
      }
      return;
    }

    // Group remaining sides by alliance: two sides are allied if both
    // have RELATIONSHIP_ALLIES toward each other (mutual).
    const allianceGroups: string[][] = [];
    const assigned = new Set<string>();

    for (const side of remainingSides) {
      if (assigned.has(side)) continue;
      const group = [side];
      assigned.add(side);

      for (const other of remainingSides) {
        if (assigned.has(other)) continue;
        // Mutual alliance check (source parity: areAllies helper in VictoryConditions.cpp).
        if (this.getTeamRelationshipBySides(side, other) === RELATIONSHIP_ALLIES
            && this.getTeamRelationshipBySides(other, side) === RELATIONSHIP_ALLIES) {
          group.push(other);
          assigned.add(other);
        }
      }
      allianceGroups.push(group);
    }

    // Game ends when only one alliance group remains.
    if (allianceGroups.length <= 1 && this.defeatedSides.size > 0) {
      this.gameEndFrame = this.frameCounter;
    }
  }

  /**
   * Source parity: VictoryConditions::hasSinglePlayerBeenDefeated — check if a
   * single side has lost all surviving objects. C++ hasAnyObjects() counts ALL
   * non-excluded entities (excludes PROJECTILE, MINE, INERT kindOf).
   */
  private hasSingleSideBeenDefeated(side: string): boolean {
    // Source parity: VictoryConditions.cpp — both VICTORY_NOUNITS and VICTORY_NOBUILDINGS
    // are set by default. C++ hasAnyObjects() counts ALL non-excluded entities regardless
    // of MP_COUNT_FOR_VICTORY. Defeat occurs only when a side has zero eligible entities.
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed || entity.slowDeathState || entity.structureCollapseState || entity.health <= 0) continue;
      const entitySide = this.normalizeSide(entity.side);
      if (entitySide !== side) continue;

      // Exclude projectiles, mines, and inert objects (source parity: Team.cpp).
      if (entity.kindOf.has('PROJECTILE') || entity.kindOf.has('MINE') || entity.kindOf.has('INERT')) {
        continue;
      }

      // Any surviving non-excluded entity prevents defeat.
      return false;
    }

    return true;
  }

  /**
   * Source parity: Player::killPlayer — destroy all remaining entities for a defeated side.
   * C++ iterates the player's object list and calls kill() on each.
   */
  private killRemainingEntitiesForSide(side: string): void {
    // Source parity: evacuate containers before killing, so contained entities
    // are released and can be killed individually (prevents orphaned passengers).
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== side) continue;
      if (entity.containProfile && this.collectContainedEntityIds(entity.id).length > 0) {
        this.evacuateContainedEntities(entity, entity.x, entity.z, null);
      }
    }

    const toKill: number[] = [];
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== side) continue;
      // Don't kill projectiles/mines — they'll clean up naturally.
      if (entity.kindOf.has('PROJECTILE') || entity.kindOf.has('MINE')) continue;
      toKill.push(entity.id);
    }
    for (const entityId of toKill) {
      this.markEntityDestroyed(entityId, -1);
    }
  }

  private updateEntityMovement(dt: number): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (entity.canMove) {
        this.updatePathfindPosCell(entity);
      }
    }

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) {
        continue;
      }
      if (!entity.canMove || !entity.moving || entity.moveTarget === null) {
        // Decelerate stopped entities.
        if (entity.currentSpeed > 0) {
          entity.currentSpeed = 0;
        }
        continue;
      }

      if (entity.pathIndex >= entity.movePath.length) {
        entity.moving = false;
        entity.moveTarget = null;
        entity.movePath = [];
        entity.pathfindGoalCell = null;
        entity.currentSpeed = 0;
        continue;
      }

      if (entity.pathIndex < entity.movePath.length && entity.moveTarget !== entity.movePath[entity.pathIndex]!) {
        entity.moveTarget = entity.movePath[entity.pathIndex]!;
      }

      const dx = entity.moveTarget.x - entity.x;
      const dz = entity.moveTarget.z - entity.z;
      const distance = Math.hypot(dx, dz);

      if (distance < 0.001) {
        entity.pathIndex += 1;
        if (entity.pathIndex >= entity.movePath.length) {
          entity.moving = false;
          entity.moveTarget = null;
          entity.movePath = [];
          entity.pathfindGoalCell = null;
          entity.currentSpeed = 0;
          continue;
        }
        entity.moveTarget = entity.movePath[entity.pathIndex]!;
        continue;
      }

      // Source parity: Locomotor physics — get active locomotor profile.
      const locoProfile = entity.locomotorSets.get(entity.activeLocomotorSet);
      const maxSpeed = entity.speed;
      const accel = locoProfile?.acceleration ?? 0;
      const brake = locoProfile?.braking ?? 0;
      const turnRateRad = locoProfile?.turnRate ?? 0;
      const minSpeed = locoProfile?.minSpeed ?? 0;

      // Source parity: Locomotor::computeDesiredDirection — angle toward waypoint.
      // In our coordinate system: atan2(dz, dx) + PI/2 converts to heading.
      const desiredHeading = Math.atan2(dz, dx) + Math.PI / 2;

      // Source parity: Locomotor turn-rate limiting.
      // If turnRate > 0, smoothly rotate toward desired heading instead of snapping.
      if (turnRateRad > 0) {
        let angleDiff = desiredHeading - entity.rotationY;
        // Normalize to [-PI, PI].
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        const maxTurn = turnRateRad * dt;
        if (Math.abs(angleDiff) <= maxTurn) {
          entity.rotationY = desiredHeading;
        } else {
          entity.rotationY += Math.sign(angleDiff) * maxTurn;
          // Normalize rotationY.
          while (entity.rotationY > Math.PI) entity.rotationY -= 2 * Math.PI;
          while (entity.rotationY < -Math.PI) entity.rotationY += 2 * Math.PI;
        }
      } else {
        // Instant rotation (legacy behavior).
        entity.rotationY = desiredHeading;
      }

      // Source parity: Locomotor acceleration/braking.
      // Compute remaining path distance for braking calculation.
      let remainingPathDist = distance;
      for (let i = entity.pathIndex + 1; i < entity.movePath.length; i++) {
        const prev = i === entity.pathIndex + 1 ? entity.moveTarget : entity.movePath[i - 1]!;
        const curr = entity.movePath[i]!;
        remainingPathDist += Math.hypot(curr.x - prev.x, curr.z - prev.z);
      }

      // Compute braking distance: v^2 / (2 * braking).
      const effectiveBrake = brake > 0 ? brake : 99999;
      const brakingDist = (entity.currentSpeed * entity.currentSpeed) / (2 * effectiveBrake);

      // Determine target speed for this frame.
      let targetSpeed = maxSpeed;
      if (remainingPathDist <= brakingDist && brake > 0) {
        // Need to decelerate — compute max speed for safe stop.
        targetSpeed = Math.sqrt(Math.max(0, 2 * effectiveBrake * remainingPathDist));
        targetSpeed = Math.min(targetSpeed, maxSpeed);
      }

      // Source parity: scale speed by turn alignment.
      // When turning sharply, slow down proportionally (C++ Locomotor behavior).
      if (turnRateRad > 0) {
        let headingDiff = desiredHeading - entity.rotationY;
        while (headingDiff > Math.PI) headingDiff -= 2 * Math.PI;
        while (headingDiff < -Math.PI) headingDiff += 2 * Math.PI;
        const alignment = Math.cos(headingDiff);
        // Units moving perpendicular or backward slow significantly.
        if (alignment < 0) {
          targetSpeed = minSpeed;
        } else {
          targetSpeed *= Math.max(0.3, alignment);
        }
      }

      // Apply acceleration or braking.
      if (accel > 0 || brake > 0) {
        if (entity.currentSpeed < targetSpeed) {
          const effectiveAccel = accel > 0 ? accel : 99999;
          entity.currentSpeed = Math.min(targetSpeed, entity.currentSpeed + effectiveAccel * dt);
        } else if (entity.currentSpeed > targetSpeed) {
          entity.currentSpeed = Math.max(targetSpeed, entity.currentSpeed - effectiveBrake * dt);
        }
      } else {
        // No physics specified — instant speed (legacy behavior).
        entity.currentSpeed = maxSpeed;
      }

      // Enforce minimum speed when moving.
      if (entity.currentSpeed > 0 && entity.currentSpeed < minSpeed && distance > minSpeed * dt * 2) {
        entity.currentSpeed = minSpeed;
      }

      const step = entity.currentSpeed * dt;
      if (distance <= step) {
        entity.x = entity.moveTarget.x;
        entity.z = entity.moveTarget.z;
        entity.pathIndex += 1;
        if (entity.pathIndex >= entity.movePath.length) {
          entity.moving = false;
          entity.moveTarget = null;
          entity.movePath = [];
          entity.pathfindGoalCell = null;
          entity.currentSpeed = 0;
          continue;
        }
        entity.moveTarget = entity.movePath[entity.pathIndex]!;
      } else if (turnRateRad > 0) {
        // Source parity: move along current heading, not directly toward target.
        // This creates realistic curved movement when turning.
        // Derive direction vector from rotationY (heading convention):
        // rotationY = atan2(dz, dx) + PI/2, so direction = (-sin(rot-PI/2), cos(rot-PI/2))
        // which simplifies to (cos(rotationY - PI/2), sin(rotationY - PI/2))
        // = (sin(rotationY), cos(rotationY))... but this depends on coordinate convention.
        // Use a safe approach: reverse the heading formula to get direction.
        const headingAngle = entity.rotationY - Math.PI / 2; // reverse the +PI/2 offset
        const headingX = Math.cos(headingAngle);
        const headingZ = Math.sin(headingAngle);
        // Blend heading movement with direct waypoint movement to prevent orbiting.
        // When well-aligned, mostly follow heading; when misaligned, bias toward waypoint.
        let headingDiff = desiredHeading - entity.rotationY;
        while (headingDiff > Math.PI) headingDiff -= 2 * Math.PI;
        while (headingDiff < -Math.PI) headingDiff += 2 * Math.PI;
        const alignment = Math.abs(headingDiff) < 0.01 ? 1 : Math.max(0, Math.cos(headingDiff));
        const directX = dx / distance;
        const directZ = dz / distance;
        const moveX = headingX * alignment + directX * (1 - alignment);
        const moveZ = headingZ * alignment + directZ * (1 - alignment);
        const moveMag = Math.hypot(moveX, moveZ);
        if (moveMag > 0.001) {
          entity.x += (moveX / moveMag) * step;
          entity.z += (moveZ / moveMag) * step;
        }
      } else {
        // No turn rate — move directly toward waypoint (legacy behavior).
        const inv = 1 / distance;
        entity.x += dx * inv * step;
        entity.z += dz * inv * step;
      }

      // Source parity: JetAI airborne entities have their Y managed by the JetAI state machine.
      // TAKING_OFF and LANDING interpolation happens in updateJetAI. Airborne aircraft
      // track terrain + cruiseHeight here.
      const jetState = entity.jetAIState;
      if (jetState && jetState.allowAirLoco) {
        // Airborne: maintain cruise altitude over terrain.
        if (this.mapHeightmap) {
          const terrainHeight = this.mapHeightmap.getInterpolatedHeight(entity.x, entity.z);
          entity.y = terrainHeight + entity.baseHeight + jetState.cruiseHeight;
        }
      } else if (!jetState || (jetState.state !== 'TAKING_OFF' && jetState.state !== 'LANDING')) {
        // Ground snap for non-aircraft or parked/reloading aircraft.
        if (this.mapHeightmap) {
          const terrainHeight = this.mapHeightmap.getInterpolatedHeight(entity.x, entity.z);
          const targetY = terrainHeight + entity.baseHeight;
          const snapAlpha = 1 - Math.exp(-this.config.terrainSnapSpeed * dt);
          entity.y += (targetY - entity.y) * snapAlpha;
        }

        // Subtle bob for unresolved movers (e.g., placeholders not in registry)
        if (!entity.resolved) {
          const bob = (Math.sin(this.animationTime * this.config.terrainSnapSpeed + entity.id) + 1) * 0.04;
          entity.y += bob;
        }
      }
      // TAKING_OFF and LANDING: Y is set in updateJetAI, don't override here.

      this.updatePathfindPosCell(entity);
    }

    // Source parity: contained entities move with their container.
    // Sync passenger positions to their container's current position.
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const containerId = entity.transportContainerId
        ?? entity.helixCarrierId
        ?? entity.garrisonContainerId
        ?? entity.tunnelContainerId;
      if (containerId === null) continue;
      const container = this.spawnedEntities.get(containerId);
      if (!container || container.destroyed) continue;
      entity.x = container.x;
      entity.z = container.z;
      entity.y = container.y;
    }
  }

  /**
   * Source parity: AnimationSteeringUpdate::update — drive turn-in-place model
   * condition transitions from PhysicsBehavior::getTurning().
   *
   * C++ module transitions:
   * INVALID -> CENTER_TO_RIGHT / CENTER_TO_LEFT
   * CENTER_TO_RIGHT -> RIGHT_TO_CENTER
   * CENTER_TO_LEFT -> LEFT_TO_CENTER
   * LEFT_TO_CENTER / RIGHT_TO_CENTER -> INVALID (when TURN_NONE)
   */
  private updateAnimationSteering(): void {
    const now = this.frameCounter;
    const TURN_EPSILON = 1e-4;

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.animationSteeringProfile;
      if (!profile) continue;

      // Source parity approximation: derive PhysicsTurningType from body yaw delta.
      const turnDelta = this.normalizeAngle(entity.rotationY - entity.animationSteeringLastRotationY);
      entity.animationSteeringLastRotationY = entity.rotationY;

      if (now < entity.animationSteeringNextTransitionFrame) {
        continue;
      }

      let currentTurn: 'TURN_NONE' | 'TURN_NEGATIVE' | 'TURN_POSITIVE' = 'TURN_NONE';
      if (turnDelta < -TURN_EPSILON) {
        currentTurn = 'TURN_NEGATIVE';
      } else if (turnDelta > TURN_EPSILON) {
        currentTurn = 'TURN_POSITIVE';
      }

      switch (entity.animationSteeringCurrentTurnAnim) {
        case null: {
          if (currentTurn === 'TURN_NEGATIVE') {
            entity.modelConditionFlags.add('CENTER_TO_RIGHT');
            entity.animationSteeringNextTransitionFrame = now + profile.transitionFrames;
            entity.animationSteeringCurrentTurnAnim = 'CENTER_TO_RIGHT';
          } else if (currentTurn === 'TURN_POSITIVE') {
            entity.modelConditionFlags.add('CENTER_TO_LEFT');
            entity.animationSteeringNextTransitionFrame = now + profile.transitionFrames;
            entity.animationSteeringCurrentTurnAnim = 'CENTER_TO_LEFT';
          }
          break;
        }
        case 'CENTER_TO_RIGHT': {
          if (currentTurn !== 'TURN_NEGATIVE') {
            entity.modelConditionFlags.delete('CENTER_TO_RIGHT');
            entity.modelConditionFlags.add('RIGHT_TO_CENTER');
            entity.animationSteeringNextTransitionFrame = now + profile.transitionFrames;
            entity.animationSteeringCurrentTurnAnim = 'RIGHT_TO_CENTER';
          }
          break;
        }
        case 'CENTER_TO_LEFT': {
          if (currentTurn !== 'TURN_POSITIVE') {
            entity.modelConditionFlags.delete('CENTER_TO_LEFT');
            entity.modelConditionFlags.add('LEFT_TO_CENTER');
            entity.animationSteeringNextTransitionFrame = now + profile.transitionFrames;
            entity.animationSteeringCurrentTurnAnim = 'LEFT_TO_CENTER';
          }
          break;
        }
        case 'LEFT_TO_CENTER':
        case 'RIGHT_TO_CENTER': {
          if (currentTurn === 'TURN_NONE') {
            entity.modelConditionFlags.delete('LEFT_TO_CENTER');
            entity.modelConditionFlags.delete('RIGHT_TO_CENTER');
            entity.animationSteeringNextTransitionFrame = now;
            entity.animationSteeringCurrentTurnAnim = null;
          }
          break;
        }
      }
    }
  }

  // ── Source parity: Unit collision separation ──────────────────────────────

  /**
   * Source parity: AIUpdateInterface::processCollision + PhysicsBehavior::applyCollideForce —
   * prevents movable ground units from overlapping by pushing them apart.
   *
   * In C++, the PartitionManager detects overlaps and AIUpdate::processCollision decides
   * whether to apply a physics bounce or just mark the unit as blocked. For idle units that
   * end up co-located, pathfinder::adjustToPossibleDestination nudges them to a safe position.
   *
   * Our approach: after movement, iterate all ground unit pairs and apply position separation
   * when bounding circles overlap. Priority: stationary units don't get pushed; both-idle
   * overlaps split the separation equally.
   */
  private updateUnitCollisionSeparation(): void {
    // Build a compact array of ground entities eligible for collision.
    const groundEntities: MapEntity[] = [];
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (!entity.canMove) continue;
      if (entity.category === 'air') continue;
      if (entity.noCollisions) continue;
      if (entity.objectStatusFlags.has('AIRBORNE_TARGET')) continue;
      // Source parity: C++ processCollision requires a locomotor to apply forces.
      // Entities without locomotors (e.g. crate victims, static objects) don't participate.
      if (entity.locomotorSets.size === 0) continue;
      // Skip contained/transported entities.
      if (entity.transportContainerId !== null
        || entity.helixCarrierId !== null
        || entity.garrisonContainerId !== null
        || entity.tunnelContainerId !== null) continue;
      groundEntities.push(entity);
    }

    const len = groundEntities.length;
    if (len < 2) return;

    // Source parity: minimum separation is PATHFIND_CELL_SIZE / 2 to prevent co-location.
    const MIN_SEPARATION = PATHFIND_CELL_SIZE * 0.5;
    // Source parity: separation strength — fraction of overlap corrected per frame.
    // C++ uses a force-based approach; we use direct position correction.
    const SEPARATION_STRENGTH = 0.4;

    for (let i = 0; i < len; i++) {
      const a = groundEntities[i]!;
      for (let j = i + 1; j < len; j++) {
        const b = groundEntities[j]!;

        // Source parity: C++ processCollision primarily handles same-team blocking.
        // Enemy units are handled by combat engagement and crush collisions, not separation.
        if (this.getTeamRelationship(a, b) !== RELATIONSHIP_ALLIES) continue;

        // Source parity: C++ canPathThroughUnits skips collision for certain units.
        // We approximate: skip if either entity has an ignored obstacle ID pointing at the other.
        if (a.ignoredMovementObstacleId === b.id || b.ignoredMovementObstacleId === a.id) continue;

        // Bounding circle radii from obstacle geometry.
        const radiusA = a.obstacleGeometry ? a.obstacleGeometry.majorRadius : MIN_SEPARATION;
        const radiusB = b.obstacleGeometry ? b.obstacleGeometry.majorRadius : MIN_SEPARATION;
        const combinedRadius = Math.max(radiusA + radiusB, MIN_SEPARATION * 2);

        const dx = b.x - a.x;
        const dz = b.z - a.z;
        const distSqr = dx * dx + dz * dz;
        const combinedRadiusSqr = combinedRadius * combinedRadius;

        if (distSqr >= combinedRadiusSqr) continue;

        // Overlap detected.
        const dist = Math.sqrt(distSqr);
        // Source parity: C++ caps overlap at 5.0 to prevent explosive separation
        // when deeply interpenetrating objects (PhysicsUpdate.cpp:1412).
        const overlap = Math.min(combinedRadius - dist, 5.0);

        // Direction from A to B (or random if coincident).
        let nx: number;
        let nz: number;
        if (dist > 0.01) {
          nx = dx / dist;
          nz = dz / dist;
        } else {
          // Source parity: C++ caps dist at 1.0 for coincident objects.
          // Use a deterministic pseudo-random direction based on entity IDs.
          const angle = ((a.id * 7 + b.id * 13) % 360) * (Math.PI / 180);
          nx = Math.cos(angle);
          nz = Math.sin(angle);
        }

        const correction = overlap * SEPARATION_STRENGTH;

        // Determine who moves: moving entities yield to stationary ones.
        const aMoving = a.moving;
        const bMoving = b.moving;
        const aIdle = !aMoving && a.attackTargetEntityId === null;
        const bIdle = !bMoving && b.attackTargetEntityId === null;

        // Source parity: immobile structures never get pushed.
        const aImmobile = a.isImmobile;
        const bImmobile = b.isImmobile;

        if (aImmobile && bImmobile) continue;

        let aFraction: number;
        let bFraction: number;

        if (aImmobile) {
          // Only push B.
          aFraction = 0;
          bFraction = 1;
        } else if (bImmobile) {
          // Only push A.
          aFraction = 1;
          bFraction = 0;
        } else if (aMoving && !bMoving) {
          // Moving A yields to stationary B.
          aFraction = 0.8;
          bFraction = 0.2;
        } else if (bMoving && !aMoving) {
          // Moving B yields to stationary A.
          aFraction = 0.2;
          bFraction = 0.8;
        } else {
          // Both moving or both idle — split evenly.
          aFraction = 0.5;
          bFraction = 0.5;
        }

        // Push A away from B (negative direction) and B away from A (positive direction).
        a.x -= nx * correction * aFraction;
        a.z -= nz * correction * aFraction;
        b.x += nx * correction * bFraction;
        b.z += nz * correction * bFraction;

        // Source parity: when both are idle and very close (< cell size / 4),
        // issue move-away commands to resolve permanent overlap.
        // C++ AIUpdate.cpp:1575-1585: nudge BOTH idle units in opposite directions.
        // C++ AIUpdate.cpp:1567-1571: skip if busy or using ability.
        if (aIdle && bIdle && !aImmobile && !bImmobile
          && distSqr < PATHFIND_CELL_SIZE * PATHFIND_CELL_SIZE * 0.25) {
          if (a.moveTarget === null
            && !a.objectStatusFlags.has('IS_USING_ABILITY')) {
            const awayX = a.x - nx * PATHFIND_CELL_SIZE;
            const awayZ = a.z - nz * PATHFIND_CELL_SIZE;
            this.issueMoveTo(a.id, awayX, awayZ);
          }
          if (b.moveTarget === null
            && !b.objectStatusFlags.has('IS_USING_ABILITY')) {
            const awayX = b.x + nx * PATHFIND_CELL_SIZE;
            const awayZ = b.z + nz * PATHFIND_CELL_SIZE;
            this.issueMoveTo(b.id, awayX, awayZ);
          }
        }
      }
    }
  }

  // ── BattlePlanUpdate implementation ──────────────────────────────────────

  /**
   * Source parity: BattlePlanUpdate::update — per-frame state machine for each
   * Strategy Center's battle plan transition (IDLE → UNPACKING → ACTIVE → PACKING → IDLE).
   */
  private updateBattlePlan(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      const profile = entity.battlePlanProfile;
      const state = entity.battlePlanState;
      if (!profile || !state) continue;

      switch (state.transitionStatus) {
        case 'IDLE':
          // Waiting for cooldown after previous plan change.
          if (state.desiredPlan !== 'NONE' && this.frameCounter >= state.idleCooldownFinishFrame) {
            state.transitionStatus = 'UNPACKING';
            state.transitionFinishFrame = this.frameCounter
              + this.getBattlePlanAnimationFrames(profile, state.desiredPlan);
          }
          break;

        case 'UNPACKING':
          if (this.frameCounter >= state.transitionFinishFrame) {
            // Transition to ACTIVE — apply bonuses.
            state.transitionStatus = 'ACTIVE';
            state.activePlan = state.desiredPlan;
            this.applyBattlePlanBonuses(entity, state.activePlan, true);
          }
          break;

        case 'ACTIVE':
          // If desired plan changed, begin packing.
          // Source parity: BattlePlanUpdate::setStatus(TRANSITIONSTATUS_PACKING) immediately
          // calls setBattlePlan(PLANSTATUS_NONE) which removes bonuses and paralyzes troops.
          if (state.desiredPlan !== state.activePlan) {
            // Remove bonuses immediately at packing start (C++ parity).
            this.applyBattlePlanBonuses(entity, state.activePlan, false);
            this.paralyzeBattlePlanTroops(entity, profile);
            state.activePlan = 'NONE';
            state.transitionStatus = 'PACKING';
            state.transitionFinishFrame = this.frameCounter
              + this.getBattlePlanAnimationFrames(profile, state.desiredPlan);
          }
          break;

        case 'PACKING':
          if (this.frameCounter >= state.transitionFinishFrame) {
            // Packing animation complete → idle cooldown.
            state.transitionStatus = 'IDLE';
            state.idleCooldownFinishFrame = this.frameCounter + profile.transitionIdleFrames;
          }
          break;
      }
    }
  }

  private requestBattlePlanChange(entity: MapEntity, desiredPlan: BattlePlanType): void {
    const state = entity.battlePlanState;
    if (!state) return;

    if (state.activePlan === desiredPlan && state.transitionStatus === 'ACTIVE') {
      return; // Already active on requested plan.
    }

    // Just set desired plan. The state machine in updateBattlePlan handles ACTIVE→PACKING
    // transition, including immediate bonus removal and paralysis (C++ parity).
    state.desiredPlan = desiredPlan;
  }

  private getBattlePlanAnimationFrames(profile: BattlePlanProfile, plan: BattlePlanType): number {
    switch (plan) {
      case 'BOMBARDMENT': return profile.bombardmentAnimationFrames;
      case 'HOLDTHELINE': return profile.holdTheLineAnimationFrames;
      case 'SEARCHANDDESTROY': return profile.searchAndDestroyAnimationFrames;
      default: return 0;
    }
  }

  /**
   * Source parity: Player::changeBattlePlan + localApplyBattlePlanBonusesToObject —
   * Apply or remove battle plan bonuses to all entities on the same side.
   * @param apply true = apply bonuses, false = remove (invert)
   */
  private applyBattlePlanBonuses(source: MapEntity, plan: BattlePlanType, apply: boolean): void {
    const side = this.normalizeSide(source.side);
    if (!side) return;

    const profile = source.battlePlanProfile;
    if (!profile) return;

    // Track per-side counts.
    let bonuses = this.sideBattlePlanBonuses.get(side);
    if (!bonuses) {
      bonuses = { bombardmentCount: 0, holdTheLineCount: 0, searchAndDestroyCount: 0 };
      this.sideBattlePlanBonuses.set(side, bonuses);
    }

    const delta = apply ? 1 : -1;
    let weaponBonusFlag = 0;
    // Source parity: Player::changeBattlePlan — only apply/remove when count transitions
    // through 1/0 (first plan of type enables, last plan of type disables). Multiple Strategy
    // Centers with the same plan don't stack army bonuses; they add redundancy.
    let shouldModifyArmy = false;

    switch (plan) {
      case 'BOMBARDMENT':
        bonuses.bombardmentCount = Math.max(0, bonuses.bombardmentCount + delta);
        weaponBonusFlag = WEAPON_BONUS_BOMBARDMENT;
        shouldModifyArmy = (apply && bonuses.bombardmentCount === 1)
          || (!apply && bonuses.bombardmentCount === 0);
        break;
      case 'HOLDTHELINE':
        bonuses.holdTheLineCount = Math.max(0, bonuses.holdTheLineCount + delta);
        weaponBonusFlag = WEAPON_BONUS_HOLDTHELINE;
        shouldModifyArmy = (apply && bonuses.holdTheLineCount === 1)
          || (!apply && bonuses.holdTheLineCount === 0);
        break;
      case 'SEARCHANDDESTROY':
        bonuses.searchAndDestroyCount = Math.max(0, bonuses.searchAndDestroyCount + delta);
        weaponBonusFlag = WEAPON_BONUS_SEARCHANDDESTROY;
        shouldModifyArmy = (apply && bonuses.searchAndDestroyCount === 1)
          || (!apply && bonuses.searchAndDestroyCount === 0);
        break;
    }

    // Source parity: only modify army bonuses on count transitions (0→1 or 1→0).
    if (shouldModifyArmy) {
      const armorScalar = plan === 'HOLDTHELINE' ? profile.holdTheLineArmorDamageScalar : 1.0;
      const sightScalar = plan === 'SEARCHANDDESTROY' ? profile.searchAndDestroySightRangeScalar : 1.0;

      for (const entity of this.spawnedEntities.values()) {
        if (entity.destroyed) continue;
        if (this.normalizeSide(entity.side) !== side) continue;
        if (!this.isBattlePlanMember(entity, profile)) continue;

        // Weapon bonus condition flag.
        if (apply) {
          entity.weaponBonusConditionFlags |= weaponBonusFlag;
        } else {
          entity.weaponBonusConditionFlags &= ~weaponBonusFlag;
        }

        // Armor damage scalar.
        if (apply && armorScalar !== 1.0) {
          entity.battlePlanDamageScalar = Math.max(0.01, entity.battlePlanDamageScalar * armorScalar);
        } else if (!apply && plan === 'HOLDTHELINE') {
          // Restore to 1.0 (undo the armor scalar).
          entity.battlePlanDamageScalar = 1.0;
        }

        // Sight range scalar — always use absolute computation from baseVisionRange.
        if (apply && sightScalar !== 1.0) {
          entity.visionRange = Math.max(0, entity.baseVisionRange * sightScalar);
        } else if (!apply && plan === 'SEARCHANDDESTROY') {
          entity.visionRange = entity.baseVisionRange;
        }
      }
    }

    // Strategy Center building-specific bonuses.
    if (plan === 'HOLDTHELINE') {
      // Building health scalar — apply to Strategy Center itself.
      if (profile.strategyCenterHoldTheLineMaxHealthScalar !== 1.0) {
        const scalar = apply
          ? profile.strategyCenterHoldTheLineMaxHealthScalar
          : (1.0 / Math.max(0.01, profile.strategyCenterHoldTheLineMaxHealthScalar));
        const newMaxHealth = Math.max(1, Math.round(source.maxHealth * scalar));
        const ratio = source.maxHealth > 0 ? source.health / source.maxHealth : 1;
        source.maxHealth = newMaxHealth;
        source.initialHealth = newMaxHealth;
        source.health = Math.round(newMaxHealth * ratio);
      }
    }

    if (plan === 'SEARCHANDDESTROY') {
      // Building sight range bonus + stealth detection.
      if (apply && profile.strategyCenterSearchAndDestroySightRangeScalar !== 1.0) {
        source.visionRange = Math.max(0, source.baseVisionRange * profile.strategyCenterSearchAndDestroySightRangeScalar);
      } else if (!apply) {
        source.visionRange = source.baseVisionRange;
      }
      // Stealth detection toggling on the building.
      if (profile.strategyCenterSearchAndDestroyDetectsStealth) {
        if (apply && !source.detectorProfile) {
          // Enable stealth detection on the building.
          source.detectorProfile = {
            detectionRange: source.visionRange,
            detectionRate: 10,
            canDetectWhileGarrisoned: true,
            canDetectWhileContained: false,
            extraRequiredKindOf: new Set(),
            extraForbiddenKindOf: new Set(),
          };
        } else if (!apply) {
          source.detectorProfile = null;
        }
      }
    }
  }

  private isBattlePlanMember(entity: MapEntity, profile: BattlePlanProfile): boolean {
    const kindOf = this.resolveEntityKindOfSet(entity);
    // If ValidMemberKindOf is non-empty, entity must have at least one matching kind.
    if (profile.validMemberKindOf.size > 0) {
      let hasValid = false;
      for (const k of profile.validMemberKindOf) {
        if (kindOf.has(k)) { hasValid = true; break; }
      }
      if (!hasValid) return false;
    }
    // If InvalidMemberKindOf is non-empty, entity must NOT have any matching kind.
    for (const k of profile.invalidMemberKindOf) {
      if (kindOf.has(k)) return false;
    }
    return true;
  }

  /**
   * Source parity: BattlePlanUpdate — paralyze all troops on the side when packing completes.
   */
  private paralyzeBattlePlanTroops(source: MapEntity, profile: BattlePlanProfile): void {
    if (profile.battlePlanParalyzeFrames <= 0) return;
    const side = this.normalizeSide(source.side);
    if (!side) return;

    for (const entity of this.spawnedEntities.values()) {
      if (entity.destroyed) continue;
      if (this.normalizeSide(entity.side) !== side) continue;
      if (entity.id === source.id) continue; // Don't paralyze the building itself.
      if (!this.isBattlePlanMember(entity, profile)) continue;

      // Source parity: paralyzeTroop uses a time-limited disable.
      // We reuse DISABLED_SUBDUED which blocks movement and actions.
      entity.objectStatusFlags.add('DISABLED_SUBDUED');
      this.battlePlanParalyzedUntilFrame.set(entity.id, this.frameCounter + profile.battlePlanParalyzeFrames);
    }
  }

  /**
   * Clear battle plan paralysis when duration expires.
   */
  private updateBattlePlanParalysis(): void {
    for (const [entityId, untilFrame] of this.battlePlanParalyzedUntilFrame.entries()) {
      if (this.frameCounter < untilFrame) continue;
      const entity = this.spawnedEntities.get(entityId);
      if (entity && !entity.destroyed) {
        entity.objectStatusFlags.delete('DISABLED_SUBDUED');
      }
      this.battlePlanParalyzedUntilFrame.delete(entityId);
    }
  }

  /**
   * Source parity: PhysicsUpdate::checkForOverlapCollision + SquishCollide::onCollide —
   * moving entities with crusherLevel > 0 crush overlapping enemies whose crushableLevel
   * is lower. Applies CRUSH damage (HUGE_DAMAGE_AMOUNT = guaranteed kill).
   */
  private updateCrushCollisions(): void {
    for (const mover of this.spawnedEntities.values()) {
      if (mover.destroyed || !mover.canMove || !mover.moving) {
        continue;
      }
      if (mover.crusherLevel <= 0) {
        continue;
      }

      // Source parity: rotationY = atan2(dz, dx) + PI/2; reverse to get movement direction.
      const moveDirX = Math.sin(mover.rotationY);
      const moveDirZ = -Math.cos(mover.rotationY);

      // Source parity: geometry major radius comes from object geometry info.
      // In this port some units keep radius via pathDiameter even when obstacleGeometry is null.
      const moverRadius = this.resolveEntityMajorRadius(mover);

      for (const target of this.spawnedEntities.values()) {
        if (target.destroyed || !target.canTakeDamage || target.id === mover.id) {
          continue;
        }
        if (!this.canCrushOrSquish(mover, target)) {
          continue;
        }

        // Source parity: SquishCollide::onCollide — hijacker/TNT-hunter immunity.
        // If the infantry has a pending enter-object action (hijackVehicle) targeting the
        // crusher, it is immune to being crushed by that specific vehicle.
        const pendingAction = this.pendingEnterObjectActions.get(target.id);
        if (pendingAction && pendingAction.targetObjectId === mover.id
          && (pendingAction.action === 'hijackVehicle' || pendingAction.action === 'convertToCarBomb')) {
          continue;
        }

        // Source parity: SquishCollide::onCollide uses radius 1.0 for infantry collision.
        const targetRadius = target.canBeSquished
          ? 1.0
          : this.resolveEntityMajorRadius(target);

        const combinedRadius = moverRadius + targetRadius;
        const dx = target.x - mover.x;
        const dz = target.z - mover.z;
        const distSqr = dx * dx + dz * dz;

        if (distSqr > combinedRadius * combinedRadius) {
          continue;
        }

        if (target.canBeSquished) {
          // Source parity: SquishCollide::onCollide — infantry crush requires the
          // crusher to be moving toward the target (dot > 0).
          if (distSqr > 0.001) {
            const dot = moveDirX * dx + moveDirZ * dz;
            if (dot <= 0) {
              continue;
            }
          }
        } else if (!this.shouldCrushVehicleTarget(mover, target)) {
          // Source parity: PhysicsUpdate vehicle-on-vehicle crush point check.
          continue;
        }

        // Source parity: ToppleUpdate::onCollide — entities with topple profile get toppled
        // instead of crushed. Death is handled by topple completion (KillWhenFinishedToppling).
        // In C++, ToppleUpdate is the collide handler, not SquishCollide.
        if (target.toppleProfile && target.toppleState === 'NONE') {
          const moverSpeed = mover.speed > 0 ? mover.speed : 1.0;
          this.applyTopplingForce(target, dx, dz, moverSpeed);
        } else {
          // Source parity: CRUSH damage uses HUGE_DAMAGE_AMOUNT (guaranteed kill).
          this.applyWeaponDamageAmount(mover.id, target, HUGE_DAMAGE_AMOUNT, 'CRUSH');
        }
      }
    }
  }

  private perpsLogicallyEqual(perpOne: number, perpTwo: number): boolean {
    const PERP_RANGE = 0.15;
    return Math.abs(perpOne - perpTwo) <= PERP_RANGE;
  }

  /**
   * Source parity: PhysicsBehavior::checkForOverlapCollision vehicle crush targeting.
   * Chooses FRONT/BACK/TOTAL crush point by shortest perpendicular-to-direction check.
   */
  private resolveVehicleCrushTarget(
    crusher: MapEntity,
    victim: MapEntity,
  ): 'TOTAL' | 'FRONT' | 'BACK' | 'NONE' {
    const frontCrushed = victim.frontCrushed;
    const backCrushed = victim.backCrushed;
    if (frontCrushed && backCrushed) {
      return 'NONE';
    }

    if (frontCrushed) return 'BACK';
    if (backCrushed) return 'FRONT';

    const dirX = Math.sin(crusher.rotationY);
    const dirZ = -Math.cos(crusher.rotationY);
    const victimDirX = Math.sin(victim.rotationY);
    const victimDirZ = -Math.cos(victim.rotationY);
    const crushPointOffsetDistance = this.resolveEntityMajorRadius(victim) * 0.5;
    const offsetX = victimDirX * crushPointOffsetDistance;
    const offsetZ = victimDirZ * crushPointOffsetDistance;

    const frontX = victim.x + offsetX;
    const frontZ = victim.z + offsetZ;
    const backX = victim.x - offsetX;
    const backZ = victim.z - offsetZ;
    const centerX = victim.x;
    const centerZ = victim.z;

    const frontVectorX = frontX - crusher.x;
    const frontVectorZ = frontZ - crusher.z;
    const backVectorX = backX - crusher.x;
    const backVectorZ = backZ - crusher.z;
    const centerVectorX = centerX - crusher.x;
    const centerVectorZ = centerZ - crusher.z;

    const frontRayLength = frontVectorX * dirX + frontVectorZ * dirZ;
    const backRayLength = backVectorX * dirX + backVectorZ * dirZ;
    const centerRayLength = centerVectorX * dirX + centerVectorZ * dirZ;

    const frontPerpLength = Math.hypot(frontRayLength * dirX - frontVectorX, frontRayLength * dirZ - frontVectorZ);
    const backPerpLength = Math.hypot(backRayLength * dirX - backVectorX, backRayLength * dirZ - backVectorZ);
    const centerPerpLength = Math.hypot(centerRayLength * dirX - centerVectorX, centerRayLength * dirZ - centerVectorZ);

    const frontVectorLength = Math.hypot(frontVectorX, frontVectorZ);
    const backVectorLength = Math.hypot(backVectorX, backVectorZ);
    const centerVectorLength = Math.hypot(centerVectorX, centerVectorZ);

    if (frontPerpLength <= centerPerpLength && frontPerpLength <= backPerpLength) {
      if (
        this.perpsLogicallyEqual(frontPerpLength, centerPerpLength)
        || this.perpsLogicallyEqual(frontPerpLength, backPerpLength)
      ) {
        if (this.perpsLogicallyEqual(frontPerpLength, centerPerpLength)) {
          return frontVectorLength < centerVectorLength ? 'FRONT' : 'TOTAL';
        }
        return frontVectorLength < backVectorLength ? 'FRONT' : 'BACK';
      }
      return 'FRONT';
    }

    if (backPerpLength <= centerPerpLength && backPerpLength <= frontPerpLength) {
      if (
        this.perpsLogicallyEqual(backPerpLength, centerPerpLength)
        || this.perpsLogicallyEqual(backPerpLength, frontPerpLength)
      ) {
        if (this.perpsLogicallyEqual(backPerpLength, centerPerpLength)) {
          return backVectorLength < centerVectorLength ? 'BACK' : 'TOTAL';
        }
        return backVectorLength < frontVectorLength ? 'BACK' : 'FRONT';
      }
      return 'BACK';
    }

    if (
      this.perpsLogicallyEqual(centerPerpLength, backPerpLength)
      || this.perpsLogicallyEqual(centerPerpLength, frontPerpLength)
    ) {
      if (this.perpsLogicallyEqual(centerPerpLength, frontPerpLength)) {
        return centerVectorLength < frontVectorLength ? 'TOTAL' : 'FRONT';
      }
      return centerVectorLength < backVectorLength ? 'TOTAL' : 'BACK';
    }
    return 'TOTAL';
  }

  /**
   * Source parity: PhysicsBehavior::checkForOverlapCollision vehicle crush gate.
   * Vehicle crush triggers only after the crusher has passed the selected crush point.
   */
  private shouldCrushVehicleTarget(crusher: MapEntity, victim: MapEntity): boolean {
    const crushTarget = this.resolveVehicleCrushTarget(crusher, victim);
    if (crushTarget === 'NONE') {
      return false;
    }

    const victimDirX = Math.sin(victim.rotationY);
    const victimDirZ = -Math.cos(victim.rotationY);
    const crushPointOffsetDistance = this.resolveEntityMajorRadius(victim) * 0.5;
    const offsetX = victimDirX * crushPointOffsetDistance;
    const offsetZ = victimDirZ * crushPointOffsetDistance;

    let pointX = victim.x;
    let pointZ = victim.z;
    if (crushTarget === 'FRONT') {
      pointX += offsetX;
      pointZ += offsetZ;
    } else if (crushTarget === 'BACK') {
      pointX -= offsetX;
      pointZ -= offsetZ;
    }

    const dx = pointX - crusher.x;
    const dz = pointZ - crusher.z;
    const dirX = Math.sin(crusher.rotationY);
    const dirZ = -Math.cos(crusher.rotationY);
    const dot = dirX * dx + dirZ * dz;
    const distanceSquared = dx * dx + dz * dz;
    const distanceTooFarSquared = 2.25 * crushPointOffsetDistance * crushPointOffsetDistance;
    return dot < 0 && distanceSquared < distanceTooFarSquared;
  }

  private clearEntitySelectionState(): void {
    for (const entity of this.spawnedEntities.values()) {
      if (entity.selected) {
        entity.selected = false;
      }
    }
  }

  private updateSelectionHighlight(): void {
    this.clearEntitySelectionState();

    for (const selectedEntityId of this.selectedEntityIds) {
      const selected = this.spawnedEntities.get(selectedEntityId);
      if (!selected) {
        continue;
      }

      selected.selected = true;
    }
  }

  private removeEntityFromSelection(entityId: number): void {
    let changed = false;
    if (this.selectedEntityId === entityId) {
      this.selectedEntityId = null;
      changed = true;
    }

    const nextSelectedEntityIds = this.selectedEntityIds.filter((selectedId) => selectedId !== entityId);
    if (nextSelectedEntityIds.length !== this.selectedEntityIds.length) {
      this.selectedEntityIds = nextSelectedEntityIds;
      if (this.selectedEntityId === null) {
        this.selectedEntityId = nextSelectedEntityIds[0] ?? null;
      }
      changed = true;
    }

    if (changed) {
      this.updateSelectionHighlight();
    }
  }

  private filterValidSelectionIds(entityIds: readonly number[]): number[] {
    const seen = new Set<number>();
    const nextSelectionIds: number[] = [];
    for (const candidateId of entityIds) {
      if (!Number.isInteger(candidateId) || candidateId <= 0) {
        continue;
      }
      const entity = this.spawnedEntities.get(candidateId);
      if (!entity || entity.destroyed) {
        continue;
      }
      // Source parity: Object::isSelectable — UNSELECTABLE or MASKED status prevents player selection.
      if (this.entityHasObjectStatus(entity, 'UNSELECTABLE') || this.entityHasObjectStatus(entity, 'MASKED')) {
        continue;
      }
      if (seen.has(candidateId)) {
        continue;
      }
      seen.add(candidateId);
      nextSelectionIds.push(candidateId);
    }

    return nextSelectionIds;
  }

  private clearSpawnedObjects(): void {
    this.commandQueue.length = 0;
    this.pendingWeaponDamageEvents.length = 0;
    this.missileAIProfileByProjectileTemplate.clear();
    this.visualEventBuffer.length = 0;
    this.nextProjectileVisualId = 1;
    for (const [entityId] of this.overchargeStateByEntityId) {
      const entity = this.spawnedEntities.get(entityId);
      if (entity && !entity.destroyed) {
        this.disableOverchargeForEntity(entity);
      }
    }
    this.overchargeStateByEntityId.clear();
    this.disabledHackedStatusByEntityId.clear();
    this.disabledEmpStatusByEntityId.clear();
    this.sellingEntities.clear();
    this.hackInternetStateByEntityId.clear();
    this.hackInternetPendingCommandByEntityId.clear();
    this.pendingEnterObjectActions.clear();
    this.pendingRepairDockActions.clear();
    this.pendingCombatDropActions.clear();
    this.pendingChinookRappels.clear();
    this.pendingChinookCommandByEntityId.clear();
    this.pendingGarrisonActions.clear();
    this.pendingTransportActions.clear();
    this.pendingTunnelActions.clear();
    this.tunnelTrackers.clear();
    this.pendingRepairActions.clear();
    this.pendingConstructionActions.clear();
    this.supplyWarehouseStates.clear();
    this.supplyTruckStates.clear();
    this.railedTransportStateByEntityId.clear();
    this.railedTransportWaypointIndex = createRailedTransportWaypointIndexImpl(null);
    this.fogOfWarGrid = null;
    this.sidePlayerIndex.clear();
    this.nextPlayerIndex = 0;
    this.skirmishAIStates.clear();
    this.sideSkirmishStartIndex.clear();
    this.sideScoreState.clear();
    this.sideAttackedBy.clear();
    this.sideAttackedFrame.clear();
    this.sideSupplySourceAttackCheckFrame.clear();
    this.sideAttackedSupplySource.clear();
    this.sideScriptAcquiredSciences.clear();
    this.sideScriptTriggeredSpecialPowerEvents.clear();
    this.sideScriptMidwaySpecialPowerEvents.clear();
    this.sideScriptCompletedSpecialPowerEvents.clear();
    this.sideScriptCompletedUpgradeEvents.clear();
    this.scriptCompletedVideos.length = 0;
    this.scriptCompletedSpeech.length = 0;
    this.scriptCompletedAudio.length = 0;
    this.scriptCompletedMusic.length = 0;
    this.scriptTeamsByName.clear();
    this.scriptObjectTopologyVersion = 0;
    this.scriptObjectCountChangedFrame = 0;
    this.scriptConditionCacheById.clear();
    this.scriptCountersByName.clear();
    this.scriptFlagsByName.clear();
    this.scriptUIInteractions.clear();
    this.scriptObjectCountBySideAndType.clear();
    this.scriptExistedEntityIds.clear();
    this.scriptTriggerMembershipByEntityId.clear();
    this.scriptTriggerEnteredByEntityId.clear();
    this.scriptTriggerExitedByEntityId.clear();
    this.scriptTriggerEnterExitFrameByEntityId.clear();
    this.scriptCompletedWaypointPathsByEntityId.clear();
    this.scriptTransportStatusByEntityId.clear();
    this.loadedMapData = null;
    this.navigationGrid = null;
    this.bridgeSegments.clear();
    this.bridgeSegmentByControlEntity.clear();
    this.resetBridgeDamageStateChanges();
    this.shortcutSpecialPowerSourceByName.clear();
    this.shortcutSpecialPowerNamesByEntityId.clear();
    this.spawnedEntities.clear();
    this.selectedEntityIds = [];
    this.selectedEntityId = null;
    this.defeatedSides.clear();
    this.gameEndFrame = null;
  }
}
